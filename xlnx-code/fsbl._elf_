
/mnt/lacie/fpga_devel/00_empty/00_empty.sdk/fsbl/Debug/fsbl.elf:     file format elf32-littlearm
/mnt/lacie/fpga_devel/00_empty/00_empty.sdk/fsbl/Debug/fsbl.elf
architecture: arm, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00000000

Program Header:
0x70000001 off    0x00028000 vaddr 0x00020000 paddr 0x00020000 align 2**2
         filesz 0x00000008 memsz 0x00000008 flags r--
    LOAD off    0x00008000 vaddr 0x00000000 paddr 0x00000000 align 2**15
         filesz 0x00020014 memsz 0x00024af0 flags rwx
    LOAD off    0x00030000 vaddr 0xffff0000 paddr 0xffff0000 align 2**15
         filesz 0x00000000 memsz 0x0000d400 flags rw-
private flags = 5000200: [Version5 EABI] [soft-float ABI]

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00017520  00000000  00000000  00008000  2**6
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .handoff      0000004c  00017520  00017520  0001f520  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .init         00000018  0001756c  0001756c  0001f56c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .fini         00000018  00017584  00017584  0001f584  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .rodata       00001210  000175a0  000175a0  0001f5a0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .data         000034b8  000187b0  000187b0  000207b0  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  6 .eh_frame     00000074  0001bc68  0001bc68  00023c68  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .mmu_tbl      00004000  0001c000  0001c000  00024000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .ARM.exidx    00000008  00020000  00020000  00028000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .init_array   00000008  00020008  00020008  00028008  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .fini_array   00000004  00020010  00020010  00028010  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 11 .rsa_ac       0000102c  00020014  00020014  00028014  2**0
                  ALLOC
 12 .ARM.attributes 00000033  00021040  00021040  00028014  2**0
                  CONTENTS, READONLY
 13 .bss          00001ab0  00021040  00021040  00028014  2**5
                  ALLOC
 14 .heap         00002000  00022af0  00022af0  00028014  2**0
                  ALLOC
 15 .stack        0000d400  ffff0000  ffff0000  00030000  2**0
                  ALLOC
 16 .debug_line   00008088  00000000  00000000  00028047  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_info   0000fe87  00000000  00000000  000300cf  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_abbrev 000038a4  00000000  00000000  0003ff56  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_aranges 00000618  00000000  00000000  00043800  2**3
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macro  0000563a  00000000  00000000  00043e18  2**0
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_str    00015dea  00000000  00000000  00049452  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .comment      00000030  00000000  00000000  0005f23c  2**0
                  CONTENTS, READONLY
 23 .debug_frame  00003280  00000000  00000000  0005f26c  2**2
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_loc    0000a9bc  00000000  00000000  000624ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_ranges 000005b8  00000000  00000000  0006cea8  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
00000000 l    d  .text  00000000 .text
00017520 l    d  .handoff 00000000 .handoff
0001756c l    d  .init  00000000 .init
00017584 l    d  .fini  00000000 .fini
000175a0 l    d  .rodata  00000000 .rodata
000187b0 l    d  .data  00000000 .data
0001bc68 l    d  .eh_frame  00000000 .eh_frame
0001c000 l    d  .mmu_tbl 00000000 .mmu_tbl
00020000 l    d  .ARM.exidx 00000000 .ARM.exidx
00020008 l    d  .init_array  00000000 .init_array
00020010 l    d  .fini_array  00000000 .fini_array
00020014 l    d  .rsa_ac  00000000 .rsa_ac
00021040 l    d  .ARM.attributes  00000000 .ARM.attributes
00021040 l    d  .bss 00000000 .bss
00022af0 l    d  .heap  00000000 .heap
ffff0000 l    d  .stack 00000000 .stack
00000000 l    d  .debug_line  00000000 .debug_line
00000000 l    d  .debug_info  00000000 .debug_info
00000000 l    d  .debug_abbrev  00000000 .debug_abbrev
00000000 l    d  .debug_aranges 00000000 .debug_aranges
00000000 l    d  .debug_macro 00000000 .debug_macro
00000000 l    d  .debug_str 00000000 .debug_str
00000000 l    d  .comment 00000000 .comment
00000000 l    d  .debug_frame 00000000 .debug_frame
00000000 l    d  .debug_loc 00000000 .debug_loc
00000000 l    d  .debug_ranges  00000000 .debug_ranges
00000000 l    df *ABS*  00000000 asm_vectors.o
000000a0 l       .text  00000000 Undefined
000000b0 l       .text  00000000 SVCHandler
000000f4 l       .text  00000000 PrefetchAbortHandler
000000d4 l       .text  00000000 DataAbortHandler
00000020 l       .text  00000000 IRQHandler
00000060 l       .text  00000000 FIQHandler
0000007c l       .text  00000000 FIQLoop
00000000 l    df *ABS*  00000000 boot.o
f8f02000 l       *ABS*  00000000 PSS_L2CC_BASE_ADDR
f8000000 l       *ABS*  00000000 PSS_SLCR_BASE_ADDR
0fffff00 l       *ABS*  00000000 RESERVED
fe00000f l       *ABS*  00000000 LRemap
f8f0277c l       *ABS*  00000000 L2CCWay
f8f02730 l       *ABS*  00000000 L2CCSync
f8f02100 l       *ABS*  00000000 L2CCCrtl
f8f02104 l       *ABS*  00000000 L2CCAuxCrtl
f8f02108 l       *ABS*  00000000 L2CCTAGLatReg
f8f0210c l       *ABS*  00000000 L2CCDataLatReg
f8f02220 l       *ABS*  00000000 L2CCIntClear
f8f0221c l       *ABS*  00000000 L2CCIntRaw
f8000004 l       *ABS*  00000000 SLCRlockReg
f8000008 l       *ABS*  00000000 SLCRUnlockReg
f8000a1c l       *ABS*  00000000 SLCRL2cRamReg
00001005 l       *ABS*  00000000 CRValMmuCac
00002000 l       *ABS*  00000000 CRValHiVectorAddr
72360000 l       *ABS*  00000000 L2CCAuxControl
00000001 l       *ABS*  00000000 L2CCControl
00000111 l       *ABS*  00000000 L2CCTAGLatency
00000121 l       *ABS*  00000000 L2CCDataLatency
0000767b l       *ABS*  00000000 SLCRlockKey
0000df0d l       *ABS*  00000000 SLCRUnlockKey
00020202 l       *ABS*  00000000 SLCRL2cRamConfig
40000000 l       *ABS*  00000000 FPEXC_EN
00000134 l       .text  00000000 OKToRun
0000012c l       .text  00000000 EndlessLoop0
00000358 l       .text  00000000 invalidate_dcache
000002b4 l       .text  00000000 Sync
000003d4 l       .text  00000000 finished
0000036c l       .text  00000000 loop1
000003c8 l       .text  00000000 skip
000003a8 l       .text  00000000 loop2
000003ac l       .text  00000000 loop3
00000000 l    df *ABS*  00000000 /mnt/lacie/opt/Xilinx/SDK/2015.2/gnu/arm/lin/bin/../lib/gcc/arm-xilinx-eabi/4.9.1/crti.o
00000000 l    df *ABS*  00000000 crtstuff.c
0001bc68 l     O .eh_frame  00000000 __EH_FRAME_BEGIN__
0001bc64 l     O .data  00000000 __JCR_LIST__
00000464 l     F .text  00000000 deregister_tm_clones
00000494 l     F .text  00000000 register_tm_clones
000004cc l     F .text  00000000 __do_global_dtors_aux
00021040 l       .bss 00000000 completed.8934
00020010 l     O .fini_array  00000000 __do_global_dtors_aux_fini_array_entry
00000510 l     F .text  00000000 frame_dummy
00021044 l       .bss 00000000 object.8939
0002000c l     O .init_array  00000000 __frame_dummy_init_array_entry
00000000 l    df *ABS*  00000000 ./src/fsbl_handoff.o
0001753c l       .handoff 00000000 Loop
00000000 l    df *ABS*  00000000 fsbl_hooks.c
00000000 l    df *ABS*  00000000 image_mover.c
00000000 l    df *ABS*  00000000 main.c
00001e24 l     F .text  000000a4 RegisterHandlers
00001ec8 l     F .text  00000020 Undef_Handler
00001ee8 l     F .text  00000020 SVC_Handler
00001f08 l     F .text  00000020 PreFetch_Abort_Handler
00001f28 l     F .text  00000020 Data_Abort_Handler
00001f48 l     F .text  00000020 IRQ_Handler
00001f68 l     F .text  00000020 FIQ_Handler
00001f88 l     F .text  0000008c Update_MultiBootRegister
00000000 l    df *ABS*  00000000 md5.c
00000000 l    df *ABS*  00000000 nand.c
00000000 l    df *ABS*  00000000 nor.c
00000000 l    df *ABS*  00000000 pcap.c
00021064 l       .bss 00000000 DcfgInstance
00000000 l    df *ABS*  00000000 ps7_init.c
00000000 l    df *ABS*  00000000 qspi.c
00000000 l    df *ABS*  00000000 rsa.c
00000000 l    df *ABS*  00000000 sd.c
00021080 l       .bss 00000000 fil
000212c0 l       .bss 00000000 fatfs
00021500 l       .bss 00000000 buffer
0001b2e8 l     O .data  00000004 boot_file
00000000 l    df *ABS*  00000000 translation_table.o
00000000 l       *ABS*  00000000 SECT
00100000 l       *ABS*  00000000 DDR_START
3fffffff l       *ABS*  00000000 DDR_END
3ff00000 l       *ABS*  00000000 DDR_SIZE
000003ff l       *ABS*  00000000 DDR_REG
00000000 l       *ABS*  00000000 UNDEF_REG
00000000 l    df *ABS*  00000000 usleep.c
00000000 l    df *ABS*  00000000 vectors.c
00000000 l    df *ABS*  00000000 xil-crt0.S
00000000 l    df *ABS*  00000000 xil_cache.c
00000000 l    df *ABS*  00000000 xil_exception.c
00006134 l     F .text  00000004 Xil_ExceptionNullHandler
00000000 l    df *ABS*  00000000 xil_io.c
00000000 l    df *ABS*  00000000 xil_printf.c
0000620c l     F .text  00000074 getnum
00006280 l     F .text  00000034 padding.part.0
000062b4 l     F .text  0000014c outnum
00000000 l    df *ABS*  00000000 xtime_l.c
00000000 l    df *ABS*  00000000 xdevcfg.c
00000000 l    df *ABS*  00000000 xdevcfg_intr.c
00000000 l    df *ABS*  00000000 xdevcfg_sinit.c
00000000 l    df *ABS*  00000000 xdevcfg_g.c
00000000 l    df *ABS*  00000000 xqspips.c
0000797c l     F .text  000000b4 XQspiPs_GetReadData
00007a30 l     F .text  00000028 StubStatusHandler
0001b32c l     O .data  0000004e FlashInst
00000000 l    df *ABS*  00000000 xqspips_sinit.c
00000000 l    df *ABS*  00000000 xqspips_options.c
00018450 l     O .rodata  00000028 OptionsTable
00000000 l    df *ABS*  00000000 cpu_init.o
00000000 l    df *ABS*  00000000 outbyte.c
00000000 l    df *ABS*  00000000 xil_assert.c
00021520 l     O .bss 00000004 Xil_AssertCallbackRoutine
00000000 l    df *ABS*  00000000 xqspips_g.c
00000000 l    df *ABS*  00000000 xuartps_hw.c
00000000 l    df *ABS*  00000000 _udivsi3.o
000091b0 l       .text  00000000 .udivsi3_skip_div0_test
00000000 l       *ABS*  00000000 shift
00000000 l    df *ABS*  00000000 _dvmd_tls.o
00000000 l    df *ABS*  00000000 _arm_addsubdf3.o
00000000 l    df *ABS*  00000000 ctype_.c
00000000 l    df *ABS*  00000000 exit.c
00000000 l    df *ABS*  00000000 fini.c
00000000 l    df *ABS*  00000000 impure.c
0001b398 l     O .data  00000428 impure_data
00000000 l    df *ABS*  00000000 init.c
00000000 l    df *ABS*  00000000 lib_a-memcpy.o
00000000 l    df *ABS*  00000000 printf.c
00000000 l    df *ABS*  00000000 lib_a-strlen-armv7.o
00000000 l    df *ABS*  00000000 vfprintf.c
0000bdf0 l     F .text  000000a8 __sbprintf
00018580 l     O .rodata  00000010 blanks.7710
00018590 l     O .rodata  00000010 zeroes.7711
00000000 l    df *ABS*  00000000 wsetup.c
00000000 l    df *ABS*  00000000 __call_atexit.c
00017504 l     F .text  0000001c register_fini
00000000 l    df *ABS*  00000000 atexit.c
00000000 l    df *ABS*  00000000 dtoa.c
0000c170 l     F .text  000001c4 quorem
00000000 l    df *ABS*  00000000 fflush.c
00000000 l    df *ABS*  00000000 findfp.c
0000d854 l     F .text  00000008 __fp_lock
0000d85c l     F .text  00000008 __fp_unlock
0000d870 l     F .text  0000015c __sinit.part.1
00000000 l    df *ABS*  00000000 mallocr.c
00000000 l    df *ABS*  00000000 fwalk.c
00000000 l    df *ABS*  00000000 locale.c
0001b7c0 l     O .data  00000020 lc_ctype_charset
0001b7e4 l     O .data  00000020 lc_message_charset
0001b804 l     O .data  00000038 lconv
00000000 l    df *ABS*  00000000 makebuf.c
00000000 l    df *ABS*  00000000 mallocr.c
00000000 l    df *ABS*  00000000 lib_a-memchr.o
00000000 l    df *ABS*  00000000 memset.c
00000000 l    df *ABS*  00000000 mlock.c
00000000 l    df *ABS*  00000000 mprec.c
000185a0 l     O .rodata  0000000c p05.6169
00000000 l    df *ABS*  00000000 s_fpclassify.c
00000000 l    df *ABS*  00000000 sbrkr.c
00000000 l    df *ABS*  00000000 stdio.c
00000000 l    df *ABS*  00000000 lib_a-strcmp.o
00000000 l    df *ABS*  00000000 vfprintf.c
0000fca0 l     F .text  000000a4 __sprint_r.part.0
00010f54 l     F .text  000000a8 __sbprintf
000186c8 l     O .rodata  00000010 blanks.7653
000186d8 l     O .rodata  00000010 zeroes.7654
00000000 l    df *ABS*  00000000 writer.c
00000000 l    df *ABS*  00000000 __atexit.c
00000000 l    df *ABS*  00000000 mallocr.c
00000000 l    df *ABS*  00000000 closer.c
00000000 l    df *ABS*  00000000 fclose.c
00000000 l    df *ABS*  00000000 fputwc.c
00000000 l    df *ABS*  00000000 fstatr.c
00000000 l    df *ABS*  00000000 fvwrite.c
00000000 l    df *ABS*  00000000 isattyr.c
00000000 l    df *ABS*  00000000 lseekr.c
00000000 l    df *ABS*  00000000 memmove.c
00000000 l    df *ABS*  00000000 readr.c
00000000 l    df *ABS*  00000000 mallocr.c
00000000 l    df *ABS*  00000000 reent.c
00000000 l    df *ABS*  00000000 wbuf.c
00000000 l    df *ABS*  00000000 wcrtomb.c
00000000 l    df *ABS*  00000000 wctomb_r.c
00000000 l    df *ABS*  00000000 _exit.c
00000000 l    df *ABS*  00000000 _sbrk.c
00021564 l     O .bss 00000004 heap.4207
00000000 l    df *ABS*  00000000 close.c
00000000 l    df *ABS*  00000000 fstat.c
00000000 l    df *ABS*  00000000 isatty.c
00000000 l    df *ABS*  00000000 lseek.c
00000000 l    df *ABS*  00000000 read.c
00000000 l    df *ABS*  00000000 write.c
00000000 l    df *ABS*  00000000 errno.c
00000000 l    df *ABS*  00000000 inbyte.c
00000000 l    df *ABS*  00000000 _divsi3.o
000126b4 l       .text  00000000 .divsi3_skip_div0_test
00000000 l       *ABS*  00000000 shift
00000000 l    df *ABS*  00000000 _aeabi_uldivmod.o
00000000 l    df *ABS*  00000000 bpabi.c
00000000 l    df *ABS*  00000000 libgcc2.c
00000000 l    df *ABS*  00000000 libgcc2.c
00000000 l    df *ABS*  00000000 ff.c
00012c68 l     F .text  0000007c get_ldnumber
00012ce4 l     F .text  0000005c validate
00012d40 l     F .text  000000ac get_fileinfo.isra.1
00012dec l     F .text  0000008c sync_window.part.3
00012e78 l     F .text  00000138 sync_fs
00012fb0 l     F .text  00000064 move_window
00013014 l     F .text  000000b0 check_fs
000130c4 l     F .text  000004e4 find_volume
000135a8 l     F .text  00000108 get_fat.part.6
000136b0 l     F .text  00000144 dir_sdi
000137f4 l     F .text  00000060 dir_remove
00013854 l     F .text  00000178 put_fat.part.8
000139cc l     F .text  00000184 create_chain
00013b50 l     F .text  000001f8 dir_next
00013d48 l     F .text  00000300 follow_path
00014048 l     F .text  000000a4 remove_chain.part.10
000140ec l     F .text  000000b8 dir_read.constprop.11
000141a4 l     F .text  000000c0 dir_register
00021568 l     O .bss 00000004 FatFs
0002156c l     O .bss 00000002 Fsid.5825
00000000 l    df *ABS*  00000000 diskio.c
00021580 l     O .bss 00000001 Stat
000215a0 l     O .bss 00000140 SdInstance
00000000 l    df *ABS*  00000000 xsdps_sinit.c
00000000 l    df *ABS*  00000000 xsdps.c
00000000 l    df *ABS*  00000000 xsdps_g.c
00000000 l    df *ABS*  00000000 xsdps_options.c
00000000 l    df *ABS*  00000000 crtstuff.c
0001bcd8 l     O .eh_frame  00000000 __FRAME_END__
0001bc64 l     O .data  00000000 __JCR_END__
00000000 l    df *ABS*  00000000 /mnt/lacie/opt/Xilinx/SDK/2015.2/gnu/arm/lin/bin/../lib/gcc/arm-xilinx-eabi/4.9.1/crtn.o
000037a8 g     F .text  0000016c PcapDataTransfer
0000f71c g     F .text  00000038 _mprec_log10
ffffc000 g       .stack 00000000 _supervisor_stack_end
0001b25c g     O .data  00000044 ps7_post_config_1_0
0000f7c0 g     F .text  00000080 __any_on
00011954 g     F .text  00000038 _isatty_r
00004fb0 g     F .text  00000204 QspiAccess
00018678 g     O .rodata  00000028 __mprec_tinytens
00005b68 g     F .text  00000048 Xil_L1ICacheInvalidateRange
000120a0 g     F .text  0000002c cleanup_glue
0001ac1c g     O .data  00000494 ps7_mio_init_data_1_0
00012964 g     F .text  0000003c .hidden __gnu_uldivmod_helper
0001b2dc g     O .data  00000004 ps7_clock_init_data
00014288 g     F .text  00000020 get_fat
0001198c g     F .text  00000040 _lseek_r
00000000 g       .text  00000000 _vector_table
0001bcdc g       .eh_frame  00000000 __eh_framehdr_start
00005e5c g     F .text  00000040 Xil_L2CacheDisable
00006f18 g     F .text  00000084 XDcfg_GetStatusRegister
0001bc68 g       .data  00000000 ___CTORS_LIST___
00004ae8 g     F .text  000001d0 InitQspi
0000437c g     F .text  0000007c mask_poll
00006198 g     F .text  00000008 Xil_In32
00005858 g     F .text  00000058 Xil_ICacheInvalidateRange
000129a0 g     F .text  000001a8 .hidden __divdi3
00004cb8 g     F .text  00000248 FlashReadID
00005a70 g     F .text  00000018 Xil_L1DCacheDisable
00000400 g       *ABS*  00000000 _ABORT_STACK_SIZE
00002014 g     F .text  00000038 GetResetReason
000005fc g     F .text  00000018 FsblHookFallback
00009718 g     F .text  00000060 .hidden __floatdidf
00009db4 g     F .text  00000040 printf
000166e4 g     F .text  000000c8 XSdPs_SetupADMA2DescTbl
000122f8 g     F .text  0000008c _wcrtomb_r
0001b2d8 g     O .data  00000004 ps7_pll_init_data
00017544 g       .handoff 00000000 FsblHandoffExit
00001dc4 g     F .text  00000030 MarkFSBLIn
0000f974 g     F .text  0000002c __sseek
0000db18 g     F .text  00000010 __sinit
000121bc g     F .text  00000124 __swbuf_r
00006140 g     F .text  00000008 Xil_PrefetchAbortHandler
0000e00c g     F .text  00000080 _setlocale_r
0000d9cc g     F .text  0000004c __sfmoreglue
00005d38 g     F .text  0000001c Xil_L2CacheInvalidateLine
0000eb78 g     F .text  00000004 __malloc_unlock
00017520 g       .handoff 00000000 FsblHandoffJtagExit
00009090 g     F .text  00000020 Xil_Assert
00001818 g     F .text  00000078 DecryptPartition
000119cc g     F .text  0000012c memmove
00021040 g       .rsa_ac  00000000 __rsa_ac_end
0000554c g     F .text  000000a8 SDAccess
0000db00 g     F .text  00000018 _cleanup
ffffc800 g       .stack 00000000 __supervisor_stack
00004670 g     F .text  000000b0 ps7_post_config
0000eb7c g     F .text  0000008c _Balloc
00020008 g       .ARM.exidx 00000000 __exidx_end
0000443c g     F .text  00000234 ps7_config
000090c4 g     F .text  00000030 XUartPs_SendByte
000013e4 g     F .text  000000a8 ValidatePartitionHeaderChecksum
ffffd000 g       .stack 00000000 _undef_stack_end
00007a58 g     F .text  000000d8 XQspiPs_Abort
000055f4 g     F .text  0000001c ReleaseSD
000072ac g     F .text  00000280 XDcfg_Transfer
00012690  w    F .text  00000010 __errno
00006148 g     F .text  00000004 Xil_ExceptionInit
00006d94 g     F .text  00000080 XDcfg_SetConfigRegister
0000781c g     F .text  000000a4 XDcfg_InterruptHandler
00000f94 g     F .text  00000070 GetImageHeaderStartAddr
00006c10 g     F .text  00000080 XDcfg_GetControlRegister
00021040 g       .ARM.attributes  00000000 __sbss_start
0001893c g     O .data  000000f4 ps7_clock_init_data_3_0
00011470 g     F .text  0000003c _fstat_r
00008d7c g     F .text  000000d4 XQspiPs_SetClkPrescaler
00022aec g     O .bss 00000004 errno
0000f918 g     F .text  00000008 __seofread
000056a4 g     F .text  00000014 PrefetchAbortInterrupt
000090f4 g     F .text  0000002c XUartPs_RecvByte
000036b8 g     F .text  00000024 InitNor
00006908 g     F .text  000000c0 XDcfg_CfgInitialize
000216e0 g     O .bss 00000001 ApplicationFlag
00005610 g     F .text  00000044 usleep
00005444 g     F .text  00000108 InitSD
000061d8 g     F .text  00000010 Xil_Out16BE
00006d10 g     F .text  00000084 XDcfg_GetLockRegister
0001bc68 g       .data  00000000 __fixup_start
000043f8 g     F .text  00000044 mask_read
0000059c g     F .text  00000030 FsblHookAfterBitstreamDload
00021a90 g     O .bss 00000005 WriteBuffer
00008cb8 g     F .text  000000c4 XQspiPs_GetOptions
00005e3c g     F .text  00000020 Xil_DCacheFlush
00005c0c g     F .text  00000020 Xil_DCacheInvalidate
0000011c g       .text  00000000 _boot
00016c90 g     F .text  0000016c XSdPs_Get_BusWidth
00007960 g     F .text  0000001c XDcfg_LookupConfig
00021a98 g     O .bss 00001005 ReadBuffer
00001aa8 g     F .text  00000040 CalcPartitionChecksum
00003e70 g     F .text  00000270 PcapDumpRegisters
0001bc68 g       .data  00000000 __fixup_end
000216e4 g     O .bss 00000004 FsblLength
00009880 g     F .text  000004e0 memcpy
00000000         *UND*  00000000 SIM_MODE
00004324 g     F .text  00000058 mask_write
0001bc68 g     O .data  00000000 .hidden __TMC_END__
0000d864 g     F .text  0000000c _cleanup_r
0000969c g     F .text  00000028 .hidden __floatsidf
0001c000 g       .mmu_tbl 00000000 __mmu_tbl_start
00021040 g       .ARM.attributes  00000000 __sdata_start
00003ad0 g     F .text  0000008c InitPcap
0001bc68 g       .data  00000000 __DTOR_END__
00015d4c g     F .text  00000164 disk_initialize
000128ec g     F .text  00000000 .hidden __aeabi_uldivmod
00005c2c g     F .text  00000030 Xil_ICacheInvalidate
ffffcc00 g       .stack 00000000 __abort_stack
00020014 g       .fini_array  00000000 __fini_array_end
000187b0 g       .rodata  00000000 __rodata_end
0000f840 g     F .text  00000070 __fpclassifyd
0000f6a4 g     F .text  00000078 __ratio
00005d54 g     F .text  00000084 Xil_L2CacheInvalidateRange
00015aa4 g     F .text  00000260 f_rename
0001959c g     O .data  00000044 ps7_post_config_3_0
00000000  w      *UND*  00000000 malloc
00009d80 g     F .text  00000034 _printf_r
00001380 g     F .text  00000064 IsEmptyHeader
000091b0 g     F .text  000001ec .hidden __udivsi3
000124e0  w    F .text  00000008 isatty
0000857c g     F .text  00000118 XQspiPs_LqspiRead
000124d0  w    F .text  00000010 _fstat
0001bc68 g       .data  00000000 __data1_start
000185b0 g     O .rodata  000000c8 __mprec_tens
000187b0 g       .data  00000000 __sbss2_end
0000e08c g     F .text  0000000c __locale_charset
00001d38 g     F .text  0000008c strcpy_rom
00021530 g     O .bss 00000004 __malloc_top_pad
000187b4 g     O .data  00000188 ps7_pll_init_data_3_0
000010dc g     F .text  00000114 HeaderDump
00015d04 g     F .text  00000048 disk_status
00008b78 g     F .text  0000001c XQspiPs_LookupConfig
000152f4 g     F .text  0000017c f_truncate
000187b0 g     O .data  00000000 .hidden __dso_handle
0001b7e0 g     O .data  00000004 __mb_cur_max
00009678 g     F .text  00000024 .hidden __aeabi_ui2d
ffffc000 g       .stack 00000000 __irq_stack
0000e0bc g     F .text  0000000c _localeconv_r
0001b324 g     O .data  00000008 XDcfg_ConfigTable
000114ac g     F .text  000004a8 __sfvwrite_r
0000eecc g     F .text  00000020 __i2b
0000602c g     F .text  00000068 Xil_DCacheFlushLine
000093c0 g     F .text  00000000 .hidden __aeabi_drsub
0000f8b0 g     F .text  00000038 _sbrk_r
00009044 g       .text  00000000 __cpu_init
00003914 g     F .text  000001bc PcapLoadPartition
00015014 g     F .text  00000018 f_closedir
00011af8 g     F .text  00000040 _read_r
00015f1c g     F .text  00000050 disk_ioctl
000111e0 g     F .text  000000f4 _fclose_r
00005c5c g     F .text  000000b0 Xil_L2CacheEnable
0000d824 g     F .text  00000030 fflush
0002155c g     O .bss 00000004 __malloc_max_sbrked_mem
000096c4 g     F .text  00000040 .hidden __extendsfdf2
000173ac g     F .text  00000158 XSdPs_Get_Mmc_ExtCsd
00000db8 g     F .text  0000016c GetPartitionHeaderInfo
000093cc g     F .text  000002ac .hidden __adddf3
000061cc g     F .text  0000000c Xil_In32BE
00000800 g       *ABS*  00000000 _SUPERVISOR_STACK_SIZE
00007b30 g     F .text  00000098 XQspiPs_Reset
00024af0 g       .heap  00000000 _heap_end
0000f4c8 g     F .text  000000dc __b2d
00020000 g       .ARM.exidx 00000000 __exidx_start
000124f0  w    F .text  00000018 lseek
000124e8  w    F .text  00000008 _isatty
00005668 g     F .text  00000014 IRQInterrupt
000024b8 g     F .text  0000005c MD5Memset
0001857c g     O .rodata  00000004 _global_impure_ptr
00011b38 g     F .text  00000568 _realloc_r
000097ec g     F .text  00000078 __libc_init_array
00022af0 g       .bss 00000000 __bss_end
000187b0 g       .data  00000000 __rodata1_start
00012b48 g     F .text  00000120 .hidden __udivdi3
00006e98 g     F .text  00000080 XDcfg_SetStatusRegister
000112e8 g     F .text  00000140 _fputwc_r
00001c0c g     F .text  00000014 FsblFallback
000225c1 g       .ARM.attributes  00000000 __ARM.attributes_end
000186a0 g     O .rodata  00000028 __mprec_bigtens
0000ecf4 g     F .text  000000e4 __s2b
0000567c g     F .text  00000014 SWInterrupt
0000352c g     F .text  0000012c MD5Final
00009678 g     F .text  00000024 .hidden __floatunsidf
0001248c  w    F .text  0000003c _sbrk
0000f2c0 g     F .text  00000064 __mcmp
000216e8 g     O .bss 00000001 PartitionChecksumFlag
0001a700 g     O .data  0000051c ps7_ddr_init_data_1_0
00021040 g       .ARM.attributes  00000000 __tbss_start
00001268 g     F .text  0000007c IsLastPartition
0000db38 g     F .text  00000018 __fp_lock_all
00015470 g     F .text  00000190 f_unlink
00018f5c g     O .data  00000494 ps7_mio_init_data_3_0
0001756c g     F .init  00000000 _init
00004210 g     F .text  000000c8 getPS7MessageInfo
00005dd8 g     F .text  00000064 Xil_L2CacheFlush
00005774 g     F .text  00000060 Xil_DCacheFlushRange
00022aa0 g     O .bss 00000004 QspiFlashMake
000097ac g     F .text  00000040 __libc_fini_array
00019890 g     O .data  0000053c ps7_ddr_init_data_2_0
0001b0b0 g     O .data  000001ac ps7_peripherals_init_data_1_0
00019614 g     O .data  00000188 ps7_pll_init_data_2_0
000120cc g     F .text  000000f0 _reclaim_reent
ffffd000 g       .stack 00000000 __fiq_stack
0000edd8 g     F .text  00000064 __hi0bits
0000614c g     F .text  00000018 Xil_ExceptionRegisterHandler
000168b8 g     F .text  00000100 XSdPs_WritePolled
00022af0 g       .heap  00000000 _heap_start
0001b2a0 g     O .data  00000034 ps7_debug_1_0
00021040 g       .ARM.attributes  00000000 __sbss_end
0000597c g     F .text  00000018 Xil_L1DCacheInvalidateLine
00005a88 g     F .text  00000018 Xil_L1DCacheFlushLine
00000400 g       *ABS*  00000000 _FIQ_STACK_SIZE
000125d0  w    F .text  00000060 write
0000768c g     F .text  0000008c XDcfg_IntrGetEnabled
0000011c g       .text  00000000 _prestart
000011f0 g     F .text  00000078 GetPartitionCount
00001074 g     F .text  00000068 LoadPartitionsHeaderInfo
000093cc g     F .text  000002ac .hidden __aeabi_dadd
000090c0 g     F .text  00000004 XNullHandler
00006400 g     F .text  00000468 xil_printf
00020040 g       .rsa_ac  00000000 __rsa_ac_start
0000f0c8 g     F .text  000000fc __pow5mult
00009704 g     F .text  00000074 .hidden __aeabi_ul2d
0002152c g     O .bss 00000004 __nlocale_changed
00008694 g     F .text  000000a8 XQspiPs_SetSlaveSelect
ffffd400 g       .stack 00000000 __undef_stack
0001a484 g     O .data  00000188 ps7_pll_init_data_1_0
00000000  w      *UND*  00000000 __deregister_frame_info
000126ac g     F .text  00000000 .hidden __aeabi_idiv
00006b74 g     F .text  0000009c XDcfg_ClearControlRegister
00003658 g     F .text  00000060 md5
000061b0 g     F .text  00000008 Xil_Out32
000071c8 g     F .text  00000090 XDcfg_IsDmaBusy
000216e9 g     O .bss 00000001 PSPartitionFlag
00016dfc g     F .text  000000e4 XSdPs_Change_BusWidth
00000000  w      *UND*  00000000 _ITM_registerTMCloneTable
00022ae0 g     O .bss 00000004 PrefetchAbortAddr
00006f9c g     F .text  00000080 XDcfg_SetRomShadowRegister
00001a4c g     F .text  0000005c GetPartitionChecksum
0001bc68 g       .data  00000000 __CTOR_LIST__
0001c000 g       .mmu_tbl 00000000 MMUTable
000187b0 g       .data  00000000 __sbss2_start
0001a450 g     O .data  00000034 ps7_debug_2_0
00005b50 g     F .text  00000018 Xil_L1ICacheInvalidateLine
000216ec g     O .bss 00000004 MoveImage
0000db28 g     F .text  00000004 __sfp_lock_acquire
0000e9e0 g     F .text  00000000 memchr
00004f00 g     F .text  000000b0 FlashRead
0000dc64 g     F .text  000002b0 _free_r
00021a80 g     O .bss 00000004 Silicon_Version
00021a8c g     O .bss 00000004 DcfgInstPtr
00022aa4 g     O .bss 00000004 QspiFlashSize
0000e098 g     F .text  00000010 __locale_mb_cur_max
00005b00 g     F .text  0000001c Xil_L1ICacheEnable
0000bff0 g     F .text  00000168 __call_exitprocs
00021528 g     O .bss 00000004 __mlocale_changed
00014c6c g     F .text  00000028 f_close
000093c8 g     F .text  000002b0 .hidden __aeabi_dsub
0001bc44 g     O .data  00000004 __malloc_sbrk_base
00005f0c g     F .text  00000120 Xil_DCacheInvalidateRange
000056cc g       .text  00000064 _start
000216f0 g     O .bss 00000004 ExecutionAddress
00009704 g     F .text  00000074 .hidden __floatundidf
00012508  w    F .text  00000018 _lseek
0001b37c g     O .data  00000010 XQspiPs_ConfigTable
000175a0 g       .rodata  00000000 __rodata_start
00005b1c g     F .text  0000001c Xil_L1ICacheDisable
0000f1c4 g     F .text  000000fc __lshift
00012520  w    F .text  00000058 read
00021040 g       *ABS*  00000000 _SDA_BASE_
0001103c g     F .text  000000d8 __register_exitproc
000145f8 g     F .text  00000284 f_read
00000f24 g     F .text  00000070 GetPartitionHeaderStartAddr
00006c90 g     F .text  00000080 XDcfg_SetLockRegister
00005814 g     F .text  00000044 Xil_ICacheInvalidateLine
0001bc68 g       .data  00000000 __data_end
0001502c g     F .text  000000a0 f_readdir
0000eeec g     F .text  000001dc __multiply
00006188 g     F .text  00000008 Xil_In8
00022af0 g       .heap  00000000 HeapBase
00001004 g     F .text  00000070 GetFsblLength
00021534 g     O .bss 00000028 __malloc_current_mallinfo
0000226c g     F .text  00000064 ImageCheckID
0000f5a4 g     F .text  00000100 __d2b
0001a260 g     O .data  000001ac ps7_peripherals_init_data_2_0
00015930 g     F .text  000000b4 f_chmod
00006a50 g     F .text  00000088 XDcfg_DisablePCAP
000111a8 g     F .text  00000038 _close_r
00022ae4 g     O .bss 00000004 DataAbortAddr
0000969c g     F .text  00000028 .hidden __aeabi_i2d
00021060 g     O .bss 00000001 LinearBootDeviceFlag
00003b5c g     F .text  000001a4 FabricInit
000216f4 g     O .bss 00000001 BitstreamFlag
00005eb8 g     F .text  00000024 Xil_ICacheDisable
ffff6000 g       .stack 00000000 _irq_stack_end
00005e9c g     F .text  0000001c Xil_DCacheDisable
00001c20 g     F .text  0000001c FsblHandoff
0000be98 g     F .text  00000158 __swsetup_r
000093bc  w    F .text  00000004 .hidden __aeabi_ldiv0
0000da18 g     F .text  000000e8 __sfp
000216f5 g     O .bss 00000001 SignedPartitionFlag
0000f754 g     F .text  0000006c __copybits
000172f8 g     F .text  000000b4 XSdPs_Pullup
0001b83c g     O .data  00000408 __malloc_av_
0000db34 g     F .text  00000004 __sinit_lock_release
0001bcdc g       .eh_frame  00000000 __eh_framehdr_end
0000f8e8 g     F .text  00000030 __sread
00015f6c g     F .text  0000000c get_fattime
00009080 g     F .text  00000010 outbyte
00022aa8 g     O .bss 00000004 QspiInstancePtr
0000eb74 g     F .text  00000004 __malloc_lock
00000000  w      *UND*  00000000 _ITM_deregisterTMCloneTable
00004720 g     F .text  000000b0 ps7_debug
00020010 g       .fini_array  00000000 __fini_array_start
0000d7d4 g     F .text  00000050 _fflush_r
00011114 g     F .text  00000094 _calloc_r
0000595c g     F .text  00000020 Xil_L1DCacheEnable
0000206c g     F .text  0000008c FsblMeasurePerfTime
00006ad8 g     F .text  0000009c XDcfg_SetControlRegister
00021040 g       .bss 00000000 __bss_start
00006000 g       *ABS*  00000000 _STACK_SIZE
00021040 g       .ARM.attributes  00000000 __tdata_start
00021040 g       .ARM.attributes  00000000 __tdata_end
0000ea80 g     F .text  000000f4 memset
00017038 g     F .text  00000144 XSdPs_Change_ClkFreq
00001ae8 g     F .text  00000124 main
000047d0 g     F .text  0000024c ps7_init
0001b2e4 g     O .data  00000004 ps7_peripherals_init_data
000036dc g     F .text  000000cc NorAccess
00021560 g     O .bss 00000004 __malloc_max_total_mem
00002000 g       *ABS*  00000000 _HEAP_SIZE
000122e0 g     F .text  00000018 __swbuf
00014b44 g     F .text  00000128 f_sync
000195e0 g     O .data  00000034 ps7_debug_3_0
00002514 g     F .text  000000d0 MD5Memcpy
00007c90 g     F .text  000003c0 XQspiPs_Transfer
000091b0 g     F .text  00000000 .hidden __aeabi_uidiv
00006204 g     F .text  00000008 Xil_EndianSwap32
0000f9a0 g     F .text  00000008 __sclose
00004ab0 g     F .text  00000024 perf_disable_clock
000112d4 g     F .text  00000014 fclose
00016000 g     F .text  00000174 XSdPs_CfgInitialize
00020010 g       .init_array  00000000 __init_array_end
0000c334 g     F .text  00001264 _dtoa_r
0000e25c g     F .text  00000778 _malloc_r
000058b0 g     F .text  000000ac Xil_L1DCacheInvalidate
00012418 g     F .text  00000028 __ascii_wctomb
00009718 g     F .text  00000060 .hidden __aeabi_l2d
000216f6 g     O .bss 00000001 EncryptedPartitionFlag
000142c8 g     F .text  00000094 f_mount
00001c3c g     F .text  00000064 OutputStatus
0000df14 g     F .text  00000078 _fwalk
00016450 g     F .text  00000248 XSdPs_SdCardInitialize
ffff0000 g       .stack 00000000 _stack_end
00022ae8 g     O .bss 00000004 Xil_AssertStatus
00000000  w      *UND*  00000000 __libc_fini
00014f20 g     F .text  000000f4 f_opendir
0001bc68 g       .data  00000000 ___DTORS_END___
000126ac g     F .text  00000220 .hidden __divsi3
00005aa0 g     F .text  00000048 Xil_L1DCacheFlushRange
00006868 g     F .text  00000050 XTime_SetTime
00021040 g       .ARM.attributes  00000000 __sdata_end
0000db68 g     F .text  000000fc _malloc_trim_r
000187b0 g       .data  00000000 __sdata2_start
0001bc68 g       .data  00000000 __CTOR_END__
0001bc68 g       .data  00000000 ___DTORS_LIST___
0000f9c8 g     F .text  000002dc strcmp
00005ae8 g     F .text  00000018 Xil_L1DCacheStoreLine
0001bc68 g       .data  00000000 __DTOR_LIST__
00010f2c g     F .text  00000028 vfiprintf
0001bc50 g     O .data  00000014 XSdPs_ConfigTable
00007258 g     F .text  00000054 XDcfg_InitiateDma
000142a8 g     F .text  00000020 put_fat
0000148c g     F .text  0000038c PartitionMove
00017584 g     F .fini  00000000 _fini
00014c94 g     F .text  0000028c f_lseek
00005d1c g     F .text  0000001c Xil_ICacheEnable
00003338 g     F .text  00000074 MD5Init
00006118 g     F .text  0000001c Xil_L2CacheStoreLine
00021524 g     O .bss 00000004 _PathLocale
00004a1c g     F .text  00000024 perf_start_clock
00022aac g     O .bss 00000034 QspiInstance
ffffc800 g       .stack 00000000 _abort_stack_end
0000c158 g     F .text  00000014 atexit
00010ffc g     F .text  00000040 _write_r
0000e0c8 g     F .text  00000018 setlocale
0002105c g     O .bss 00000004 FlashReadBaseAddress
000216f8 g     O .bss 00000004 PartitionCount
00001df4 g     F .text  00000030 ClearFSBLIn
00008f88 g     F .text  000000bc XQspiPs_GetDelays
000216fc g     O .bss 00000001 PLPartitionFlag
0001b390 g     O .data  00000004 _impure_ptr
0000d598 g     F .text  0000023c __sflush_r
0000e0b4 g     F .text  00000008 __locale_cjk_lang
000061a0 g     F .text  00000008 Xil_Out8
00020008 g       .init_array  00000000 __preinit_array_end
000033ac g     F .text  00000180 MD5Update
000187b0 g       .data  00000000 __sdata2_end
00021a84 g     O .bss 00000001 SystemInitFlag
000061f4 g     F .text  00000010 Xil_EndianSwap16
0000f464 g     F .text  00000064 __ulp
000150cc g     F .text  000000a4 f_stat
0000db50 g     F .text  00000018 __fp_unlock_all
0000873c g     F .text  000000a0 XQspiPs_SetStatusHandler
000020f8 g     F .text  00000080 GetSiliconVersion
000126a0 g     F .text  0000000c inbyte
00001000 g       *ABS*  00000000 _RSA_AC_SIZE
00016bb0 g     F .text  000000e0 XSdPs_SetBlkSize
00004a40 g     F .text  00000030 perf_reset_clock
0001b2ec g     O .data  00000038 XExc_VectorTable
0000e0e0 g     F .text  0000000c localeconv
00014264 g     F .text  00000024 clust2sect
00015fe4 g     F .text  0000001c XSdPs_LookupConfig
000005cc g     F .text  00000030 FsblHookBeforeHandoff
0001bc68 g       .data  00000000 ___CTORS_END___
ffff6000 g       .stack 00000000 __stack
00004ad4 g     F .text  00000014 perf_reset_and_start_timer
0000939c g     F .text  00000020 .hidden __aeabi_uidivmod
00024af0 g       .heap  00000000 HeapLimit
00008e50 g     F .text  00000088 XQspiPs_GetClkPrescaler
00006164 g     F .text  00000024 Xil_ExceptionRemoveHandler
00002428 g     F .text  0000008c DDRInitCheck
0000056c g     F .text  00000030 FsblHookBeforeBitstreamDload
00012630  w    F .text  00000060 _write
000159e4 g     F .text  000000c0 f_utime
00008050 g     F .text  0000052c XQspiPs_PolledTransfer
ffffd400 g       .stack 00000000 _end
00001cc4 g     F .text  00000074 memcpy_rom
00009120 g     F .text  00000090 XUartPs_ResetHw
0001b2e0 g     O .data  00000004 ps7_ddr_init_data
000187b0 g       .data  00000000 __rodata1_end
000193f0 g     O .data  000001ac ps7_peripherals_init_data_3_0
00003d00 g     F .text  00000170 ClearPcapStatus
00002178 g     F .text  000000f4 HeaderChecksum
0001487c g     F .text  000002c8 f_write
00001ca0 g     F .text  00000024 ErrorLockdown
0001bc68 g       .data  00000000 __data1_end
00019dcc g     O .data  00000494 ps7_mio_init_data_2_0
00005690 g     F .text  00000014 DataAbortInterrupt
00007718 g     F .text  00000084 XDcfg_IntrGetStatus
000061e8 g     F .text  0000000c Xil_Out32BE
0000f920 g     F .text  00000054 __swrite
0000779c g     F .text  00000080 XDcfg_IntrClear
0001bc48 g     O .data  00000004 __malloc_trim_threshold
0001435c g     F .text  0000029c f_open
00008b94 g     F .text  00000124 XQspiPs_SetOptions
00022af0 g       .heap  00000000 _heap
00015f78 g     F .text  0000006c disk_write
0000e0a8 g     F .text  0000000c __locale_msgcharset
000087dc g     F .text  0000039c XQspiPs_InterruptHandler
00018a30 g     O .data  0000052c ps7_ddr_init_data_3_0
00009778 g     F .text  00000034 exit
0000fd60 g     F .text  000011cc _vfiprintf_r
0000df8c g     F .text  00000080 _fwalk_reent
000051b4 g     F .text  00000290 SendBankSelect
0000f324 g     F .text  00000140 __mdiff
000022d0 g     F .text  00000158 NextValidImageCheck
0001b38c g     O .data  00000004 __ctype_ptr__
00021040 g       .ARM.attributes  00000000 __tbss_end
0000db2c g     F .text  00000004 __sfp_lock_release
00016ee0 g     F .text  00000158 XSdPs_Get_BusSpeed
00018478 g     O .rodata  00000101 _ctype_
00012578  w    F .text  00000058 _read
00020008 g       .init_array  00000000 __init_array_start
000093bc  w    F .text  00000004 .hidden __aeabi_idiv0
000040e0 g     F .text  00000130 XDcfgPollDone
00000614 g     F .text  000007a4 LoadBootImage
00015600 g     F .text  00000330 f_mkdir
0001717c g     F .text  0000017c XSdPs_Change_BusSpeed
00007144 g     F .text  00000084 XDcfg_GetMiscControlRegister
00012488  w    F .text  00000004 _exit
00005730 g     F .text  00000044 Xil_DCacheInvalidateLine
000061b8 g     F .text  00000014 Xil_In16BE
000075dc g     F .text  000000b0 XDcfg_IntrDisable
00016174 g     F .text  0000015c XSdPs_FrameCmd
0000e0ec g     F .text  00000170 __smakebuf_r
000078c0 g     F .text  000000a0 XDcfg_SetHandler
00005654 g     F .text  00000014 FIQInterrupt
00009e00 g     F .text  000000dc strlen
00015eb0 g     F .text  0000006c disk_read
000169b8 g     F .text  000001f8 XSdPs_MmcCardInitialize
ffff6000 g       .stack 00000000 _stack
0001a60c g     O .data  000000f4 ps7_clock_init_data_1_0
0001bc4c g     O .data  00000004 __wctomb
00012928 g     F .text  0000003c .hidden __gnu_ldivmod_helper
00007bc8 g     F .text  000000c8 XQspiPs_CfgInitialize
0000fd44 g     F .text  0000001c __sprint_r
00015170 g     F .text  00000184 f_getfree
000090b0 g     F .text  00000010 Xil_AssertSetCallback
000061a8 g     F .text  00000008 Xil_Out16
000096c4 g     F .text  00000040 .hidden __aeabi_f2d
000025e4 g     F .text  00000d54 MD5Transform
000187b0 g       .data  00000000 __data_start
00006094 g     F .text  00000084 Xil_L2CacheFlushRange
00021700 g     O .bss 00000380 PartitionHeader
00008ed8 g     F .text  000000b0 XQspiPs_SetDelays
0001a40c g     O .data  00000044 ps7_post_config_2_0
000057d4 g     F .text  00000040 Xil_DCacheStoreLine
00005bb0 g     F .text  0000005c Xil_L2CacheInvalidate
00012440 g     F .text  00000048 _wctomb_r
00000000  w      *UND*  00000000 _Jv_RegisterClasses
ffffcc00 g       .stack 00000000 _fiq_stack_end
000070a0 g     F .text  000000a4 XDcfg_SetMiscControlRegister
000167ac g     F .text  0000010c XSdPs_ReadPolled
00006190 g     F .text  00000008 Xil_In16
000093c8 g     F .text  000002b0 .hidden __subdf3
00009f00 g     F .text  00001ec8 _vfprintf_r
00020008 g       .init_array  00000000 __preinit_array_start
000059dc g     F .text  00000094 Xil_L1DCacheFlush
000162d0 g     F .text  00000180 XSdPs_CmdTransfer
00000400 g       *ABS*  00000000 _UNDEF_STACK_SIZE
000069c8 g     F .text  00000088 XDcfg_EnablePCAP
00005b38 g     F .text  00000018 Xil_L1ICacheInvalidate
0000ee3c g     F .text  00000090 __lo0bits
0001979c g     O .data  000000f4 ps7_clock_init_data_2_0
000128cc g     F .text  00000020 .hidden __aeabi_idivmod
0001b2d4 g     O .data  00000004 ps7_mio_init_data
00005edc g     F .text  00000030 Xil_L2CacheFlushLine
000187b0 g       *ABS*  00000000 _SDA2_BASE_
00006138 g     F .text  00000008 Xil_DataAbortHandler
0000701c g     F .text  00000084 XDcfg_GetSoftwareIdRegister
000068b8 g     F .text  00000050 XTime_GetTime
00000000  w      *UND*  00000000 __register_frame_info
00012384 g     F .text  00000094 wcrtomb
0000752c g     F .text  000000b0 XDcfg_IntrEnable
00020000 g       .mmu_tbl 00000000 __mmu_tbl_end
00021a88 g     O .bss 00000004 PcapCtrlRegVal
00001890 g     F .text  000001bc ValidateParition
00005d0c g     F .text  00000010 Xil_DCacheEnable
00021040 g       .ARM.attributes  00000000 __ARM.attributes_start
00004a70 g     F .text  00000040 get_number_of_cycles_for_delay
0000bdc8 g     F .text  00000028 vfprintf
00005994 g     F .text  00000048 Xil_L1DCacheInvalidateRange
000042d8 g     F .text  0000004c ps7GetSiliconVersion
00011428 g     F .text  00000048 fputwc
000124c8  w    F .text  00000008 _close
00006e14 g     F .text  00000084 XDcfg_GetConfigRegister
0000204c g     F .text  00000020 FsblGetGlobalTime
00000000  w      *UND*  00000000 free
0000db30 g     F .text  00000004 __sinit_lock_acquire
000012e4 g     F .text  0000009c ValidateHeader
0000ec24 g     F .text  000000d0 __multadd
00016698 g     F .text  0000004c XSdPs_Select_Card
0000ec08 g     F .text  0000001c _Bfree



Disassembly of section .text:

00000000 <_vector_table>:

.globl _vector_table

.section .vectors
_vector_table:
  B _boot
       0: ea000045  b 11c <_boot>
  B Undefined
       4: ea000025  b a0 <Undefined>
  B SVCHandler
       8: ea000028  b b0 <SVCHandler>
  B PrefetchAbortHandler
       c: ea000038  b f4 <PrefetchAbortHandler>
  B DataAbortHandler
      10: ea00002f  b d4 <DataAbortHandler>
  NOP /* Placeholder for address exception vector*/
      14: e320f000  nop {0}
  B IRQHandler
      18: ea000000  b 20 <IRQHandler>
  B FIQHandler
      1c: ea00000f  b 60 <FIQHandler>

00000020 <IRQHandler>:


IRQHandler:         /* IRQ vector handler */

  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code*/
      20: e92d500f  push  {r0, r1, r2, r3, ip, lr}
#ifdef __ARM_NEON__
  vpush {d0-d7}
      24: ed2d0b10  vpush {d0-d7}
  vpush {d16-d31}
      28: ed6d0b20  vpush {d16-d31}
  vmrs r1, FPSCR
      2c: eef11a10  vmrs  r1, fpscr
  push {r1}
      30: e52d1004  push  {r1}    ; (str r1, [sp, #-4]!)
  vmrs r1, FPEXC
      34: eef81a10  vmrs  r1, fpexc
  push {r1}
      38: e52d1004  push  {r1}    ; (str r1, [sp, #-4]!)
  ldr r2, =prof_pc
  subs  r3, lr, #0
  str r3, [r2]
#endif

  bl  IRQInterrupt      /* IRQ vector */
      3c: eb001589  bl  5668 <IRQInterrupt>

#ifdef __ARM_NEON__
  pop   {r1}
      40: e49d1004  pop {r1}    ; (ldr r1, [sp], #4)
  vmsr    FPEXC, r1
      44: eee81a10  vmsr  fpexc, r1
  pop   {r1}
      48: e49d1004  pop {r1}    ; (ldr r1, [sp], #4)
  vmsr    FPSCR, r1
      4c: eee11a10  vmsr  fpscr, r1
  vpop    {d16-d31}
      50: ecfd0b20  vpop  {d16-d31}
  vpop    {d0-d7}
      54: ecbd0b10  vpop  {d0-d7}
#endif
  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
      58: e8bd500f  pop {r0, r1, r2, r3, ip, lr}


  subs  pc, lr, #4      /* adjust return */
      5c: e25ef004  subs  pc, lr, #4

00000060 <FIQHandler>:


FIQHandler:         /* FIQ vector handler */
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
      60: e92d500f  push  {r0, r1, r2, r3, ip, lr}
#ifdef __ARM_NEON__
  vpush {d0-d7}
      64: ed2d0b10  vpush {d0-d7}
  vpush {d16-d31}
      68: ed6d0b20  vpush {d16-d31}
  vmrs r1, FPSCR
      6c: eef11a10  vmrs  r1, fpscr
  push {r1}
      70: e52d1004  push  {r1}    ; (str r1, [sp, #-4]!)
  vmrs r1, FPEXC
      74: eef81a10  vmrs  r1, fpexc
  push {r1}
      78: e52d1004  push  {r1}    ; (str r1, [sp, #-4]!)

0000007c <FIQLoop>:
#endif

FIQLoop:
  bl  FIQInterrupt      /* FIQ vector */
      7c: eb001574  bl  5654 <FIQInterrupt>

#ifdef __ARM_NEON__
  pop   {r1}
      80: e49d1004  pop {r1}    ; (ldr r1, [sp], #4)
  vmsr    FPEXC, r1
      84: eee81a10  vmsr  fpexc, r1
  pop   {r1}
      88: e49d1004  pop {r1}    ; (ldr r1, [sp], #4)
  vmsr    FPSCR, r1
      8c: eee11a10  vmsr  fpscr, r1
  vpop    {d16-d31}
      90: ecfd0b20  vpop  {d16-d31}
  vpop    {d0-d7}
      94: ecbd0b10  vpop  {d0-d7}
#endif
  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
      98: e8bd500f  pop {r0, r1, r2, r3, ip, lr}
  subs  pc, lr, #4      /* adjust return */
      9c: e25ef004  subs  pc, lr, #4

000000a0 <Undefined>:


Undefined:          /* Undefined handler */
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
      a0: e92d500f  push  {r0, r1, r2, r3, ip, lr}

  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
      a4: e8bd500f  pop {r0, r1, r2, r3, ip, lr}

  b _prestart
      a8: ea00001b  b 11c <_boot>

  movs  pc, lr
      ac: e1b0f00e  movs  pc, lr

000000b0 <SVCHandler>:


SVCHandler:         /* SWI handler */
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
      b0: e92d500f  push  {r0, r1, r2, r3, ip, lr}

  tst r0, #0x20     /* check the T bit */
      b4: e3100020  tst r0, #32
  ldrneh  r0, [lr,#-2]      /* Thumb mode */
      b8: 115e00b2  ldrhne  r0, [lr, #-2]
  bicne r0, r0, #0xff00     /* Thumb mode */
      bc: 13c00cff  bicne r0, r0, #65280  ; 0xff00
  ldreq r0, [lr,#-4]      /* ARM mode */
      c0: 051e0004  ldreq r0, [lr, #-4]
  biceq r0, r0, #0xff000000   /* ARM mode */
      c4: 03c004ff  biceq r0, r0, #-16777216  ; 0xff000000

  bl  SWInterrupt     /* SWInterrupt: call C function here */
      c8: eb00156b  bl  567c <SWInterrupt>

  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
      cc: e8bd500f  pop {r0, r1, r2, r3, ip, lr}

  movs  pc, lr    /*return to the next instruction after the SWI instruction */
      d0: e1b0f00e  movs  pc, lr

000000d4 <DataAbortHandler>:


DataAbortHandler:       /* Data Abort handler */
#ifdef CONFIG_ARM_ERRATA_775420
  dsb
      d4: f57ff04f  dsb sy
#endif
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
      d8: e92d500f  push  {r0, r1, r2, r3, ip, lr}
  ldr     r0, =DataAbortAddr
      dc: e59f0030  ldr r0, [pc, #48] ; 114 <L2CCTAGLatency+0x3>
  sub     r1, lr, #8
      e0: e24e1008  sub r1, lr, #8
  str     r1, [r0]                /* Stores instruction causing data abort */
      e4: e5801000  str r1, [r0]

  bl  DataAbortInterrupt    /*DataAbortInterrupt :call C function here */
      e8: eb001568  bl  5690 <DataAbortInterrupt>

  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
      ec: e8bd500f  pop {r0, r1, r2, r3, ip, lr}

  subs  pc, lr, #8      /* points to the instruction that caused the Data Abort exception */
      f0: e25ef008  subs  pc, lr, #8

000000f4 <PrefetchAbortHandler>:

PrefetchAbortHandler:       /* Prefetch Abort handler */
#ifdef CONFIG_ARM_ERRATA_775420
  dsb
      f4: f57ff04f  dsb sy
#endif
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
      f8: e92d500f  push  {r0, r1, r2, r3, ip, lr}
  ldr     r0, =PrefetchAbortAddr
      fc: e59f0014  ldr r0, [pc, #20] ; 118 <L2CCTAGLatency+0x7>
  sub     r1, lr, #4
     100: e24e1004  sub r1, lr, #4
  str     r1, [r0]                /* Stores instruction causing prefetch abort */
     104: e5801000  str r1, [r0]

  bl  PrefetchAbortInterrupt    /* PrefetchAbortInterrupt: call C function here */
     108: eb001565  bl  56a4 <PrefetchAbortInterrupt>

  ldmia sp!,{r0-r3,r12,lr}    /* state restore from compiled code */
     10c: e8bd500f  pop {r0, r1, r2, r3, ip, lr}

  subs  pc, lr, #4      /* points to the instruction that caused the Prefetch Abort exception */
     110: e25ef004  subs  pc, lr, #4
DataAbortHandler:       /* Data Abort handler */
#ifdef CONFIG_ARM_ERRATA_775420
  dsb
#endif
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
  ldr     r0, =DataAbortAddr
     114: 00022ae4  .word 0x00022ae4
PrefetchAbortHandler:       /* Prefetch Abort handler */
#ifdef CONFIG_ARM_ERRATA_775420
  dsb
#endif
  stmdb sp!,{r0-r3,r12,lr}    /* state save from compiled code */
  ldr     r0, =PrefetchAbortAddr
     118: 00022ae0  .word 0x00022ae0

0000011c <_boot>:
_prestart:
_boot:

#if XPAR_CPU_ID==0
/* only allow cpu0 through */
  mrc p15,0,r1,c0,c0,5
     11c: ee101fb0  mrc 15, 0, r1, cr0, cr0, {5}
  and r1, r1, #0xf
     120: e201100f  and r1, r1, #15
  cmp r1, #0
     124: e3510000  cmp r1, #0
  beq OKToRun
     128: 0a000001  beq 134 <OKToRun>

0000012c <EndlessLoop0>:
EndlessLoop0:
  wfe
     12c: e320f002  wfe
  b EndlessLoop0
     130: eafffffd  b 12c <EndlessLoop0>

00000134 <OKToRun>:
  wfe
  b EndlessLoop1
#endif

OKToRun:
  mrc     p15, 0, r0, c0, c0, 0   /* Get the revision */
     134: ee100f10  mrc 15, 0, r0, cr0, cr0, {0}
  and     r5, r0, #0x00f00000
     138: e200560f  and r5, r0, #15728640 ; 0xf00000
  and     r6, r0, #0x0000000f
     13c: e200600f  and r6, r0, #15
  orr     r6, r6, r5, lsr #20-4
     140: e1866825  orr r6, r6, r5, lsr #16

#ifdef CONFIG_ARM_ERRATA_742230
        cmp     r6, #0x22                       /* only present up to r2p2 */
     144: e3560022  cmp r6, #34 ; 0x22
        mrcle   p15, 0, r10, c15, c0, 1         /* read diagnostic register */
     148: de1faf30  mrcle 15, 0, sl, cr15, cr0, {1}
        orrle   r10, r10, #1 << 4               /* set bit #4 */
     14c: d38aa010  orrle sl, sl, #16
        mcrle   p15, 0, r10, c15, c0, 1         /* write diagnostic register */
     150: de0faf30  mcrle 15, 0, sl, cr15, cr0, {1}
#endif

#ifdef CONFIG_ARM_ERRATA_743622
  teq     r5, #0x00200000                 /* only present in r2p* */
     154: e3350602  teq r5, #2097152  ; 0x200000
  mrceq   p15, 0, r10, c15, c0, 1         /* read diagnostic register */
     158: 0e1faf30  mrceq 15, 0, sl, cr15, cr0, {1}
  orreq   r10, r10, #1 << 6               /* set bit #6 */
     15c: 038aa040  orreq sl, sl, #64 ; 0x40
  mcreq   p15, 0, r10, c15, c0, 1         /* write diagnostic register */
     160: 0e0faf30  mcreq 15, 0, sl, cr15, cr0, {1}
#endif

  /* set VBAR to the _vector_table address in linker script */
  ldr r0, =vector_base
     164: e59f027c  ldr r0, [pc, #636]  ; 3e8 <finished+0x14>
  mcr p15, 0, r0, c12, c0, 0
     168: ee0c0f10  mcr 15, 0, r0, cr12, cr0, {0}

  /*invalidate scu*/
  ldr r7, =0xf8f0000c
     16c: e59f7278  ldr r7, [pc, #632]  ; 3ec <finished+0x18>
  ldr r6, =0xffff
     170: e59f6278  ldr r6, [pc, #632]  ; 3f0 <finished+0x1c>
  str r6, [r7]
     174: e5876000  str r6, [r7]

  /* Invalidate caches and TLBs */
  mov r0,#0       /* r0 = 0  */
     178: e3a00000  mov r0, #0
  mcr p15, 0, r0, c8, c7, 0   /* invalidate TLBs */
     17c: ee080f17  mcr 15, 0, r0, cr8, cr7, {0}
  mcr p15, 0, r0, c7, c5, 0   /* invalidate icache */
     180: ee070f15  mcr 15, 0, r0, cr7, cr5, {0}
  mcr p15, 0, r0, c7, c5, 6   /* Invalidate branch predictor array */
     184: ee070fd5  mcr 15, 0, r0, cr7, cr5, {6}
  bl  invalidate_dcache   /* invalidate dcache */
     188: eb000072  bl  358 <invalidate_dcache>

  /* Disable MMU, if enabled */
  mrc p15, 0, r0, c1, c0, 0   /* read CP15 register 1 */
     18c: ee110f10  mrc 15, 0, r0, cr1, cr0, {0}
  bic r0, r0, #0x1      /* clear bit 0 */
     190: e3c00001  bic r0, r0, #1
  mcr p15, 0, r0, c1, c0, 0   /* write value back */
     194: ee010f10  mcr 15, 0, r0, cr1, cr0, {0}
  add r2, r2, #0x100000   /* next section */
  subs  r3, r3, #1
  bge mmu_loop      /* loop till 512MB is covered */
#endif

  mrs r0, cpsr      /* get the current PSR */
     198: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the irq stack pointer */
     19c: e3e0101f  mvn r1, #31
  and r2, r1, r0
     1a0: e0012000  and r2, r1, r0
  orr r2, r2, #0x12     /* IRQ mode */
     1a4: e3822012  orr r2, r2, #18
  msr cpsr, r2
     1a8: e129f002  msr CPSR_fc, r2
  ldr r13,=IRQ_stack      /* IRQ stack pointer */
     1ac: e59fd240  ldr sp, [pc, #576]  ; 3f4 <finished+0x20>

  mrs r0, cpsr      /* get the current PSR */
     1b0: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the supervisor stack pointer */
     1b4: e3e0101f  mvn r1, #31
  and r2, r1, r0
     1b8: e0012000  and r2, r1, r0
  orr r2, r2, #0x13     /* supervisor mode */
     1bc: e3822013  orr r2, r2, #19
  msr cpsr, r2
     1c0: e129f002  msr CPSR_fc, r2
  ldr r13,=SPV_stack      /* Supervisor stack pointer */
     1c4: e59fd22c  ldr sp, [pc, #556]  ; 3f8 <finished+0x24>

  mrs r0, cpsr      /* get the current PSR */
     1c8: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the Abort  stack pointer */
     1cc: e3e0101f  mvn r1, #31
  and r2, r1, r0
     1d0: e0012000  and r2, r1, r0
  orr r2, r2, #0x17     /* Abort mode */
     1d4: e3822017  orr r2, r2, #23
  msr cpsr, r2
     1d8: e129f002  msr CPSR_fc, r2
  ldr r13,=Abort_stack    /* Abort stack pointer */
     1dc: e59fd218  ldr sp, [pc, #536]  ; 3fc <finished+0x28>

  mrs r0, cpsr      /* get the current PSR */
     1e0: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the FIQ stack pointer */
     1e4: e3e0101f  mvn r1, #31
  and r2, r1, r0
     1e8: e0012000  and r2, r1, r0
  orr r2, r2, #0x11     /* FIQ mode */
     1ec: e3822011  orr r2, r2, #17
  msr cpsr, r2
     1f0: e129f002  msr CPSR_fc, r2
  ldr r13,=FIQ_stack      /* FIQ stack pointer */
     1f4: e59fd204  ldr sp, [pc, #516]  ; 400 <_ABORT_STACK_SIZE>

  mrs r0, cpsr      /* get the current PSR */
     1f8: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the Undefine stack pointer */
     1fc: e3e0101f  mvn r1, #31
  and r2, r1, r0
     200: e0012000  and r2, r1, r0
  orr r2, r2, #0x1b     /* Undefine mode */
     204: e382201b  orr r2, r2, #27
  msr cpsr, r2
     208: e129f002  msr CPSR_fc, r2
  ldr r13,=Undef_stack    /* Undefine stack pointer */
     20c: e59fd1f0  ldr sp, [pc, #496]  ; 404 <_ABORT_STACK_SIZE+0x4>

  mrs r0, cpsr      /* get the current PSR */
     210: e10f0000  mrs r0, CPSR
  mvn r1, #0x1f     /* set up the system stack pointer */
     214: e3e0101f  mvn r1, #31
  and r2, r1, r0
     218: e0012000  and r2, r1, r0
  orr r2, r2, #0x1F     /* SYS mode */
     21c: e382201f  orr r2, r2, #31
  msr cpsr, r2
     220: e129f002  msr CPSR_fc, r2
  ldr r13,=SYS_stack      /* SYS stack pointer */
     224: e59fd1dc  ldr sp, [pc, #476]  ; 408 <_ABORT_STACK_SIZE+0x8>

  /*set scu enable bit in scu*/
  ldr r7, =0xf8f00000
     228: e59f71dc  ldr r7, [pc, #476]  ; 40c <_ABORT_STACK_SIZE+0xc>
  ldr r0, [r7]
     22c: e5970000  ldr r0, [r7]
  orr r0, r0, #0x1
     230: e3800001  orr r0, r0, #1
  str r0, [r7]
     234: e5870000  str r0, [r7]

  /* enable MMU and cache */

  ldr r0,=TblBase     /* Load MMU translation table base */
     238: e59f01d0  ldr r0, [pc, #464]  ; 410 <_ABORT_STACK_SIZE+0x10>
  orr r0, r0, #0x5B     /* Outer-cacheable, WB */
     23c: e380005b  orr r0, r0, #91 ; 0x5b
  mcr 15, 0, r0, c2, c0, 0    /* TTB0 */
     240: ee020f10  mcr 15, 0, r0, cr2, cr0, {0}

  mvn r0,#0       /* Load MMU domains -- all ones=manager */
     244: e3e00000  mvn r0, #0
  mcr p15,0,r0,c3,c0,0
     248: ee030f10  mcr 15, 0, r0, cr3, cr0, {0}

  /* Enable mmu, icahce and dcache */
  ldr r0,=CRValMmuCac
     24c: e59f01c0  ldr r0, [pc, #448]  ; 414 <_ABORT_STACK_SIZE+0x14>
  mcr p15,0,r0,c1,c0,0    /* Enable cache and MMU */
     250: ee010f10  mcr 15, 0, r0, cr1, cr0, {0}
  dsb         /* dsb  allow the MMU to start up */
     254: f57ff04f  dsb sy
  isb         /* isb  flush prefetch buffer */
     258: f57ff06f  isb sy

  /* Write to ACTLR */
  mrc p15, 0, r0, c1, c0, 1   /* Read ACTLR*/
     25c: ee110f30  mrc 15, 0, r0, cr1, cr0, {1}
  orr r0, r0, #(0x01 << 6)    /* set SMP bit */
     260: e3800040  orr r0, r0, #64 ; 0x40
  orr r0, r0, #(0x01 )    /* */
     264: e3800001  orr r0, r0, #1
  mcr p15, 0, r0, c1, c0, 1   /* Write ACTLR*/
     268: ee010f30  mcr 15, 0, r0, cr1, cr0, {1}

/* Invalidate L2 Cache and enable L2 Cache*/
/* For AMP, assume running on CPU1. Don't initialize L2 Cache (up to Linux) */
#if USE_AMP!=1
  ldr r0,=L2CCCrtl      /* Load L2CC base address base + control register */
     26c: e59f01a4  ldr r0, [pc, #420]  ; 418 <_ABORT_STACK_SIZE+0x18>
  mov r1, #0        /* force the disable bit */
     270: e3a01000  mov r1, #0
  str r1, [r0]      /* disable the L2 Caches */
     274: e5801000  str r1, [r0]

  ldr r0,=L2CCAuxCrtl     /* Load L2CC base address base + Aux control register */
     278: e59f019c  ldr r0, [pc, #412]  ; 41c <_ABORT_STACK_SIZE+0x1c>
  ldr r1,[r0]       /* read the register */
     27c: e5901000  ldr r1, [r0]
  ldr r2,=L2CCAuxControl    /* set the default bits */
     280: e59f2198  ldr r2, [pc, #408]  ; 420 <_ABORT_STACK_SIZE+0x20>
  orr r1,r1,r2
     284: e1811002  orr r1, r1, r2
  str r1, [r0]      /* store the Aux Control Register */
     288: e5801000  str r1, [r0]

  ldr r0,=L2CCTAGLatReg   /* Load L2CC base address base + TAG Latency address */
     28c: e59f0190  ldr r0, [pc, #400]  ; 424 <_ABORT_STACK_SIZE+0x24>
  ldr r1,=L2CCTAGLatency    /* set the latencies for the TAG*/
     290: e59f1190  ldr r1, [pc, #400]  ; 428 <_ABORT_STACK_SIZE+0x28>
  str r1, [r0]      /* store the TAG Latency register Register */
     294: e5801000  str r1, [r0]

  ldr r0,=L2CCDataLatReg    /* Load L2CC base address base + Data Latency address */
     298: e59f018c  ldr r0, [pc, #396]  ; 42c <_ABORT_STACK_SIZE+0x2c>
  ldr r1,=L2CCDataLatency   /* set the latencies for the Data*/
     29c: e59f118c  ldr r1, [pc, #396]  ; 430 <_ABORT_STACK_SIZE+0x30>
  str r1, [r0]      /* store the Data Latency register Register */
     2a0: e5801000  str r1, [r0]

  ldr r0,=L2CCWay     /* Load L2CC base address base + way register*/
     2a4: e59f0188  ldr r0, [pc, #392]  ; 434 <_ABORT_STACK_SIZE+0x34>
  ldr r2, =0xFFFF
     2a8: e59f2140  ldr r2, [pc, #320]  ; 3f0 <finished+0x1c>
  str r2, [r0]      /* force invalidate */
     2ac: e5802000  str r2, [r0]

  ldr r0,=L2CCSync      /* need to poll 0x730, PSS_L2CC_CACHE_SYNC_OFFSET */
     2b0: e59f0180  ldr r0, [pc, #384]  ; 438 <_ABORT_STACK_SIZE+0x38>

000002b4 <Sync>:
            /* Load L2CC base address base + sync register*/
  /* poll for completion */
Sync: ldr r1, [r0]
     2b4: e5901000  ldr r1, [r0]
  cmp r1, #0
     2b8: e3510000  cmp r1, #0
  bne Sync
     2bc: 1afffffc  bne 2b4 <Sync>

  ldr r0,=L2CCIntRaw      /* clear pending interrupts */
     2c0: e59f0174  ldr r0, [pc, #372]  ; 43c <_ABORT_STACK_SIZE+0x3c>
  ldr r1,[r0]
     2c4: e5901000  ldr r1, [r0]
  ldr r0,=L2CCIntClear
     2c8: e59f0170  ldr r0, [pc, #368]  ; 440 <_ABORT_STACK_SIZE+0x40>
  str r1,[r0]
     2cc: e5801000  str r1, [r0]

  ldr r0,=SLCRUnlockReg   /* Load SLCR base address base + unlock register */
     2d0: e59f016c  ldr r0, [pc, #364]  ; 444 <_ABORT_STACK_SIZE+0x44>
  ldr r1,=SLCRUnlockKey       /* set unlock key */
     2d4: e59f116c  ldr r1, [pc, #364]  ; 448 <_ABORT_STACK_SIZE+0x48>
  str r1, [r0]          /* Unlock SLCR */
     2d8: e5801000  str r1, [r0]

  ldr r0,=SLCRL2cRamReg   /* Load SLCR base address base + l2c Ram Control register */
     2dc: e59f0168  ldr r0, [pc, #360]  ; 44c <_ABORT_STACK_SIZE+0x4c>
  ldr r1,=SLCRL2cRamConfig          /* set the configuration value */
     2e0: e59f1168  ldr r1, [pc, #360]  ; 450 <_ABORT_STACK_SIZE+0x50>
  str r1, [r0]            /* store the L2c Ram Control Register */
     2e4: e5801000  str r1, [r0]

  ldr r0,=SLCRlockReg           /* Load SLCR base address base + lock register */
     2e8: e59f0164  ldr r0, [pc, #356]  ; 454 <_ABORT_STACK_SIZE+0x54>
  ldr r1,=SLCRlockKey           /* set lock key */
     2ec: e59f1164  ldr r1, [pc, #356]  ; 458 <_ABORT_STACK_SIZE+0x58>
  str r1, [r0]            /* lock SLCR */
     2f0: e5801000  str r1, [r0]

  ldr r0,=L2CCCrtl      /* Load L2CC base address base + control register */
     2f4: e59f011c  ldr r0, [pc, #284]  ; 418 <_ABORT_STACK_SIZE+0x18>
  ldr r1,[r0]       /* read the register */
     2f8: e5901000  ldr r1, [r0]
  mov r2, #L2CCControl    /* set the enable bit */
     2fc: e3a02001  mov r2, #1
  orr r1,r1,r2
     300: e1811002  orr r1, r1, r2
  str r1, [r0]      /* enable the L2 Caches */
     304: e5801000  str r1, [r0]
#endif

  mov r0, r0
     308: e1a00000  nop     ; (mov r0, r0)
  mrc p15, 0, r1, c1, c0, 2   /* read cp access control register (CACR) into r1 */
     30c: ee111f50  mrc 15, 0, r1, cr1, cr0, {2}
  orr r1, r1, #(0xf << 20)    /* enable full access for p10 & p11 */
     310: e381160f  orr r1, r1, #15728640 ; 0xf00000
  mcr p15, 0, r1, c1, c0, 2   /* write back into CACR */
     314: ee011f50  mcr 15, 0, r1, cr1, cr0, {2}

  /* enable vfp */
  fmrx  r1, FPEXC     /* read the exception register */
     318: eef81a10  vmrs  r1, fpexc
  orr r1,r1, #FPEXC_EN    /* set VFP enable bit, leave the others in orig state */
     31c: e3811101  orr r1, r1, #1073741824 ; 0x40000000
  fmxr  FPEXC, r1     /* write back the exception register */
     320: eee81a10  vmsr  fpexc, r1

  mrc p15,0,r0,c1,c0,0    /* flow prediction enable */
     324: ee110f10  mrc 15, 0, r0, cr1, cr0, {0}
  orr r0, r0, #(0x01 << 11)   /* #0x8000 */
     328: e3800b02  orr r0, r0, #2048 ; 0x800
  mcr p15,0,r0,c1,c0,0
     32c: ee010f10  mcr 15, 0, r0, cr1, cr0, {0}

  mrc p15,0,r0,c1,c0,1    /* read Auxiliary Control Register */
     330: ee110f30  mrc 15, 0, r0, cr1, cr0, {1}
  orr r0, r0, #(0x1 << 2)   /* enable Dside prefetch */
     334: e3800004  orr r0, r0, #4
  orr r0, r0, #(0x1 << 1)   /* enable L2 Prefetch hint */
     338: e3800002  orr r0, r0, #2
  mcr p15,0,r0,c1,c0,1    /* write Auxiliary Control Register */
     33c: ee010f30  mcr 15, 0, r0, cr1, cr0, {1}

  mrs r0, cpsr      /* get the current PSR */
     340: e10f0000  mrs r0, CPSR
  bic r0, r0, #0x100      /* enable asynchronous abort exception */
     344: e3c00c01  bic r0, r0, #256  ; 0x100
  msr cpsr_xsf, r0
     348: e12ef000  msr CPSR_fsx, r0


  b _start        /* jump to C startup code */
     34c: ea0014de  b 56cc <_start>
  and r0, r0, r0      /* no op */
     350: e0000000  and r0, r0, r0

.Ldone: b .Ldone        /* Paranoia: we should never get here */
     354: eafffffe  b 354 <Sync+0xa0>

00000358 <invalidate_dcache>:
 * the whole D-cache. Need to invalidate each line.
 *
 *************************************************************************
 */
invalidate_dcache:
  mrc p15, 1, r0, c0, c0, 1   /* read CLIDR */
     358: ee300f30  mrc 15, 1, r0, cr0, cr0, {1}
  ands  r3, r0, #0x7000000
     35c: e2103407  ands  r3, r0, #117440512  ; 0x7000000
  mov r3, r3, lsr #23     /* cache level value (naturally aligned) */
     360: e1a03ba3  lsr r3, r3, #23
  beq finished
     364: 0a00001a  beq 3d4 <finished>
  mov r10, #0       /* start with level 0 */
     368: e3a0a000  mov sl, #0

0000036c <loop1>:
loop1:
  add r2, r10, r10, lsr #1    /* work out 3xcachelevel */
     36c: e08a20aa  add r2, sl, sl, lsr #1
  mov r1, r0, lsr r2      /* bottom 3 bits are the Cache type for this level */
     370: e1a01230  lsr r1, r0, r2
  and r1, r1, #7      /* get those 3 bits alone */
     374: e2011007  and r1, r1, #7
  cmp r1, #2
     378: e3510002  cmp r1, #2
  blt skip        /* no cache or only instruction cache at this level */
     37c: ba000011  blt 3c8 <skip>
  mcr p15, 2, r10, c0, c0, 0    /* write the Cache Size selection register */
     380: ee40af10  mcr 15, 2, sl, cr0, cr0, {0}
  isb         /* isb to sync the change to the CacheSizeID reg */
     384: f57ff06f  isb sy
  mrc p15, 1, r1, c0, c0, 0   /* reads current Cache Size ID register */
     388: ee301f10  mrc 15, 1, r1, cr0, cr0, {0}
  and r2, r1, #7      /* extract the line length field */
     38c: e2012007  and r2, r1, #7
  add r2, r2, #4      /* add 4 for the line length offset (log2 16 bytes) */
     390: e2822004  add r2, r2, #4
  ldr r4, =0x3ff
     394: e59f40c0  ldr r4, [pc, #192]  ; 45c <_ABORT_STACK_SIZE+0x5c>
  ands  r4, r4, r1, lsr #3    /* r4 is the max number on the way size (right aligned) */
     398: e01441a1  ands  r4, r4, r1, lsr #3
  clz r5, r4        /* r5 is the bit position of the way size increment */
     39c: e16f5f14  clz r5, r4
  ldr r7, =0x7fff
     3a0: e59f70b8  ldr r7, [pc, #184]  ; 460 <_ABORT_STACK_SIZE+0x60>
  ands  r7, r7, r1, lsr #13   /* r7 is the max number of the index size (right aligned) */
     3a4: e01776a1  ands  r7, r7, r1, lsr #13

000003a8 <loop2>:
loop2:
  mov r9, r4        /* r9 working copy of the max way size (right aligned) */
     3a8: e1a09004  mov r9, r4

000003ac <loop3>:
loop3:
  orr r11, r10, r9, lsl r5    /* factor in the way number and cache number into r11 */
     3ac: e18ab519  orr fp, sl, r9, lsl r5
  orr r11, r11, r7, lsl r2    /* factor in the index number */
     3b0: e18bb217  orr fp, fp, r7, lsl r2
  mcr p15, 0, r11, c7, c6, 2    /* invalidate by set/way */
     3b4: ee07bf56  mcr 15, 0, fp, cr7, cr6, {2}
  subs  r9, r9, #1      /* decrement the way number */
     3b8: e2599001  subs  r9, r9, #1
  bge loop3
     3bc: aafffffa  bge 3ac <loop3>
  subs  r7, r7, #1      /* decrement the index */
     3c0: e2577001  subs  r7, r7, #1
  bge loop2
     3c4: aafffff7  bge 3a8 <loop2>

000003c8 <skip>:
skip:
  add r10, r10, #2      /* increment the cache number */
     3c8: e28aa002  add sl, sl, #2
  cmp r3, r10
     3cc: e153000a  cmp r3, sl
  bgt loop1
     3d0: caffffe5  bgt 36c <loop1>

000003d4 <finished>:

finished:
  mov r10, #0       /* swith back to cache level 0 */
     3d4: e3a0a000  mov sl, #0
  mcr p15, 2, r10, c0, c0, 0    /* select current cache level in cssr */
     3d8: ee40af10  mcr 15, 2, sl, cr0, cr0, {0}
  dsb
     3dc: f57ff04f  dsb sy
  isb
     3e0: f57ff06f  isb sy

  bx  lr
     3e4: e12fff1e  bx  lr
  orreq   r10, r10, #1 << 6               /* set bit #6 */
  mcreq   p15, 0, r10, c15, c0, 1         /* write diagnostic register */
#endif

  /* set VBAR to the _vector_table address in linker script */
  ldr r0, =vector_base
     3e8: 00000000  .word 0x00000000
  mcr p15, 0, r0, c12, c0, 0

  /*invalidate scu*/
  ldr r7, =0xf8f0000c
     3ec: f8f0000c  .word 0xf8f0000c
  ldr r6, =0xffff
     3f0: 0000ffff  .word 0x0000ffff
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the irq stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x12     /* IRQ mode */
  msr cpsr, r2
  ldr r13,=IRQ_stack      /* IRQ stack pointer */
     3f4: ffffc000  .word 0xffffc000
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the supervisor stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x13     /* supervisor mode */
  msr cpsr, r2
  ldr r13,=SPV_stack      /* Supervisor stack pointer */
     3f8: ffffc800  .word 0xffffc800
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the Abort  stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x17     /* Abort mode */
  msr cpsr, r2
  ldr r13,=Abort_stack    /* Abort stack pointer */
     3fc: ffffcc00  .word 0xffffcc00
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the FIQ stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x11     /* FIQ mode */
  msr cpsr, r2
  ldr r13,=FIQ_stack      /* FIQ stack pointer */
     400: ffffd000  .word 0xffffd000
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the Undefine stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x1b     /* Undefine mode */
  msr cpsr, r2
  ldr r13,=Undef_stack    /* Undefine stack pointer */
     404: ffffd400  .word 0xffffd400
  mrs r0, cpsr      /* get the current PSR */
  mvn r1, #0x1f     /* set up the system stack pointer */
  and r2, r1, r0
  orr r2, r2, #0x1F     /* SYS mode */
  msr cpsr, r2
  ldr r13,=SYS_stack      /* SYS stack pointer */
     408: ffff6000  .word 0xffff6000

  /*set scu enable bit in scu*/
  ldr r7, =0xf8f00000
     40c: f8f00000  .word 0xf8f00000
  orr r0, r0, #0x1
  str r0, [r7]

  /* enable MMU and cache */

  ldr r0,=TblBase     /* Load MMU translation table base */
     410: 0001c000  .word 0x0001c000

  mvn r0,#0       /* Load MMU domains -- all ones=manager */
  mcr p15,0,r0,c3,c0,0

  /* Enable mmu, icahce and dcache */
  ldr r0,=CRValMmuCac
     414: 00001005  .word 0x00001005
  mcr p15, 0, r0, c1, c0, 1   /* Write ACTLR*/

/* Invalidate L2 Cache and enable L2 Cache*/
/* For AMP, assume running on CPU1. Don't initialize L2 Cache (up to Linux) */
#if USE_AMP!=1
  ldr r0,=L2CCCrtl      /* Load L2CC base address base + control register */
     418: f8f02100  .word 0xf8f02100
  mov r1, #0        /* force the disable bit */
  str r1, [r0]      /* disable the L2 Caches */

  ldr r0,=L2CCAuxCrtl     /* Load L2CC base address base + Aux control register */
     41c: f8f02104  .word 0xf8f02104
  ldr r1,[r0]       /* read the register */
  ldr r2,=L2CCAuxControl    /* set the default bits */
     420: 72360000  .word 0x72360000
  orr r1,r1,r2
  str r1, [r0]      /* store the Aux Control Register */

  ldr r0,=L2CCTAGLatReg   /* Load L2CC base address base + TAG Latency address */
     424: f8f02108  .word 0xf8f02108
  ldr r1,=L2CCTAGLatency    /* set the latencies for the TAG*/
     428: 00000111  .word 0x00000111
  str r1, [r0]      /* store the TAG Latency register Register */

  ldr r0,=L2CCDataLatReg    /* Load L2CC base address base + Data Latency address */
     42c: f8f0210c  .word 0xf8f0210c
  ldr r1,=L2CCDataLatency   /* set the latencies for the Data*/
     430: 00000121  .word 0x00000121
  str r1, [r0]      /* store the Data Latency register Register */

  ldr r0,=L2CCWay     /* Load L2CC base address base + way register*/
     434: f8f0277c  .word 0xf8f0277c
  ldr r2, =0xFFFF
  str r2, [r0]      /* force invalidate */

  ldr r0,=L2CCSync      /* need to poll 0x730, PSS_L2CC_CACHE_SYNC_OFFSET */
     438: f8f02730  .word 0xf8f02730
  /* poll for completion */
Sync: ldr r1, [r0]
  cmp r1, #0
  bne Sync

  ldr r0,=L2CCIntRaw      /* clear pending interrupts */
     43c: f8f0221c  .word 0xf8f0221c
  ldr r1,[r0]
  ldr r0,=L2CCIntClear
     440: f8f02220  .word 0xf8f02220
  str r1,[r0]

  ldr r0,=SLCRUnlockReg   /* Load SLCR base address base + unlock register */
     444: f8000008  .word 0xf8000008
  ldr r1,=SLCRUnlockKey       /* set unlock key */
     448: 0000df0d  .word 0x0000df0d
  str r1, [r0]          /* Unlock SLCR */

  ldr r0,=SLCRL2cRamReg   /* Load SLCR base address base + l2c Ram Control register */
     44c: f8000a1c  .word 0xf8000a1c
  ldr r1,=SLCRL2cRamConfig          /* set the configuration value */
     450: 00020202  .word 0x00020202
  str r1, [r0]            /* store the L2c Ram Control Register */

  ldr r0,=SLCRlockReg           /* Load SLCR base address base + lock register */
     454: f8000004  .word 0xf8000004
  ldr r1,=SLCRlockKey           /* set lock key */
     458: 0000767b  .word 0x0000767b
  mcr p15, 2, r10, c0, c0, 0    /* write the Cache Size selection register */
  isb         /* isb to sync the change to the CacheSizeID reg */
  mrc p15, 1, r1, c0, c0, 0   /* reads current Cache Size ID register */
  and r2, r1, #7      /* extract the line length field */
  add r2, r2, #4      /* add 4 for the line length offset (log2 16 bytes) */
  ldr r4, =0x3ff
     45c: 000003ff  .word 0x000003ff
  ands  r4, r4, r1, lsr #3    /* r4 is the max number on the way size (right aligned) */
  clz r5, r4        /* r5 is the bit position of the way size increment */
  ldr r7, =0x7fff
     460: 00007fff  .word 0x00007fff

00000464 <deregister_tm_clones>:
     464: e59f3024  ldr r3, [pc, #36] ; 490 <deregister_tm_clones+0x2c>
     468: e30b0c68  movw  r0, #48232  ; 0xbc68
     46c: e3400001  movt  r0, #1
     470: e0603003  rsb r3, r0, r3
     474: e3530006  cmp r3, #6
     478: 912fff1e  bxls  lr
     47c: e3003000  movw  r3, #0
     480: e3403000  movt  r3, #0
     484: e3530000  cmp r3, #0
     488: 012fff1e  bxeq  lr
     48c: e12fff13  bx  r3
     490: 0001bc6b  .word 0x0001bc6b

00000494 <register_tm_clones>:
     494: e30b3c68  movw  r3, #48232  ; 0xbc68
     498: e30b0c68  movw  r0, #48232  ; 0xbc68
     49c: e3403001  movt  r3, #1
     4a0: e3400001  movt  r0, #1
     4a4: e0601003  rsb r1, r0, r3
     4a8: e1a01141  asr r1, r1, #2
     4ac: e0811fa1  add r1, r1, r1, lsr #31
     4b0: e1b010c1  asrs  r1, r1, #1
     4b4: 012fff1e  bxeq  lr
     4b8: e3003000  movw  r3, #0
     4bc: e3403000  movt  r3, #0
     4c0: e3530000  cmp r3, #0
     4c4: 012fff1e  bxeq  lr
     4c8: e12fff13  bx  r3

000004cc <__do_global_dtors_aux>:
     4cc: e92d4010  push  {r4, lr}
     4d0: e3014040  movw  r4, #4160 ; 0x1040
     4d4: e3404002  movt  r4, #2
     4d8: e5d43000  ldrb  r3, [r4]
     4dc: e3530000  cmp r3, #0
     4e0: 18bd8010  popne {r4, pc}
     4e4: ebffffde  bl  464 <deregister_tm_clones>
     4e8: e3003000  movw  r3, #0
     4ec: e3403000  movt  r3, #0
     4f0: e3530000  cmp r3, #0
     4f4: 0a000002  beq 504 <__do_global_dtors_aux+0x38>
     4f8: e30b0c68  movw  r0, #48232  ; 0xbc68
     4fc: e3400001  movt  r0, #1
     500: e320f000  nop {0}
     504: e3a03001  mov r3, #1
     508: e5c43000  strb  r3, [r4]
     50c: e8bd8010  pop {r4, pc}

00000510 <frame_dummy>:
     510: e92d4008  push  {r3, lr}
     514: e3003000  movw  r3, #0
     518: e3403000  movt  r3, #0
     51c: e3530000  cmp r3, #0
     520: 0a000004  beq 538 <frame_dummy+0x28>
     524: e30b0c68  movw  r0, #48232  ; 0xbc68
     528: e3011044  movw  r1, #4164 ; 0x1044
     52c: e3400001  movt  r0, #1
     530: e3401002  movt  r1, #2
     534: e320f000  nop {0}
     538: e30b0c64  movw  r0, #48228  ; 0xbc64
     53c: e3400001  movt  r0, #1
     540: e5903000  ldr r3, [r0]
     544: e3530000  cmp r3, #0
     548: 1a000001  bne 554 <frame_dummy+0x44>
     54c: e8bd4008  pop {r3, lr}
     550: eaffffcf  b 494 <register_tm_clones>
     554: e3003000  movw  r3, #0
     558: e3403000  movt  r3, #0
     55c: e3530000  cmp r3, #0
     560: 0afffff9  beq 54c <frame_dummy+0x3c>
     564: e12fff33  blx r3
     568: eafffff7  b 54c <frame_dummy+0x3c>

0000056c <FsblHookBeforeBitstreamDload>:
*   - XST_SUCCESS to indicate success
*   - XST_FAILURE.to indicate failure
*
****************************************************************************/
u32 FsblHookBeforeBitstreamDload(void)
{
     56c: e92d4800  push  {fp, lr}
     570: e28db004  add fp, sp, #4
     574: e24dd008  sub sp, sp, #8
  u32 Status;

  Status = XST_SUCCESS;
     578: e3a03000  mov r3, #0
     57c: e50b3008  str r3, [fp, #-8]

  /*
   * User logic to be added here. Errors to be stored in the status variable
   * and returned
   */
  fsbl_printf(DEBUG_INFO,"In FsblHookBeforeBitstreamDload function \r\n");
     580: e30705a0  movw  r0, #30112  ; 0x75a0
     584: e3400001  movt  r0, #1
     588: eb00179c  bl  6400 <xil_printf>

  return (Status);
     58c: e51b3008  ldr r3, [fp, #-8]
}
     590: e1a00003  mov r0, r3
     594: e24bd004  sub sp, fp, #4
     598: e8bd8800  pop {fp, pc}

0000059c <FsblHookAfterBitstreamDload>:
*   - XST_SUCCESS to indicate success
*   - XST_FAILURE.to indicate failure
*
****************************************************************************/
u32 FsblHookAfterBitstreamDload(void)
{
     59c: e92d4800  push  {fp, lr}
     5a0: e28db004  add fp, sp, #4
     5a4: e24dd008  sub sp, sp, #8
  u32 Status;

  Status = XST_SUCCESS;
     5a8: e3a03000  mov r3, #0
     5ac: e50b3008  str r3, [fp, #-8]

  /*
   * User logic to be added here.
   * Errors to be stored in the status variable and returned
   */
  fsbl_printf(DEBUG_INFO, "In FsblHookAfterBitstreamDload function \r\n");
     5b0: e30705cc  movw  r0, #30156  ; 0x75cc
     5b4: e3400001  movt  r0, #1
     5b8: eb001790  bl  6400 <xil_printf>

  return (Status);
     5bc: e51b3008  ldr r3, [fp, #-8]
}
     5c0: e1a00003  mov r0, r3
     5c4: e24bd004  sub sp, fp, #4
     5c8: e8bd8800  pop {fp, pc}

000005cc <FsblHookBeforeHandoff>:
*   - XST_SUCCESS to indicate success
*   - XST_FAILURE.to indicate failure
*
****************************************************************************/
u32 FsblHookBeforeHandoff(void)
{
     5cc: e92d4800  push  {fp, lr}
     5d0: e28db004  add fp, sp, #4
     5d4: e24dd008  sub sp, sp, #8
  u32 Status;

  Status = XST_SUCCESS;
     5d8: e3a03000  mov r3, #0
     5dc: e50b3008  str r3, [fp, #-8]

  /*
   * User logic to be added here.
   * Errors to be stored in the status variable and returned
   */
  fsbl_printf(DEBUG_INFO,"In FsblHookBeforeHandoff function \r\n");
     5e0: e30705f8  movw  r0, #30200  ; 0x75f8
     5e4: e3400001  movt  r0, #1
     5e8: eb001784  bl  6400 <xil_printf>

  return (Status);
     5ec: e51b3008  ldr r3, [fp, #-8]
}
     5f0: e1a00003  mov r0, r3
     5f4: e24bd004  sub sp, fp, #4
     5f8: e8bd8800  pop {fp, pc}

000005fc <FsblHookFallback>:
*
* @return None
*
****************************************************************************/
void FsblHookFallback(void)
{
     5fc: e92d4800  push  {fp, lr}
     600: e28db004  add fp, sp, #4
  /*
   * User logic to be added here.
   * Errors to be stored in the status variable and returned
   */
  fsbl_printf(DEBUG_INFO,"In FsblHookFallback function \r\n");
     604: e3070620  movw  r0, #30240  ; 0x7620
     608: e3400001  movt  r0, #1
     60c: eb00177b  bl  6400 <xil_printf>
  while(1);
     610: eafffffe  b 610 <FsblHookFallback+0x14>

00000614 <LoadBootImage>:
*
* @note   None
*
****************************************************************************/
u32 LoadBootImage(void)
{
     614: e92d4800  push  {fp, lr}
     618: e28db004  add fp, sp, #4
     61c: e24dd050  sub sp, sp, #80 ; 0x50
  u32 RebootStatusRegister = 0;
     620: e3a03000  mov r3, #0
     624: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4
  u32 MultiBootReg = 0;
     628: e3a03000  mov r3, #0
     62c: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
  u32 ImageStartAddress = 0;
     630: e3a03000  mov r3, #0
     634: e50b3008  str r3, [fp, #-8]
  u32 PartitionDataLength;
  u32 PartitionImageLength;
  u32 PartitionTotalSize;
  u32 PartitionExecAddr;
  u32 PartitionAttr;
  u32 ExecAddress = 0;
     638: e3a03000  mov r3, #0
     63c: e50b3010  str r3, [fp, #-16]
  u32 PartitionLoadAddr;
  u32 PartitionStartAddr;
  u32 PartitionChecksumOffset;
  u8 ExecAddrFlag = 0 ;
     640: e3a03000  mov r3, #0
     644: e54b3015  strb  r3, [fp, #-21]  ; 0xffffffeb
  u32 HeaderSize;
#endif
  /*
   * Resetting the Flags
   */
  BitstreamFlag = 0;
     648: e30136f4  movw  r3, #5876 ; 0x16f4
     64c: e3403002  movt  r3, #2
     650: e3a02000  mov r2, #0
     654: e5c32000  strb  r2, [r3]
  ApplicationFlag = 0;
     658: e30136e0  movw  r3, #5856 ; 0x16e0
     65c: e3403002  movt  r3, #2
     660: e3a02000  mov r2, #0
     664: e5c32000  strb  r2, [r3]

  RebootStatusRegister = Xil_In32(REBOOT_STATUS_REG);
     668: e3a00f96  mov r0, #600  ; 0x258
     66c: e34f0800  movt  r0, #63488  ; 0xf800
     670: eb0016c8  bl  6198 <Xil_In32>
     674: e50b001c  str r0, [fp, #-28]  ; 0xffffffe4
  fsbl_printf(DEBUG_INFO,
     678: e3070640  movw  r0, #30272  ; 0x7640
     67c: e3400001  movt  r0, #1
     680: e51b101c  ldr r1, [fp, #-28]  ; 0xffffffe4
     684: eb00175d  bl  6400 <xil_printf>
      "Reboot status register: 0x%08x\r\n",RebootStatusRegister);

  if (Silicon_Version == SILICON_VERSION_1) {
     688: e3013a80  movw  r3, #6784 ; 0x1a80
     68c: e3403002  movt  r3, #2
     690: e5933000  ldr r3, [r3]
     694: e3530000  cmp r3, #0
     698: 1a000011  bne 6e4 <LoadBootImage+0xd0>
    /*
     * Clear out fallback mask from previous run
     * We start from the first partition again
     */
    if ((RebootStatusRegister & FSBL_FAIL_MASK) ==
     69c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
     6a0: e203320f  and r3, r3, #-268435456 ; 0xf0000000
     6a4: e353020f  cmp r3, #-268435456 ; 0xf0000000
     6a8: 1a000009  bne 6d4 <LoadBootImage+0xc0>
        FSBL_FAIL_MASK) {
      fsbl_printf(DEBUG_INFO,
     6ac: e3070664  movw  r0, #30308  ; 0x7664
     6b0: e3400001  movt  r0, #1
     6b4: eb001751  bl  6400 <xil_printf>
          "Reboot status shows previous run falls back\r\n");
      RebootStatusRegister &= ~(FSBL_FAIL_MASK);
     6b8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
     6bc: e3c3320f  bic r3, r3, #-268435456 ; 0xf0000000
     6c0: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4
      Xil_Out32(REBOOT_STATUS_REG, RebootStatusRegister);
     6c4: e3a00f96  mov r0, #600  ; 0x258
     6c8: e34f0800  movt  r0, #63488  ; 0xf800
     6cc: e51b101c  ldr r1, [fp, #-28]  ; 0xffffffe4
     6d0: eb0016b6  bl  61b0 <Xil_Out32>
    }

    /*
     * Read the image start address
     */
    ImageStartAddress = *(u32 *)BASEADDR_HOLDER;
     6d4: e3e03007  mvn r3, #7
     6d8: e5933000  ldr r3, [r3]
     6dc: e50b3008  str r3, [fp, #-8]
     6e0: ea00000f  b 724 <LoadBootImage+0x110>
  } else {
    /*
     * read the multiboot register
     */
    MultiBootReg =  XDcfg_ReadReg(DcfgInstPtr->Config.BaseAddr,
     6e4: e3013a8c  movw  r3, #6796 ; 0x1a8c
     6e8: e3403002  movt  r3, #2
     6ec: e5933000  ldr r3, [r3]
     6f0: e5933004  ldr r3, [r3, #4]
     6f4: e283302c  add r3, r3, #44 ; 0x2c
     6f8: e1a00003  mov r0, r3
     6fc: eb0016a5  bl  6198 <Xil_In32>
     700: e50b0020  str r0, [fp, #-32]  ; 0xffffffe0
        XDCFG_MULTIBOOT_ADDR_OFFSET);

    fsbl_printf(DEBUG_INFO,"Multiboot Register: 0x%08x\r\n",MultiBootReg);
     704: e3070694  movw  r0, #30356  ; 0x7694
     708: e3400001  movt  r0, #1
     70c: e51b1020  ldr r1, [fp, #-32]  ; 0xffffffe0
     710: eb00173a  bl  6400 <xil_printf>

    /*
     * Compute the image start address
     */
    ImageStartAddress = (MultiBootReg & PCAP_MBOOT_REG_REBOOT_OFFSET_MASK)
     714: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
     718: e7ec3053  ubfx  r3, r3, #0, #13
     71c: e1a03783  lsl r3, r3, #15
     720: e50b3008  str r3, [fp, #-8]
                  * GOLDEN_IMAGE_OFFSET;
  }

  fsbl_printf(DEBUG_INFO,"Image Start Address: 0x%08x\r\n",ImageStartAddress);
     724: e30706b4  movw  r0, #30388  ; 0x76b4
     728: e3400001  movt  r0, #1
     72c: e51b1008  ldr r1, [fp, #-8]
     730: eb001732  bl  6400 <xil_printf>

  /*
   * Get partitions header information
   */
  Status = GetPartitionHeaderInfo(ImageStartAddress);
     734: e51b0008  ldr r0, [fp, #-8]
     738: eb00019e  bl  db8 <GetPartitionHeaderInfo>
     73c: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
  if (Status != XST_SUCCESS) {
     740: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     744: e3530000  cmp r3, #0
     748: 0a000005  beq 764 <LoadBootImage+0x150>
    fsbl_printf(DEBUG_GENERAL, "Partition Header Load Failed\r\n");
     74c: e30706d4  movw  r0, #30420  ; 0x76d4
     750: e3400001  movt  r0, #1
     754: eb001729  bl  6400 <xil_printf>
    OutputStatus(GET_HEADER_INFO_FAIL);
     758: e30a000e  movw  r0, #40974  ; 0xa00e
     75c: eb000536  bl  1c3c <OutputStatus>
    FsblFallback();
     760: eb000529  bl  1c0c <FsblFallback>

  /*
   * RSA is not implemented in 1.0 and 2.0
   * silicon
   */
  if ((Silicon_Version != SILICON_VERSION_1) &&
     764: e3013a80  movw  r3, #6784 ; 0x1a80
     768: e3403002  movt  r3, #2
     76c: e5933000  ldr r3, [r3]
     770: e3530000  cmp r3, #0
     774: 0a000015  beq 7d0 <LoadBootImage+0x1bc>
      (Silicon_Version != SILICON_VERSION_2)) {
     778: e3013a80  movw  r3, #6784 ; 0x1a80
     77c: e3403002  movt  r3, #2
     780: e5933000  ldr r3, [r3]

  /*
   * RSA is not implemented in 1.0 and 2.0
   * silicon
   */
  if ((Silicon_Version != SILICON_VERSION_1) &&
     784: e3530001  cmp r3, #1
     788: 0a000010  beq 7d0 <LoadBootImage+0x1bc>
      (Silicon_Version != SILICON_VERSION_2)) {
    /*
     * Read Efuse Status Register
     */
    EfuseStatusRegValue = Xil_In32(EFUSE_STATUS_REG);
     78c: e30d0010  movw  r0, #53264  ; 0xd010
     790: e34f0800  movt  r0, #63488  ; 0xf800
     794: eb00167f  bl  6198 <Xil_In32>
     798: e50b0028  str r0, [fp, #-40]  ; 0xffffffd8
    if (EfuseStatusRegValue & EFUSE_STATUS_RSA_ENABLE_MASK) {
     79c: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
     7a0: e2033b01  and r3, r3, #1024 ; 0x400
     7a4: e3530000  cmp r3, #0
     7a8: 0a000008  beq 7d0 <LoadBootImage+0x1bc>
      fsbl_printf(DEBUG_GENERAL,"RSA enabled for Chip\r\n");
     7ac: e30706f4  movw  r0, #30452  ; 0x76f4
     7b0: e3400001  movt  r0, #1
     7b4: eb001711  bl  6400 <xil_printf>
      }
#else
      /*
       * In case user not enabled RSA authentication feature
       */
      fsbl_printf(DEBUG_GENERAL,"RSA_SUPPORT_NOT_ENABLED_FAIL\r\n");
     7b8: e307070c  movw  r0, #30476  ; 0x770c
     7bc: e3400001  movt  r0, #1
     7c0: eb00170e  bl  6400 <xil_printf>
      OutputStatus(RSA_SUPPORT_NOT_ENABLED_FAIL);
     7c4: e30a0011  movw  r0, #40977  ; 0xa011
     7c8: eb00051b  bl  1c3c <OutputStatus>
      FsblFallback();
     7cc: eb00050e  bl  1c0c <FsblFallback>
#else
  /*
   * First partition header was ignored by FSBL
   * As it contain FSBL partition information
   */
  PartitionNum = 1;
     7d0: e3a03001  mov r3, #1
     7d4: e50b300c  str r3, [fp, #-12]
#endif

  while (PartitionNum < PartitionCount) {
     7d8: ea00016c  b d90 <_SUPERVISOR_STACK_SIZE+0x590>

    fsbl_printf(DEBUG_INFO, "Partition Number: %d\r\n", PartitionNum);
     7dc: e307072c  movw  r0, #30508  ; 0x772c
     7e0: e3400001  movt  r0, #1
     7e4: e51b100c  ldr r1, [fp, #-12]
     7e8: eb001704  bl  6400 <xil_printf>

    HeaderPtr = &PartitionHeader[PartitionNum];
     7ec: e51b300c  ldr r3, [fp, #-12]
     7f0: e1a02303  lsl r2, r3, #6
     7f4: e3013700  movw  r3, #5888 ; 0x1700
     7f8: e3403002  movt  r3, #2
     7fc: e0823003  add r3, r2, r3
     800: e50b302c  str r3, [fp, #-44]  ; 0xffffffd4

    /*
     * Print partition header information
     */
    HeaderDump(HeaderPtr);
     804: e51b002c  ldr r0, [fp, #-44]  ; 0xffffffd4
     808: eb000233  bl  10dc <HeaderDump>

    /*
     * Validate partition header
     */
    Status = ValidateHeader(HeaderPtr);
     80c: e51b002c  ldr r0, [fp, #-44]  ; 0xffffffd4
     810: eb0002b3  bl  12e4 <ValidateHeader>
     814: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
    if (Status != XST_SUCCESS) {
     818: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     81c: e3530000  cmp r3, #0
     820: 0a000005  beq 83c <_SUPERVISOR_STACK_SIZE+0x3c>
      fsbl_printf(DEBUG_GENERAL, "INVALID_HEADER_FAIL\r\n");
     824: e3070744  movw  r0, #30532  ; 0x7744
     828: e3400001  movt  r0, #1
     82c: eb0016f3  bl  6400 <xil_printf>
      OutputStatus(INVALID_HEADER_FAIL);
     830: e30a000d  movw  r0, #40973  ; 0xa00d
     834: eb000500  bl  1c3c <OutputStatus>
      FsblFallback();
     838: eb0004f3  bl  1c0c <FsblFallback>
    }

    /*
     * Load partition header information in to local variables
     */
    PartitionDataLength = HeaderPtr->DataWordLen;
     83c: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     840: e5933004  ldr r3, [r3, #4]
     844: e50b3030  str r3, [fp, #-48]  ; 0xffffffd0
    PartitionImageLength = HeaderPtr->ImageWordLen;
     848: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     84c: e5933000  ldr r3, [r3]
     850: e50b3034  str r3, [fp, #-52]  ; 0xffffffcc
    PartitionExecAddr = HeaderPtr->ExecAddr;
     854: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     858: e5933010  ldr r3, [r3, #16]
     85c: e50b3038  str r3, [fp, #-56]  ; 0xffffffc8
    PartitionAttr = HeaderPtr->PartitionAttr;
     860: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     864: e5933018  ldr r3, [r3, #24]
     868: e50b303c  str r3, [fp, #-60]  ; 0xffffffc4
    PartitionLoadAddr = HeaderPtr->LoadAddr;
     86c: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     870: e593300c  ldr r3, [r3, #12]
     874: e50b3040  str r3, [fp, #-64]  ; 0xffffffc0
    PartitionChecksumOffset = HeaderPtr->CheckSumOffset;
     878: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     87c: e5933020  ldr r3, [r3, #32]
     880: e50b3044  str r3, [fp, #-68]  ; 0xffffffbc
    PartitionStartAddr = HeaderPtr->PartitionStart;
     884: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     888: e5933014  ldr r3, [r3, #20]
     88c: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
    PartitionTotalSize = HeaderPtr->PartitionWordLen;
     890: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
     894: e5933008  ldr r3, [r3, #8]
     898: e50b3048  str r3, [fp, #-72]  ; 0xffffffb8

    /*
     * Partition owner should be FSBL to validate the partition
     */
    if ((PartitionAttr & ATTRIBUTE_PARTITION_OWNER_MASK) !=
     89c: e51b303c  ldr r3, [fp, #-60]  ; 0xffffffc4
     8a0: e2033803  and r3, r3, #196608 ; 0x30000
     8a4: e3530000  cmp r3, #0
     8a8: 0a000007  beq 8cc <_SUPERVISOR_STACK_SIZE+0xcc>
        ATTRIBUTE_PARTITION_OWNER_FSBL) {
      /*
       * if FSBL is not the owner of partition,
       * skip this partition, continue with next partition
       */
       fsbl_printf(DEBUG_INFO, "Skipping partition %0x\r\n", 
     8ac: e307075c  movw  r0, #30556  ; 0x775c
     8b0: e3400001  movt  r0, #1
     8b4: e51b100c  ldr r1, [fp, #-12]
     8b8: eb0016d0  bl  6400 <xil_printf>
                    PartitionNum);
      /*
       * Increment partition number
       */
      PartitionNum++;
     8bc: e51b300c  ldr r3, [fp, #-12]
     8c0: e2833001  add r3, r3, #1
     8c4: e50b300c  str r3, [fp, #-12]
      continue;
     8c8: ea000130  b d90 <_SUPERVISOR_STACK_SIZE+0x590>
    }

    if (PartitionAttr & ATTRIBUTE_PL_IMAGE_MASK) {
     8cc: e51b303c  ldr r3, [fp, #-60]  ; 0xffffffc4
     8d0: e2033020  and r3, r3, #32
     8d4: e3530000  cmp r3, #0
     8d8: 0a00001a  beq 948 <_SUPERVISOR_STACK_SIZE+0x148>
      fsbl_printf(DEBUG_INFO, "Bitstream\r\n");
     8dc: e3070778  movw  r0, #30584  ; 0x7778
     8e0: e3400001  movt  r0, #1
     8e4: eb0016c5  bl  6400 <xil_printf>
      PLPartitionFlag = 1;
     8e8: e30136fc  movw  r3, #5884 ; 0x16fc
     8ec: e3403002  movt  r3, #2
     8f0: e3a02001  mov r2, #1
     8f4: e5c32000  strb  r2, [r3]
      PSPartitionFlag = 0;
     8f8: e30136e9  movw  r3, #5865 ; 0x16e9
     8fc: e3403002  movt  r3, #2
     900: e3a02000  mov r2, #0
     904: e5c32000  strb  r2, [r3]
      BitstreamFlag = 1;
     908: e30136f4  movw  r3, #5876 ; 0x16f4
     90c: e3403002  movt  r3, #2
     910: e3a02001  mov r2, #1
     914: e5c32000  strb  r2, [r3]
      if (ApplicationFlag == 1) {
     918: e30136e0  movw  r3, #5856 ; 0x16e0
     91c: e3403002  movt  r3, #2
     920: e5d33000  ldrb  r3, [r3]
     924: e3530001  cmp r3, #1
     928: 1a000006  bne 948 <_SUPERVISOR_STACK_SIZE+0x148>
#ifdef STDOUT_BASEADDRESS
        xil_printf("\r\nFSBL Warning !!!"
     92c: e3070784  movw  r0, #30596  ; 0x7784
     930: e3400001  movt  r0, #1
     934: eb0016b1  bl  6400 <xil_printf>
            "Bitstream not loaded into PL\r\n");
                xil_printf("Partition order invalid\r\n");
     938: e30707b8  movw  r0, #30648  ; 0x77b8
     93c: e3400001  movt  r0, #1
     940: eb0016ae  bl  6400 <xil_printf>
#endif
        break;
     944: ea000117  b da8 <_SUPERVISOR_STACK_SIZE+0x5a8>
      }
    }

    if (PartitionAttr & ATTRIBUTE_PS_IMAGE_MASK) {
     948: e51b303c  ldr r3, [fp, #-60]  ; 0xffffffc4
     94c: e2033010  and r3, r3, #16
     950: e3530000  cmp r3, #0
     954: 0a00000e  beq 994 <_SUPERVISOR_STACK_SIZE+0x194>
      fsbl_printf(DEBUG_INFO, "Application\r\n");
     958: e30707d4  movw  r0, #30676  ; 0x77d4
     95c: e3400001  movt  r0, #1
     960: eb0016a6  bl  6400 <xil_printf>
      PSPartitionFlag = 1;
     964: e30136e9  movw  r3, #5865 ; 0x16e9
     968: e3403002  movt  r3, #2
     96c: e3a02001  mov r2, #1
     970: e5c32000  strb  r2, [r3]
      PLPartitionFlag = 0;
     974: e30136fc  movw  r3, #5884 ; 0x16fc
     978: e3403002  movt  r3, #2
     97c: e3a02000  mov r2, #0
     980: e5c32000  strb  r2, [r3]
      ApplicationFlag = 1;
     984: e30136e0  movw  r3, #5856 ; 0x16e0
     988: e3403002  movt  r3, #2
     98c: e3a02001  mov r2, #1
     990: e5c32000  strb  r2, [r3]

    /*
     * Encrypted partition will have different value
     * for Image length and data length
     */
    if (PartitionDataLength != PartitionImageLength) {
     994: e51b2030  ldr r2, [fp, #-48]  ; 0xffffffd0
     998: e51b3034  ldr r3, [fp, #-52]  ; 0xffffffcc
     99c: e1520003  cmp r2, r3
     9a0: 0a000007  beq 9c4 <_SUPERVISOR_STACK_SIZE+0x1c4>
      fsbl_printf(DEBUG_INFO, "Encrypted\r\n");
     9a4: e30707e4  movw  r0, #30692  ; 0x77e4
     9a8: e3400001  movt  r0, #1
     9ac: eb001693  bl  6400 <xil_printf>
      EncryptedPartitionFlag = 1;
     9b0: e30136f6  movw  r3, #5878 ; 0x16f6
     9b4: e3403002  movt  r3, #2
     9b8: e3a02001  mov r2, #1
     9bc: e5c32000  strb  r2, [r3]
     9c0: ea000003  b 9d4 <_SUPERVISOR_STACK_SIZE+0x1d4>
    } else {
      EncryptedPartitionFlag = 0;
     9c4: e30136f6  movw  r3, #5878 ; 0x16f6
     9c8: e3403002  movt  r3, #2
     9cc: e3a02000  mov r2, #0
     9d0: e5c32000  strb  r2, [r3]
    }

    /*
     * Check for partition checksum check
     */
    if (PartitionAttr & ATTRIBUTE_CHECKSUM_TYPE_MASK) {
     9d4: e51b303c  ldr r3, [fp, #-60]  ; 0xffffffc4
     9d8: e2033a07  and r3, r3, #28672  ; 0x7000
     9dc: e3530000  cmp r3, #0
     9e0: 0a000004  beq 9f8 <_SUPERVISOR_STACK_SIZE+0x1f8>
      PartitionChecksumFlag = 1;
     9e4: e30136e8  movw  r3, #5864 ; 0x16e8
     9e8: e3403002  movt  r3, #2
     9ec: e3a02001  mov r2, #1
     9f0: e5c32000  strb  r2, [r3]
     9f4: ea000003  b a08 <_SUPERVISOR_STACK_SIZE+0x208>
    } else {
      PartitionChecksumFlag = 0;
     9f8: e30136e8  movw  r3, #5864 ; 0x16e8
     9fc: e3403002  movt  r3, #2
     a00: e3a02000  mov r2, #0
     a04: e5c32000  strb  r2, [r3]
    }

    /*
     * RSA signature check
     */
    if (PartitionAttr & ATTRIBUTE_RSA_PRESENT_MASK) {
     a08: e51b303c  ldr r3, [fp, #-60]  ; 0xffffffc4
     a0c: e2033902  and r3, r3, #32768  ; 0x8000
     a10: e3530000  cmp r3, #0
     a14: 0a000007  beq a38 <_SUPERVISOR_STACK_SIZE+0x238>
      fsbl_printf(DEBUG_INFO, "RSA Signed\r\n");
     a18: e30707f0  movw  r0, #30704  ; 0x77f0
     a1c: e3400001  movt  r0, #1
     a20: eb001676  bl  6400 <xil_printf>
      SignedPartitionFlag = 1;
     a24: e30136f5  movw  r3, #5877 ; 0x16f5
     a28: e3403002  movt  r3, #2
     a2c: e3a02001  mov r2, #1
     a30: e5c32000  strb  r2, [r3]
     a34: ea000003  b a48 <_SUPERVISOR_STACK_SIZE+0x248>
    } else {
      SignedPartitionFlag = 0;
     a38: e30136f5  movw  r3, #5877 ; 0x16f5
     a3c: e3403002  movt  r3, #2
     a40: e3a02000  mov r2, #0
     a44: e5c32000  strb  r2, [r3]
    /*
     * Load address check
     * Loop will break when PS load address zero and partition is
     * un-signed or un-encrypted
     */
    if ((PSPartitionFlag == 1) && (PartitionLoadAddr < DDR_START_ADDR)) {
     a48: e30136e9  movw  r3, #5865 ; 0x16e9
     a4c: e3403002  movt  r3, #2
     a50: e5d33000  ldrb  r3, [r3]
     a54: e3530001  cmp r3, #1
     a58: 1a000015  bne ab4 <_SUPERVISOR_STACK_SIZE+0x2b4>
     a5c: e51b3040  ldr r3, [fp, #-64]  ; 0xffffffc0
     a60: e3530601  cmp r3, #1048576  ; 0x100000
     a64: 2a000012  bcs ab4 <_SUPERVISOR_STACK_SIZE+0x2b4>
      if ((PartitionLoadAddr == 0) &&
     a68: e51b3040  ldr r3, [fp, #-64]  ; 0xffffffc0
     a6c: e3530000  cmp r3, #0
     a70: 1a000009  bne a9c <_SUPERVISOR_STACK_SIZE+0x29c>
          (!((SignedPartitionFlag == 1) ||
     a74: e30136f5  movw  r3, #5877 ; 0x16f5
     a78: e3403002  movt  r3, #2
     a7c: e5d33000  ldrb  r3, [r3]
     * Load address check
     * Loop will break when PS load address zero and partition is
     * un-signed or un-encrypted
     */
    if ((PSPartitionFlag == 1) && (PartitionLoadAddr < DDR_START_ADDR)) {
      if ((PartitionLoadAddr == 0) &&
     a80: e3530001  cmp r3, #1
     a84: 0a000004  beq a9c <_SUPERVISOR_STACK_SIZE+0x29c>
          (!((SignedPartitionFlag == 1) ||
              (EncryptedPartitionFlag == 1)))) {
     a88: e30136f6  movw  r3, #5878 ; 0x16f6
     a8c: e3403002  movt  r3, #2
     a90: e5d33000  ldrb  r3, [r3]
     * Loop will break when PS load address zero and partition is
     * un-signed or un-encrypted
     */
    if ((PSPartitionFlag == 1) && (PartitionLoadAddr < DDR_START_ADDR)) {
      if ((PartitionLoadAddr == 0) &&
          (!((SignedPartitionFlag == 1) ||
     a94: e3530001  cmp r3, #1
     a98: 1a0000c2  bne da8 <_SUPERVISOR_STACK_SIZE+0x5a8>
              (EncryptedPartitionFlag == 1)))) {
        break;
      } else {
        fsbl_printf(DEBUG_GENERAL,
     a9c: e3070800  movw  r0, #30720  ; 0x7800
     aa0: e3400001  movt  r0, #1
     aa4: eb001655  bl  6400 <xil_printf>
            "INVALID_LOAD_ADDRESS_FAIL\r\n");
        OutputStatus(INVALID_LOAD_ADDRESS_FAIL);
     aa8: e30a000f  movw  r0, #40975  ; 0xa00f
     aac: eb000462  bl  1c3c <OutputStatus>
        FsblFallback();
     ab0: eb000455  bl  1c0c <FsblFallback>
      }
    }

    if (PSPartitionFlag && (PartitionLoadAddr > DDR_END_ADDR)) {
     ab4: e30136e9  movw  r3, #5865 ; 0x16e9
     ab8: e3403002  movt  r3, #2
     abc: e5d33000  ldrb  r3, [r3]
     ac0: e3530000  cmp r3, #0
     ac4: 0a000008  beq aec <_SUPERVISOR_STACK_SIZE+0x2ec>
     ac8: e51b3040  ldr r3, [fp, #-64]  ; 0xffffffc0
     acc: e3730107  cmn r3, #-1073741823  ; 0xc0000001
     ad0: 9a000005  bls aec <_SUPERVISOR_STACK_SIZE+0x2ec>
      fsbl_printf(DEBUG_GENERAL,
     ad4: e3070800  movw  r0, #30720  ; 0x7800
     ad8: e3400001  movt  r0, #1
     adc: eb001647  bl  6400 <xil_printf>
          "INVALID_LOAD_ADDRESS_FAIL\r\n");
      OutputStatus(INVALID_LOAD_ADDRESS_FAIL);
     ae0: e30a000f  movw  r0, #40975  ; 0xa00f
     ae4: eb000454  bl  1c3c <OutputStatus>
      FsblFallback();
     ae8: eb000447  bl  1c0c <FsblFallback>
    }

        /*
         * Load execution address of first PS partition
         */
        if (PSPartitionFlag && (!ExecAddrFlag)) {
     aec: e30136e9  movw  r3, #5865 ; 0x16e9
     af0: e3403002  movt  r3, #2
     af4: e5d33000  ldrb  r3, [r3]
     af8: e3530000  cmp r3, #0
     afc: 0a000007  beq b20 <_SUPERVISOR_STACK_SIZE+0x320>
     b00: e55b3015  ldrb  r3, [fp, #-21]  ; 0xffffffeb
     b04: e3530000  cmp r3, #0
     b08: 1a000004  bne b20 <_SUPERVISOR_STACK_SIZE+0x320>
          ExecAddrFlag++;
     b0c: e55b3015  ldrb  r3, [fp, #-21]  ; 0xffffffeb
     b10: e2833001  add r3, r3, #1
     b14: e54b3015  strb  r3, [fp, #-21]  ; 0xffffffeb
          ExecAddress = PartitionExecAddr;
     b18: e51b3038  ldr r3, [fp, #-56]  ; 0xffffffc8
     b1c: e50b3010  str r3, [fp, #-16]
        }

    /*
     * FSBL user hook call before bitstream download
     */
    if (PLPartitionFlag) {
     b20: e30136fc  movw  r3, #5884 ; 0x16fc
     b24: e3403002  movt  r3, #2
     b28: e5d33000  ldrb  r3, [r3]
     b2c: e3530000  cmp r3, #0
     b30: 0a00000a  beq b60 <_SUPERVISOR_STACK_SIZE+0x360>
      Status = FsblHookBeforeBitstreamDload();
     b34: ebfffe8c  bl  56c <FsblHookBeforeBitstreamDload>
     b38: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
      if (Status != XST_SUCCESS) {
     b3c: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     b40: e3530000  cmp r3, #0
     b44: 0a000005  beq b60 <_SUPERVISOR_STACK_SIZE+0x360>
        fsbl_printf(DEBUG_GENERAL,"FSBL_BEFORE_BSTREAM_HOOK_FAIL\r\n");
     b48: e307081c  movw  r0, #30748  ; 0x781c
     b4c: e3400001  movt  r0, #1
     b50: eb00162a  bl  6400 <xil_printf>
        OutputStatus(FSBL_BEFORE_BSTREAM_HOOK_FAIL);
     b54: e30a0402  movw  r0, #41986  ; 0xa402
     b58: eb000437  bl  1c3c <OutputStatus>
        FsblFallback();
     b5c: eb00042a  bl  1c0c <FsblFallback>
    }

    /*
     * Move partitions from boot device
     */
    Status = PartitionMove(ImageStartAddress, HeaderPtr);
     b60: e51b0008  ldr r0, [fp, #-8]
     b64: e51b102c  ldr r1, [fp, #-44]  ; 0xffffffd4
     b68: eb000247  bl  148c <PartitionMove>
     b6c: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
    if (Status != XST_SUCCESS) {
     b70: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     b74: e3530000  cmp r3, #0
     b78: 0a000005  beq b94 <_SUPERVISOR_STACK_SIZE+0x394>
      fsbl_printf(DEBUG_GENERAL,"PARTITION_MOVE_FAIL\r\n");
     b7c: e307083c  movw  r0, #30780  ; 0x783c
     b80: e3400001  movt  r0, #1
     b84: eb00161d  bl  6400 <xil_printf>
      OutputStatus(PARTITION_MOVE_FAIL);
     b88: e30a000b  movw  r0, #40971  ; 0xa00b
     b8c: eb00042a  bl  1c3c <OutputStatus>
      FsblFallback();
     b90: eb00041d  bl  1c0c <FsblFallback>
    }

    if ((SignedPartitionFlag) || (PartitionChecksumFlag)) {
     b94: e30136f5  movw  r3, #5877 ; 0x16f5
     b98: e3403002  movt  r3, #2
     b9c: e5d33000  ldrb  r3, [r3]
     ba0: e3530000  cmp r3, #0
     ba4: 1a000004  bne bbc <_SUPERVISOR_STACK_SIZE+0x3bc>
     ba8: e30136e8  movw  r3, #5864 ; 0x16e8
     bac: e3403002  movt  r3, #2
     bb0: e5d33000  ldrb  r3, [r3]
     bb4: e3530000  cmp r3, #0
     bb8: 0a000061  beq d44 <_SUPERVISOR_STACK_SIZE+0x544>
      if(PLPartitionFlag) {
     bbc: e30136fc  movw  r3, #5884 ; 0x16fc
     bc0: e3403002  movt  r3, #2
     bc4: e5d33000  ldrb  r3, [r3]
     bc8: e3530000  cmp r3, #0
     bcc: 0a000002  beq bdc <_SUPERVISOR_STACK_SIZE+0x3dc>
        /*
         * PL partition loaded in to DDR temporary address
         * for authentication and checksum verification
         */
        PartitionStartAddr = DDR_TEMP_START_ADDR;
     bd0: e3a03601  mov r3, #1048576  ; 0x100000
     bd4: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
     bd8: ea000001  b be4 <_SUPERVISOR_STACK_SIZE+0x3e4>
      } else {
        PartitionStartAddr = PartitionLoadAddr;
     bdc: e51b3040  ldr r3, [fp, #-64]  ; 0xffffffc0
     be0: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
      }

      if (PartitionChecksumFlag) {
     be4: e30136e8  movw  r3, #5864 ; 0x16e8
     be8: e3403002  movt  r3, #2
     bec: e5d33000  ldrb  r3, [r3]
     bf0: e3530000  cmp r3, #0
     bf4: 0a000015  beq c50 <_SUPERVISOR_STACK_SIZE+0x450>
        /*
         * Validate the partition data with checksum
         */
        Status = ValidateParition(PartitionStartAddr,
     bf8: e51b3048  ldr r3, [fp, #-72]  ; 0xffffffb8
     bfc: e1a01103  lsl r1, r3, #2
            (PartitionTotalSize << WORD_LENGTH_SHIFT),
            ImageStartAddress  +
            (PartitionChecksumOffset << WORD_LENGTH_SHIFT));
     c00: e51b3044  ldr r3, [fp, #-68]  ; 0xffffffbc
     c04: e1a02103  lsl r2, r3, #2

      if (PartitionChecksumFlag) {
        /*
         * Validate the partition data with checksum
         */
        Status = ValidateParition(PartitionStartAddr,
     c08: e51b3008  ldr r3, [fp, #-8]
     c0c: e0823003  add r3, r2, r3
     c10: e51b0014  ldr r0, [fp, #-20]  ; 0xffffffec
     c14: e1a02003  mov r2, r3
     c18: eb00031c  bl  1890 <ValidateParition>
     c1c: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
            (PartitionTotalSize << WORD_LENGTH_SHIFT),
            ImageStartAddress  +
            (PartitionChecksumOffset << WORD_LENGTH_SHIFT));
        if (Status != XST_SUCCESS) {
     c20: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     c24: e3530000  cmp r3, #0
     c28: 0a000005  beq c44 <_SUPERVISOR_STACK_SIZE+0x444>
          fsbl_printf(DEBUG_GENERAL,"PARTITION_CHECKSUM_FAIL\r\n");
     c2c: e3070854  movw  r0, #30804  ; 0x7854
     c30: e3400001  movt  r0, #1
     c34: eb0015f1  bl  6400 <xil_printf>
          OutputStatus(PARTITION_CHECKSUM_FAIL);
     c38: e30a0010  movw  r0, #40976  ; 0xa010
     c3c: eb0003fe  bl  1c3c <OutputStatus>
          FsblFallback();
     c40: eb0003f1  bl  1c0c <FsblFallback>
        }

        fsbl_printf(DEBUG_INFO, "Partition Validation Done\r\n");
     c44: e3070870  movw  r0, #30832  ; 0x7870
     c48: e3400001  movt  r0, #1
     c4c: eb0015eb  bl  6400 <xil_printf>
      }

      /*
       * Authentication Partition
       */
      if (SignedPartitionFlag == 1 ) {
     c50: e30136f5  movw  r3, #5877 ; 0x16f5
     c54: e3403002  movt  r3, #2
     c58: e5d33000  ldrb  r3, [r3]
     c5c: e3530001  cmp r3, #1
     c60: 1a000005  bne c7c <_SUPERVISOR_STACK_SIZE+0x47c>
                Xil_DCacheDisable();
#else
        /*
         * In case user not enabled RSA authentication feature
         */
        fsbl_printf(DEBUG_GENERAL,"RSA_SUPPORT_NOT_ENABLED_FAIL\r\n");
     c64: e307070c  movw  r0, #30476  ; 0x770c
     c68: e3400001  movt  r0, #1
     c6c: eb0015e3  bl  6400 <xil_printf>
        OutputStatus(RSA_SUPPORT_NOT_ENABLED_FAIL);
     c70: e30a0011  movw  r0, #40977  ; 0xa011
     c74: eb0003f0  bl  1c3c <OutputStatus>
        FsblFallback();
     c78: eb0003e3  bl  1c0c <FsblFallback>
      }

      /*
       * Decrypt PS partition
       */
      if (EncryptedPartitionFlag && PSPartitionFlag) {
     c7c: e30136f6  movw  r3, #5878 ; 0x16f6
     c80: e3403002  movt  r3, #2
     c84: e5d33000  ldrb  r3, [r3]
     c88: e3530000  cmp r3, #0
     c8c: 0a000012  beq cdc <_SUPERVISOR_STACK_SIZE+0x4dc>
     c90: e30136e9  movw  r3, #5865 ; 0x16e9
     c94: e3403002  movt  r3, #2
     c98: e5d33000  ldrb  r3, [r3]
     c9c: e3530000  cmp r3, #0
     ca0: 0a00000d  beq cdc <_SUPERVISOR_STACK_SIZE+0x4dc>
        Status = DecryptPartition(PartitionStartAddr,
     ca4: e51b0014  ldr r0, [fp, #-20]  ; 0xffffffec
     ca8: e51b1030  ldr r1, [fp, #-48]  ; 0xffffffd0
     cac: e51b2034  ldr r2, [fp, #-52]  ; 0xffffffcc
     cb0: eb0002d8  bl  1818 <DecryptPartition>
     cb4: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
            PartitionDataLength,
            PartitionImageLength);
        if (Status != XST_SUCCESS) {
     cb8: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     cbc: e3530000  cmp r3, #0
     cc0: 0a000005  beq cdc <_SUPERVISOR_STACK_SIZE+0x4dc>
          fsbl_printf(DEBUG_GENERAL,"DECRYPTION_FAIL\r\n");
     cc4: e307088c  movw  r0, #30860  ; 0x788c
     cc8: e3400001  movt  r0, #1
     ccc: eb0015cb  bl  6400 <xil_printf>
          OutputStatus(DECRYPTION_FAIL);
     cd0: e30a0003  movw  r0, #40963  ; 0xa003
     cd4: eb0003d8  bl  1c3c <OutputStatus>
          FsblFallback();
     cd8: eb0003cb  bl  1c0c <FsblFallback>
      }

      /*
       * Load Signed PL partition in Fabric
       */
      if (PLPartitionFlag) {
     cdc: e30136fc  movw  r3, #5884 ; 0x16fc
     ce0: e3403002  movt  r3, #2
     ce4: e5d33000  ldrb  r3, [r3]
     ce8: e3530000  cmp r3, #0
     cec: 0a000014  beq d44 <_SUPERVISOR_STACK_SIZE+0x544>
        Status = PcapLoadPartition((u32*)PartitionStartAddr,
     cf0: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
     cf4: e51b2040  ldr r2, [fp, #-64]  ; 0xffffffc0
     cf8: e30136f6  movw  r3, #5878 ; 0x16f6
     cfc: e3403002  movt  r3, #2
     d00: e5d33000  ldrb  r3, [r3]
     d04: e58d3000  str r3, [sp]
     d08: e1a00001  mov r0, r1
     d0c: e1a01002  mov r1, r2
     d10: e51b2034  ldr r2, [fp, #-52]  ; 0xffffffcc
     d14: e51b3030  ldr r3, [fp, #-48]  ; 0xffffffd0
     d18: eb000afd  bl  3914 <PcapLoadPartition>
     d1c: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
            (u32*)PartitionLoadAddr,
            PartitionImageLength,
            PartitionDataLength,
            EncryptedPartitionFlag);
        if (Status != XST_SUCCESS) {
     d20: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     d24: e3530000  cmp r3, #0
     d28: 0a000005  beq d44 <_SUPERVISOR_STACK_SIZE+0x544>
          fsbl_printf(DEBUG_GENERAL,"BITSTREAM_DOWNLOAD_FAIL\r\n");
     d2c: e30708a0  movw  r0, #30880  ; 0x78a0
     d30: e3400001  movt  r0, #1
     d34: eb0015b1  bl  6400 <xil_printf>
          OutputStatus(BITSTREAM_DOWNLOAD_FAIL);
     d38: e30a0004  movw  r0, #40964  ; 0xa004
     d3c: eb0003be  bl  1c3c <OutputStatus>
          FsblFallback();
     d40: eb0003b1  bl  1c0c <FsblFallback>


    /*
     * FSBL user hook call after bitstream download
     */
    if (PLPartitionFlag) {
     d44: e30136fc  movw  r3, #5884 ; 0x16fc
     d48: e3403002  movt  r3, #2
     d4c: e5d33000  ldrb  r3, [r3]
     d50: e3530000  cmp r3, #0
     d54: 0a00000a  beq d84 <_SUPERVISOR_STACK_SIZE+0x584>
      Status = FsblHookAfterBitstreamDload();
     d58: ebfffe0f  bl  59c <FsblHookAfterBitstreamDload>
     d5c: e50b0024  str r0, [fp, #-36]  ; 0xffffffdc
      if (Status != XST_SUCCESS) {
     d60: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
     d64: e3530000  cmp r3, #0
     d68: 0a000005  beq d84 <_SUPERVISOR_STACK_SIZE+0x584>
        fsbl_printf(DEBUG_GENERAL,"FSBL_AFTER_BSTREAM_HOOK_FAIL\r\n");
     d6c: e30708bc  movw  r0, #30908  ; 0x78bc
     d70: e3400001  movt  r0, #1
     d74: eb0015a1  bl  6400 <xil_printf>
        OutputStatus(FSBL_AFTER_BSTREAM_HOOK_FAIL);
     d78: e30a0403  movw  r0, #41987  ; 0xa403
     d7c: eb0003ae  bl  1c3c <OutputStatus>
        FsblFallback();
     d80: eb0003a1  bl  1c0c <FsblFallback>
      }
    }
    /*
     * Increment partition number
     */
    PartitionNum++;
     d84: e51b300c  ldr r3, [fp, #-12]
     d88: e2833001  add r3, r3, #1
     d8c: e50b300c  str r3, [fp, #-12]
   * As it contain FSBL partition information
   */
  PartitionNum = 1;
#endif

  while (PartitionNum < PartitionCount) {
     d90: e30136f8  movw  r3, #5880 ; 0x16f8
     d94: e3403002  movt  r3, #2
     d98: e5933000  ldr r3, [r3]
     d9c: e51b200c  ldr r2, [fp, #-12]
     da0: e1520003  cmp r2, r3
     da4: 3afffe8c  bcc 7dc <LoadBootImage+0x1c8>
     * Increment partition number
     */
    PartitionNum++;
  }

  return ExecAddress;
     da8: e51b3010  ldr r3, [fp, #-16]
}
     dac: e1a00003  mov r0, r3
     db0: e24bd004  sub sp, fp, #4
     db4: e8bd8800  pop {fp, pc}

00000db8 <GetPartitionHeaderInfo>:
*
* @note   None
*
****************************************************************************/
u32 GetPartitionHeaderInfo(u32 ImageBaseAddress)
{
     db8: e92d4800  push  {fp, lr}
     dbc: e28db004  add fp, sp, #4
     dc0: e24dd010  sub sp, sp, #16
     dc4: e50b0010  str r0, [fp, #-16]


    /*
     * Get the length of the FSBL from BootHeader
     */
    Status = GetFsblLength(ImageBaseAddress, &FsblLength);
     dc8: e51b0010  ldr r0, [fp, #-16]
     dcc: e30116e4  movw  r1, #5860 ; 0x16e4
     dd0: e3401002  movt  r1, #2
     dd4: eb00008a  bl  1004 <GetFsblLength>
     dd8: e50b0008  str r0, [fp, #-8]
    if (Status != XST_SUCCESS) {
     ddc: e51b3008  ldr r3, [fp, #-8]
     de0: e3530000  cmp r3, #0
     de4: 0a000004  beq dfc <GetPartitionHeaderInfo+0x44>
      fsbl_printf(DEBUG_GENERAL, "Get Header Start Address Failed\r\n");
     de8: e30708dc  movw  r0, #30940  ; 0x78dc
     dec: e3400001  movt  r0, #1
     df0: eb001582  bl  6400 <xil_printf>
      return XST_FAILURE;
     df4: e3a03001  mov r3, #1
     df8: ea000046  b f18 <GetPartitionHeaderInfo+0x160>
    }

    /*
    * Get the start address of the partition header table
    */
    Status = GetPartitionHeaderStartAddr(ImageBaseAddress,
     dfc: e24b300c  sub r3, fp, #12
     e00: e51b0010  ldr r0, [fp, #-16]
     e04: e1a01003  mov r1, r3
     e08: eb000045  bl  f24 <GetPartitionHeaderStartAddr>
     e0c: e50b0008  str r0, [fp, #-8]
            &PartitionHeaderOffset);
    if (Status != XST_SUCCESS) {
     e10: e51b3008  ldr r3, [fp, #-8]
     e14: e3530000  cmp r3, #0
     e18: 0a000004  beq e30 <GetPartitionHeaderInfo+0x78>
      fsbl_printf(DEBUG_GENERAL, "Get Header Start Address Failed\r\n");
     e1c: e30708dc  movw  r0, #30940  ; 0x78dc
     e20: e3400001  movt  r0, #1
     e24: eb001575  bl  6400 <xil_printf>
      return XST_FAILURE;
     e28: e3a03001  mov r3, #1
     e2c: ea000039  b f18 <GetPartitionHeaderInfo+0x160>
    }

    /*
     * Header offset on flash
     */
    PartitionHeaderOffset += ImageBaseAddress;
     e30: e51b200c  ldr r2, [fp, #-12]
     e34: e51b3010  ldr r3, [fp, #-16]
     e38: e0823003  add r3, r2, r3
     e3c: e50b300c  str r3, [fp, #-12]

    fsbl_printf(DEBUG_INFO,"Partition Header Offset:0x%08x\r\n",
     e40: e51b300c  ldr r3, [fp, #-12]
     e44: e3070900  movw  r0, #30976  ; 0x7900
     e48: e3400001  movt  r0, #1
     e4c: e1a01003  mov r1, r3
     e50: eb00156a  bl  6400 <xil_printf>
        PartitionHeaderOffset);

    /*
     * Load all partitions header data in to global variable
     */
    Status = LoadPartitionsHeaderInfo(PartitionHeaderOffset,
     e54: e51b300c  ldr r3, [fp, #-12]
     e58: e1a00003  mov r0, r3
     e5c: e3011700  movw  r1, #5888 ; 0x1700
     e60: e3401002  movt  r1, #2
     e64: eb000082  bl  1074 <LoadPartitionsHeaderInfo>
     e68: e50b0008  str r0, [fp, #-8]
            &PartitionHeader[0]);
    if (Status != XST_SUCCESS) {
     e6c: e51b3008  ldr r3, [fp, #-8]
     e70: e3530000  cmp r3, #0
     e74: 0a000004  beq e8c <GetPartitionHeaderInfo+0xd4>
      fsbl_printf(DEBUG_GENERAL, "Header Information Load Failed\r\n");
     e78: e3070924  movw  r0, #31012  ; 0x7924
     e7c: e3400001  movt  r0, #1
     e80: eb00155e  bl  6400 <xil_printf>
      return XST_FAILURE;
     e84: e3a03001  mov r3, #1
     e88: ea000022  b f18 <GetPartitionHeaderInfo+0x160>
    }

    /*
     * Get partitions count from partitions header information
     */
  PartitionCount = GetPartitionCount(&PartitionHeader[0]);
     e8c: e3010700  movw  r0, #5888 ; 0x1700
     e90: e3400002  movt  r0, #2
     e94: eb0000d5  bl  11f0 <GetPartitionCount>
     e98: e1a02000  mov r2, r0
     e9c: e30136f8  movw  r3, #5880 ; 0x16f8
     ea0: e3403002  movt  r3, #2
     ea4: e5832000  str r2, [r3]

    fsbl_printf(DEBUG_INFO, "Partition Count: %d\r\n", PartitionCount);
     ea8: e30136f8  movw  r3, #5880 ; 0x16f8
     eac: e3403002  movt  r3, #2
     eb0: e5933000  ldr r3, [r3]
     eb4: e3070948  movw  r0, #31048  ; 0x7948
     eb8: e3400001  movt  r0, #1
     ebc: e1a01003  mov r1, r3
     ec0: eb00154e  bl  6400 <xil_printf>

    /*
     * Partition Count check
     */
    if (PartitionCount >= MAX_PARTITION_NUMBER) {
     ec4: e30136f8  movw  r3, #5880 ; 0x16f8
     ec8: e3403002  movt  r3, #2
     ecc: e5933000  ldr r3, [r3]
     ed0: e353000d  cmp r3, #13
     ed4: 9a000004  bls eec <GetPartitionHeaderInfo+0x134>
        fsbl_printf(DEBUG_GENERAL, "Invalid Partition Count\r\n");
     ed8: e3070960  movw  r0, #31072  ; 0x7960
     edc: e3400001  movt  r0, #1
     ee0: eb001546  bl  6400 <xil_printf>
    return XST_FAILURE;
     ee4: e3a03001  mov r3, #1
     ee8: ea00000a  b f18 <GetPartitionHeaderInfo+0x160>
#ifndef MMC_SUPPORT
    } else if (PartitionCount <= 1) {
     eec: e30136f8  movw  r3, #5880 ; 0x16f8
     ef0: e3403002  movt  r3, #2
     ef4: e5933000  ldr r3, [r3]
     ef8: e3530001  cmp r3, #1
     efc: 8a000004  bhi f14 <GetPartitionHeaderInfo+0x15c>
        fsbl_printf(DEBUG_GENERAL, "There is no partition to load\r\n");
     f00: e307097c  movw  r0, #31100  ; 0x797c
     f04: e3400001  movt  r0, #1
     f08: eb00153c  bl  6400 <xil_printf>
    return XST_FAILURE;
     f0c: e3a03001  mov r3, #1
     f10: ea000000  b f18 <GetPartitionHeaderInfo+0x160>
#endif
  }

    return XST_SUCCESS;
     f14: e3a03000  mov r3, #0
}
     f18: e1a00003  mov r0, r3
     f1c: e24bd004  sub sp, fp, #4
     f20: e8bd8800  pop {fp, pc}

00000f24 <GetPartitionHeaderStartAddr>:
*
* @note   None
*
****************************************************************************/
u32 GetPartitionHeaderStartAddr(u32 ImageAddress, u32 *Offset)
{
     f24: e92d4800  push  {fp, lr}
     f28: e28db004  add fp, sp, #4
     f2c: e24dd010  sub sp, sp, #16
     f30: e50b0010  str r0, [fp, #-16]
     f34: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  u32 Status;

  Status = MoveImage(ImageAddress + IMAGE_PHDR_OFFSET, (u32)Offset, 4);
     f38: e30136ec  movw  r3, #5868 ; 0x16ec
     f3c: e3403002  movt  r3, #2
     f40: e5933000  ldr r3, [r3]
     f44: e51b2010  ldr r2, [fp, #-16]
     f48: e282109c  add r1, r2, #156  ; 0x9c
     f4c: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
     f50: e1a00001  mov r0, r1
     f54: e1a01002  mov r1, r2
     f58: e3a02004  mov r2, #4
     f5c: e12fff33  blx r3
     f60: e50b0008  str r0, [fp, #-8]
  if (Status != XST_SUCCESS) {
     f64: e51b3008  ldr r3, [fp, #-8]
     f68: e3530000  cmp r3, #0
     f6c: 0a000004  beq f84 <GetPartitionHeaderStartAddr+0x60>
    fsbl_printf(DEBUG_GENERAL,"Move Image failed\r\n");
     f70: e307099c  movw  r0, #31132  ; 0x799c
     f74: e3400001  movt  r0, #1
     f78: eb001520  bl  6400 <xil_printf>
    return XST_FAILURE;
     f7c: e3a03001  mov r3, #1
     f80: ea000000  b f88 <GetPartitionHeaderStartAddr+0x64>
  }

  return XST_SUCCESS;
     f84: e3a03000  mov r3, #0
}
     f88: e1a00003  mov r0, r3
     f8c: e24bd004  sub sp, fp, #4
     f90: e8bd8800  pop {fp, pc}

00000f94 <GetImageHeaderStartAddr>:
*
* @note   None
*
****************************************************************************/
u32 GetImageHeaderStartAddr(u32 ImageAddress, u32 *Offset)
{
     f94: e92d4800  push  {fp, lr}
     f98: e28db004  add fp, sp, #4
     f9c: e24dd010  sub sp, sp, #16
     fa0: e50b0010  str r0, [fp, #-16]
     fa4: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  u32 Status;

  Status = MoveImage(ImageAddress + IMAGE_HDR_OFFSET, (u32)Offset, 4);
     fa8: e30136ec  movw  r3, #5868 ; 0x16ec
     fac: e3403002  movt  r3, #2
     fb0: e5933000  ldr r3, [r3]
     fb4: e51b2010  ldr r2, [fp, #-16]
     fb8: e2821098  add r1, r2, #152  ; 0x98
     fbc: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
     fc0: e1a00001  mov r0, r1
     fc4: e1a01002  mov r1, r2
     fc8: e3a02004  mov r2, #4
     fcc: e12fff33  blx r3
     fd0: e50b0008  str r0, [fp, #-8]
  if (Status != XST_SUCCESS) {
     fd4: e51b3008  ldr r3, [fp, #-8]
     fd8: e3530000  cmp r3, #0
     fdc: 0a000004  beq ff4 <GetImageHeaderStartAddr+0x60>
    fsbl_printf(DEBUG_GENERAL,"Move Image failed\r\n");
     fe0: e307099c  movw  r0, #31132  ; 0x799c
     fe4: e3400001  movt  r0, #1
     fe8: eb001504  bl  6400 <xil_printf>
    return XST_FAILURE;
     fec: e3a03001  mov r3, #1
     ff0: ea000000  b ff8 <GetImageHeaderStartAddr+0x64>
  }

  return XST_SUCCESS;
     ff4: e3a03000  mov r3, #0
}
     ff8: e1a00003  mov r0, r3
     ffc: e24bd004  sub sp, fp, #4
    1000: e8bd8800  pop {fp, pc}

00001004 <GetFsblLength>:
*
* @note   None
*
****************************************************************************/
u32 GetFsblLength(u32 ImageAddress, u32 *FsblLength)
{
    1004: e92d4800  push  {fp, lr}
    1008: e28db004  add fp, sp, #4
    100c: e24dd010  sub sp, sp, #16
    1010: e50b0010  str r0, [fp, #-16]
    1014: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  u32 Status;

  Status = MoveImage(ImageAddress + IMAGE_TOT_BYTE_LEN_OFFSET,
    1018: e30136ec  movw  r3, #5868 ; 0x16ec
    101c: e3403002  movt  r3, #2
    1020: e5933000  ldr r3, [r3]
    1024: e51b2010  ldr r2, [fp, #-16]
    1028: e2821040  add r1, r2, #64 ; 0x40
    102c: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    1030: e1a00001  mov r0, r1
    1034: e1a01002  mov r1, r2
    1038: e3a02004  mov r2, #4
    103c: e12fff33  blx r3
    1040: e50b0008  str r0, [fp, #-8]
              (u32)FsblLength, 4);
  if (Status != XST_SUCCESS) {
    1044: e51b3008  ldr r3, [fp, #-8]
    1048: e3530000  cmp r3, #0
    104c: 0a000004  beq 1064 <CRValMmuCac+0x5f>
    fsbl_printf(DEBUG_GENERAL,"Move Image failed reading FsblLength\r\n");
    1050: e30709b0  movw  r0, #31152  ; 0x79b0
    1054: e3400001  movt  r0, #1
    1058: eb0014e8  bl  6400 <xil_printf>
    return XST_FAILURE;
    105c: e3a03001  mov r3, #1
    1060: ea000000  b 1068 <CRValMmuCac+0x63>
  }

  return XST_SUCCESS;
    1064: e3a03000  mov r3, #0
}
    1068: e1a00003  mov r0, r3
    106c: e24bd004  sub sp, fp, #4
    1070: e8bd8800  pop {fp, pc}

00001074 <LoadPartitionsHeaderInfo>:
*
* @note   None
*
****************************************************************************/
u32 LoadPartitionsHeaderInfo(u32 PartHeaderOffset,  PartHeader *Header)
{
    1074: e92d4800  push  {fp, lr}
    1078: e28db004  add fp, sp, #4
    107c: e24dd010  sub sp, sp, #16
    1080: e50b0010  str r0, [fp, #-16]
    1084: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  u32 Status;

  Status = MoveImage(PartHeaderOffset, (u32)Header, sizeof(PartHeader)*MAX_PARTITION_NUMBER);
    1088: e30136ec  movw  r3, #5868 ; 0x16ec
    108c: e3403002  movt  r3, #2
    1090: e5933000  ldr r3, [r3]
    1094: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    1098: e51b0010  ldr r0, [fp, #-16]
    109c: e1a01002  mov r1, r2
    10a0: e3a02d0e  mov r2, #896  ; 0x380
    10a4: e12fff33  blx r3
    10a8: e50b0008  str r0, [fp, #-8]
  if (Status != XST_SUCCESS) {
    10ac: e51b3008  ldr r3, [fp, #-8]
    10b0: e3530000  cmp r3, #0
    10b4: 0a000004  beq 10cc <LoadPartitionsHeaderInfo+0x58>
    fsbl_printf(DEBUG_GENERAL,"Move Image failed\r\n");
    10b8: e307099c  movw  r0, #31132  ; 0x799c
    10bc: e3400001  movt  r0, #1
    10c0: eb0014ce  bl  6400 <xil_printf>
    return XST_FAILURE;
    10c4: e3a03001  mov r3, #1
    10c8: ea000000  b 10d0 <LoadPartitionsHeaderInfo+0x5c>
  }

  return XST_SUCCESS;
    10cc: e3a03000  mov r3, #0
}
    10d0: e1a00003  mov r0, r3
    10d4: e24bd004  sub sp, fp, #4
    10d8: e8bd8800  pop {fp, pc}

000010dc <HeaderDump>:
*
* @note   None
*
******************************************************************************/
void HeaderDump(PartHeader *Header)
{
    10dc: e92d4800  push  {fp, lr}
    10e0: e28db004  add fp, sp, #4
    10e4: e24dd008  sub sp, sp, #8
    10e8: e50b0008  str r0, [fp, #-8]
  fsbl_printf(DEBUG_INFO, "Header Dump\r\n");
    10ec: e30709d8  movw  r0, #31192  ; 0x79d8
    10f0: e3400001  movt  r0, #1
    10f4: eb0014c1  bl  6400 <xil_printf>
  fsbl_printf(DEBUG_INFO, "Image Word Len: 0x%08x\r\n",
    10f8: e51b3008  ldr r3, [fp, #-8]
    10fc: e5933000  ldr r3, [r3]
    1100: e30709e8  movw  r0, #31208  ; 0x79e8
    1104: e3400001  movt  r0, #1
    1108: e1a01003  mov r1, r3
    110c: eb0014bb  bl  6400 <xil_printf>
                  Header->ImageWordLen);
  fsbl_printf(DEBUG_INFO, "Data Word Len: 0x%08x\r\n",
    1110: e51b3008  ldr r3, [fp, #-8]
    1114: e5933004  ldr r3, [r3, #4]
    1118: e3070a04  movw  r0, #31236  ; 0x7a04
    111c: e3400001  movt  r0, #1
    1120: e1a01003  mov r1, r3
    1124: eb0014b5  bl  6400 <xil_printf>
                  Header->DataWordLen);
  fsbl_printf(DEBUG_INFO, "Partition Word Len:0x%08x\r\n",
    1128: e51b3008  ldr r3, [fp, #-8]
    112c: e5933008  ldr r3, [r3, #8]
    1130: e3070a1c  movw  r0, #31260  ; 0x7a1c
    1134: e3400001  movt  r0, #1
    1138: e1a01003  mov r1, r3
    113c: eb0014af  bl  6400 <xil_printf>
                  Header->PartitionWordLen);
  fsbl_printf(DEBUG_INFO, "Load Addr: 0x%08x\r\n",
    1140: e51b3008  ldr r3, [fp, #-8]
    1144: e593300c  ldr r3, [r3, #12]
    1148: e3070a38  movw  r0, #31288  ; 0x7a38
    114c: e3400001  movt  r0, #1
    1150: e1a01003  mov r1, r3
    1154: eb0014a9  bl  6400 <xil_printf>
                  Header->LoadAddr);
  fsbl_printf(DEBUG_INFO, "Exec Addr: 0x%08x\r\n",
    1158: e51b3008  ldr r3, [fp, #-8]
    115c: e5933010  ldr r3, [r3, #16]
    1160: e3070a4c  movw  r0, #31308  ; 0x7a4c
    1164: e3400001  movt  r0, #1
    1168: e1a01003  mov r1, r3
    116c: eb0014a3  bl  6400 <xil_printf>
                  Header->ExecAddr);
  fsbl_printf(DEBUG_INFO, "Partition Start: 0x%08x\r\n",
    1170: e51b3008  ldr r3, [fp, #-8]
    1174: e5933014  ldr r3, [r3, #20]
    1178: e3070a60  movw  r0, #31328  ; 0x7a60
    117c: e3400001  movt  r0, #1
    1180: e1a01003  mov r1, r3
    1184: eb00149d  bl  6400 <xil_printf>
                  Header->PartitionStart);
  fsbl_printf(DEBUG_INFO, "Partition Attr: 0x%08x\r\n",
    1188: e51b3008  ldr r3, [fp, #-8]
    118c: e5933018  ldr r3, [r3, #24]
    1190: e3070a7c  movw  r0, #31356  ; 0x7a7c
    1194: e3400001  movt  r0, #1
    1198: e1a01003  mov r1, r3
    119c: eb001497  bl  6400 <xil_printf>
                  Header->PartitionAttr);
  fsbl_printf(DEBUG_INFO, "Partition Checksum Offset: 0x%08x\r\n",
    11a0: e51b3008  ldr r3, [fp, #-8]
    11a4: e5933020  ldr r3, [r3, #32]
    11a8: e3070a98  movw  r0, #31384  ; 0x7a98
    11ac: e3400001  movt  r0, #1
    11b0: e1a01003  mov r1, r3
    11b4: eb001491  bl  6400 <xil_printf>
                    Header->CheckSumOffset);
  fsbl_printf(DEBUG_INFO, "Section Count: 0x%08x\r\n",
    11b8: e51b3008  ldr r3, [fp, #-8]
    11bc: e593301c  ldr r3, [r3, #28]
    11c0: e3070abc  movw  r0, #31420  ; 0x7abc
    11c4: e3400001  movt  r0, #1
    11c8: e1a01003  mov r1, r3
    11cc: eb00148b  bl  6400 <xil_printf>
                  Header->SectionCount);
  fsbl_printf(DEBUG_INFO, "Checksum: 0x%08x\r\n",
    11d0: e51b3008  ldr r3, [fp, #-8]
    11d4: e593303c  ldr r3, [r3, #60] ; 0x3c
    11d8: e3070ad4  movw  r0, #31444  ; 0x7ad4
    11dc: e3400001  movt  r0, #1
    11e0: e1a01003  mov r1, r3
    11e4: eb001485  bl  6400 <xil_printf>
                  Header->CheckSum);
}
    11e8: e24bd004  sub sp, fp, #4
    11ec: e8bd8800  pop {fp, pc}

000011f0 <GetPartitionCount>:
*
* @note   None
*
*******************************************************************************/
u32 GetPartitionCount(PartHeader *Header)
{
    11f0: e92d4800  push  {fp, lr}
    11f4: e28db004  add fp, sp, #4
    11f8: e24dd010  sub sp, sp, #16
    11fc: e50b0010  str r0, [fp, #-16]
    u32 Count=0;
    1200: e3a03000  mov r3, #0
    1204: e50b3008  str r3, [fp, #-8]
    struct HeaderArray *Hap;

    for(Count = 0; Count < MAX_PARTITION_NUMBER; Count++) {
    1208: e3a03000  mov r3, #0
    120c: e50b3008  str r3, [fp, #-8]
    1210: ea00000d  b 124c <GetPartitionCount+0x5c>
        Hap = (struct HeaderArray *)&Header[Count];
    1214: e51b3008  ldr r3, [fp, #-8]
    1218: e1a03303  lsl r3, r3, #6
    121c: e51b2010  ldr r2, [fp, #-16]
    1220: e0823003  add r3, r2, r3
    1224: e50b300c  str r3, [fp, #-12]
        if(IsLastPartition(Hap)!=XST_FAILURE)
    1228: e51b000c  ldr r0, [fp, #-12]
    122c: eb00000d  bl  1268 <IsLastPartition>
    1230: e1a03000  mov r3, r0
    1234: e3530001  cmp r3, #1
    1238: 0a000000  beq 1240 <GetPartitionCount+0x50>
            break;
    123c: ea000005  b 1258 <GetPartitionCount+0x68>
u32 GetPartitionCount(PartHeader *Header)
{
    u32 Count=0;
    struct HeaderArray *Hap;

    for(Count = 0; Count < MAX_PARTITION_NUMBER; Count++) {
    1240: e51b3008  ldr r3, [fp, #-8]
    1244: e2833001  add r3, r3, #1
    1248: e50b3008  str r3, [fp, #-8]
    124c: e51b3008  ldr r3, [fp, #-8]
    1250: e353000d  cmp r3, #13
    1254: 9affffee  bls 1214 <GetPartitionCount+0x24>
        Hap = (struct HeaderArray *)&Header[Count];
        if(IsLastPartition(Hap)!=XST_FAILURE)
            break;
    }

  return Count;
    1258: e51b3008  ldr r3, [fp, #-8]
}
    125c: e1a00003  mov r0, r3
    1260: e24bd004  sub sp, fp, #4
    1264: e8bd8800  pop {fp, pc}

00001268 <IsLastPartition>:
*   - XST_SUCCESS if it is the last partition
*   - XST_FAILURE if it is not last partition
*
****************************************************************************/
u32 IsLastPartition(struct HeaderArray *H)
{
    1268: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    126c: e28db000  add fp, sp, #0
    1270: e24dd014  sub sp, sp, #20
    1274: e50b0010  str r0, [fp, #-16]
  int Index;

  if (H->Fields[PARTITION_HDR_CHECKSUM_WORD_COUNT] != 0xFFFFFFFF) {
    1278: e51b3010  ldr r3, [fp, #-16]
    127c: e593303c  ldr r3, [r3, #60] ; 0x3c
    1280: e3730001  cmn r3, #1
    1284: 0a000001  beq 1290 <IsLastPartition+0x28>
    return  XST_FAILURE;
    1288: e3a03001  mov r3, #1
    128c: ea000010  b 12d4 <IsLastPartition+0x6c>
  }

  for (Index = 0; Index < PARTITION_HDR_WORD_COUNT - 1; Index++) {
    1290: e3a03000  mov r3, #0
    1294: e50b3008  str r3, [fp, #-8]
    1298: ea000009  b 12c4 <IsLastPartition+0x5c>

        if (H->Fields[Index] != 0x0) {
    129c: e51b3010  ldr r3, [fp, #-16]
    12a0: e51b2008  ldr r2, [fp, #-8]
    12a4: e7933102  ldr r3, [r3, r2, lsl #2]
    12a8: e3530000  cmp r3, #0
    12ac: 0a000001  beq 12b8 <IsLastPartition+0x50>
      return XST_FAILURE;
    12b0: e3a03001  mov r3, #1
    12b4: ea000006  b 12d4 <IsLastPartition+0x6c>

  if (H->Fields[PARTITION_HDR_CHECKSUM_WORD_COUNT] != 0xFFFFFFFF) {
    return  XST_FAILURE;
  }

  for (Index = 0; Index < PARTITION_HDR_WORD_COUNT - 1; Index++) {
    12b8: e51b3008  ldr r3, [fp, #-8]
    12bc: e2833001  add r3, r3, #1
    12c0: e50b3008  str r3, [fp, #-8]
    12c4: e51b3008  ldr r3, [fp, #-8]
    12c8: e353000e  cmp r3, #14
    12cc: dafffff2  ble 129c <IsLastPartition+0x34>
        if (H->Fields[Index] != 0x0) {
      return XST_FAILURE;
    }
  }

    return XST_SUCCESS;
    12d0: e3a03000  mov r3, #0
}
    12d4: e1a00003  mov r0, r3
    12d8: e24bd000  sub sp, fp, #0
    12dc: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    12e0: e12fff1e  bx  lr

000012e4 <ValidateHeader>:
*
* @note   None
*
*******************************************************************************/
u32 ValidateHeader(PartHeader *Header)
{
    12e4: e92d4800  push  {fp, lr}
    12e8: e28db004  add fp, sp, #4
    12ec: e24dd010  sub sp, sp, #16
    12f0: e50b0010  str r0, [fp, #-16]
  struct HeaderArray *Hap;

    Hap = (struct HeaderArray *)Header;
    12f4: e51b3010  ldr r3, [fp, #-16]
    12f8: e50b3008  str r3, [fp, #-8]

  /*
   * If there are no partitions to load, fail
   */
  if (IsEmptyHeader(Hap) == XST_SUCCESS) {
    12fc: e51b0008  ldr r0, [fp, #-8]
    1300: eb00001e  bl  1380 <IsEmptyHeader>
    1304: e1a03000  mov r3, r0
    1308: e3530000  cmp r3, #0
    130c: 1a000004  bne 1324 <ValidateHeader+0x40>
    fsbl_printf(DEBUG_GENERAL, "IMAGE_HAS_NO_PARTITIONS\r\n");
    1310: e3070ae8  movw  r0, #31464  ; 0x7ae8
    1314: e3400001  movt  r0, #1
    1318: eb001438  bl  6400 <xil_printf>
      return XST_FAILURE;
    131c: e3a03001  mov r3, #1
    1320: ea000013  b 1374 <ValidateHeader+0x90>
  }

  /*
   * Validate partition header checksum
   */
  if (ValidatePartitionHeaderChecksum(Hap) != XST_SUCCESS) {
    1324: e51b0008  ldr r0, [fp, #-8]
    1328: eb00002d  bl  13e4 <ValidatePartitionHeaderChecksum>
    132c: e1a03000  mov r3, r0
    1330: e3530000  cmp r3, #0
    1334: 0a000004  beq 134c <ValidateHeader+0x68>
    fsbl_printf(DEBUG_GENERAL, "PARTITION_HEADER_CORRUPTION\r\n");
    1338: e3070b04  movw  r0, #31492  ; 0x7b04
    133c: e3400001  movt  r0, #1
    1340: eb00142e  bl  6400 <xil_printf>
    return XST_FAILURE;
    1344: e3a03001  mov r3, #1
    1348: ea000009  b 1374 <ValidateHeader+0x90>
  }

    /*
     * Validate partition data size
     */
  if (Header->ImageWordLen > MAXIMUM_IMAGE_WORD_LEN) {
    134c: e51b3010  ldr r3, [fp, #-16]
    1350: e5933000  ldr r3, [r3]
    1354: e3530101  cmp r3, #1073741824 ; 0x40000000
    1358: 9a000004  bls 1370 <ValidateHeader+0x8c>
    fsbl_printf(DEBUG_GENERAL, "INVALID_PARTITION_LENGTH\r\n");
    135c: e3070b24  movw  r0, #31524  ; 0x7b24
    1360: e3400001  movt  r0, #1
    1364: eb001425  bl  6400 <xil_printf>
    return XST_FAILURE;
    1368: e3a03001  mov r3, #1
    136c: ea000000  b 1374 <ValidateHeader+0x90>
  }

  return XST_SUCCESS;
    1370: e3a03000  mov r3, #0
}
    1374: e1a00003  mov r0, r3
    1378: e24bd004  sub sp, fp, #4
    137c: e8bd8800  pop {fp, pc}

00001380 <IsEmptyHeader>:
* @note   Caller is responsible to make sure the address is valid.
*
*
****************************************************************************/
u32 IsEmptyHeader(struct HeaderArray *H)
{
    1380: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    1384: e28db000  add fp, sp, #0
    1388: e24dd014  sub sp, sp, #20
    138c: e50b0010  str r0, [fp, #-16]
  int Index;

  for (Index = 0; Index < PARTITION_HDR_WORD_COUNT; Index++) {
    1390: e3a03000  mov r3, #0
    1394: e50b3008  str r3, [fp, #-8]
    1398: ea000009  b 13c4 <IsEmptyHeader+0x44>
    if (H->Fields[Index] != 0x0) {
    139c: e51b3010  ldr r3, [fp, #-16]
    13a0: e51b2008  ldr r2, [fp, #-8]
    13a4: e7933102  ldr r3, [r3, r2, lsl #2]
    13a8: e3530000  cmp r3, #0
    13ac: 0a000001  beq 13b8 <IsEmptyHeader+0x38>
      return XST_FAILURE;
    13b0: e3a03001  mov r3, #1
    13b4: ea000006  b 13d4 <IsEmptyHeader+0x54>
****************************************************************************/
u32 IsEmptyHeader(struct HeaderArray *H)
{
  int Index;

  for (Index = 0; Index < PARTITION_HDR_WORD_COUNT; Index++) {
    13b8: e51b3008  ldr r3, [fp, #-8]
    13bc: e2833001  add r3, r3, #1
    13c0: e50b3008  str r3, [fp, #-8]
    13c4: e51b3008  ldr r3, [fp, #-8]
    13c8: e353000f  cmp r3, #15
    13cc: dafffff2  ble 139c <IsEmptyHeader+0x1c>
    if (H->Fields[Index] != 0x0) {
      return XST_FAILURE;
    }
  }

  return XST_SUCCESS;
    13d0: e3a03000  mov r3, #0
}
    13d4: e1a00003  mov r0, r3
    13d8: e24bd000  sub sp, fp, #0
    13dc: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    13e0: e12fff1e  bx  lr

000013e4 <ValidatePartitionHeaderChecksum>:
*
* @note   None.
*
****************************************************************************/
u32 ValidatePartitionHeaderChecksum(struct HeaderArray *H)
{
    13e4: e92d4800  push  {fp, lr}
    13e8: e28db004  add fp, sp, #4
    13ec: e24dd010  sub sp, sp, #16
    13f0: e50b0010  str r0, [fp, #-16]
  u32 Checksum;
  u32 Count;

  Checksum = 0;
    13f4: e3a03000  mov r3, #0
    13f8: e50b3008  str r3, [fp, #-8]

  for (Count = 0; Count < PARTITION_HDR_CHECKSUM_WORD_COUNT; Count++) {
    13fc: e3a03000  mov r3, #0
    1400: e50b300c  str r3, [fp, #-12]
    1404: ea000008  b 142c <ValidatePartitionHeaderChecksum+0x48>
    /*
     * Read the word from the header
     */
    Checksum += H->Fields[Count];
    1408: e51b3010  ldr r3, [fp, #-16]
    140c: e51b200c  ldr r2, [fp, #-12]
    1410: e7933102  ldr r3, [r3, r2, lsl #2]
    1414: e51b2008  ldr r2, [fp, #-8]
    1418: e0823003  add r3, r2, r3
    141c: e50b3008  str r3, [fp, #-8]
  u32 Checksum;
  u32 Count;

  Checksum = 0;

  for (Count = 0; Count < PARTITION_HDR_CHECKSUM_WORD_COUNT; Count++) {
    1420: e51b300c  ldr r3, [fp, #-12]
    1424: e2833001  add r3, r3, #1
    1428: e50b300c  str r3, [fp, #-12]
    142c: e51b300c  ldr r3, [fp, #-12]
    1430: e353000e  cmp r3, #14
    1434: 9afffff3  bls 1408 <ValidatePartitionHeaderChecksum+0x24>
  }

  /*
   * Invert checksum, last bit of error checking
   */
  Checksum ^= 0xFFFFFFFF;
    1438: e51b3008  ldr r3, [fp, #-8]
    143c: e1e03003  mvn r3, r3
    1440: e50b3008  str r3, [fp, #-8]

  /*
   * Validate the checksum
   */
  if (H->Fields[PARTITION_HDR_CHECKSUM_WORD_COUNT] != Checksum) {
    1444: e51b3010  ldr r3, [fp, #-16]
    1448: e593203c  ldr r2, [r3, #60] ; 0x3c
    144c: e51b3008  ldr r3, [fp, #-8]
    1450: e1520003  cmp r2, r3
    1454: 0a000008  beq 147c <ValidatePartitionHeaderChecksum+0x98>
      fsbl_printf(DEBUG_GENERAL, "Error: Checksum 0x%8.8x != 0x%8.8x\r\n",
    1458: e51b3010  ldr r3, [fp, #-16]
    145c: e593303c  ldr r3, [r3, #60] ; 0x3c
    1460: e3070b40  movw  r0, #31552  ; 0x7b40
    1464: e3400001  movt  r0, #1
    1468: e51b1008  ldr r1, [fp, #-8]
    146c: e1a02003  mov r2, r3
    1470: eb0013e2  bl  6400 <xil_printf>
      Checksum, H->Fields[PARTITION_HDR_CHECKSUM_WORD_COUNT]);
    return XST_FAILURE;
    1474: e3a03001  mov r3, #1
    1478: ea000000  b 1480 <ValidatePartitionHeaderChecksum+0x9c>
  }

  return XST_SUCCESS;
    147c: e3a03000  mov r3, #0
}
    1480: e1a00003  mov r0, r3
    1484: e24bd004  sub sp, fp, #4
    1488: e8bd8800  pop {fp, pc}

0000148c <PartitionMove>:
*
* @note   None
*
*******************************************************************************/
u32 PartitionMove(u32 ImageBaseAddress, PartHeader *Header)
{
    148c: e92d4800  push  {fp, lr}
    1490: e28db004  add fp, sp, #4
    1494: e24dd028  sub sp, sp, #40 ; 0x28
    1498: e50b0020  str r0, [fp, #-32]  ; 0xffffffe0
    149c: e50b1024  str r1, [fp, #-36]  ; 0xffffffdc
    u32 SourceAddr;
    u32 Status;
    u8 SecureTransferFlag = 0;
    14a0: e3a03000  mov r3, #0
    14a4: e54b3009  strb  r3, [fp, #-9]
    u32 LoadAddr;
    u32 ImageWordLen;
    u32 DataWordLen;

  SourceAddr = ImageBaseAddress;
    14a8: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    14ac: e50b3008  str r3, [fp, #-8]
  SourceAddr += Header->PartitionStart<<WORD_LENGTH_SHIFT;
    14b0: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    14b4: e5933014  ldr r3, [r3, #20]
    14b8: e1a03103  lsl r3, r3, #2
    14bc: e51b2008  ldr r2, [fp, #-8]
    14c0: e0823003  add r3, r2, r3
    14c4: e50b3008  str r3, [fp, #-8]
  LoadAddr = Header->LoadAddr;
    14c8: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    14cc: e593300c  ldr r3, [r3, #12]
    14d0: e50b3010  str r3, [fp, #-16]
  ImageWordLen = Header->ImageWordLen;
    14d4: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    14d8: e5933000  ldr r3, [r3]
    14dc: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
  DataWordLen = Header->DataWordLen;
    14e0: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    14e4: e5933004  ldr r3, [r3, #4]
    14e8: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8

  /*
   * Add flash base address for linear boot devices
   */
  if (LinearBootDeviceFlag) {
    14ec: e3013060  movw  r3, #4192 ; 0x1060
    14f0: e3403002  movt  r3, #2
    14f4: e5d33000  ldrb  r3, [r3]
    14f8: e3530000  cmp r3, #0
    14fc: 0a000005  beq 1518 <PartitionMove+0x8c>
    SourceAddr += FlashReadBaseAddress;
    1500: e301305c  movw  r3, #4188 ; 0x105c
    1504: e3403002  movt  r3, #2
    1508: e5933000  ldr r3, [r3]
    150c: e51b2008  ldr r2, [fp, #-8]
    1510: e0823003  add r3, r2, r3
    1514: e50b3008  str r3, [fp, #-8]
  }

  /*
   * Partition encrypted
   */
  if(EncryptedPartitionFlag) {
    1518: e30136f6  movw  r3, #5878 ; 0x16f6
    151c: e3403002  movt  r3, #2
    1520: e5d33000  ldrb  r3, [r3]
    1524: e3530000  cmp r3, #0
    1528: 0a000001  beq 1534 <PartitionMove+0xa8>
    SecureTransferFlag = 1;
    152c: e3a03001  mov r3, #1
    1530: e54b3009  strb  r3, [fp, #-9]

  /*
   * For Signed or checksum enabled partition, 
   * Total partition image need to copied to DDR
   */
  if (SignedPartitionFlag || PartitionChecksumFlag) {
    1534: e30136f5  movw  r3, #5877 ; 0x16f5
    1538: e3403002  movt  r3, #2
    153c: e5d33000  ldrb  r3, [r3]
    1540: e3530000  cmp r3, #0
    1544: 1a000004  bne 155c <PartitionMove+0xd0>
    1548: e30136e8  movw  r3, #5864 ; 0x16e8
    154c: e3403002  movt  r3, #2
    1550: e5d33000  ldrb  r3, [r3]
    1554: e3530000  cmp r3, #0
    1558: 0a000005  beq 1574 <PartitionMove+0xe8>
    ImageWordLen = Header->PartitionWordLen;
    155c: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    1560: e5933008  ldr r3, [r3, #8]
    1564: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
    DataWordLen = Header->PartitionWordLen;
    1568: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    156c: e5933008  ldr r3, [r3, #8]
    1570: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8

  /*
   * Encrypted and Signed PS partition need to be loaded on to DDR
   * without decryption
   */
  if (PSPartitionFlag &&
    1574: e30136e9  movw  r3, #5865 ; 0x16e9
    1578: e3403002  movt  r3, #2
    157c: e5d33000  ldrb  r3, [r3]
    1580: e3530000  cmp r3, #0
    1584: 0a000010  beq 15cc <PartitionMove+0x140>
      (SignedPartitionFlag || PartitionChecksumFlag) &&
    1588: e30136f5  movw  r3, #5877 ; 0x16f5
    158c: e3403002  movt  r3, #2
    1590: e5d33000  ldrb  r3, [r3]

  /*
   * Encrypted and Signed PS partition need to be loaded on to DDR
   * without decryption
   */
  if (PSPartitionFlag &&
    1594: e3530000  cmp r3, #0
    1598: 1a000004  bne 15b0 <PartitionMove+0x124>
      (SignedPartitionFlag || PartitionChecksumFlag) &&
    159c: e30136e8  movw  r3, #5864 ; 0x16e8
    15a0: e3403002  movt  r3, #2
    15a4: e5d33000  ldrb  r3, [r3]
    15a8: e3530000  cmp r3, #0
    15ac: 0a000006  beq 15cc <PartitionMove+0x140>
    15b0: e30136f6  movw  r3, #5878 ; 0x16f6
    15b4: e3403002  movt  r3, #2
    15b8: e5d33000  ldrb  r3, [r3]
    15bc: e3530000  cmp r3, #0
    15c0: 0a000001  beq 15cc <PartitionMove+0x140>
      EncryptedPartitionFlag) {
    SecureTransferFlag = 0;
    15c4: e3a03000  mov r3, #0
    15c8: e54b3009  strb  r3, [fp, #-9]

  /*
   * CPU is used for data transfer in case of non-linear
   * boot device
   */
  if (!LinearBootDeviceFlag) {
    15cc: e3013060  movw  r3, #4192 ; 0x1060
    15d0: e3403002  movt  r3, #2
    15d4: e5d33000  ldrb  r3, [r3]
    15d8: e3530000  cmp r3, #0
    15dc: 1a000019  bne 1648 <PartitionMove+0x1bc>
    /*
     * PL partition copied to DDR temporary location
     */
    if (PLPartitionFlag) {
    15e0: e30136fc  movw  r3, #5884 ; 0x16fc
    15e4: e3403002  movt  r3, #2
    15e8: e5d33000  ldrb  r3, [r3]
    15ec: e3530000  cmp r3, #0
    15f0: 0a000001  beq 15fc <PartitionMove+0x170>
      LoadAddr = DDR_TEMP_START_ADDR;
    15f4: e3a03601  mov r3, #1048576  ; 0x100000
    15f8: e50b3010  str r3, [fp, #-16]
    }

    Status = MoveImage(SourceAddr,
    15fc: e30136ec  movw  r3, #5868 ; 0x16ec
    1600: e3403002  movt  r3, #2
    1604: e5933000  ldr r3, [r3]
    1608: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    160c: e1a02102  lsl r2, r2, #2
    1610: e51b0008  ldr r0, [fp, #-8]
    1614: e51b1010  ldr r1, [fp, #-16]
    1618: e12fff33  blx r3
    161c: e50b001c  str r0, [fp, #-28]  ; 0xffffffe4
            LoadAddr,
            (ImageWordLen << WORD_LENGTH_SHIFT));
    if(Status != XST_SUCCESS) {
    1620: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    1624: e3530000  cmp r3, #0
    1628: 0a000004  beq 1640 <PartitionMove+0x1b4>
      fsbl_printf(DEBUG_GENERAL, "Move Image Failed\r\n");
    162c: e3070b68  movw  r0, #31592  ; 0x7b68
    1630: e3400001  movt  r0, #1
    1634: eb001371  bl  6400 <xil_printf>
      return XST_FAILURE;
    1638: e3a03001  mov r3, #1
    163c: ea000072  b 180c <PartitionMove+0x380>
    }

    /*
     * As image present at load address
     */
    SourceAddr = LoadAddr;
    1640: e51b3010  ldr r3, [fp, #-16]
    1644: e50b3008  str r3, [fp, #-8]
  }

  if ((LinearBootDeviceFlag && PLPartitionFlag &&
    1648: e3013060  movw  r3, #4192 ; 0x1060
    164c: e3403002  movt  r3, #2
    1650: e5d33000  ldrb  r3, [r3]
    1654: e3530000  cmp r3, #0
    1658: 0a00000e  beq 1698 <PartitionMove+0x20c>
    165c: e30136fc  movw  r3, #5884 ; 0x16fc
    1660: e3403002  movt  r3, #2
    1664: e5d33000  ldrb  r3, [r3]
    1668: e3530000  cmp r3, #0
    166c: 0a000009  beq 1698 <PartitionMove+0x20c>
      (SignedPartitionFlag || PartitionChecksumFlag)) ||
    1670: e30136f5  movw  r3, #5877 ; 0x16f5
    1674: e3403002  movt  r3, #2
    1678: e5d33000  ldrb  r3, [r3]
     * As image present at load address
     */
    SourceAddr = LoadAddr;
  }

  if ((LinearBootDeviceFlag && PLPartitionFlag &&
    167c: e3530000  cmp r3, #0
    1680: 1a00001b  bne 16f4 <PartitionMove+0x268>
      (SignedPartitionFlag || PartitionChecksumFlag)) ||
    1684: e30136e8  movw  r3, #5864 ; 0x16e8
    1688: e3403002  movt  r3, #2
    168c: e5d33000  ldrb  r3, [r3]
    1690: e3530000  cmp r3, #0
    1694: 1a000016  bne 16f4 <PartitionMove+0x268>
        (LinearBootDeviceFlag && PSPartitionFlag) ||
    1698: e3013060  movw  r3, #4192 ; 0x1060
    169c: e3403002  movt  r3, #2
    16a0: e5d33000  ldrb  r3, [r3]
     */
    SourceAddr = LoadAddr;
  }

  if ((LinearBootDeviceFlag && PLPartitionFlag &&
      (SignedPartitionFlag || PartitionChecksumFlag)) ||
    16a4: e3530000  cmp r3, #0
    16a8: 0a000004  beq 16c0 <PartitionMove+0x234>
        (LinearBootDeviceFlag && PSPartitionFlag) ||
    16ac: e30136e9  movw  r3, #5865 ; 0x16e9
    16b0: e3403002  movt  r3, #2
    16b4: e5d33000  ldrb  r3, [r3]
    16b8: e3530000  cmp r3, #0
    16bc: 1a00000c  bne 16f4 <PartitionMove+0x268>
        ((!LinearBootDeviceFlag) && PSPartitionFlag && SecureTransferFlag)) {
    16c0: e3013060  movw  r3, #4192 ; 0x1060
    16c4: e3403002  movt  r3, #2
    16c8: e5d33000  ldrb  r3, [r3]
    SourceAddr = LoadAddr;
  }

  if ((LinearBootDeviceFlag && PLPartitionFlag &&
      (SignedPartitionFlag || PartitionChecksumFlag)) ||
        (LinearBootDeviceFlag && PSPartitionFlag) ||
    16cc: e3530000  cmp r3, #0
    16d0: 1a000024  bne 1768 <PartitionMove+0x2dc>
        ((!LinearBootDeviceFlag) && PSPartitionFlag && SecureTransferFlag)) {
    16d4: e30136e9  movw  r3, #5865 ; 0x16e9
    16d8: e3403002  movt  r3, #2
    16dc: e5d33000  ldrb  r3, [r3]
    16e0: e3530000  cmp r3, #0
    16e4: 0a00001f  beq 1768 <PartitionMove+0x2dc>
    16e8: e55b3009  ldrb  r3, [fp, #-9]
    16ec: e3530000  cmp r3, #0
    16f0: 0a00001c  beq 1768 <PartitionMove+0x2dc>
    /*
     * PL signed partition copied to DDR temporary location
     * using non-secure PCAP for linear boot device
     */
    if(PLPartitionFlag){
    16f4: e30136fc  movw  r3, #5884 ; 0x16fc
    16f8: e3403002  movt  r3, #2
    16fc: e5d33000  ldrb  r3, [r3]
    1700: e3530000  cmp r3, #0
    1704: 0a000003  beq 1718 <PartitionMove+0x28c>
      SecureTransferFlag = 0;
    1708: e3a03000  mov r3, #0
    170c: e54b3009  strb  r3, [fp, #-9]
      LoadAddr = DDR_TEMP_START_ADDR;
    1710: e3a03601  mov r3, #1048576  ; 0x100000
    1714: e50b3010  str r3, [fp, #-16]
    }

    /*
     * Data transfer using PCAP
     */
    Status = PcapDataTransfer((u32*)SourceAddr,
    1718: e51b1008  ldr r1, [fp, #-8]
    171c: e51b2010  ldr r2, [fp, #-16]
    1720: e55b3009  ldrb  r3, [fp, #-9]
    1724: e58d3000  str r3, [sp]
    1728: e1a00001  mov r0, r1
    172c: e1a01002  mov r1, r2
    1730: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    1734: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    1738: eb00081a  bl  37a8 <PcapDataTransfer>
    173c: e50b001c  str r0, [fp, #-28]  ; 0xffffffe4
            (u32*)LoadAddr,
            ImageWordLen,
            DataWordLen,
            SecureTransferFlag);
    if(Status != XST_SUCCESS) {
    1740: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    1744: e3530000  cmp r3, #0
    1748: 0a000004  beq 1760 <PartitionMove+0x2d4>
      fsbl_printf(DEBUG_GENERAL, "PCAP Data Transfer Failed\r\n");
    174c: e3070b7c  movw  r0, #31612  ; 0x7b7c
    1750: e3400001  movt  r0, #1
    1754: eb001329  bl  6400 <xil_printf>
      return XST_FAILURE;
    1758: e3a03001  mov r3, #1
    175c: ea00002a  b 180c <PartitionMove+0x380>
    }

    /*
     * As image present at load address
     */
    SourceAddr = LoadAddr;
    1760: e51b3010  ldr r3, [fp, #-16]
    1764: e50b3008  str r3, [fp, #-8]

  /*
   * Load Bitstream partition in to fabric only
   * if checksum and authentication bits are not set
   */
  if (PLPartitionFlag && (!(SignedPartitionFlag || PartitionChecksumFlag))) {
    1768: e30136fc  movw  r3, #5884 ; 0x16fc
    176c: e3403002  movt  r3, #2
    1770: e5d33000  ldrb  r3, [r3]
    1774: e3530000  cmp r3, #0
    1778: 0a000022  beq 1808 <PartitionMove+0x37c>
    177c: e30136f5  movw  r3, #5877 ; 0x16f5
    1780: e3403002  movt  r3, #2
    1784: e5d33000  ldrb  r3, [r3]
    1788: e3530000  cmp r3, #0
    178c: 1a00001d  bne 1808 <PartitionMove+0x37c>
    1790: e30136e8  movw  r3, #5864 ; 0x16e8
    1794: e3403002  movt  r3, #2
    1798: e5d33000  ldrb  r3, [r3]
    179c: e3530000  cmp r3, #0
    17a0: 1a000018  bne 1808 <PartitionMove+0x37c>
    Status = PcapLoadPartition((u32*)SourceAddr,
    17a4: e51b1008  ldr r1, [fp, #-8]
          (u32*)Header->LoadAddr,
    17a8: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    17ac: e593300c  ldr r3, [r3, #12]
  /*
   * Load Bitstream partition in to fabric only
   * if checksum and authentication bits are not set
   */
  if (PLPartitionFlag && (!(SignedPartitionFlag || PartitionChecksumFlag))) {
    Status = PcapLoadPartition((u32*)SourceAddr,
    17b0: e1a0e003  mov lr, r3
    17b4: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    17b8: e5932000  ldr r2, [r3]
    17bc: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    17c0: e593c004  ldr ip, [r3, #4]
    17c4: e30136f6  movw  r3, #5878 ; 0x16f6
    17c8: e3403002  movt  r3, #2
    17cc: e5d33000  ldrb  r3, [r3]
    17d0: e58d3000  str r3, [sp]
    17d4: e1a00001  mov r0, r1
    17d8: e1a0100e  mov r1, lr
    17dc: e1a0300c  mov r3, ip
    17e0: eb00084b  bl  3914 <PcapLoadPartition>
    17e4: e50b001c  str r0, [fp, #-28]  ; 0xffffffe4
          (u32*)Header->LoadAddr,
          Header->ImageWordLen,
          Header->DataWordLen,
          EncryptedPartitionFlag);
    if(Status != XST_SUCCESS) {
    17e8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    17ec: e3530000  cmp r3, #0
    17f0: 0a000004  beq 1808 <PartitionMove+0x37c>
      fsbl_printf(DEBUG_GENERAL, "PCAP Bitstream Download Failed\r\n");
    17f4: e3070b98  movw  r0, #31640  ; 0x7b98
    17f8: e3400001  movt  r0, #1
    17fc: eb0012ff  bl  6400 <xil_printf>
      return XST_FAILURE;
    1800: e3a03001  mov r3, #1
    1804: ea000000  b 180c <PartitionMove+0x380>
    }
  }

  return XST_SUCCESS;
    1808: e3a03000  mov r3, #0
}
    180c: e1a00003  mov r0, r3
    1810: e24bd004  sub sp, fp, #4
    1814: e8bd8800  pop {fp, pc}

00001818 <DecryptPartition>:
*
* @note   None
*
*******************************************************************************/
u32 DecryptPartition(u32 StartAddr, u32 DataLength, u32 ImageLength)
{
    1818: e92d4800  push  {fp, lr}
    181c: e28db004  add fp, sp, #4
    1820: e24dd020  sub sp, sp, #32
    1824: e50b0010  str r0, [fp, #-16]
    1828: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    182c: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
  u32 Status;
  u8 SecureTransferFlag =1;
    1830: e3a03001  mov r3, #1
    1834: e54b3005  strb  r3, [fp, #-5]

  /*
   * Data transfer using PCAP
   */
  Status = PcapDataTransfer((u32*)StartAddr,
    1838: e51b1010  ldr r1, [fp, #-16]
    183c: e51b2010  ldr r2, [fp, #-16]
    1840: e55b3005  ldrb  r3, [fp, #-5]
    1844: e58d3000  str r3, [sp]
    1848: e1a00001  mov r0, r1
    184c: e1a01002  mov r1, r2
    1850: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    1854: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    1858: eb0007d2  bl  37a8 <PcapDataTransfer>
    185c: e50b000c  str r0, [fp, #-12]
          (u32*)StartAddr,
          ImageLength,
          DataLength,
          SecureTransferFlag);
  if (Status != XST_SUCCESS) {
    1860: e51b300c  ldr r3, [fp, #-12]
    1864: e3530000  cmp r3, #0
    1868: 0a000004  beq 1880 <DecryptPartition+0x68>
    fsbl_printf(DEBUG_GENERAL,"PCAP Data Transfer failed \r\n");
    186c: e3070bbc  movw  r0, #31676  ; 0x7bbc
    1870: e3400001  movt  r0, #1
    1874: eb0012e1  bl  6400 <xil_printf>
    return XST_FAILURE;
    1878: e3a03001  mov r3, #1
    187c: ea000000  b 1884 <DecryptPartition+0x6c>
  }

  return XST_SUCCESS;
    1880: e3a03000  mov r3, #0
}
    1884: e1a00003  mov r0, r3
    1888: e24bd004  sub sp, fp, #4
    188c: e8bd8800  pop {fp, pc}

00001890 <ValidateParition>:
*
* @note   None
*
*******************************************************************************/
u32 ValidateParition(u32 StartAddr, u32 Length, u32 ChecksumOffset)
{
    1890: e92d4800  push  {fp, lr}
    1894: e28db004  add fp, sp, #4
    1898: e24dd038  sub sp, sp, #56 ; 0x38
    189c: e50b0030  str r0, [fp, #-48]  ; 0xffffffd0
    18a0: e50b1034  str r1, [fp, #-52]  ; 0xffffffcc
    18a4: e50b2038  str r2, [fp, #-56]  ; 0xffffffc8
#endif

    /*
     * Get checksum from flash
     */
    Status = GetPartitionChecksum(ChecksumOffset, &Checksum[0]);
    18a8: e24b301c  sub r3, fp, #28
    18ac: e51b0038  ldr r0, [fp, #-56]  ; 0xffffffc8
    18b0: e1a01003  mov r1, r3
    18b4: eb000064  bl  1a4c <GetPartitionChecksum>
    18b8: e50b000c  str r0, [fp, #-12]
    if(Status != XST_SUCCESS) {
    18bc: e51b300c  ldr r3, [fp, #-12]
    18c0: e3530000  cmp r3, #0
    18c4: 0a000001  beq 18d0 <ValidateParition+0x40>
            return XST_FAILURE;
    18c8: e3a03001  mov r3, #1
    18cc: ea00005b  b 1a40 <ValidateParition+0x1b0>
    }

    fsbl_printf(DEBUG_INFO, "Actual checksum\r\n");
    18d0: e3070bdc  movw  r0, #31708  ; 0x7bdc
    18d4: e3400001  movt  r0, #1
    18d8: eb0012c8  bl  6400 <xil_printf>

    for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    18dc: e3a03000  mov r3, #0
    18e0: e50b3008  str r3, [fp, #-8]
    18e4: ea00000a  b 1914 <ValidateParition+0x84>
      fsbl_printf(DEBUG_INFO, "0x%0x ",Checksum[Index]);
    18e8: e24b201c  sub r2, fp, #28
    18ec: e51b3008  ldr r3, [fp, #-8]
    18f0: e0823003  add r3, r2, r3
    18f4: e5d33000  ldrb  r3, [r3]
    18f8: e3070bf0  movw  r0, #31728  ; 0x7bf0
    18fc: e3400001  movt  r0, #1
    1900: e1a01003  mov r1, r3
    1904: eb0012bd  bl  6400 <xil_printf>
            return XST_FAILURE;
    }

    fsbl_printf(DEBUG_INFO, "Actual checksum\r\n");

    for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    1908: e51b3008  ldr r3, [fp, #-8]
    190c: e2833001  add r3, r3, #1
    1910: e50b3008  str r3, [fp, #-8]
    1914: e51b3008  ldr r3, [fp, #-8]
    1918: e353000f  cmp r3, #15
    191c: 9afffff1  bls 18e8 <ValidateParition+0x58>
      fsbl_printf(DEBUG_INFO, "0x%0x ",Checksum[Index]);
    }

    fsbl_printf(DEBUG_INFO, "\r\n");
    1920: e3070bf8  movw  r0, #31736  ; 0x7bf8
    1924: e3400001  movt  r0, #1
    1928: eb0012b4  bl  6400 <xil_printf>

    /*
     * Calculate checksum for the partition
     */
    Status = CalcPartitionChecksum(StartAddr, Length, &CalcChecksum[0]);
    192c: e24b302c  sub r3, fp, #44 ; 0x2c
    1930: e51b0030  ldr r0, [fp, #-48]  ; 0xffffffd0
    1934: e51b1034  ldr r1, [fp, #-52]  ; 0xffffffcc
    1938: e1a02003  mov r2, r3
    193c: eb000059  bl  1aa8 <CalcPartitionChecksum>
    1940: e50b000c  str r0, [fp, #-12]
  if(Status != XST_SUCCESS) {
    1944: e51b300c  ldr r3, [fp, #-12]
    1948: e3530000  cmp r3, #0
    194c: 0a000001  beq 1958 <ValidateParition+0xc8>
        return XST_FAILURE;
    1950: e3a03001  mov r3, #1
    1954: ea000039  b 1a40 <ValidateParition+0x1b0>
    }

    fsbl_printf(DEBUG_INFO, "Calculated checksum\r\n");
    1958: e3070bfc  movw  r0, #31740  ; 0x7bfc
    195c: e3400001  movt  r0, #1
    1960: eb0012a6  bl  6400 <xil_printf>

    for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    1964: e3a03000  mov r3, #0
    1968: e50b3008  str r3, [fp, #-8]
    196c: ea00000a  b 199c <ValidateParition+0x10c>
          fsbl_printf(DEBUG_INFO, "0x%0x ",CalcChecksum[Index]);
    1970: e24b202c  sub r2, fp, #44 ; 0x2c
    1974: e51b3008  ldr r3, [fp, #-8]
    1978: e0823003  add r3, r2, r3
    197c: e5d33000  ldrb  r3, [r3]
    1980: e3070bf0  movw  r0, #31728  ; 0x7bf0
    1984: e3400001  movt  r0, #1
    1988: e1a01003  mov r1, r3
    198c: eb00129b  bl  6400 <xil_printf>
        return XST_FAILURE;
    }

    fsbl_printf(DEBUG_INFO, "Calculated checksum\r\n");

    for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    1990: e51b3008  ldr r3, [fp, #-8]
    1994: e2833001  add r3, r3, #1
    1998: e50b3008  str r3, [fp, #-8]
    199c: e51b3008  ldr r3, [fp, #-8]
    19a0: e353000f  cmp r3, #15
    19a4: 9afffff1  bls 1970 <ValidateParition+0xe0>
          fsbl_printf(DEBUG_INFO, "0x%0x ",CalcChecksum[Index]);
    }

    fsbl_printf(DEBUG_INFO, "\r\n");
    19a8: e3070bf8  movw  r0, #31736  ; 0x7bf8
    19ac: e3400001  movt  r0, #1
    19b0: eb001292  bl  6400 <xil_printf>

    /*
     * Compare actual checksum with the calculated checksum
     */
  for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    19b4: e3a03000  mov r3, #0
    19b8: e50b3008  str r3, [fp, #-8]
    19bc: ea00001b  b 1a30 <ValidateParition+0x1a0>
        if(Checksum[Index] != CalcChecksum[Index]) {
    19c0: e24b201c  sub r2, fp, #28
    19c4: e51b3008  ldr r3, [fp, #-8]
    19c8: e0823003  add r3, r2, r3
    19cc: e5d32000  ldrb  r2, [r3]
    19d0: e24b102c  sub r1, fp, #44 ; 0x2c
    19d4: e51b3008  ldr r3, [fp, #-8]
    19d8: e0813003  add r3, r1, r3
    19dc: e5d33000  ldrb  r3, [r3]
    19e0: e1520003  cmp r2, r3
    19e4: 0a00000e  beq 1a24 <ValidateParition+0x194>
            fsbl_printf(DEBUG_GENERAL, "Error: "
    19e8: e24b201c  sub r2, fp, #28
    19ec: e51b3008  ldr r3, [fp, #-8]
    19f0: e0823003  add r3, r2, r3
    19f4: e5d33000  ldrb  r3, [r3]
    19f8: e1a01003  mov r1, r3
    19fc: e24b202c  sub r2, fp, #44 ; 0x2c
    1a00: e51b3008  ldr r3, [fp, #-8]
    1a04: e0823003  add r3, r2, r3
    1a08: e5d33000  ldrb  r3, [r3]
    1a0c: e3070c14  movw  r0, #31764  ; 0x7c14
    1a10: e3400001  movt  r0, #1
    1a14: e1a02003  mov r2, r3
    1a18: eb001278  bl  6400 <xil_printf>
                "Partition DataChecksum 0x%0x!= 0x%0x\r\n",
      Checksum[Index], CalcChecksum[Index]);
        return XST_FAILURE;
    1a1c: e3a03001  mov r3, #1
    1a20: ea000006  b 1a40 <ValidateParition+0x1b0>
    fsbl_printf(DEBUG_INFO, "\r\n");

    /*
     * Compare actual checksum with the calculated checksum
     */
  for (Index = 0; Index < MD5_CHECKSUM_SIZE; Index++) {
    1a24: e51b3008  ldr r3, [fp, #-8]
    1a28: e2833001  add r3, r3, #1
    1a2c: e50b3008  str r3, [fp, #-8]
    1a30: e51b3008  ldr r3, [fp, #-8]
    1a34: e353000f  cmp r3, #15
    1a38: 9affffe0  bls 19c0 <ValidateParition+0x130>
      Checksum[Index], CalcChecksum[Index]);
        return XST_FAILURE;
        }
    }

    return XST_SUCCESS;
    1a3c: e3a03000  mov r3, #0
}
    1a40: e1a00003  mov r0, r3
    1a44: e24bd004  sub sp, fp, #4
    1a48: e8bd8800  pop {fp, pc}

00001a4c <GetPartitionChecksum>:
*
* @note   None
*
*******************************************************************************/
u32 GetPartitionChecksum(u32 ChecksumOffset, u8 *Checksum)
{
    1a4c: e92d4800  push  {fp, lr}
    1a50: e28db004  add fp, sp, #4
    1a54: e24dd010  sub sp, sp, #16
    1a58: e50b0010  str r0, [fp, #-16]
    1a5c: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    u32 Status;

    Status = MoveImage(ChecksumOffset, (u32)Checksum, MD5_CHECKSUM_SIZE);
    1a60: e30136ec  movw  r3, #5868 ; 0x16ec
    1a64: e3403002  movt  r3, #2
    1a68: e5933000  ldr r3, [r3]
    1a6c: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    1a70: e51b0010  ldr r0, [fp, #-16]
    1a74: e1a01002  mov r1, r2
    1a78: e3a02010  mov r2, #16
    1a7c: e12fff33  blx r3
    1a80: e50b0008  str r0, [fp, #-8]
    if(Status != XST_SUCCESS) {
    1a84: e51b3008  ldr r3, [fp, #-8]
    1a88: e3530000  cmp r3, #0
    1a8c: 0a000001  beq 1a98 <GetPartitionChecksum+0x4c>
        return XST_FAILURE;
    1a90: e3a03001  mov r3, #1
    1a94: ea000000  b 1a9c <GetPartitionChecksum+0x50>
    }

    return XST_SUCCESS;
    1a98: e3a03000  mov r3, #0
}
    1a9c: e1a00003  mov r0, r3
    1aa0: e24bd004  sub sp, fp, #4
    1aa4: e8bd8800  pop {fp, pc}

00001aa8 <CalcPartitionChecksum>:
*
* @note   None
*
*******************************************************************************/
u32 CalcPartitionChecksum(u32 SourceAddr, u32 DataLength, u8 *Checksum)
{
    1aa8: e92d4800  push  {fp, lr}
    1aac: e28db004  add fp, sp, #4
    1ab0: e24dd010  sub sp, sp, #16
    1ab4: e50b0008  str r0, [fp, #-8]
    1ab8: e50b100c  str r1, [fp, #-12]
    1abc: e50b2010  str r2, [fp, #-16]
  /*
   * Calculate checksum using MD5 algorithm
   */
  md5((u8*)SourceAddr, DataLength, Checksum, 0 );
    1ac0: e51b3008  ldr r3, [fp, #-8]
    1ac4: e1a00003  mov r0, r3
    1ac8: e51b100c  ldr r1, [fp, #-12]
    1acc: e51b2010  ldr r2, [fp, #-16]
    1ad0: e3a03000  mov r3, #0
    1ad4: eb0006df  bl  3658 <md5>

    return XST_SUCCESS;
    1ad8: e3a03000  mov r3, #0
}
    1adc: e1a00003  mov r0, r3
    1ae0: e24bd004  sub sp, fp, #4
    1ae4: e8bd8800  pop {fp, pc}

00001ae8 <main>:
****************************************************************************/

#define FSBL_PERF

int main(void)
{
    1ae8: e92d4800  push  {fp, lr}
    1aec: e28db004  add fp, sp, #4
    1af0: e24dd028  sub sp, sp, #40 ; 0x28

  u32 BootModeRegister = 0;
    1af4: e3a03000  mov r3, #0
    1af8: e50b3008  str r3, [fp, #-8]
  u32 HandoffAddress = 0;
    1afc: e3a03000  mov r3, #0
    1b00: e50b300c  str r3, [fp, #-12]
  u32 Status = XST_SUCCESS;
    1b04: e3a03000  mov r3, #0
    1b08: e50b3010  str r3, [fp, #-16]

  /*
   * PCW initialization for MIO,PLL,CLK and DDR
   */
  Status = ps7_init();
    1b0c: eb000b2f  bl  47d0 <ps7_init>
    1b10: e1a03000  mov r3, r0
    1b14: e50b3010  str r3, [fp, #-16]
  if (Status != FSBL_PS7_INIT_SUCCESS) {
    1b18: e51b3010  ldr r3, [fp, #-16]
    1b1c: e3530000  cmp r3, #0
    1b20: 0a00000a  beq 1b50 <main+0x68>
    fsbl_printf(DEBUG_GENERAL,"PS7_INIT_FAIL : %s\r\n",
    1b24: e51b0010  ldr r0, [fp, #-16]
    1b28: eb0009b8  bl  4210 <getPS7MessageInfo>
    1b2c: e1a03000  mov r3, r0
    1b30: e3070c44  movw  r0, #31812  ; 0x7c44
    1b34: e3400001  movt  r0, #1
    1b38: e1a01003  mov r1, r3
    1b3c: eb00122f  bl  6400 <xil_printf>
            getPS7MessageInfo(Status));
    OutputStatus(PS7_INIT_FAIL);
    1b40: e30a0012  movw  r0, #40978  ; 0xa012
    1b44: eb00003c  bl  1c3c <OutputStatus>
    /*
     * Calling FsblHookFallback instead of Fallback
     * since, devcfg driver is not yet initialized
     */
    FsblHookFallback();
    1b48: ebfffaab  bl  5fc <FsblHookFallback>
    1b4c: ea000006  b 1b6c <main+0x84>
  } else {

    fsbl_printf(DEBUG_GENERAL,"PS7_INIT_SUCCESS : %s\r\n",
    1b50: e51b0010  ldr r0, [fp, #-16]
    1b54: eb0009ad  bl  4210 <getPS7MessageInfo>
    1b58: e1a03000  mov r3, r0
    1b5c: e3070c5c  movw  r0, #31836  ; 0x7c5c
    1b60: e3400001  movt  r0, #1
    1b64: e1a01003  mov r1, r3
    1b68: eb001224  bl  6400 <xil_printf>
  }

  /*
   * Unlock SLCR for SLCR register write
   */
  SlcrUnlock();
    1b6c: e3a00008  mov r0, #8
    1b70: e34f0800  movt  r0, #63488  ; 0xf800
    1b74: e30d1f0d  movw  r1, #57101  ; 0xdf0d
    1b78: e34d1f0d  movt  r1, #57101  ; 0xdf0d
    1b7c: eb00118b  bl  61b0 <Xil_Out32>
   * time taken for mio, clock and ddr initialisation
   * done in the ps7_init function is not accounted in the FSBL
   *
   */
#ifdef FSBL_PERF
  XTime tCur = 0;
    1b80: f2c00010  vmov.i32  d16, #0 ; 0x00000000
    1b84: ed4b0b09  vstr  d16, [fp, #-36] ; 0xffffffdc
  FsblGetGlobalTime(&tCur);
    1b88: e24b3024  sub r3, fp, #36 ; 0x24
    1b8c: e1a00003  mov r0, r3
    1b90: eb00012d  bl  204c <FsblGetGlobalTime>
#endif

  /*
   * Flush the Caches
   */
  Xil_DCacheFlush();
    1b94: eb0010a8  bl  5e3c <Xil_DCacheFlush>

  /*
   * Disable Data Cache
   */
  Xil_DCacheDisable();
    1b98: eb0010bf  bl  5e9c <Xil_DCacheDisable>

  /*
   * Register the Exception handlers
   */
  RegisterHandlers();
    1b9c: eb0000a0  bl  1e24 <RegisterHandlers>
  
  /*
   * Print the FSBL Banner
   */
  fsbl_printf(DEBUG_GENERAL,"\n\rXilinx First Stage Boot Loader \n\r");
    1ba0: e3070c74  movw  r0, #31860  ; 0x7c74
    1ba4: e3400001  movt  r0, #1
    1ba8: eb001214  bl  6400 <xil_printf>
  fsbl_printf(DEBUG_GENERAL,"Release %d.%d  %s-%s\r\n",
    1bac: e3073cbc  movw  r3, #31932  ; 0x7cbc
    1bb0: e3403001  movt  r3, #1
    1bb4: e58d3000  str r3, [sp]
    1bb8: e3070c98  movw  r0, #31896  ; 0x7c98
    1bbc: e3400001  movt  r0, #1
    1bc0: e30017df  movw  r1, #2015 ; 0x7df
    1bc4: e3a02002  mov r2, #2
    1bc8: e3073cb0  movw  r3, #31920  ; 0x7cb0
    1bcc: e3403001  movt  r3, #1
    1bd0: eb00120a  bl  6400 <xil_printf>

  /*
   * For Performance measurement
   */
#ifdef FSBL_PERF
  XTime tEnd = 0;
    1bd4: f2c00010  vmov.i32  d16, #0 ; 0x00000000
    1bd8: ed4b0b07  vstr  d16, [fp, #-28] ; 0xffffffe4
  fsbl_printf(DEBUG_GENERAL,"Total Execution time is ");
    1bdc: e3070cc8  movw  r0, #31944  ; 0x7cc8
    1be0: e3400001  movt  r0, #1
    1be4: eb001205  bl  6400 <xil_printf>
  FsblMeasurePerfTime(tCur,tEnd);
    1be8: e14b22d4  ldrd  r2, [fp, #-36]  ; 0xffffffdc
    1bec: e1a00002  mov r0, r2
    1bf0: e1a01003  mov r1, r3
    1bf4: e14b21dc  ldrd  r2, [fp, #-28]  ; 0xffffffe4
    1bf8: eb00011b  bl  206c <FsblMeasurePerfTime>
//#else
//  OutputStatus(NO_DDR);
//  FsblFallback();
//#endif

  return Status;
    1bfc: e51b3010  ldr r3, [fp, #-16]
}
    1c00: e1a00003  mov r0, r3
    1c04: e24bd004  sub sp, fp, #4
    1c08: e8bd8800  pop {fp, pc}

00001c0c <FsblFallback>:
*
* @note   None
*
****************************************************************************/
void FsblFallback(void)
{
    1c0c: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    1c10: e28db000  add fp, sp, #0
//
//  /*
//   * Reset PS, so Boot ROM will restart
//   */
//  Xil_Out32(PS_RST_CTRL_REG, PS_RST_MASK);
}
    1c14: e24bd000  sub sp, fp, #0
    1c18: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    1c1c: e12fff1e  bx  lr

00001c20 <FsblHandoff>:
*
* @note   This function does not return.
*
****************************************************************************/
void FsblHandoff(u32 FsblStartAddr)
{
    1c20: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    1c24: e28db000  add fp, sp, #0
    1c28: e24dd00c  sub sp, sp, #12
    1c2c: e50b0008  str r0, [fp, #-8]
//  }
//
//  OutputStatus(ILLEGAL_RETURN);
//
//  FsblFallback();
}
    1c30: e24bd000  sub sp, fp, #0
    1c34: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    1c38: e12fff1e  bx  lr

00001c3c <OutputStatus>:
*
* @note   None.
*
****************************************************************************/
void OutputStatus(u32 State)
{
    1c3c: e92d4800  push  {fp, lr}
    1c40: e28db004  add fp, sp, #4
    1c44: e24dd010  sub sp, sp, #16
    1c48: e50b0010  str r0, [fp, #-16]
#ifdef STDOUT_BASEADDRESS
  u32 UartReg = 0;
    1c4c: e3a03000  mov r3, #0
    1c50: e50b3008  str r3, [fp, #-8]

  fsbl_printf(DEBUG_GENERAL,"FSBL Status = 0x%.4x\r\n", State);
    1c54: e3070ce4  movw  r0, #31972  ; 0x7ce4
    1c58: e3400001  movt  r0, #1
    1c5c: e51b1010  ldr r1, [fp, #-16]
    1c60: eb0011e6  bl  6400 <xil_printf>
  /*
   * The TX buffer needs to be flushed out
   * If this is not done some of the prints will not appear on the
   * serial output
   */
  UartReg = Xil_In32(STDOUT_BASEADDRESS + XUARTPS_SR_OFFSET);
    1c64: e301002c  movw  r0, #4140 ; 0x102c
    1c68: e34e0000  movt  r0, #57344  ; 0xe000
    1c6c: eb001149  bl  6198 <Xil_In32>
    1c70: e50b0008  str r0, [fp, #-8]
  while ((UartReg & XUARTPS_SR_TXEMPTY) != XUARTPS_SR_TXEMPTY) {
    1c74: ea000003  b 1c88 <OutputStatus+0x4c>
    UartReg = Xil_In32(STDOUT_BASEADDRESS + XUARTPS_SR_OFFSET);
    1c78: e301002c  movw  r0, #4140 ; 0x102c
    1c7c: e34e0000  movt  r0, #57344  ; 0xe000
    1c80: eb001144  bl  6198 <Xil_In32>
    1c84: e50b0008  str r0, [fp, #-8]
   * The TX buffer needs to be flushed out
   * If this is not done some of the prints will not appear on the
   * serial output
   */
  UartReg = Xil_In32(STDOUT_BASEADDRESS + XUARTPS_SR_OFFSET);
  while ((UartReg & XUARTPS_SR_TXEMPTY) != XUARTPS_SR_TXEMPTY) {
    1c88: e51b3008  ldr r3, [fp, #-8]
    1c8c: e2033008  and r3, r3, #8
    1c90: e3530000  cmp r3, #0
    1c94: 0afffff7  beq 1c78 <OutputStatus+0x3c>
    UartReg = Xil_In32(STDOUT_BASEADDRESS + XUARTPS_SR_OFFSET);
  }
#endif
}
    1c98: e24bd004  sub sp, fp, #4
    1c9c: e8bd8800  pop {fp, pc}

00001ca0 <ErrorLockdown>:
*
* @note   This function does not return, the PS block is reset
*
****************************************************************************/
void ErrorLockdown(u32 State) 
{
    1ca0: e92d4800  push  {fp, lr}
    1ca4: e28db004  add fp, sp, #4
    1ca8: e24dd008  sub sp, sp, #8
    1cac: e50b0008  str r0, [fp, #-8]
  /*
   * Store the error status
   */
  OutputStatus(State);
    1cb0: e51b0008  ldr r0, [fp, #-8]
    1cb4: ebffffe0  bl  1c3c <OutputStatus>

  /*
   * Fall back
   */
  FsblFallback();
    1cb8: ebffffd3  bl  1c0c <FsblFallback>
}
    1cbc: e24bd004  sub sp, fp, #4
    1cc0: e8bd8800  pop {fp, pc}

00001cc4 <memcpy_rom>:
*
* @return Starting address for destination
*
****************************************************************************/
void *(memcpy_rom)(void * s1, const void * s2, u32 n)
{
    1cc4: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    1cc8: e28db000  add fp, sp, #0
    1ccc: e24dd01c  sub sp, sp, #28
    1cd0: e50b0010  str r0, [fp, #-16]
    1cd4: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    1cd8: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
  char *dst = (char *)s1;
    1cdc: e51b3010  ldr r3, [fp, #-16]
    1ce0: e50b3008  str r3, [fp, #-8]
  const char *src = (char *)s2;
    1ce4: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    1ce8: e50b300c  str r3, [fp, #-12]

  /*
   * Loop and copy
   */
  while (n-- != 0)
    1cec: ea000007  b 1d10 <memcpy_rom+0x4c>
    *dst++ = *src++;
    1cf0: e51b3008  ldr r3, [fp, #-8]
    1cf4: e2832001  add r2, r3, #1
    1cf8: e50b2008  str r2, [fp, #-8]
    1cfc: e51b200c  ldr r2, [fp, #-12]
    1d00: e2821001  add r1, r2, #1
    1d04: e50b100c  str r1, [fp, #-12]
    1d08: e5d22000  ldrb  r2, [r2]
    1d0c: e5c32000  strb  r2, [r3]
  const char *src = (char *)s2;

  /*
   * Loop and copy
   */
  while (n-- != 0)
    1d10: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    1d14: e2432001  sub r2, r3, #1
    1d18: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
    1d1c: e3530000  cmp r3, #0
    1d20: 1afffff2  bne 1cf0 <memcpy_rom+0x2c>
    *dst++ = *src++;
  return s1;
    1d24: e51b3010  ldr r3, [fp, #-16]
}
    1d28: e1a00003  mov r0, r3
    1d2c: e24bd000  sub sp, fp, #0
    1d30: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    1d34: e12fff1e  bx  lr

00001d38 <strcpy_rom>:
*
* @return Starting address for the destination string
*
****************************************************************************/
char *strcpy_rom(char *Dest, const char *Src)
{
    1d38: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    1d3c: e28db000  add fp, sp, #0
    1d40: e24dd014  sub sp, sp, #20
    1d44: e50b0010  str r0, [fp, #-16]
    1d48: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  unsigned i;
  for (i=0; Src[i] != '\0'; ++i)
    1d4c: e3a03000  mov r3, #0
    1d50: e50b3008  str r3, [fp, #-8]
    1d54: ea00000a  b 1d84 <strcpy_rom+0x4c>
    Dest[i] = Src[i];
    1d58: e51b2010  ldr r2, [fp, #-16]
    1d5c: e51b3008  ldr r3, [fp, #-8]
    1d60: e0823003  add r3, r2, r3
    1d64: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    1d68: e51b2008  ldr r2, [fp, #-8]
    1d6c: e0812002  add r2, r1, r2
    1d70: e5d22000  ldrb  r2, [r2]
    1d74: e5c32000  strb  r2, [r3]
*
****************************************************************************/
char *strcpy_rom(char *Dest, const char *Src)
{
  unsigned i;
  for (i=0; Src[i] != '\0'; ++i)
    1d78: e51b3008  ldr r3, [fp, #-8]
    1d7c: e2833001  add r3, r3, #1
    1d80: e50b3008  str r3, [fp, #-8]
    1d84: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    1d88: e51b3008  ldr r3, [fp, #-8]
    1d8c: e0823003  add r3, r2, r3
    1d90: e5d33000  ldrb  r3, [r3]
    1d94: e3530000  cmp r3, #0
    1d98: 1affffee  bne 1d58 <strcpy_rom+0x20>
    Dest[i] = Src[i];
  Dest[i] = '\0';
    1d9c: e51b2010  ldr r2, [fp, #-16]
    1da0: e51b3008  ldr r3, [fp, #-8]
    1da4: e0823003  add r3, r2, r3
    1da8: e3a02000  mov r2, #0
    1dac: e5c32000  strb  r2, [r3]
  return Dest;
    1db0: e51b3010  ldr r3, [fp, #-16]
}
    1db4: e1a00003  mov r0, r3
    1db8: e24bd000  sub sp, fp, #0
    1dbc: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    1dc0: e12fff1e  bx  lr

00001dc4 <MarkFSBLIn>:
*
* @note   None.
*
****************************************************************************/
void MarkFSBLIn(void)
{
    1dc4: e92d4800  push  {fp, lr}
    1dc8: e28db004  add fp, sp, #4
  Xil_Out32(REBOOT_STATUS_REG,
    Xil_In32(REBOOT_STATUS_REG) | FSBL_IN_MASK);
    1dcc: e3a00f96  mov r0, #600  ; 0x258
    1dd0: e34f0800  movt  r0, #63488  ; 0xf800
    1dd4: eb0010ef  bl  6198 <Xil_In32>
    1dd8: e1a03000  mov r3, r0
* @note   None.
*
****************************************************************************/
void MarkFSBLIn(void)
{
  Xil_Out32(REBOOT_STATUS_REG,
    1ddc: e3833206  orr r3, r3, #1610612736 ; 0x60000000
    1de0: e3a00f96  mov r0, #600  ; 0x258
    1de4: e34f0800  movt  r0, #63488  ; 0xf800
    1de8: e1a01003  mov r1, r3
    1dec: eb0010ef  bl  61b0 <Xil_Out32>
    Xil_In32(REBOOT_STATUS_REG) | FSBL_IN_MASK);
}
    1df0: e8bd8800  pop {fp, pc}

00001df4 <ClearFSBLIn>:
*
* @note   None.
*
****************************************************************************/
void ClearFSBLIn(void) 
{
    1df4: e92d4800  push  {fp, lr}
    1df8: e28db004  add fp, sp, #4
  Xil_Out32(REBOOT_STATUS_REG,
    (Xil_In32(REBOOT_STATUS_REG)) & ~(FSBL_FAIL_MASK));
    1dfc: e3a00f96  mov r0, #600  ; 0x258
    1e00: e34f0800  movt  r0, #63488  ; 0xf800
    1e04: eb0010e3  bl  6198 <Xil_In32>
    1e08: e1a03000  mov r3, r0
* @note   None.
*
****************************************************************************/
void ClearFSBLIn(void) 
{
  Xil_Out32(REBOOT_STATUS_REG,
    1e0c: e3c3320f  bic r3, r3, #-268435456 ; 0xf0000000
    1e10: e3a00f96  mov r0, #600  ; 0x258
    1e14: e34f0800  movt  r0, #63488  ; 0xf800
    1e18: e1a01003  mov r1, r3
    1e1c: eb0010e3  bl  61b0 <Xil_Out32>
    (Xil_In32(REBOOT_STATUS_REG)) & ~(FSBL_FAIL_MASK));
}
    1e20: e8bd8800  pop {fp, pc}

00001e24 <RegisterHandlers>:
*
* @note   None.
*
****************************************************************************/
static void RegisterHandlers(void) 
{
    1e24: e92d4800  push  {fp, lr}
    1e28: e28db004  add fp, sp, #4
    1e2c: e24dd008  sub sp, sp, #8
  Xil_ExceptionInit();
    1e30: eb0010c4  bl  6148 <Xil_ExceptionInit>

   /*
   * Initialize the vector table. Register the stub Handler for each
   * exception.
   */
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_UNDEFINED_INT,
    1e34: e3a00001  mov r0, #1
    1e38: e3011ec8  movw  r1, #7880 ; 0x1ec8
    1e3c: e3401000  movt  r1, #0
    1e40: e3a02000  mov r2, #0
    1e44: eb0010c0  bl  614c <Xil_ExceptionRegisterHandler>
          (Xil_ExceptionHandler)Undef_Handler,
          (void *) 0);
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_SWI_INT,
    1e48: e3a00002  mov r0, #2
    1e4c: e3011ee8  movw  r1, #7912 ; 0x1ee8
    1e50: e3401000  movt  r1, #0
    1e54: e3a02000  mov r2, #0
    1e58: eb0010bb  bl  614c <Xil_ExceptionRegisterHandler>
          (Xil_ExceptionHandler)SVC_Handler,
          (void *) 0);
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_PREFETCH_ABORT_INT,
    1e5c: e3a00003  mov r0, #3
    1e60: e3011f08  movw  r1, #7944 ; 0x1f08
    1e64: e3401000  movt  r1, #0
    1e68: e3a02000  mov r2, #0
    1e6c: eb0010b6  bl  614c <Xil_ExceptionRegisterHandler>
        (Xil_ExceptionHandler)PreFetch_Abort_Handler,
        (void *) 0);
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_DATA_ABORT_INT,
    1e70: e3a00004  mov r0, #4
    1e74: e3011f28  movw  r1, #7976 ; 0x1f28
    1e78: e3401000  movt  r1, #0
    1e7c: e3a02000  mov r2, #0
    1e80: eb0010b1  bl  614c <Xil_ExceptionRegisterHandler>
        (Xil_ExceptionHandler)Data_Abort_Handler,
        (void *) 0);
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_IRQ_INT,
    1e84: e3a00005  mov r0, #5
    1e88: e3011f48  movw  r1, #8008 ; 0x1f48
    1e8c: e3401000  movt  r1, #0
    1e90: e3a02000  mov r2, #0
    1e94: eb0010ac  bl  614c <Xil_ExceptionRegisterHandler>
        (Xil_ExceptionHandler)IRQ_Handler,(void *) 0);
  Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_FIQ_INT,
    1e98: e3a00006  mov r0, #6
    1e9c: e3011f68  movw  r1, #8040 ; 0x1f68
    1ea0: e3401000  movt  r1, #0
    1ea4: e3a02000  mov r2, #0
    1ea8: eb0010a7  bl  614c <Xil_ExceptionRegisterHandler>
      (Xil_ExceptionHandler)FIQ_Handler,(void *) 0);

  Xil_ExceptionEnable();
    1eac: e10f3000  mrs r3, CPSR
    1eb0: e50b3008  str r3, [fp, #-8]
    1eb4: e51b3008  ldr r3, [fp, #-8]
    1eb8: e3c33080  bic r3, r3, #128  ; 0x80
    1ebc: e129f003  msr CPSR_fc, r3

}
    1ec0: e24bd004  sub sp, fp, #4
    1ec4: e8bd8800  pop {fp, pc}

00001ec8 <Undef_Handler>:

static void Undef_Handler (void)
{
    1ec8: e92d4800  push  {fp, lr}
    1ecc: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"UNDEFINED_HANDLER\r\n");
    1ed0: e3070cfc  movw  r0, #31996  ; 0x7cfc
    1ed4: e3400001  movt  r0, #1
    1ed8: eb001148  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_UNDEFINED_INT);
    1edc: e30a0301  movw  r0, #41729  ; 0xa301
    1ee0: ebffff6e  bl  1ca0 <ErrorLockdown>
}
    1ee4: e8bd8800  pop {fp, pc}

00001ee8 <SVC_Handler>:

static void SVC_Handler (void)
{
    1ee8: e92d4800  push  {fp, lr}
    1eec: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"SVC_HANDLER \r\n");
    1ef0: e3070d10  movw  r0, #32016  ; 0x7d10
    1ef4: e3400001  movt  r0, #1
    1ef8: eb001140  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_SWI_INT);
    1efc: e30a0302  movw  r0, #41730  ; 0xa302
    1f00: ebffff66  bl  1ca0 <ErrorLockdown>
}
    1f04: e8bd8800  pop {fp, pc}

00001f08 <PreFetch_Abort_Handler>:

static void PreFetch_Abort_Handler (void)
{
    1f08: e92d4800  push  {fp, lr}
    1f0c: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"PREFETCH_ABORT_HANDLER \r\n");
    1f10: e3070d20  movw  r0, #32032  ; 0x7d20
    1f14: e3400001  movt  r0, #1
    1f18: eb001138  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_PREFETCH_ABORT_INT);
    1f1c: e30a0303  movw  r0, #41731  ; 0xa303
    1f20: ebffff5e  bl  1ca0 <ErrorLockdown>
}
    1f24: e8bd8800  pop {fp, pc}

00001f28 <Data_Abort_Handler>:

static void Data_Abort_Handler (void)
{
    1f28: e92d4800  push  {fp, lr}
    1f2c: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"DATA_ABORT_HANDLER \r\n");
    1f30: e3070d3c  movw  r0, #32060  ; 0x7d3c
    1f34: e3400001  movt  r0, #1
    1f38: eb001130  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_DATA_ABORT_INT);
    1f3c: e30a0304  movw  r0, #41732  ; 0xa304
    1f40: ebffff56  bl  1ca0 <ErrorLockdown>
}
    1f44: e8bd8800  pop {fp, pc}

00001f48 <IRQ_Handler>:

static void IRQ_Handler (void)
{
    1f48: e92d4800  push  {fp, lr}
    1f4c: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"IRQ_HANDLER \r\n");
    1f50: e3070d54  movw  r0, #32084  ; 0x7d54
    1f54: e3400001  movt  r0, #1
    1f58: eb001128  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_IRQ_INT);
    1f5c: e30a0305  movw  r0, #41733  ; 0xa305
    1f60: ebffff4e  bl  1ca0 <ErrorLockdown>
}
    1f64: e8bd8800  pop {fp, pc}

00001f68 <FIQ_Handler>:

static void FIQ_Handler (void)
{
    1f68: e92d4800  push  {fp, lr}
    1f6c: e28db004  add fp, sp, #4
  fsbl_printf(DEBUG_GENERAL,"FIQ_HANDLER \r\n");
    1f70: e3070d64  movw  r0, #32100  ; 0x7d64
    1f74: e3400001  movt  r0, #1
    1f78: eb001120  bl  6400 <xil_printf>
  ErrorLockdown (EXCEPTION_ID_FIQ_INT);
    1f7c: e30a0306  movw  r0, #41734  ; 0xa306
    1f80: ebffff46  bl  1ca0 <ErrorLockdown>
}
    1f84: e8bd8800  pop {fp, pc}

00001f88 <Update_MultiBootRegister>:
* @return
* return  none
*
****************************************************************************/
static void Update_MultiBootRegister(void)
{
    1f88: e92d4800  push  {fp, lr}
    1f8c: e28db004  add fp, sp, #4
    1f90: e24dd008  sub sp, sp, #8
  u32 MultiBootReg = 0;
    1f94: e3a03000  mov r3, #0
    1f98: e50b3008  str r3, [fp, #-8]

  if (Silicon_Version != SILICON_VERSION_1) {
    1f9c: e3013a80  movw  r3, #6784 ; 0x1a80
    1fa0: e3403002  movt  r3, #2
    1fa4: e5933000  ldr r3, [r3]
    1fa8: e3530000  cmp r3, #0
    1fac: 0a000016  beq 200c <_HEAP_SIZE+0xc>
    /*
     * Read the mulitboot register
     */
    MultiBootReg =  XDcfg_ReadReg(DcfgInstPtr->Config.BaseAddr,
    1fb0: e3013a8c  movw  r3, #6796 ; 0x1a8c
    1fb4: e3403002  movt  r3, #2
    1fb8: e5933000  ldr r3, [r3]
    1fbc: e5933004  ldr r3, [r3, #4]
    1fc0: e283302c  add r3, r3, #44 ; 0x2c
    1fc4: e1a00003  mov r0, r3
    1fc8: eb001072  bl  6198 <Xil_In32>
    1fcc: e50b0008  str r0, [fp, #-8]
          XDCFG_MULTIBOOT_ADDR_OFFSET);

    /*
     * Incrementing multiboot register by one
     */
    MultiBootReg++;
    1fd0: e51b3008  ldr r3, [fp, #-8]
    1fd4: e2833001  add r3, r3, #1
    1fd8: e50b3008  str r3, [fp, #-8]

    XDcfg_WriteReg(DcfgInstPtr->Config.BaseAddr,
    1fdc: e3013a8c  movw  r3, #6796 ; 0x1a8c
    1fe0: e3403002  movt  r3, #2
    1fe4: e5933000  ldr r3, [r3]
    1fe8: e5933004  ldr r3, [r3, #4]
    1fec: e283302c  add r3, r3, #44 ; 0x2c
    1ff0: e1a00003  mov r0, r3
    1ff4: e51b1008  ldr r1, [fp, #-8]
    1ff8: eb00106c  bl  61b0 <Xil_Out32>
        XDCFG_MULTIBOOT_ADDR_OFFSET,
        MultiBootReg);

    fsbl_printf(DEBUG_INFO,"Updated MultiBootReg = 0x%08x\r\n",
    1ffc: e3070d74  movw  r0, #32116  ; 0x7d74
    2000: e3400001  movt  r0, #1
    2004: e51b1008  ldr r1, [fp, #-8]
    2008: eb0010fc  bl  6400 <xil_printf>
        MultiBootReg);
  }
}
    200c: e24bd004  sub sp, fp, #4
    2010: e8bd8800  pop {fp, pc}

00002014 <GetResetReason>:
* @note   None
*
*******************************************************************************/

u32 GetResetReason(void)
{
    2014: e92d4800  push  {fp, lr}
    2018: e28db004  add fp, sp, #4
    201c: e24dd008  sub sp, sp, #8
  u32 Regval;

  /* We are using REBOOT_STATUS_REG, we have to use bits 23:16 */
  /* for storing the RESET_REASON register value*/
  Regval = ((Xil_In32(REBOOT_STATUS_REG) >> 16) & 0xFF);
    2020: e3a00f96  mov r0, #600  ; 0x258
    2024: e34f0800  movt  r0, #63488  ; 0xf800
    2028: eb00105a  bl  6198 <Xil_In32>
    202c: e1a03000  mov r3, r0
    2030: e1a03823  lsr r3, r3, #16
    2034: e6ef3073  uxtb  r3, r3
    2038: e50b3008  str r3, [fp, #-8]

  return Regval;
    203c: e51b3008  ldr r3, [fp, #-8]
}
    2040: e1a00003  mov r0, r3
    2044: e24bd004  sub sp, fp, #4
    2048: e8bd8800  pop {fp, pc}

0000204c <FsblGetGlobalTime>:
* @note   None
*
*******************************************************************************/
#ifdef FSBL_PERF
void FsblGetGlobalTime (XTime *tCur)
{
    204c: e92d4800  push  {fp, lr}
    2050: e28db004  add fp, sp, #4
    2054: e24dd008  sub sp, sp, #8
    2058: e50b0008  str r0, [fp, #-8]
  XTime_GetTime(tCur);
    205c: e51b0008  ldr r0, [fp, #-8]
    2060: eb001214  bl  68b8 <XTime_GetTime>
}
    2064: e24bd004  sub sp, fp, #4
    2068: e8bd8800  pop {fp, pc}

0000206c <FsblMeasurePerfTime>:
*
* @note   None
*
*******************************************************************************/
void FsblMeasurePerfTime (XTime tCur, XTime tEnd)
{
    206c: e92d4800  push  {fp, lr}
    2070: ed2d8b02  vpush {d8}
    2074: e28db00c  add fp, sp, #12
    2078: e24dd020  sub sp, sp, #32
    207c: e14b02f4  strd  r0, [fp, #-36]  ; 0xffffffdc
    2080: e14b22fc  strd  r2, [fp, #-44]  ; 0xffffffd4
  double tDiff = 0.0;
    2084: e3a02000  mov r2, #0
    2088: e3a03000  mov r3, #0
    208c: e14b21f4  strd  r2, [fp, #-20]  ; 0xffffffec
  double tPerfSeconds;
  XTime_GetTime(&tEnd);
    2090: e24b302c  sub r3, fp, #44 ; 0x2c
    2094: e1a00003  mov r0, r3
    2098: eb001206  bl  68b8 <XTime_GetTime>
  tDiff  = (double)tEnd - (double)tCur;
    209c: e14b22dc  ldrd  r2, [fp, #-44]  ; 0xffffffd4
    20a0: e1a00002  mov r0, r2
    20a4: e1a01003  mov r1, r3
    20a8: eb001d95  bl  9704 <__aeabi_ul2d>
    20ac: ec410b18  vmov  d8, r0, r1
    20b0: e14b02d4  ldrd  r0, [fp, #-36]  ; 0xffffffdc
    20b4: eb001d92  bl  9704 <__aeabi_ul2d>
    20b8: ec410b30  vmov  d16, r0, r1
    20bc: ee780b60  vsub.f64  d16, d8, d16
    20c0: ed4b0b05  vstr  d16, [fp, #-20] ; 0xffffffec

  /*
   * Convert tPerf into Seconds
   */
  tPerfSeconds = tDiff/COUNTS_PER_SECOND;
    20c4: ed5b0b05  vldr  d16, [fp, #-20] ; 0xffffffec
    20c8: eddf1b08  vldr  d17, [pc, #32]  ; 20f0 <FsblMeasurePerfTime+0x84>
    20cc: eec00ba1  vdiv.f64  d16, d16, d17
    20d0: ed4b0b07  vstr  d16, [fp, #-28] ; 0xffffffe4

#if defined(STDOUT_BASEADDRESS)
  printf("%f seconds \r\n",tPerfSeconds);
    20d4: e3070d94  movw  r0, #32148  ; 0x7d94
    20d8: e3400001  movt  r0, #1
    20dc: e14b21dc  ldrd  r2, [fp, #-28]  ; 0xffffffe4
    20e0: eb001f33  bl  9db4 <printf>
#endif

}
    20e4: e24bd00c  sub sp, fp, #12
    20e8: ecbd8b02  vpop  {d8}
    20ec: e8bd8800  pop {fp, pc}
    20f0: 5f000000  .word 0x5f000000
    20f4: 41b3de43  .word 0x41b3de43

000020f8 <GetSiliconVersion>:
*
* @note   None
*
*******************************************************************************/
void GetSiliconVersion(void)
{
    20f8: e92d4800  push  {fp, lr}
    20fc: e28db004  add fp, sp, #4
  /*
   * Get the silicon version
   */
  Silicon_Version = XDcfg_GetPsVersion(DcfgInstPtr);
    2100: e3013a8c  movw  r3, #6796 ; 0x1a8c
    2104: e3403002  movt  r3, #2
    2108: e5933000  ldr r3, [r3]
    210c: e5933004  ldr r3, [r3, #4]
    2110: e2833080  add r3, r3, #128  ; 0x80
    2114: e1a00003  mov r0, r3
    2118: eb00101e  bl  6198 <Xil_In32>
    211c: e1a03000  mov r3, r0
    2120: e1a02e23  lsr r2, r3, #28
    2124: e3013a80  movw  r3, #6784 ; 0x1a80
    2128: e3403002  movt  r3, #2
    212c: e5832000  str r2, [r3]
  if(Silicon_Version == SILICON_VERSION_3_1) {
    2130: e3013a80  movw  r3, #6784 ; 0x1a80
    2134: e3403002  movt  r3, #2
    2138: e5933000  ldr r3, [r3]
    213c: e3530003  cmp r3, #3
    2140: 1a000003  bne 2154 <GetSiliconVersion+0x5c>
    fsbl_printf(DEBUG_GENERAL,"Silicon Version 3.1\r\n");
    2144: e3070da4  movw  r0, #32164  ; 0x7da4
    2148: e3400001  movt  r0, #1
    214c: eb0010ab  bl  6400 <xil_printf>
    2150: ea000007  b 2174 <GetSiliconVersion+0x7c>
  } else {
    fsbl_printf(DEBUG_GENERAL,"Silicon Version %d.0\r\n",
    2154: e3013a80  movw  r3, #6784 ; 0x1a80
    2158: e3403002  movt  r3, #2
    215c: e5933000  ldr r3, [r3]
    2160: e2833001  add r3, r3, #1
    2164: e3070dbc  movw  r0, #32188  ; 0x7dbc
    2168: e3400001  movt  r0, #1
    216c: e1a01003  mov r1, r3
    2170: eb0010a2  bl  6400 <xil_printf>
        Silicon_Version + 1);
  }
}
    2174: e8bd8800  pop {fp, pc}

00002178 <HeaderChecksum>:
*   - XST_FAILURE if ID mismatches
*
* @note   None
*
*******************************************************************************/
u32 HeaderChecksum(u32 FlashOffsetAddress){
    2178: e92d4800  push  {fp, lr}
    217c: e28db004  add fp, sp, #4
    2180: e24dd018  sub sp, sp, #24
    2184: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
  u32 Checksum = 0;
    2188: e3a03000  mov r3, #0
    218c: e50b3008  str r3, [fp, #-8]
  u32 Count;
  u32 TempValue = 0;
    2190: e3a03000  mov r3, #0
    2194: e50b3010  str r3, [fp, #-16]

  for (Count = 0; Count < IMAGE_HEADER_CHECKSUM_COUNT; Count++) {
    2198: e3a03000  mov r3, #0
    219c: e50b300c  str r3, [fp, #-12]
    21a0: ea000013  b 21f4 <HeaderChecksum+0x7c>
    /*
     * Read the word from the header
     */
    MoveImage(FlashOffsetAddress + IMAGE_WIDTH_CHECK_OFFSET + (Count*4), (u32)&TempValue, 4);
    21a4: e30136ec  movw  r3, #5868 ; 0x16ec
    21a8: e3403002  movt  r3, #2
    21ac: e5933000  ldr r3, [r3]
    21b0: e51b200c  ldr r2, [fp, #-12]
    21b4: e1a01102  lsl r1, r2, #2
    21b8: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    21bc: e0812002  add r2, r1, r2
    21c0: e2821020  add r1, r2, #32
    21c4: e24b2010  sub r2, fp, #16
    21c8: e1a00001  mov r0, r1
    21cc: e1a01002  mov r1, r2
    21d0: e3a02004  mov r2, #4
    21d4: e12fff33  blx r3

    /*
     * Update checksum
     */
    Checksum += TempValue;
    21d8: e51b3010  ldr r3, [fp, #-16]
    21dc: e51b2008  ldr r2, [fp, #-8]
    21e0: e0823003  add r3, r2, r3
    21e4: e50b3008  str r3, [fp, #-8]
u32 HeaderChecksum(u32 FlashOffsetAddress){
  u32 Checksum = 0;
  u32 Count;
  u32 TempValue = 0;

  for (Count = 0; Count < IMAGE_HEADER_CHECKSUM_COUNT; Count++) {
    21e8: e51b300c  ldr r3, [fp, #-12]
    21ec: e2833001  add r3, r3, #1
    21f0: e50b300c  str r3, [fp, #-12]
    21f4: e51b300c  ldr r3, [fp, #-12]
    21f8: e3530009  cmp r3, #9
    21fc: 9affffe8  bls 21a4 <HeaderChecksum+0x2c>
  }

  /*
   * Invert checksum, last bit of error checking
   */
  Checksum ^= 0xFFFFFFFF;
    2200: e51b3008  ldr r3, [fp, #-8]
    2204: e1e03003  mvn r3, r3
    2208: e50b3008  str r3, [fp, #-8]
  MoveImage(FlashOffsetAddress + IMAGE_CHECKSUM_OFFSET, (u32)&TempValue, 4);
    220c: e30136ec  movw  r3, #5868 ; 0x16ec
    2210: e3403002  movt  r3, #2
    2214: e5933000  ldr r3, [r3]
    2218: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    221c: e2821048  add r1, r2, #72 ; 0x48
    2220: e24b2010  sub r2, fp, #16
    2224: e1a00001  mov r0, r1
    2228: e1a01002  mov r1, r2
    222c: e3a02004  mov r2, #4
    2230: e12fff33  blx r3

  /*
   * Validate the checksum
   */
  if (TempValue != Checksum){
    2234: e51b2010  ldr r2, [fp, #-16]
    2238: e51b3008  ldr r3, [fp, #-8]
    223c: e1520003  cmp r2, r3
    2240: 0a000005  beq 225c <HeaderChecksum+0xe4>
    fsbl_printf(DEBUG_INFO, "Checksum = %8.8x\r\n", Checksum);
    2244: e3070dd4  movw  r0, #32212  ; 0x7dd4
    2248: e3400001  movt  r0, #1
    224c: e51b1008  ldr r1, [fp, #-8]
    2250: eb00106a  bl  6400 <xil_printf>
    return XST_FAILURE;
    2254: e3a03001  mov r3, #1
    2258: ea000000  b 2260 <HeaderChecksum+0xe8>
  }

  return XST_SUCCESS;
    225c: e3a03000  mov r3, #0
}
    2260: e1a00003  mov r0, r3
    2264: e24bd004  sub sp, fp, #4
    2268: e8bd8800  pop {fp, pc}

0000226c <ImageCheckID>:
*   - XST_FAILURE if ID mismatches
*
* @note   None
*
*******************************************************************************/
u32 ImageCheckID(u32 FlashOffsetAddress){
    226c: e92d4800  push  {fp, lr}
    2270: e28db004  add fp, sp, #4
    2274: e24dd010  sub sp, sp, #16
    2278: e50b0010  str r0, [fp, #-16]
  u32 ID;

  /*
   * Read in the header info
   */
  MoveImage(FlashOffsetAddress + IMAGE_IDENT_OFFSET, (u32)&ID, 4);
    227c: e30136ec  movw  r3, #5868 ; 0x16ec
    2280: e3403002  movt  r3, #2
    2284: e5933000  ldr r3, [r3]
    2288: e51b2010  ldr r2, [fp, #-16]
    228c: e2821024  add r1, r2, #36 ; 0x24
    2290: e24b2008  sub r2, fp, #8
    2294: e1a00001  mov r0, r1
    2298: e1a01002  mov r1, r2
    229c: e3a02004  mov r2, #4
    22a0: e12fff33  blx r3

  /*
   * Check the ID, make sure image is XLNX format
   */
  if (ID != IMAGE_IDENT){
    22a4: e51b2008  ldr r2, [fp, #-8]
    22a8: e3043e58  movw  r3, #20056  ; 0x4e58
    22ac: e345384c  movt  r3, #22604  ; 0x584c
    22b0: e1520003  cmp r2, r3
    22b4: 0a000001  beq 22c0 <ImageCheckID+0x54>
    return XST_FAILURE;
    22b8: e3a03001  mov r3, #1
    22bc: ea000000  b 22c4 <ImageCheckID+0x58>
  }

  return XST_SUCCESS;
    22c0: e3a03000  mov r3, #0
}
    22c4: e1a00003  mov r0, r3
    22c8: e24bd004  sub sp, fp, #4
    22cc: e8bd8800  pop {fp, pc}

000022d0 <NextValidImageCheck>:
*
* @note   None
*
*******************************************************************************/
u32 NextValidImageCheck(void)
{
    22d0: e92d4800  push  {fp, lr}
    22d4: e28db004  add fp, sp, #4
    22d8: e24dd010  sub sp, sp, #16
  u32 ImageBaseAddr;
  u32 MultiBootReg;
  u32 BootDevMaxSize=0;
    22dc: e3a03000  mov r3, #0
    22e0: e50b3010  str r3, [fp, #-16]

  fsbl_printf(DEBUG_GENERAL, "Searching For Next Valid Image");
    22e4: e3070de8  movw  r0, #32232  ; 0x7de8
    22e8: e3400001  movt  r0, #1
    22ec: eb001043  bl  6400 <xil_printf>
  
  /*
   * Setting variable with maximum flash size based on boot mode
   */
#ifdef XPAR_PS7_QSPI_LINEAR_0_S_AXI_BASEADDR
  if (FlashReadBaseAddress == XPS_QSPI_LINEAR_BASEADDR) {
    22f0: e301305c  movw  r3, #4188 ; 0x105c
    22f4: e3403002  movt  r3, #2
    22f8: e5933000  ldr r3, [r3]
    22fc: e353033f  cmp r3, #-67108864  ; 0xfc000000
    2300: 1a000003  bne 2314 <NextValidImageCheck+0x44>
    BootDevMaxSize = QspiFlashSize;
    2304: e3023aa4  movw  r3, #10916  ; 0x2aa4
    2308: e3403002  movt  r3, #2
    230c: e5933000  ldr r3, [r3]
    2310: e50b3010  str r3, [fp, #-16]
  }
#endif

  if (FlashReadBaseAddress == XPS_NAND_BASEADDR) {
    2314: e301305c  movw  r3, #4188 ; 0x105c
    2318: e3403002  movt  r3, #2
    231c: e5933000  ldr r3, [r3]
    2320: e35304e1  cmp r3, #-520093696 ; 0xe1000000
    2324: 1a000001  bne 2330 <NextValidImageCheck+0x60>
    BootDevMaxSize  = NAND_FLASH_SIZE;
    2328: e3a03302  mov r3, #134217728  ; 0x8000000
    232c: e50b3010  str r3, [fp, #-16]
  }

  if (FlashReadBaseAddress == XPS_NOR_BASEADDR) {
    2330: e301305c  movw  r3, #4188 ; 0x105c
    2334: e3403002  movt  r3, #2
    2338: e5933000  ldr r3, [r3]
    233c: e35304e2  cmp r3, #-503316480 ; 0xe2000000
    2340: 1a000001  bne 234c <NextValidImageCheck+0x7c>
    BootDevMaxSize  = NOR_FLASH_SIZE;
    2344: e3a03402  mov r3, #33554432 ; 0x2000000
    2348: e50b3010  str r3, [fp, #-16]
  }

  /*
   * Read the multiboot register
   */
  MultiBootReg =  XDcfg_ReadReg(DcfgInstPtr->Config.BaseAddr,
    234c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    2350: e3403002  movt  r3, #2
    2354: e5933000  ldr r3, [r3]
    2358: e5933004  ldr r3, [r3, #4]
    235c: e283302c  add r3, r3, #44 ; 0x2c
    2360: e1a00003  mov r0, r3
    2364: eb000f8b  bl  6198 <Xil_In32>
    2368: e50b000c  str r0, [fp, #-12]
      XDCFG_MULTIBOOT_ADDR_OFFSET);

  /*
   * Compute the image start address
   */
  ImageBaseAddr = (MultiBootReg & PCAP_MBOOT_REG_REBOOT_OFFSET_MASK)
    236c: e51b300c  ldr r3, [fp, #-12]
    2370: e7ec3053  ubfx  r3, r3, #0, #13
    2374: e1a03783  lsl r3, r3, #15
    2378: e50b3008  str r3, [fp, #-8]
  
  /*
   * Valid image search continue till end of the flash
   * With increment 32KB in each iteration
   */
  while (ImageBaseAddr < BootDevMaxSize) {
    237c: ea000021  b 2408 <NextValidImageCheck+0x138>

    fsbl_printf(DEBUG_INFO,".");
    2380: e3070e08  movw  r0, #32264  ; 0x7e08
    2384: e3400001  movt  r0, #1
    2388: eb00101c  bl  6400 <xil_printf>

    /*
     * Valid image search using XLNX pattern at fixed offset
     * and header checksum
     */
    if ((ImageCheckID(ImageBaseAddr) == XST_SUCCESS) &&
    238c: e51b0008  ldr r0, [fp, #-8]
    2390: ebffffb5  bl  226c <ImageCheckID>
    2394: e1a03000  mov r3, r0
    2398: e3530000  cmp r3, #0
    239c: 1a000012  bne 23ec <NextValidImageCheck+0x11c>
        (HeaderChecksum(ImageBaseAddr) == XST_SUCCESS)) {
    23a0: e51b0008  ldr r0, [fp, #-8]
    23a4: ebffff73  bl  2178 <HeaderChecksum>
    23a8: e1a03000  mov r3, r0

    /*
     * Valid image search using XLNX pattern at fixed offset
     * and header checksum
     */
    if ((ImageCheckID(ImageBaseAddr) == XST_SUCCESS) &&
    23ac: e3530000  cmp r3, #0
    23b0: 1a00000d  bne 23ec <NextValidImageCheck+0x11c>
        (HeaderChecksum(ImageBaseAddr) == XST_SUCCESS)) {

      fsbl_printf(DEBUG_GENERAL, "\r\nImage found, offset: 0x%.8x\r\n",
    23b4: e3070e0c  movw  r0, #32268  ; 0x7e0c
    23b8: e3400001  movt  r0, #1
    23bc: e51b1008  ldr r1, [fp, #-8]
    23c0: eb00100e  bl  6400 <xil_printf>
          ImageBaseAddr);
      /*
       * Update multiboot register
       */
      XDcfg_WriteReg(DcfgInstPtr->Config.BaseAddr,
    23c4: e3013a8c  movw  r3, #6796 ; 0x1a8c
    23c8: e3403002  movt  r3, #2
    23cc: e5933000  ldr r3, [r3]
    23d0: e5933004  ldr r3, [r3, #4]
    23d4: e283302c  add r3, r3, #44 ; 0x2c
    23d8: e1a00003  mov r0, r3
    23dc: e51b100c  ldr r1, [fp, #-12]
    23e0: eb000f72  bl  61b0 <Xil_Out32>
          XDCFG_MULTIBOOT_ADDR_OFFSET,
          MultiBootReg);

      return XST_SUCCESS;
    23e4: e3a03000  mov r3, #0
    23e8: ea00000b  b 241c <NextValidImageCheck+0x14c>
    }

    /*
     * Increment mulitboot count
     */
    MultiBootReg++;
    23ec: e51b300c  ldr r3, [fp, #-12]
    23f0: e2833001  add r3, r3, #1
    23f4: e50b300c  str r3, [fp, #-12]

    /*
     * Compute the image start address
     */
    ImageBaseAddr = (MultiBootReg & PCAP_MBOOT_REG_REBOOT_OFFSET_MASK)
    23f8: e51b300c  ldr r3, [fp, #-12]
    23fc: e7ec3053  ubfx  r3, r3, #0, #13
    2400: e1a03783  lsl r3, r3, #15
    2404: e50b3008  str r3, [fp, #-8]
  
  /*
   * Valid image search continue till end of the flash
   * With increment 32KB in each iteration
   */
  while (ImageBaseAddr < BootDevMaxSize) {
    2408: e51b2008  ldr r2, [fp, #-8]
    240c: e51b3010  ldr r3, [fp, #-16]
    2410: e1520003  cmp r2, r3
    2414: 3affffd9  bcc 2380 <NextValidImageCheck+0xb0>
     */
    ImageBaseAddr = (MultiBootReg & PCAP_MBOOT_REG_REBOOT_OFFSET_MASK)
              * GOLDEN_IMAGE_OFFSET;
  }

  return XST_FAILURE;
    2418: e3a03001  mov r3, #1
}
    241c: e1a00003  mov r0, r3
    2420: e24bd004  sub sp, fp, #4
    2424: e8bd8800  pop {fp, pc}

00002428 <DDRInitCheck>:
*
* @note   None.
*
****************************************************************************/
u32 DDRInitCheck(void)
{
    2428: e92d4800  push  {fp, lr}
    242c: e28db004  add fp, sp, #4
    2430: e24dd008  sub sp, sp, #8
  u32 ReadVal;

  /*
   * Write and Read from the DDR location for sanity checks
   */
  Xil_Out32(DDR_START_ADDR, DDR_TEST_PATTERN);
    2434: e3a00601  mov r0, #1048576  ; 0x100000
    2438: e30a1a55  movw  r1, #43605  ; 0xaa55
    243c: e34a1a55  movt  r1, #43605  ; 0xaa55
    2440: eb000f5a  bl  61b0 <Xil_Out32>
  ReadVal = Xil_In32(DDR_START_ADDR);
    2444: e3a00601  mov r0, #1048576  ; 0x100000
    2448: eb000f52  bl  6198 <Xil_In32>
    244c: e50b0008  str r0, [fp, #-8]
  if (ReadVal != DDR_TEST_PATTERN) {
    2450: e51b2008  ldr r2, [fp, #-8]
    2454: e30a3a55  movw  r3, #43605  ; 0xaa55
    2458: e34a3a55  movt  r3, #43605  ; 0xaa55
    245c: e1520003  cmp r2, r3
    2460: 0a000001  beq 246c <DDRInitCheck+0x44>
    return XST_FAILURE;
    2464: e3a03001  mov r3, #1
    2468: ea00000e  b 24a8 <DDRInitCheck+0x80>
  }

  /*
   * Write and Read from the DDR location for sanity checks
   */
  Xil_Out32(DDR_START_ADDR + DDR_TEST_OFFSET, DDR_TEST_PATTERN);
    246c: e3a00602  mov r0, #2097152  ; 0x200000
    2470: e30a1a55  movw  r1, #43605  ; 0xaa55
    2474: e34a1a55  movt  r1, #43605  ; 0xaa55
    2478: eb000f4c  bl  61b0 <Xil_Out32>
  ReadVal = Xil_In32(DDR_START_ADDR + DDR_TEST_OFFSET);
    247c: e3a00602  mov r0, #2097152  ; 0x200000
    2480: eb000f44  bl  6198 <Xil_In32>
    2484: e50b0008  str r0, [fp, #-8]
  if (ReadVal != DDR_TEST_PATTERN) {
    2488: e51b2008  ldr r2, [fp, #-8]
    248c: e30a3a55  movw  r3, #43605  ; 0xaa55
    2490: e34a3a55  movt  r3, #43605  ; 0xaa55
    2494: e1520003  cmp r2, r3
    2498: 0a000001  beq 24a4 <DDRInitCheck+0x7c>
    return XST_FAILURE;
    249c: e3a03001  mov r3, #1
    24a0: ea000000  b 24a8 <DDRInitCheck+0x80>
  }

  return XST_SUCCESS;
    24a4: e3a03000  mov r3, #0
}
    24a8: e1a00003  mov r0, r3
    24ac: e24bd004  sub sp, fp, #4
    24b0: e8bd8800  pop {fp, pc}
    24b4: e320f000  nop {0}

000024b8 <MD5Memset>:
*
* @note   None
*
****************************************************************************/
inline void * MD5Memset( void *dest, int  ch, u32 count )
{
    24b8: e92d0810  push  {r4, fp}
    24bc: e28db004  add fp, sp, #4
    24c0: e24dd010  sub sp, sp, #16
    24c4: e50b0008  str r0, [fp, #-8]
    24c8: e50b100c  str r1, [fp, #-12]
    24cc: e50b2010  str r2, [fp, #-16]
  register char *dst8 = (char*)dest;
    24d0: e51b4008  ldr r4, [fp, #-8]

  while( count-- )
    24d4: ea000004  b 24ec <MD5Memset+0x34>
    *dst8++ = ch;
    24d8: e1a03004  mov r3, r4
    24dc: e2834001  add r4, r3, #1
    24e0: e51b200c  ldr r2, [fp, #-12]
    24e4: e6ef2072  uxtb  r2, r2
    24e8: e5c32000  strb  r2, [r3]
****************************************************************************/
inline void * MD5Memset( void *dest, int  ch, u32 count )
{
  register char *dst8 = (char*)dest;

  while( count-- )
    24ec: e51b3010  ldr r3, [fp, #-16]
    24f0: e2432001  sub r2, r3, #1
    24f4: e50b2010  str r2, [fp, #-16]
    24f8: e3530000  cmp r3, #0
    24fc: 1afffff5  bne 24d8 <MD5Memset+0x20>
    *dst8++ = ch;

  return dest;
    2500: e51b3008  ldr r3, [fp, #-8]
}
    2504: e1a00003  mov r0, r3
    2508: e24bd004  sub sp, fp, #4
    250c: e8bd0810  pop {r4, fp}
    2510: e12fff1e  bx  lr

00002514 <MD5Memcpy>:
* @note   None
*
****************************************************************************/
inline void * MD5Memcpy( void *dest, const void *src,
       u32 count, boolean doByteSwap )
{
    2514: e92d0830  push  {r4, r5, fp}
    2518: e28db008  add fp, sp, #8
    251c: e24dd014  sub sp, sp, #20
    2520: e50b0010  str r0, [fp, #-16]
    2524: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    2528: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
    252c: e54b3019  strb  r3, [fp, #-25]  ; 0xffffffe7
  register char * dst8 = (char*)dest;
    2530: e51b4010  ldr r4, [fp, #-16]
  register char * src8 = (char*)src;
    2534: e51b5014  ldr r5, [fp, #-20]  ; 0xffffffec
  
  if( doByteSwap == FALSE ) {
    2538: e55b3019  ldrb  r3, [fp, #-25]  ; 0xffffffe7
    253c: e3530000  cmp r3, #0
    2540: 1a00000c  bne 2578 <MD5Memcpy+0x64>
    while( count-- )
    2544: ea000005  b 2560 <MD5Memcpy+0x4c>
      *dst8++ = *src8++;
    2548: e1a03004  mov r3, r4
    254c: e2834001  add r4, r3, #1
    2550: e1a02005  mov r2, r5
    2554: e2825001  add r5, r2, #1
    2558: e5d22000  ldrb  r2, [r2]
    255c: e5c32000  strb  r2, [r3]
{
  register char * dst8 = (char*)dest;
  register char * src8 = (char*)src;
  
  if( doByteSwap == FALSE ) {
    while( count-- )
    2560: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    2564: e2432001  sub r2, r3, #1
    2568: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
    256c: e3530000  cmp r3, #0
    2570: 1afffff4  bne 2548 <MD5Memcpy+0x34>
    2574: ea000015  b 25d0 <MD5Memcpy+0xbc>
      *dst8++ = *src8++;
  } else {
    count /= sizeof( u32 );
    2578: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    257c: e1a03123  lsr r3, r3, #2
    2580: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
    
    while( count-- ) {
    2584: ea00000c  b 25bc <MD5Memcpy+0xa8>
      dst8[ 0 ] = src8[ 3 ];
    2588: e5d53003  ldrb  r3, [r5, #3]
    258c: e5c43000  strb  r3, [r4]
      dst8[ 1 ] = src8[ 2 ];
    2590: e2843001  add r3, r4, #1
    2594: e5d52002  ldrb  r2, [r5, #2]
    2598: e5c32000  strb  r2, [r3]
      dst8[ 2 ] = src8[ 1 ];
    259c: e2843002  add r3, r4, #2
    25a0: e5d52001  ldrb  r2, [r5, #1]
    25a4: e5c32000  strb  r2, [r3]
      dst8[ 3 ] = src8[ 0 ];
    25a8: e2843003  add r3, r4, #3
    25ac: e5d52000  ldrb  r2, [r5]
    25b0: e5c32000  strb  r2, [r3]
      
      dst8 += 4;
    25b4: e2844004  add r4, r4, #4
      src8 += 4;
    25b8: e2855004  add r5, r5, #4
    while( count-- )
      *dst8++ = *src8++;
  } else {
    count /= sizeof( u32 );
    
    while( count-- ) {
    25bc: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    25c0: e2432001  sub r2, r3, #1
    25c4: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
    25c8: e3530000  cmp r3, #0
    25cc: 1affffed  bne 2588 <MD5Memcpy+0x74>
      dst8 += 4;
      src8 += 4;
    }
  }
  
  return dest;
    25d0: e51b3010  ldr r3, [fp, #-16]
}
    25d4: e1a00003  mov r0, r3
    25d8: e24bd008  sub sp, fp, #8
    25dc: e8bd0830  pop {r4, r5, fp}
    25e0: e12fff1e  bx  lr

000025e4 <MD5Transform>:
*
* @note   None
*
****************************************************************************/
void MD5Transform( u32 *buffer, u32 *intermediate )
{
    25e4: e92d08f0  push  {r4, r5, r6, r7, fp}
    25e8: e28db010  add fp, sp, #16
    25ec: e24dd00c  sub sp, sp, #12
    25f0: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
    25f4: e50b101c  str r1, [fp, #-28]  ; 0xffffffe4
  register u32 a, b, c, d;
  
  a = buffer[ 0 ];
    25f8: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    25fc: e5936000  ldr r6, [r3]
  b = buffer[ 1 ];
    2600: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    2604: e5935004  ldr r5, [r3, #4]
  c = buffer[ 2 ];
    2608: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    260c: e5937008  ldr r7, [r3, #8]
  d = buffer[ 3 ];
    2610: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    2614: e593400c  ldr r4, [r3, #12]

  MD5_STEP( F1, a, b, c, d, intermediate[  0 ] + 0xd76aa478,  7 );
    2618: e0273004  eor r3, r7, r4
    261c: e0033005  and r3, r3, r5
    2620: e0232004  eor r2, r3, r4
    2624: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2628: e5933000  ldr r3, [r3]
    262c: e0823003  add r3, r2, r3
    2630: e0833006  add r3, r3, r6
    2634: e30a6478  movw  r6, #42104  ; 0xa478
    2638: e34d676a  movt  r6, #55146  ; 0xd76a
    263c: e0836006  add r6, r3, r6
    2640: e1a06ce6  ror r6, r6, #25
    2644: e0866005  add r6, r6, r5
  MD5_STEP( F1, d, a, b, c, intermediate[  1 ] + 0xe8c7b756, 12 );
    2648: e0253007  eor r3, r5, r7
    264c: e0033006  and r3, r3, r6
    2650: e0232007  eor r2, r3, r7
    2654: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2658: e2833004  add r3, r3, #4
    265c: e5933000  ldr r3, [r3]
    2660: e0823003  add r3, r2, r3
    2664: e0833004  add r3, r3, r4
    2668: e30b4756  movw  r4, #46934  ; 0xb756
    266c: e34e48c7  movt  r4, #59591  ; 0xe8c7
    2670: e0834004  add r4, r3, r4
    2674: e1a04a64  ror r4, r4, #20
    2678: e0844006  add r4, r4, r6
  MD5_STEP( F1, c, d, a, b, intermediate[  2 ] + 0x242070db, 17 );
    267c: e0263005  eor r3, r6, r5
    2680: e0033004  and r3, r3, r4
    2684: e0232005  eor r2, r3, r5
    2688: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    268c: e2833008  add r3, r3, #8
    2690: e5933000  ldr r3, [r3]
    2694: e0823003  add r3, r2, r3
    2698: e0833007  add r3, r3, r7
    269c: e30770db  movw  r7, #28891  ; 0x70db
    26a0: e3427420  movt  r7, #9248 ; 0x2420
    26a4: e0837007  add r7, r3, r7
    26a8: e1a077e7  ror r7, r7, #15
    26ac: e0877004  add r7, r7, r4
  MD5_STEP( F1, b, c, d, a, intermediate[  3 ] + 0xc1bdceee, 22 );
    26b0: e0243006  eor r3, r4, r6
    26b4: e0033007  and r3, r3, r7
    26b8: e0232006  eor r2, r3, r6
    26bc: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    26c0: e283300c  add r3, r3, #12
    26c4: e5933000  ldr r3, [r3]
    26c8: e0823003  add r3, r2, r3
    26cc: e0833005  add r3, r3, r5
    26d0: e30c5eee  movw  r5, #52974  ; 0xceee
    26d4: e34c51bd  movt  r5, #49597  ; 0xc1bd
    26d8: e0835005  add r5, r3, r5
    26dc: e1a05565  ror r5, r5, #10
    26e0: e0855007  add r5, r5, r7
  MD5_STEP( F1, a, b, c, d, intermediate[  4 ] + 0xf57c0faf,  7 );
    26e4: e0273004  eor r3, r7, r4
    26e8: e0033005  and r3, r3, r5
    26ec: e0232004  eor r2, r3, r4
    26f0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    26f4: e2833010  add r3, r3, #16
    26f8: e5933000  ldr r3, [r3]
    26fc: e0823003  add r3, r2, r3
    2700: e0833006  add r3, r3, r6
    2704: e3006faf  movw  r6, #4015 ; 0xfaf
    2708: e34f657c  movt  r6, #62844  ; 0xf57c
    270c: e0836006  add r6, r3, r6
    2710: e1a06ce6  ror r6, r6, #25
    2714: e0866005  add r6, r6, r5
  MD5_STEP( F1, d, a, b, c, intermediate[  5 ] + 0x4787c62a, 12 );
    2718: e0253007  eor r3, r5, r7
    271c: e0033006  and r3, r3, r6
    2720: e0232007  eor r2, r3, r7
    2724: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2728: e2833014  add r3, r3, #20
    272c: e5933000  ldr r3, [r3]
    2730: e0823003  add r3, r2, r3
    2734: e0833004  add r3, r3, r4
    2738: e30c462a  movw  r4, #50730  ; 0xc62a
    273c: e3444787  movt  r4, #18311  ; 0x4787
    2740: e0834004  add r4, r3, r4
    2744: e1a04a64  ror r4, r4, #20
    2748: e0844006  add r4, r4, r6
  MD5_STEP( F1, c, d, a, b, intermediate[  6 ] + 0xa8304613, 17 );
    274c: e0263005  eor r3, r6, r5
    2750: e0033004  and r3, r3, r4
    2754: e0232005  eor r2, r3, r5
    2758: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    275c: e2833018  add r3, r3, #24
    2760: e5933000  ldr r3, [r3]
    2764: e0823003  add r3, r2, r3
    2768: e0833007  add r3, r3, r7
    276c: e3047613  movw  r7, #17939  ; 0x4613
    2770: e34a7830  movt  r7, #43056  ; 0xa830
    2774: e0837007  add r7, r3, r7
    2778: e1a077e7  ror r7, r7, #15
    277c: e0877004  add r7, r7, r4
  MD5_STEP( F1, b, c, d, a, intermediate[  7 ] + 0xfd469501, 22 );
    2780: e0243006  eor r3, r4, r6
    2784: e0033007  and r3, r3, r7
    2788: e0232006  eor r2, r3, r6
    278c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2790: e283301c  add r3, r3, #28
    2794: e5933000  ldr r3, [r3]
    2798: e0823003  add r3, r2, r3
    279c: e0833005  add r3, r3, r5
    27a0: e3095501  movw  r5, #38145  ; 0x9501
    27a4: e34f5d46  movt  r5, #64838  ; 0xfd46
    27a8: e0835005  add r5, r3, r5
    27ac: e1a05565  ror r5, r5, #10
    27b0: e0855007  add r5, r5, r7
  MD5_STEP( F1, a, b, c, d, intermediate[  8 ] + 0x698098d8,  7 );
    27b4: e0273004  eor r3, r7, r4
    27b8: e0033005  and r3, r3, r5
    27bc: e0232004  eor r2, r3, r4
    27c0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    27c4: e2833020  add r3, r3, #32
    27c8: e5933000  ldr r3, [r3]
    27cc: e0823003  add r3, r2, r3
    27d0: e0833006  add r3, r3, r6
    27d4: e30968d8  movw  r6, #39128  ; 0x98d8
    27d8: e3466980  movt  r6, #27008  ; 0x6980
    27dc: e0836006  add r6, r3, r6
    27e0: e1a06ce6  ror r6, r6, #25
    27e4: e0866005  add r6, r6, r5
  MD5_STEP( F1, d, a, b, c, intermediate[  9 ] + 0x8b44f7af, 12 );
    27e8: e0253007  eor r3, r5, r7
    27ec: e0033006  and r3, r3, r6
    27f0: e0232007  eor r2, r3, r7
    27f4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    27f8: e2833024  add r3, r3, #36 ; 0x24
    27fc: e5933000  ldr r3, [r3]
    2800: e0823003  add r3, r2, r3
    2804: e0833004  add r3, r3, r4
    2808: e30f47af  movw  r4, #63407  ; 0xf7af
    280c: e3484b44  movt  r4, #35652  ; 0x8b44
    2810: e0834004  add r4, r3, r4
    2814: e1a04a64  ror r4, r4, #20
    2818: e0844006  add r4, r4, r6
  MD5_STEP( F1, c, d, a, b, intermediate[ 10 ] + 0xffff5bb1, 17 );
    281c: e0263005  eor r3, r6, r5
    2820: e0033004  and r3, r3, r4
    2824: e0232005  eor r2, r3, r5
    2828: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    282c: e2833028  add r3, r3, #40 ; 0x28
    2830: e5933000  ldr r3, [r3]
    2834: e0823003  add r3, r2, r3
    2838: e0833007  add r3, r3, r7
    283c: e2437b29  sub r7, r3, #41984  ; 0xa400
    2840: e247704f  sub r7, r7, #79 ; 0x4f
    2844: e1a077e7  ror r7, r7, #15
    2848: e0877004  add r7, r7, r4
  MD5_STEP( F1, b, c, d, a, intermediate[ 11 ] + 0x895cd7be, 22 );
    284c: e0243006  eor r3, r4, r6
    2850: e0033007  and r3, r3, r7
    2854: e0232006  eor r2, r3, r6
    2858: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    285c: e283302c  add r3, r3, #44 ; 0x2c
    2860: e5933000  ldr r3, [r3]
    2864: e0823003  add r3, r2, r3
    2868: e0833005  add r3, r3, r5
    286c: e30d57be  movw  r5, #55230  ; 0xd7be
    2870: e348595c  movt  r5, #35164  ; 0x895c
    2874: e0835005  add r5, r3, r5
    2878: e1a05565  ror r5, r5, #10
    287c: e0855007  add r5, r5, r7
  MD5_STEP( F1, a, b, c, d, intermediate[ 12 ] + 0x6b901122,  7 );
    2880: e0273004  eor r3, r7, r4
    2884: e0033005  and r3, r3, r5
    2888: e0232004  eor r2, r3, r4
    288c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2890: e2833030  add r3, r3, #48 ; 0x30
    2894: e5933000  ldr r3, [r3]
    2898: e0823003  add r3, r2, r3
    289c: e0833006  add r3, r3, r6
    28a0: e3016122  movw  r6, #4386 ; 0x1122
    28a4: e3466b90  movt  r6, #27536  ; 0x6b90
    28a8: e0836006  add r6, r3, r6
    28ac: e1a06ce6  ror r6, r6, #25
    28b0: e0866005  add r6, r6, r5
  MD5_STEP( F1, d, a, b, c, intermediate[ 13 ] + 0xfd987193, 12 );
    28b4: e0253007  eor r3, r5, r7
    28b8: e0033006  and r3, r3, r6
    28bc: e0232007  eor r2, r3, r7
    28c0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    28c4: e2833034  add r3, r3, #52 ; 0x34
    28c8: e5933000  ldr r3, [r3]
    28cc: e0823003  add r3, r2, r3
    28d0: e0833004  add r3, r3, r4
    28d4: e3074193  movw  r4, #29075  ; 0x7193
    28d8: e34f4d98  movt  r4, #64920  ; 0xfd98
    28dc: e0834004  add r4, r3, r4
    28e0: e1a04a64  ror r4, r4, #20
    28e4: e0844006  add r4, r4, r6
  MD5_STEP( F1, c, d, a, b, intermediate[ 14 ] + 0xa679438e, 17 );
    28e8: e0263005  eor r3, r6, r5
    28ec: e0033004  and r3, r3, r4
    28f0: e0232005  eor r2, r3, r5
    28f4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    28f8: e2833038  add r3, r3, #56 ; 0x38
    28fc: e5933000  ldr r3, [r3]
    2900: e0823003  add r3, r2, r3
    2904: e0833007  add r3, r3, r7
    2908: e304738e  movw  r7, #17294  ; 0x438e
    290c: e34a7679  movt  r7, #42617  ; 0xa679
    2910: e0837007  add r7, r3, r7
    2914: e1a077e7  ror r7, r7, #15
    2918: e0877004  add r7, r7, r4
  MD5_STEP( F1, b, c, d, a, intermediate[ 15 ] + 0x49b40821, 22 );
    291c: e0243006  eor r3, r4, r6
    2920: e0033007  and r3, r3, r7
    2924: e0232006  eor r2, r3, r6
    2928: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    292c: e283303c  add r3, r3, #60 ; 0x3c
    2930: e5933000  ldr r3, [r3]
    2934: e0823003  add r3, r2, r3
    2938: e0833005  add r3, r3, r5
    293c: e3005821  movw  r5, #2081 ; 0x821
    2940: e34459b4  movt  r5, #18868  ; 0x49b4
    2944: e0835005  add r5, r3, r5
    2948: e1a05565  ror r5, r5, #10
    294c: e0855007  add r5, r5, r7
  
  MD5_STEP( F2, a, b, c, d, intermediate[  1 ] + 0xf61e2562,  5 );
    2950: e0253007  eor r3, r5, r7
    2954: e0033004  and r3, r3, r4
    2958: e0232007  eor r2, r3, r7
    295c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2960: e2833004  add r3, r3, #4
    2964: e5933000  ldr r3, [r3]
    2968: e0823003  add r3, r2, r3
    296c: e0833006  add r3, r3, r6
    2970: e3026562  movw  r6, #9570 ; 0x2562
    2974: e34f661e  movt  r6, #63006  ; 0xf61e
    2978: e0836006  add r6, r3, r6
    297c: e1a06de6  ror r6, r6, #27
    2980: e0866005  add r6, r6, r5
  MD5_STEP( F2, d, a, b, c, intermediate[  6 ] + 0xc040b340,  9 );
    2984: e0263005  eor r3, r6, r5
    2988: e0033007  and r3, r3, r7
    298c: e0232005  eor r2, r3, r5
    2990: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2994: e2833018  add r3, r3, #24
    2998: e5933000  ldr r3, [r3]
    299c: e0823003  add r3, r2, r3
    29a0: e0833004  add r3, r3, r4
    29a4: e30b4340  movw  r4, #45888  ; 0xb340
    29a8: e34c4040  movt  r4, #49216  ; 0xc040
    29ac: e0834004  add r4, r3, r4
    29b0: e1a04be4  ror r4, r4, #23
    29b4: e0844006  add r4, r4, r6
  MD5_STEP( F2, c, d, a, b, intermediate[ 11 ] + 0x265e5a51, 14 );
    29b8: e0243006  eor r3, r4, r6
    29bc: e0033005  and r3, r3, r5
    29c0: e0232006  eor r2, r3, r6
    29c4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    29c8: e283302c  add r3, r3, #44 ; 0x2c
    29cc: e5933000  ldr r3, [r3]
    29d0: e0823003  add r3, r2, r3
    29d4: e0833007  add r3, r3, r7
    29d8: e3057a51  movw  r7, #23121  ; 0x5a51
    29dc: e342765e  movt  r7, #9822 ; 0x265e
    29e0: e0837007  add r7, r3, r7
    29e4: e1a07967  ror r7, r7, #18
    29e8: e0877004  add r7, r7, r4
  MD5_STEP( F2, b, c, d, a, intermediate[  0 ] + 0xe9b6c7aa, 20 );
    29ec: e0273004  eor r3, r7, r4
    29f0: e0033006  and r3, r3, r6
    29f4: e0232004  eor r2, r3, r4
    29f8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    29fc: e5933000  ldr r3, [r3]
    2a00: e0823003  add r3, r2, r3
    2a04: e0833005  add r3, r3, r5
    2a08: e30c57aa  movw  r5, #51114  ; 0xc7aa
    2a0c: e34e59b6  movt  r5, #59830  ; 0xe9b6
    2a10: e0835005  add r5, r3, r5
    2a14: e1a05665  ror r5, r5, #12
    2a18: e0855007  add r5, r5, r7
  MD5_STEP( F2, a, b, c, d, intermediate[  5 ] + 0xd62f105d,  5 );
    2a1c: e0253007  eor r3, r5, r7
    2a20: e0033004  and r3, r3, r4
    2a24: e0232007  eor r2, r3, r7
    2a28: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2a2c: e2833014  add r3, r3, #20
    2a30: e5933000  ldr r3, [r3]
    2a34: e0823003  add r3, r2, r3
    2a38: e0833006  add r3, r3, r6
    2a3c: e301605d  movw  r6, #4189 ; 0x105d
    2a40: e34d662f  movt  r6, #54831  ; 0xd62f
    2a44: e0836006  add r6, r3, r6
    2a48: e1a06de6  ror r6, r6, #27
    2a4c: e0866005  add r6, r6, r5
  MD5_STEP( F2, d, a, b, c, intermediate[ 10 ] + 0x02441453,  9 );
    2a50: e0263005  eor r3, r6, r5
    2a54: e0033007  and r3, r3, r7
    2a58: e0232005  eor r2, r3, r5
    2a5c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2a60: e2833028  add r3, r3, #40 ; 0x28
    2a64: e5933000  ldr r3, [r3]
    2a68: e0823003  add r3, r2, r3
    2a6c: e0833004  add r3, r3, r4
    2a70: e3014453  movw  r4, #5203 ; 0x1453
    2a74: e3404244  movt  r4, #580  ; 0x244
    2a78: e0834004  add r4, r3, r4
    2a7c: e1a04be4  ror r4, r4, #23
    2a80: e0844006  add r4, r4, r6
  MD5_STEP( F2, c, d, a, b, intermediate[ 15 ] + 0xd8a1e681, 14 );
    2a84: e0243006  eor r3, r4, r6
    2a88: e0033005  and r3, r3, r5
    2a8c: e0232006  eor r2, r3, r6
    2a90: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2a94: e283303c  add r3, r3, #60 ; 0x3c
    2a98: e5933000  ldr r3, [r3]
    2a9c: e0823003  add r3, r2, r3
    2aa0: e0833007  add r3, r3, r7
    2aa4: e30e7681  movw  r7, #59009  ; 0xe681
    2aa8: e34d78a1  movt  r7, #55457  ; 0xd8a1
    2aac: e0837007  add r7, r3, r7
    2ab0: e1a07967  ror r7, r7, #18
    2ab4: e0877004  add r7, r7, r4
  MD5_STEP( F2, b, c, d, a, intermediate[  4 ] + 0xe7d3fbc8, 20 );
    2ab8: e0273004  eor r3, r7, r4
    2abc: e0033006  and r3, r3, r6
    2ac0: e0232004  eor r2, r3, r4
    2ac4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2ac8: e2833010  add r3, r3, #16
    2acc: e5933000  ldr r3, [r3]
    2ad0: e0823003  add r3, r2, r3
    2ad4: e0833005  add r3, r3, r5
    2ad8: e30f5bc8  movw  r5, #64456  ; 0xfbc8
    2adc: e34e57d3  movt  r5, #59347  ; 0xe7d3
    2ae0: e0835005  add r5, r3, r5
    2ae4: e1a05665  ror r5, r5, #12
    2ae8: e0855007  add r5, r5, r7
  MD5_STEP( F2, a, b, c, d, intermediate[  9 ] + 0x21e1cde6,  5 );
    2aec: e0253007  eor r3, r5, r7
    2af0: e0033004  and r3, r3, r4
    2af4: e0232007  eor r2, r3, r7
    2af8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2afc: e2833024  add r3, r3, #36 ; 0x24
    2b00: e5933000  ldr r3, [r3]
    2b04: e0823003  add r3, r2, r3
    2b08: e0833006  add r3, r3, r6
    2b0c: e30c6de6  movw  r6, #52710  ; 0xcde6
    2b10: e34261e1  movt  r6, #8673 ; 0x21e1
    2b14: e0836006  add r6, r3, r6
    2b18: e1a06de6  ror r6, r6, #27
    2b1c: e0866005  add r6, r6, r5
  MD5_STEP( F2, d, a, b, c, intermediate[ 14 ] + 0xc33707d6,  9 );
    2b20: e0263005  eor r3, r6, r5
    2b24: e0033007  and r3, r3, r7
    2b28: e0232005  eor r2, r3, r5
    2b2c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2b30: e2833038  add r3, r3, #56 ; 0x38
    2b34: e5933000  ldr r3, [r3]
    2b38: e0823003  add r3, r2, r3
    2b3c: e0833004  add r3, r3, r4
    2b40: e30047d6  movw  r4, #2006 ; 0x7d6
    2b44: e34c4337  movt  r4, #49975  ; 0xc337
    2b48: e0834004  add r4, r3, r4
    2b4c: e1a04be4  ror r4, r4, #23
    2b50: e0844006  add r4, r4, r6
  MD5_STEP( F2, c, d, a, b, intermediate[  3 ] + 0xf4d50d87, 14 );
    2b54: e0243006  eor r3, r4, r6
    2b58: e0033005  and r3, r3, r5
    2b5c: e0232006  eor r2, r3, r6
    2b60: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2b64: e283300c  add r3, r3, #12
    2b68: e5933000  ldr r3, [r3]
    2b6c: e0823003  add r3, r2, r3
    2b70: e0833007  add r3, r3, r7
    2b74: e3007d87  movw  r7, #3463 ; 0xd87
    2b78: e34f74d5  movt  r7, #62677  ; 0xf4d5
    2b7c: e0837007  add r7, r3, r7
    2b80: e1a07967  ror r7, r7, #18
    2b84: e0877004  add r7, r7, r4
  MD5_STEP( F2, b, c, d, a, intermediate[  8 ] + 0x455a14ed, 20 );
    2b88: e0273004  eor r3, r7, r4
    2b8c: e0033006  and r3, r3, r6
    2b90: e0232004  eor r2, r3, r4
    2b94: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2b98: e2833020  add r3, r3, #32
    2b9c: e5933000  ldr r3, [r3]
    2ba0: e0823003  add r3, r2, r3
    2ba4: e0833005  add r3, r3, r5
    2ba8: e30154ed  movw  r5, #5357 ; 0x14ed
    2bac: e344555a  movt  r5, #17754  ; 0x455a
    2bb0: e0835005  add r5, r3, r5
    2bb4: e1a05665  ror r5, r5, #12
    2bb8: e0855007  add r5, r5, r7
  MD5_STEP( F2, a, b, c, d, intermediate[ 13 ] + 0xa9e3e905,  5 );
    2bbc: e0253007  eor r3, r5, r7
    2bc0: e0033004  and r3, r3, r4
    2bc4: e0232007  eor r2, r3, r7
    2bc8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2bcc: e2833034  add r3, r3, #52 ; 0x34
    2bd0: e5933000  ldr r3, [r3]
    2bd4: e0823003  add r3, r2, r3
    2bd8: e0833006  add r3, r3, r6
    2bdc: e30e6905  movw  r6, #59653  ; 0xe905
    2be0: e34a69e3  movt  r6, #43491  ; 0xa9e3
    2be4: e0836006  add r6, r3, r6
    2be8: e1a06de6  ror r6, r6, #27
    2bec: e0866005  add r6, r6, r5
  MD5_STEP( F2, d, a, b, c, intermediate[  2 ] + 0xfcefa3f8,  9 );
    2bf0: e0263005  eor r3, r6, r5
    2bf4: e0033007  and r3, r3, r7
    2bf8: e0232005  eor r2, r3, r5
    2bfc: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2c00: e2833008  add r3, r3, #8
    2c04: e5933000  ldr r3, [r3]
    2c08: e0823003  add r3, r2, r3
    2c0c: e0833004  add r3, r3, r4
    2c10: e30a43f8  movw  r4, #41976  ; 0xa3f8
    2c14: e34f4cef  movt  r4, #64751  ; 0xfcef
    2c18: e0834004  add r4, r3, r4
    2c1c: e1a04be4  ror r4, r4, #23
    2c20: e0844006  add r4, r4, r6
  MD5_STEP( F2, c, d, a, b, intermediate[  7 ] + 0x676f02d9, 14 );
    2c24: e0243006  eor r3, r4, r6
    2c28: e0033005  and r3, r3, r5
    2c2c: e0232006  eor r2, r3, r6
    2c30: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2c34: e283301c  add r3, r3, #28
    2c38: e5933000  ldr r3, [r3]
    2c3c: e0823003  add r3, r2, r3
    2c40: e0833007  add r3, r3, r7
    2c44: e30072d9  movw  r7, #729  ; 0x2d9
    2c48: e346776f  movt  r7, #26479  ; 0x676f
    2c4c: e0837007  add r7, r3, r7
    2c50: e1a07967  ror r7, r7, #18
    2c54: e0877004  add r7, r7, r4
  MD5_STEP( F2, b, c, d, a, intermediate[ 12 ] + 0x8d2a4c8a, 20 );
    2c58: e0273004  eor r3, r7, r4
    2c5c: e0033006  and r3, r3, r6
    2c60: e0232004  eor r2, r3, r4
    2c64: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2c68: e2833030  add r3, r3, #48 ; 0x30
    2c6c: e5933000  ldr r3, [r3]
    2c70: e0823003  add r3, r2, r3
    2c74: e0833005  add r3, r3, r5
    2c78: e3045c8a  movw  r5, #19594  ; 0x4c8a
    2c7c: e3485d2a  movt  r5, #36138  ; 0x8d2a
    2c80: e0835005  add r5, r3, r5
    2c84: e1a05665  ror r5, r5, #12
    2c88: e0855007  add r5, r5, r7
  
  MD5_STEP( F3, a, b, c, d, intermediate[  5 ] + 0xfffa3942,  4 );
    2c8c: e0253007  eor r3, r5, r7
    2c90: e0232004  eor r2, r3, r4
    2c94: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2c98: e2833014  add r3, r3, #20
    2c9c: e5933000  ldr r3, [r3]
    2ca0: e0823003  add r3, r2, r3
    2ca4: e0833006  add r3, r3, r6
    2ca8: e3036942  movw  r6, #14658  ; 0x3942
    2cac: e34f6ffa  movt  r6, #65530  ; 0xfffa
    2cb0: e0836006  add r6, r3, r6
    2cb4: e1a06e66  ror r6, r6, #28
    2cb8: e0866005  add r6, r6, r5
  MD5_STEP( F3, d, a, b, c, intermediate[  8 ] + 0x8771f681, 11 );
    2cbc: e0263005  eor r3, r6, r5
    2cc0: e0232007  eor r2, r3, r7
    2cc4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2cc8: e2833020  add r3, r3, #32
    2ccc: e5933000  ldr r3, [r3]
    2cd0: e0823003  add r3, r2, r3
    2cd4: e0833004  add r3, r3, r4
    2cd8: e30f4681  movw  r4, #63105  ; 0xf681
    2cdc: e3484771  movt  r4, #34673  ; 0x8771
    2ce0: e0834004  add r4, r3, r4
    2ce4: e1a04ae4  ror r4, r4, #21
    2ce8: e0844006  add r4, r4, r6
  MD5_STEP( F3, c, d, a, b, intermediate[ 11 ] + 0x6d9d6122, 16 );
    2cec: e0243006  eor r3, r4, r6
    2cf0: e0232005  eor r2, r3, r5
    2cf4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2cf8: e283302c  add r3, r3, #44 ; 0x2c
    2cfc: e5933000  ldr r3, [r3]
    2d00: e0823003  add r3, r2, r3
    2d04: e0833007  add r3, r3, r7
    2d08: e3067122  movw  r7, #24866  ; 0x6122
    2d0c: e3467d9d  movt  r7, #28061  ; 0x6d9d
    2d10: e0837007  add r7, r3, r7
    2d14: e1a07867  ror r7, r7, #16
    2d18: e0877004  add r7, r7, r4
  MD5_STEP( F3, b, c, d, a, intermediate[ 14 ] + 0xfde5380c, 23 );
    2d1c: e0273004  eor r3, r7, r4
    2d20: e0232006  eor r2, r3, r6
    2d24: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2d28: e2833038  add r3, r3, #56 ; 0x38
    2d2c: e5933000  ldr r3, [r3]
    2d30: e0823003  add r3, r2, r3
    2d34: e0833005  add r3, r3, r5
    2d38: e303580c  movw  r5, #14348  ; 0x380c
    2d3c: e34f5de5  movt  r5, #64997  ; 0xfde5
    2d40: e0835005  add r5, r3, r5
    2d44: e1a054e5  ror r5, r5, #9
    2d48: e0855007  add r5, r5, r7
  MD5_STEP( F3, a, b, c, d, intermediate[  1 ] + 0xa4beea44,  4 );
    2d4c: e0253007  eor r3, r5, r7
    2d50: e0232004  eor r2, r3, r4
    2d54: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2d58: e2833004  add r3, r3, #4
    2d5c: e5933000  ldr r3, [r3]
    2d60: e0823003  add r3, r2, r3
    2d64: e0833006  add r3, r3, r6
    2d68: e30e6a44  movw  r6, #59972  ; 0xea44
    2d6c: e34a64be  movt  r6, #42174  ; 0xa4be
    2d70: e0836006  add r6, r3, r6
    2d74: e1a06e66  ror r6, r6, #28
    2d78: e0866005  add r6, r6, r5
  MD5_STEP( F3, d, a, b, c, intermediate[  4 ] + 0x4bdecfa9, 11 );
    2d7c: e0263005  eor r3, r6, r5
    2d80: e0232007  eor r2, r3, r7
    2d84: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2d88: e2833010  add r3, r3, #16
    2d8c: e5933000  ldr r3, [r3]
    2d90: e0823003  add r3, r2, r3
    2d94: e0833004  add r3, r3, r4
    2d98: e30c4fa9  movw  r4, #53161  ; 0xcfa9
    2d9c: e3444bde  movt  r4, #19422  ; 0x4bde
    2da0: e0834004  add r4, r3, r4
    2da4: e1a04ae4  ror r4, r4, #21
    2da8: e0844006  add r4, r4, r6
  MD5_STEP( F3, c, d, a, b, intermediate[  7 ] + 0xf6bb4b60, 16 );
    2dac: e0243006  eor r3, r4, r6
    2db0: e0232005  eor r2, r3, r5
    2db4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2db8: e283301c  add r3, r3, #28
    2dbc: e5933000  ldr r3, [r3]
    2dc0: e0823003  add r3, r2, r3
    2dc4: e0833007  add r3, r3, r7
    2dc8: e3047b60  movw  r7, #19296  ; 0x4b60
    2dcc: e34f76bb  movt  r7, #63163  ; 0xf6bb
    2dd0: e0837007  add r7, r3, r7
    2dd4: e1a07867  ror r7, r7, #16
    2dd8: e0877004  add r7, r7, r4
  MD5_STEP( F3, b, c, d, a, intermediate[ 10 ] + 0xbebfbc70, 23 );
    2ddc: e0273004  eor r3, r7, r4
    2de0: e0232006  eor r2, r3, r6
    2de4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2de8: e2833028  add r3, r3, #40 ; 0x28
    2dec: e5933000  ldr r3, [r3]
    2df0: e0823003  add r3, r2, r3
    2df4: e0833005  add r3, r3, r5
    2df8: e30b5c70  movw  r5, #48240  ; 0xbc70
    2dfc: e34b5ebf  movt  r5, #48831  ; 0xbebf
    2e00: e0835005  add r5, r3, r5
    2e04: e1a054e5  ror r5, r5, #9
    2e08: e0855007  add r5, r5, r7
  MD5_STEP( F3, a, b, c, d, intermediate[ 13 ] + 0x289b7ec6,  4 );
    2e0c: e0253007  eor r3, r5, r7
    2e10: e0232004  eor r2, r3, r4
    2e14: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2e18: e2833034  add r3, r3, #52 ; 0x34
    2e1c: e5933000  ldr r3, [r3]
    2e20: e0823003  add r3, r2, r3
    2e24: e0833006  add r3, r3, r6
    2e28: e3076ec6  movw  r6, #32454  ; 0x7ec6
    2e2c: e342689b  movt  r6, #10395  ; 0x289b
    2e30: e0836006  add r6, r3, r6
    2e34: e1a06e66  ror r6, r6, #28
    2e38: e0866005  add r6, r6, r5
  MD5_STEP( F3, d, a, b, c, intermediate[  0 ] + 0xeaa127fa, 11 );
    2e3c: e0263005  eor r3, r6, r5
    2e40: e0232007  eor r2, r3, r7
    2e44: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2e48: e5933000  ldr r3, [r3]
    2e4c: e0823003  add r3, r2, r3
    2e50: e0833004  add r3, r3, r4
    2e54: e30247fa  movw  r4, #10234  ; 0x27fa
    2e58: e34e4aa1  movt  r4, #60065  ; 0xeaa1
    2e5c: e0834004  add r4, r3, r4
    2e60: e1a04ae4  ror r4, r4, #21
    2e64: e0844006  add r4, r4, r6
  MD5_STEP( F3, c, d, a, b, intermediate[  3 ] + 0xd4ef3085, 16 );
    2e68: e0243006  eor r3, r4, r6
    2e6c: e0232005  eor r2, r3, r5
    2e70: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2e74: e283300c  add r3, r3, #12
    2e78: e5933000  ldr r3, [r3]
    2e7c: e0823003  add r3, r2, r3
    2e80: e0833007  add r3, r3, r7
    2e84: e3037085  movw  r7, #12421  ; 0x3085
    2e88: e34d74ef  movt  r7, #54511  ; 0xd4ef
    2e8c: e0837007  add r7, r3, r7
    2e90: e1a07867  ror r7, r7, #16
    2e94: e0877004  add r7, r7, r4
  MD5_STEP( F3, b, c, d, a, intermediate[  6 ] + 0x04881d05, 23 );
    2e98: e0273004  eor r3, r7, r4
    2e9c: e0232006  eor r2, r3, r6
    2ea0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2ea4: e2833018  add r3, r3, #24
    2ea8: e5933000  ldr r3, [r3]
    2eac: e0823003  add r3, r2, r3
    2eb0: e0833005  add r3, r3, r5
    2eb4: e3015d05  movw  r5, #7429 ; 0x1d05
    2eb8: e3405488  movt  r5, #1160 ; 0x488
    2ebc: e0835005  add r5, r3, r5
    2ec0: e1a054e5  ror r5, r5, #9
    2ec4: e0855007  add r5, r5, r7
  MD5_STEP( F3, a, b, c, d, intermediate[  9 ] + 0xd9d4d039,  4 );
    2ec8: e0253007  eor r3, r5, r7
    2ecc: e0232004  eor r2, r3, r4
    2ed0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2ed4: e2833024  add r3, r3, #36 ; 0x24
    2ed8: e5933000  ldr r3, [r3]
    2edc: e0823003  add r3, r2, r3
    2ee0: e0833006  add r3, r3, r6
    2ee4: e30d6039  movw  r6, #53305  ; 0xd039
    2ee8: e34d69d4  movt  r6, #55764  ; 0xd9d4
    2eec: e0836006  add r6, r3, r6
    2ef0: e1a06e66  ror r6, r6, #28
    2ef4: e0866005  add r6, r6, r5
  MD5_STEP( F3, d, a, b, c, intermediate[ 12 ] + 0xe6db99e5, 11 );
    2ef8: e0263005  eor r3, r6, r5
    2efc: e0232007  eor r2, r3, r7
    2f00: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2f04: e2833030  add r3, r3, #48 ; 0x30
    2f08: e5933000  ldr r3, [r3]
    2f0c: e0823003  add r3, r2, r3
    2f10: e0833004  add r3, r3, r4
    2f14: e30949e5  movw  r4, #39397  ; 0x99e5
    2f18: e34e46db  movt  r4, #59099  ; 0xe6db
    2f1c: e0834004  add r4, r3, r4
    2f20: e1a04ae4  ror r4, r4, #21
    2f24: e0844006  add r4, r4, r6
  MD5_STEP( F3, c, d, a, b, intermediate[ 15 ] + 0x1fa27cf8, 16 );
    2f28: e0243006  eor r3, r4, r6
    2f2c: e0232005  eor r2, r3, r5
    2f30: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2f34: e283303c  add r3, r3, #60 ; 0x3c
    2f38: e5933000  ldr r3, [r3]
    2f3c: e0823003  add r3, r2, r3
    2f40: e0833007  add r3, r3, r7
    2f44: e3077cf8  movw  r7, #31992  ; 0x7cf8
    2f48: e3417fa2  movt  r7, #8098 ; 0x1fa2
    2f4c: e0837007  add r7, r3, r7
    2f50: e1a07867  ror r7, r7, #16
    2f54: e0877004  add r7, r7, r4
  MD5_STEP( F3, b, c, d, a, intermediate[  2 ] + 0xc4ac5665, 23 );
    2f58: e0273004  eor r3, r7, r4
    2f5c: e0232006  eor r2, r3, r6
    2f60: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2f64: e2833008  add r3, r3, #8
    2f68: e5933000  ldr r3, [r3]
    2f6c: e0823003  add r3, r2, r3
    2f70: e0833005  add r3, r3, r5
    2f74: e3055665  movw  r5, #22117  ; 0x5665
    2f78: e34c54ac  movt  r5, #50348  ; 0xc4ac
    2f7c: e0835005  add r5, r3, r5
    2f80: e1a054e5  ror r5, r5, #9
    2f84: e0855007  add r5, r5, r7
  
  MD5_STEP( F4, a, b, c, d, intermediate[  0 ] + 0xf4292244,  6 );
    2f88: e1e03004  mvn r3, r4
    2f8c: e1833005  orr r3, r3, r5
    2f90: e0232007  eor r2, r3, r7
    2f94: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2f98: e5933000  ldr r3, [r3]
    2f9c: e0823003  add r3, r2, r3
    2fa0: e0833006  add r3, r3, r6
    2fa4: e3026244  movw  r6, #8772 ; 0x2244
    2fa8: e34f6429  movt  r6, #62505  ; 0xf429
    2fac: e0836006  add r6, r3, r6
    2fb0: e1a06d66  ror r6, r6, #26
    2fb4: e0866005  add r6, r6, r5
  MD5_STEP( F4, d, a, b, c, intermediate[  7 ] + 0x432aff97, 10 );
    2fb8: e1e03007  mvn r3, r7
    2fbc: e1833006  orr r3, r3, r6
    2fc0: e0232005  eor r2, r3, r5
    2fc4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2fc8: e283301c  add r3, r3, #28
    2fcc: e5933000  ldr r3, [r3]
    2fd0: e0823003  add r3, r2, r3
    2fd4: e0833004  add r3, r3, r4
    2fd8: e30f4f97  movw  r4, #65431  ; 0xff97
    2fdc: e344432a  movt  r4, #17194  ; 0x432a
    2fe0: e0834004  add r4, r3, r4
    2fe4: e1a04b64  ror r4, r4, #22
    2fe8: e0844006  add r4, r4, r6
  MD5_STEP( F4, c, d, a, b, intermediate[ 14 ] + 0xab9423a7, 15 );
    2fec: e1e03005  mvn r3, r5
    2ff0: e1833004  orr r3, r3, r4
    2ff4: e0232006  eor r2, r3, r6
    2ff8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    2ffc: e2833038  add r3, r3, #56 ; 0x38
    3000: e5933000  ldr r3, [r3]
    3004: e0823003  add r3, r2, r3
    3008: e0833007  add r3, r3, r7
    300c: e30273a7  movw  r7, #9127 ; 0x23a7
    3010: e34a7b94  movt  r7, #43924  ; 0xab94
    3014: e0837007  add r7, r3, r7
    3018: e1a078e7  ror r7, r7, #17
    301c: e0877004  add r7, r7, r4
  MD5_STEP( F4, b, c, d, a, intermediate[  5 ] + 0xfc93a039, 21 );
    3020: e1e03006  mvn r3, r6
    3024: e1833007  orr r3, r3, r7
    3028: e0232004  eor r2, r3, r4
    302c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3030: e2833014  add r3, r3, #20
    3034: e5933000  ldr r3, [r3]
    3038: e0823003  add r3, r2, r3
    303c: e0833005  add r3, r3, r5
    3040: e30a5039  movw  r5, #41017  ; 0xa039
    3044: e34f5c93  movt  r5, #64659  ; 0xfc93
    3048: e0835005  add r5, r3, r5
    304c: e1a055e5  ror r5, r5, #11
    3050: e0855007  add r5, r5, r7
  MD5_STEP( F4, a, b, c, d, intermediate[ 12 ] + 0x655b59c3,  6 );
    3054: e1e03004  mvn r3, r4
    3058: e1833005  orr r3, r3, r5
    305c: e0232007  eor r2, r3, r7
    3060: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3064: e2833030  add r3, r3, #48 ; 0x30
    3068: e5933000  ldr r3, [r3]
    306c: e0823003  add r3, r2, r3
    3070: e0833006  add r3, r3, r6
    3074: e30569c3  movw  r6, #22979  ; 0x59c3
    3078: e346655b  movt  r6, #25947  ; 0x655b
    307c: e0836006  add r6, r3, r6
    3080: e1a06d66  ror r6, r6, #26
    3084: e0866005  add r6, r6, r5
  MD5_STEP( F4, d, a, b, c, intermediate[  3 ] + 0x8f0ccc92, 10 );
    3088: e1e03007  mvn r3, r7
    308c: e1833006  orr r3, r3, r6
    3090: e0232005  eor r2, r3, r5
    3094: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3098: e283300c  add r3, r3, #12
    309c: e5933000  ldr r3, [r3]
    30a0: e0823003  add r3, r2, r3
    30a4: e0833004  add r3, r3, r4
    30a8: e30c4c92  movw  r4, #52370  ; 0xcc92
    30ac: e3484f0c  movt  r4, #36620  ; 0x8f0c
    30b0: e0834004  add r4, r3, r4
    30b4: e1a04b64  ror r4, r4, #22
    30b8: e0844006  add r4, r4, r6
  MD5_STEP( F4, c, d, a, b, intermediate[ 10 ] + 0xffeff47d, 15 );
    30bc: e1e03005  mvn r3, r5
    30c0: e1833004  orr r3, r3, r4
    30c4: e0232006  eor r2, r3, r6
    30c8: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    30cc: e2833028  add r3, r3, #40 ; 0x28
    30d0: e5933000  ldr r3, [r3]
    30d4: e0823003  add r3, r2, r3
    30d8: e0833007  add r3, r3, r7
    30dc: e30f747d  movw  r7, #62589  ; 0xf47d
    30e0: e34f7fef  movt  r7, #65519  ; 0xffef
    30e4: e0837007  add r7, r3, r7
    30e8: e1a078e7  ror r7, r7, #17
    30ec: e0877004  add r7, r7, r4
  MD5_STEP( F4, b, c, d, a, intermediate[  1 ] + 0x85845dd1, 21 );
    30f0: e1e03006  mvn r3, r6
    30f4: e1833007  orr r3, r3, r7
    30f8: e0232004  eor r2, r3, r4
    30fc: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3100: e2833004  add r3, r3, #4
    3104: e5933000  ldr r3, [r3]
    3108: e0823003  add r3, r2, r3
    310c: e0833005  add r3, r3, r5
    3110: e3055dd1  movw  r5, #24017  ; 0x5dd1
    3114: e3485584  movt  r5, #34180  ; 0x8584
    3118: e0835005  add r5, r3, r5
    311c: e1a055e5  ror r5, r5, #11
    3120: e0855007  add r5, r5, r7
  MD5_STEP( F4, a, b, c, d, intermediate[  8 ] + 0x6fa87e4f,  6 );
    3124: e1e03004  mvn r3, r4
    3128: e1833005  orr r3, r3, r5
    312c: e0232007  eor r2, r3, r7
    3130: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3134: e2833020  add r3, r3, #32
    3138: e5933000  ldr r3, [r3]
    313c: e0823003  add r3, r2, r3
    3140: e0833006  add r3, r3, r6
    3144: e3076e4f  movw  r6, #32335  ; 0x7e4f
    3148: e3466fa8  movt  r6, #28584  ; 0x6fa8
    314c: e0836006  add r6, r3, r6
    3150: e1a06d66  ror r6, r6, #26
    3154: e0866005  add r6, r6, r5
  MD5_STEP( F4, d, a, b, c, intermediate[ 15 ] + 0xfe2ce6e0, 10 );
    3158: e1e03007  mvn r3, r7
    315c: e1833006  orr r3, r3, r6
    3160: e0232005  eor r2, r3, r5
    3164: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3168: e283303c  add r3, r3, #60 ; 0x3c
    316c: e5933000  ldr r3, [r3]
    3170: e0823003  add r3, r2, r3
    3174: e0833004  add r3, r3, r4
    3178: e30e46e0  movw  r4, #59104  ; 0xe6e0
    317c: e34f4e2c  movt  r4, #65068  ; 0xfe2c
    3180: e0834004  add r4, r3, r4
    3184: e1a04b64  ror r4, r4, #22
    3188: e0844006  add r4, r4, r6
  MD5_STEP( F4, c, d, a, b, intermediate[  6 ] + 0xa3014314, 15 );
    318c: e1e03005  mvn r3, r5
    3190: e1833004  orr r3, r3, r4
    3194: e0232006  eor r2, r3, r6
    3198: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    319c: e2833018  add r3, r3, #24
    31a0: e5933000  ldr r3, [r3]
    31a4: e0823003  add r3, r2, r3
    31a8: e0833007  add r3, r3, r7
    31ac: e3047314  movw  r7, #17172  ; 0x4314
    31b0: e34a7301  movt  r7, #41729  ; 0xa301
    31b4: e0837007  add r7, r3, r7
    31b8: e1a078e7  ror r7, r7, #17
    31bc: e0877004  add r7, r7, r4
  MD5_STEP( F4, b, c, d, a, intermediate[ 13 ] + 0x4e0811a1, 21 );
    31c0: e1e03006  mvn r3, r6
    31c4: e1833007  orr r3, r3, r7
    31c8: e0232004  eor r2, r3, r4
    31cc: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    31d0: e2833034  add r3, r3, #52 ; 0x34
    31d4: e5933000  ldr r3, [r3]
    31d8: e0823003  add r3, r2, r3
    31dc: e0833005  add r3, r3, r5
    31e0: e30151a1  movw  r5, #4513 ; 0x11a1
    31e4: e3445e08  movt  r5, #19976  ; 0x4e08
    31e8: e0835005  add r5, r3, r5
    31ec: e1a055e5  ror r5, r5, #11
    31f0: e0855007  add r5, r5, r7
  MD5_STEP( F4, a, b, c, d, intermediate[  4 ] + 0xf7537e82,  6 );
    31f4: e1e03004  mvn r3, r4
    31f8: e1833005  orr r3, r3, r5
    31fc: e0232007  eor r2, r3, r7
    3200: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3204: e2833010  add r3, r3, #16
    3208: e5933000  ldr r3, [r3]
    320c: e0823003  add r3, r2, r3
    3210: e0833006  add r3, r3, r6
    3214: e3076e82  movw  r6, #32386  ; 0x7e82
    3218: e34f6753  movt  r6, #63315  ; 0xf753
    321c: e0836006  add r6, r3, r6
    3220: e1a06d66  ror r6, r6, #26
    3224: e0866005  add r6, r6, r5
  MD5_STEP( F4, d, a, b, c, intermediate[ 11 ] + 0xbd3af235, 10 );
    3228: e1e03007  mvn r3, r7
    322c: e1833006  orr r3, r3, r6
    3230: e0232005  eor r2, r3, r5
    3234: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3238: e283302c  add r3, r3, #44 ; 0x2c
    323c: e5933000  ldr r3, [r3]
    3240: e0823003  add r3, r2, r3
    3244: e0833004  add r3, r3, r4
    3248: e30f4235  movw  r4, #62005  ; 0xf235
    324c: e34b4d3a  movt  r4, #48442  ; 0xbd3a
    3250: e0834004  add r4, r3, r4
    3254: e1a04b64  ror r4, r4, #22
    3258: e0844006  add r4, r4, r6
  MD5_STEP( F4, c, d, a, b, intermediate[  2 ] + 0x2ad7d2bb, 15 );
    325c: e1e03005  mvn r3, r5
    3260: e1833004  orr r3, r3, r4
    3264: e0232006  eor r2, r3, r6
    3268: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    326c: e2833008  add r3, r3, #8
    3270: e5933000  ldr r3, [r3]
    3274: e0823003  add r3, r2, r3
    3278: e0833007  add r3, r3, r7
    327c: e30d72bb  movw  r7, #53947  ; 0xd2bb
    3280: e3427ad7  movt  r7, #10967  ; 0x2ad7
    3284: e0837007  add r7, r3, r7
    3288: e1a078e7  ror r7, r7, #17
    328c: e0877004  add r7, r7, r4
  MD5_STEP( F4, b, c, d, a, intermediate[  9 ] + 0xeb86d391, 21 );
    3290: e1e03006  mvn r3, r6
    3294: e1833007  orr r3, r3, r7
    3298: e0232004  eor r2, r3, r4
    329c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    32a0: e2833024  add r3, r3, #36 ; 0x24
    32a4: e5933000  ldr r3, [r3]
    32a8: e0823003  add r3, r2, r3
    32ac: e0833005  add r3, r3, r5
    32b0: e30d5391  movw  r5, #54161  ; 0xd391
    32b4: e34e5b86  movt  r5, #60294  ; 0xeb86
    32b8: e0835005  add r5, r3, r5
    32bc: e1a055e5  ror r5, r5, #11
    32c0: e0855007  add r5, r5, r7

  buffer[ 0 ] += a;
    32c4: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    32c8: e5933000  ldr r3, [r3]
    32cc: e0832006  add r2, r3, r6
    32d0: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    32d4: e5832000  str r2, [r3]
  buffer[ 1 ] += b;
    32d8: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    32dc: e2833004  add r3, r3, #4
    32e0: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    32e4: e2822004  add r2, r2, #4
    32e8: e5922000  ldr r2, [r2]
    32ec: e0822005  add r2, r2, r5
    32f0: e5832000  str r2, [r3]
  buffer[ 2 ] += c;
    32f4: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    32f8: e2833008  add r3, r3, #8
    32fc: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    3300: e2822008  add r2, r2, #8
    3304: e5922000  ldr r2, [r2]
    3308: e0822007  add r2, r2, r7
    330c: e5832000  str r2, [r3]
  buffer[ 3 ] += d;
    3310: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    3314: e283300c  add r3, r3, #12
    3318: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    331c: e282200c  add r2, r2, #12
    3320: e5922000  ldr r2, [r2]
    3324: e0822004  add r2, r2, r4
    3328: e5832000  str r2, [r3]
  
}
    332c: e24bd010  sub sp, fp, #16
    3330: e8bd08f0  pop {r4, r5, r6, r7, fp}
    3334: e12fff1e  bx  lr

00003338 <MD5Init>:
*
* @note   None
*
****************************************************************************/
inline void MD5Init( MD5Context *context )
{
    3338: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    333c: e28db000  add fp, sp, #0
    3340: e24dd00c  sub sp, sp, #12
    3344: e50b0008  str r0, [fp, #-8]
  
  context->buffer[ 0 ] = 0x67452301;
    3348: e51b2008  ldr r2, [fp, #-8]
    334c: e3023301  movw  r3, #8961 ; 0x2301
    3350: e3463745  movt  r3, #26437  ; 0x6745
    3354: e5823000  str r3, [r2]
  context->buffer[ 1 ] = 0xefcdab89;
    3358: e51b2008  ldr r2, [fp, #-8]
    335c: e30a3b89  movw  r3, #43913  ; 0xab89
    3360: e34e3fcd  movt  r3, #61389  ; 0xefcd
    3364: e5823004  str r3, [r2, #4]
  context->buffer[ 2 ] = 0x98badcfe;
    3368: e51b2008  ldr r2, [fp, #-8]
    336c: e30d3cfe  movw  r3, #56574  ; 0xdcfe
    3370: e34938ba  movt  r3, #39098  ; 0x98ba
    3374: e5823008  str r3, [r2, #8]
  context->buffer[ 3 ] = 0x10325476;
    3378: e51b2008  ldr r2, [fp, #-8]
    337c: e3053476  movw  r3, #21622  ; 0x5476
    3380: e3413032  movt  r3, #4146 ; 0x1032
    3384: e582300c  str r3, [r2, #12]

  context->bits[ 0 ] = 0;
    3388: e51b3008  ldr r3, [fp, #-8]
    338c: e3a02000  mov r2, #0
    3390: e5832010  str r2, [r3, #16]
  context->bits[ 1 ] = 0;
    3394: e51b3008  ldr r3, [fp, #-8]
    3398: e3a02000  mov r2, #0
    339c: e5832014  str r2, [r3, #20]
  
}
    33a0: e24bd000  sub sp, fp, #0
    33a4: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    33a8: e12fff1e  bx  lr

000033ac <MD5Update>:
* @note   None
*
****************************************************************************/
inline void MD5Update( MD5Context *context, u8 *buffer,
       u32 len, boolean doByteSwap )
{
    33ac: e92d4830  push  {r4, r5, fp, lr}
    33b0: e28db00c  add fp, sp, #12
    33b4: e24dd010  sub sp, sp, #16
    33b8: e50b0010  str r0, [fp, #-16]
    33bc: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    33c0: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
    33c4: e54b3019  strb  r3, [fp, #-25]  ; 0xffffffe7
  
  /*
   * Update bitcount
   */

  temp = context->bits[ 0 ];
    33c8: e51b3010  ldr r3, [fp, #-16]
    33cc: e5934010  ldr r4, [r3, #16]
  
  if( ( context->bits[ 0 ] = temp + ( (u32)len << 3 ) ) < temp ) {
    33d0: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    33d4: e1a03183  lsl r3, r3, #3
    33d8: e0832004  add r2, r3, r4
    33dc: e51b3010  ldr r3, [fp, #-16]
    33e0: e5832010  str r2, [r3, #16]
    33e4: e51b3010  ldr r3, [fp, #-16]
    33e8: e5933010  ldr r3, [r3, #16]
    33ec: e1530004  cmp r3, r4
    33f0: 2a000004  bcs 3408 <MD5Update+0x5c>
    /*
     * Carry from low to high
     */
    context->bits[ 1 ]++;
    33f4: e51b3010  ldr r3, [fp, #-16]
    33f8: e5933014  ldr r3, [r3, #20]
    33fc: e2832001  add r2, r3, #1
    3400: e51b3010  ldr r3, [fp, #-16]
    3404: e5832014  str r2, [r3, #20]
  }
    
  context->bits[ 1 ] += len >> 29;
    3408: e51b3010  ldr r3, [fp, #-16]
    340c: e5932014  ldr r2, [r3, #20]
    3410: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    3414: e1a03ea3  lsr r3, r3, #29
    3418: e0822003  add r2, r2, r3
    341c: e51b3010  ldr r3, [fp, #-16]
    3420: e5832014  str r2, [r3, #20]
  
  /*
   * Bytes already in shsInfo->data
   */
  
  temp = ( temp >> 3 ) & 0x3f;
    3424: e1a031a4  lsr r3, r4, #3
    3428: e203403f  and r4, r3, #63 ; 0x3f

  /*
   * Handle any leading odd-sized chunks
   */

  if( temp ) {
    342c: e3540000  cmp r4, #0
    3430: 0a00001d  beq 34ac <MD5Update+0x100>
    p = (u8 *)context->intermediate + temp;
    3434: e2843018  add r3, r4, #24
    3438: e51b2010  ldr r2, [fp, #-16]
    343c: e0825003  add r5, r2, r3

    temp = MD5_SIGNATURE_BYTE_SIZE - temp;
    3440: e2644040  rsb r4, r4, #64 ; 0x40
    
    if( len < temp ) {
    3444: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    3448: e1530004  cmp r3, r4
    344c: 2a000005  bcs 3468 <MD5Update+0xbc>
      MD5Memcpy( p, buffer, len, doByteSwap );
    3450: e55b3019  ldrb  r3, [fp, #-25]  ; 0xffffffe7
    3454: e1a00005  mov r0, r5
    3458: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    345c: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    3460: ebfffc2b  bl  2514 <MD5Memcpy>
      return;
    3464: ea00002e  b 3524 <MD5Update+0x178>
    }
    
    MD5Memcpy( p, buffer, temp, doByteSwap );
    3468: e55b3019  ldrb  r3, [fp, #-25]  ; 0xffffffe7
    346c: e1a00005  mov r0, r5
    3470: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    3474: e1a02004  mov r2, r4
    3478: ebfffc25  bl  2514 <MD5Memcpy>
    
    MD5Transform( context->buffer, (u32 *)context->intermediate );
    347c: e51b2010  ldr r2, [fp, #-16]
    3480: e51b3010  ldr r3, [fp, #-16]
    3484: e2833018  add r3, r3, #24
    3488: e1a00002  mov r0, r2
    348c: e1a01003  mov r1, r3
    3490: ebfffc53  bl  25e4 <MD5Transform>
    
    buffer += temp;
    3494: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    3498: e0833004  add r3, r3, r4
    349c: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
    len    -= temp;
    34a0: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    34a4: e0643003  rsb r3, r4, r3
    34a8: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
    
  /*
   * Process data in 64-byte, 512 bit, chunks
   */

  while( len >= MD5_SIGNATURE_BYTE_SIZE ) {
    34ac: ea000012  b 34fc <MD5Update+0x150>
    MD5Memcpy( context->intermediate, buffer, MD5_SIGNATURE_BYTE_SIZE,
    34b0: e51b3010  ldr r3, [fp, #-16]
    34b4: e2832018  add r2, r3, #24
    34b8: e55b3019  ldrb  r3, [fp, #-25]  ; 0xffffffe7
    34bc: e1a00002  mov r0, r2
    34c0: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    34c4: e3a02040  mov r2, #64 ; 0x40
    34c8: ebfffc11  bl  2514 <MD5Memcpy>
         doByteSwap );
    
    MD5Transform( context->buffer, (u32 *)context->intermediate );
    34cc: e51b2010  ldr r2, [fp, #-16]
    34d0: e51b3010  ldr r3, [fp, #-16]
    34d4: e2833018  add r3, r3, #24
    34d8: e1a00002  mov r0, r2
    34dc: e1a01003  mov r1, r3
    34e0: ebfffc3f  bl  25e4 <MD5Transform>
    
    buffer += MD5_SIGNATURE_BYTE_SIZE;
    34e4: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    34e8: e2833040  add r3, r3, #64 ; 0x40
    34ec: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
    len    -= MD5_SIGNATURE_BYTE_SIZE;
    34f0: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    34f4: e2433040  sub r3, r3, #64 ; 0x40
    34f8: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
    
  /*
   * Process data in 64-byte, 512 bit, chunks
   */

  while( len >= MD5_SIGNATURE_BYTE_SIZE ) {
    34fc: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    3500: e353003f  cmp r3, #63 ; 0x3f
    3504: 8affffe9  bhi 34b0 <MD5Update+0x104>
  }

  /*
   * Handle any remaining bytes of data
   */
  MD5Memcpy( context->intermediate, buffer, len, doByteSwap );
    3508: e51b3010  ldr r3, [fp, #-16]
    350c: e2832018  add r2, r3, #24
    3510: e55b3019  ldrb  r3, [fp, #-25]  ; 0xffffffe7
    3514: e1a00002  mov r0, r2
    3518: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    351c: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    3520: ebfffbfb  bl  2514 <MD5Memcpy>
  
}
    3524: e24bd00c  sub sp, fp, #12
    3528: e8bd8830  pop {r4, r5, fp, pc}

0000352c <MD5Final>:
* @note   None
*
****************************************************************************/
inline void MD5Final( MD5Context *context, u8 *digest,
      boolean doByteSwap )
{
    352c: e92d4800  push  {fp, lr}
    3530: e28db004  add fp, sp, #4
    3534: e24dd018  sub sp, sp, #24
    3538: e50b0010  str r0, [fp, #-16]
    353c: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    3540: e1a03002  mov r3, r2
    3544: e54b3015  strb  r3, [fp, #-21]  ; 0xffffffeb
  u8 *  p;
  
  /*
   * Compute number of bytes mod 64
   */
  count = ( context->bits[ 0 ] >> 3 ) & 0x3F;
    3548: e51b3010  ldr r3, [fp, #-16]
    354c: e5933010  ldr r3, [r3, #16]
    3550: e1a031a3  lsr r3, r3, #3
    3554: e203303f  and r3, r3, #63 ; 0x3f
    3558: e50b3008  str r3, [fp, #-8]

  /*
   * Set the first char of padding to 0x80. This is safe since there is
   * always at least one byte free
   */
  p = context->intermediate + count;
    355c: e51b3008  ldr r3, [fp, #-8]
    3560: e2833018  add r3, r3, #24
    3564: e51b2010  ldr r2, [fp, #-16]
    3568: e0823003  add r3, r2, r3
    356c: e50b300c  str r3, [fp, #-12]
  *p++ = 0x80;
    3570: e51b300c  ldr r3, [fp, #-12]
    3574: e2832001  add r2, r3, #1
    3578: e50b200c  str r2, [fp, #-12]
    357c: e3e0207f  mvn r2, #127  ; 0x7f
    3580: e5c32000  strb  r2, [r3]

  /*
   * Bytes of padding needed to make 64 bytes
   */
  count = MD5_SIGNATURE_BYTE_SIZE - 1 - count;
    3584: e51b3008  ldr r3, [fp, #-8]
    3588: e263303f  rsb r3, r3, #63 ; 0x3f
    358c: e50b3008  str r3, [fp, #-8]

  /*
   * Pad out to 56 mod 64
   */
  if( count < 8 ) {
    3590: e51b3008  ldr r3, [fp, #-8]
    3594: e3530007  cmp r3, #7
    3598: 8a000010  bhi 35e0 <MD5Final+0xb4>
    /*
     * Two lots of padding: Pad the first block to 64 bytes
     */
    MD5Memset( p, 0, count );
    359c: e51b000c  ldr r0, [fp, #-12]
    35a0: e3a01000  mov r1, #0
    35a4: e51b2008  ldr r2, [fp, #-8]
    35a8: ebfffbc2  bl  24b8 <MD5Memset>
    
    MD5Transform( context->buffer, (u32 *)context->intermediate );
    35ac: e51b2010  ldr r2, [fp, #-16]
    35b0: e51b3010  ldr r3, [fp, #-16]
    35b4: e2833018  add r3, r3, #24
    35b8: e1a00002  mov r0, r2
    35bc: e1a01003  mov r1, r3
    35c0: ebfffc07  bl  25e4 <MD5Transform>

    /*
     * Now fill the next block with 56 bytes
     */
    MD5Memset( context->intermediate, 0, 56 );
    35c4: e51b3010  ldr r3, [fp, #-16]
    35c8: e2833018  add r3, r3, #24
    35cc: e1a00003  mov r0, r3
    35d0: e3a01000  mov r1, #0
    35d4: e3a02038  mov r2, #56 ; 0x38
    35d8: ebfffbb6  bl  24b8 <MD5Memset>
    35dc: ea000005  b 35f8 <MD5Final+0xcc>
  } else {
    /*
     * Pad block to 56 bytes
     */
    MD5Memset( p, 0, count - 8 );
    35e0: e51b3008  ldr r3, [fp, #-8]
    35e4: e2433008  sub r3, r3, #8
    35e8: e51b000c  ldr r0, [fp, #-12]
    35ec: e3a01000  mov r1, #0
    35f0: e1a02003  mov r2, r3
    35f4: ebfffbaf  bl  24b8 <MD5Memset>
  }

  /*
   * Append length in bits and transform
   */
  ( (u32 *)context->intermediate )[ 14 ] = context->bits[ 0 ];
    35f8: e51b3010  ldr r3, [fp, #-16]
    35fc: e2833050  add r3, r3, #80 ; 0x50
    3600: e51b2010  ldr r2, [fp, #-16]
    3604: e5922010  ldr r2, [r2, #16]
    3608: e5832000  str r2, [r3]
  ( (u32 *)context->intermediate )[ 15 ] = context->bits[ 1 ];
    360c: e51b3010  ldr r3, [fp, #-16]
    3610: e2833054  add r3, r3, #84 ; 0x54
    3614: e51b2010  ldr r2, [fp, #-16]
    3618: e5922014  ldr r2, [r2, #20]
    361c: e5832000  str r2, [r3]

  MD5Transform( context->buffer, (u32 *)context->intermediate );
    3620: e51b2010  ldr r2, [fp, #-16]
    3624: e51b3010  ldr r3, [fp, #-16]
    3628: e2833018  add r3, r3, #24
    362c: e1a00002  mov r0, r2
    3630: e1a01003  mov r1, r3
    3634: ebfffbea  bl  25e4 <MD5Transform>
  
  /*
   * Now return the digest
   */
  MD5Memcpy( digest, context->buffer, 16, doByteSwap );
    3638: e51b2010  ldr r2, [fp, #-16]
    363c: e55b3015  ldrb  r3, [fp, #-21]  ; 0xffffffeb
    3640: e51b0014  ldr r0, [fp, #-20]  ; 0xffffffec
    3644: e1a01002  mov r1, r2
    3648: e3a02010  mov r2, #16
    364c: ebfffbb0  bl  2514 <MD5Memcpy>
}
    3650: e24bd004  sub sp, fp, #4
    3654: e8bd8800  pop {fp, pc}

00003658 <md5>:
*
* @note   None
*
****************************************************************************/
void md5( u8 *input, u32 len, u8 *digest, boolean doByteSwap )
{
    3658: e92d4800  push  {fp, lr}
    365c: e28db004  add fp, sp, #4
    3660: e24dd068  sub sp, sp, #104  ; 0x68
    3664: e50b0060  str r0, [fp, #-96]  ; 0xffffffa0
    3668: e50b1064  str r1, [fp, #-100] ; 0xffffff9c
    366c: e50b2068  str r2, [fp, #-104] ; 0xffffff98
    3670: e54b3069  strb  r3, [fp, #-105] ; 0xffffff97
  MD5Context context;

  MD5Init( &context );
    3674: e24b305c  sub r3, fp, #92 ; 0x5c
    3678: e1a00003  mov r0, r3
    367c: ebffff2d  bl  3338 <MD5Init>
  
  MD5Update( &context, input, len, doByteSwap );
    3680: e24b205c  sub r2, fp, #92 ; 0x5c
    3684: e55b3069  ldrb  r3, [fp, #-105] ; 0xffffff97
    3688: e1a00002  mov r0, r2
    368c: e51b1060  ldr r1, [fp, #-96]  ; 0xffffffa0
    3690: e51b2064  ldr r2, [fp, #-100] ; 0xffffff9c
    3694: ebffff44  bl  33ac <MD5Update>
  
  MD5Final( &context, digest, doByteSwap );
    3698: e24b205c  sub r2, fp, #92 ; 0x5c
    369c: e55b3069  ldrb  r3, [fp, #-105] ; 0xffffff97
    36a0: e1a00002  mov r0, r2
    36a4: e51b1068  ldr r1, [fp, #-104] ; 0xffffff98
    36a8: e1a02003  mov r2, r3
    36ac: ebffff9e  bl  352c <MD5Final>
}
    36b0: e24bd004  sub sp, fp, #4
    36b4: e8bd8800  pop {fp, pc}

000036b8 <InitNor>:
*
* @note   None.
*
****************************************************************************/
void InitNor(void)
{
    36b8: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    36bc: e28db000  add fp, sp, #0

  /*
   * Set up the base address for access
   */
  FlashReadBaseAddress = XPS_NOR_BASEADDR;
    36c0: e301305c  movw  r3, #4188 ; 0x105c
    36c4: e3403002  movt  r3, #2
    36c8: e3a024e2  mov r2, #-503316480 ; 0xe2000000
    36cc: e5832000  str r2, [r3]
}
    36d0: e24bd000  sub sp, fp, #0
    36d4: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    36d8: e12fff1e  bx  lr

000036dc <NorAccess>:
*
* @note   None.
*
****************************************************************************/
u32 NorAccess(u32 SourceAddress, u32 DestinationAddress, u32 LengthBytes)
{
    36dc: e92d4800  push  {fp, lr}
    36e0: e28db004  add fp, sp, #4
    36e4: e24dd028  sub sp, sp, #40 ; 0x28
    36e8: e50b0020  str r0, [fp, #-32]  ; 0xffffffe0
    36ec: e50b1024  str r1, [fp, #-36]  ; 0xffffffdc
    36f0: e50b2028  str r2, [fp, #-40]  ; 0xffffffd8

  /*
   * check for non-word tail
   * add bytes to cover the end
   */
  if ((LengthBytes%4) != 0){
    36f4: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    36f8: e2033003  and r3, r3, #3
    36fc: e3530000  cmp r3, #0
    3700: 0a000003  beq 3714 <NorAccess+0x38>

    LengthBytes += (4 - (LengthBytes & 0x00000003));
    3704: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    3708: e3c33003  bic r3, r3, #3
    370c: e2833004  add r3, r3, #4
    3710: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
  }

  LengthWords = LengthBytes >> WORD_LENGTH_SHIFT;
    3714: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    3718: e1a03123  lsr r3, r3, #2
    371c: e50b3014  str r3, [fp, #-20]  ; 0xffffffec

  SourceAddr = (u32 *)(SourceAddress + FlashReadBaseAddress);
    3720: e301305c  movw  r3, #4188 ; 0x105c
    3724: e3403002  movt  r3, #2
    3728: e5932000  ldr r2, [r3]
    372c: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    3730: e0823003  add r3, r2, r3
    3734: e50b300c  str r3, [fp, #-12]
  DestAddr = (u32 *)(DestinationAddress);
    3738: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    373c: e50b3010  str r3, [fp, #-16]

  /*
   * Word transfers, endianism isn't an issue
   */
  for (Count=0; Count < LengthWords; Count++){
    3740: e3a03000  mov r3, #0
    3744: e50b3008  str r3, [fp, #-8]
    3748: ea00000e  b 3788 <NorAccess+0xac>

    Data = Xil_In32((u32)(SourceAddr++));
    374c: e51b300c  ldr r3, [fp, #-12]
    3750: e2832004  add r2, r3, #4
    3754: e50b200c  str r2, [fp, #-12]
    3758: e1a00003  mov r0, r3
    375c: eb000a8d  bl  6198 <Xil_In32>
    3760: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
    Xil_Out32((u32)(DestAddr++), Data);
    3764: e51b3010  ldr r3, [fp, #-16]
    3768: e2832004  add r2, r3, #4
    376c: e50b2010  str r2, [fp, #-16]
    3770: e1a00003  mov r0, r3
    3774: e51b1018  ldr r1, [fp, #-24]  ; 0xffffffe8
    3778: eb000a8c  bl  61b0 <Xil_Out32>
  DestAddr = (u32 *)(DestinationAddress);

  /*
   * Word transfers, endianism isn't an issue
   */
  for (Count=0; Count < LengthWords; Count++){
    377c: e51b3008  ldr r3, [fp, #-8]
    3780: e2833001  add r3, r3, #1
    3784: e50b3008  str r3, [fp, #-8]
    3788: e51b2008  ldr r2, [fp, #-8]
    378c: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    3790: e1520003  cmp r2, r3
    3794: 3affffec  bcc 374c <NorAccess+0x70>

    Data = Xil_In32((u32)(SourceAddr++));
    Xil_Out32((u32)(DestAddr++), Data);
  }

  return XST_SUCCESS;
    3798: e3a03000  mov r3, #0
}
    379c: e1a00003  mov r0, r3
    37a0: e24bd004  sub sp, fp, #4
    37a4: e8bd8800  pop {fp, pc}

000037a8 <PcapDataTransfer>:
* @note    None
*
****************************************************************************/
u32 PcapDataTransfer(u32 *SourceDataPtr, u32 *DestinationDataPtr,
        u32 SourceLength, u32 DestinationLength, u32 SecureTransfer)
{
    37a8: e92d4800  push  {fp, lr}
    37ac: e28db004  add fp, sp, #4
    37b0: e24dd028  sub sp, sp, #40 ; 0x28
    37b4: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
    37b8: e50b101c  str r1, [fp, #-28]  ; 0xffffffe4
    37bc: e50b2020  str r2, [fp, #-32]  ; 0xffffffe0
    37c0: e50b3024  str r3, [fp, #-36]  ; 0xffffffdc
  u32 Status;
  u32 IntrStsReg;
  u32 PcapTransferType = XDCFG_CONCURRENT_NONSEC_READ_WRITE;
    37c4: e3a03005  mov r3, #5
    37c8: e50b3008  str r3, [fp, #-8]

  /*
   * Check for secure transfer
   */
  if (SecureTransfer) {
    37cc: e59b3004  ldr r3, [fp, #4]
    37d0: e3530000  cmp r3, #0
    37d4: 0a000001  beq 37e0 <PcapDataTransfer+0x38>
    PcapTransferType = XDCFG_CONCURRENT_SECURE_READ_WRITE;
    37d8: e3a03004  mov r3, #4
    37dc: e50b3008  str r3, [fp, #-8]
#endif

  /*
   * Clear the PCAP status registers
   */
  Status = ClearPcapStatus();
    37e0: eb000146  bl  3d00 <ClearPcapStatus>
    37e4: e50b000c  str r0, [fp, #-12]
  if (Status != XST_SUCCESS) {
    37e8: e51b300c  ldr r3, [fp, #-12]
    37ec: e3530000  cmp r3, #0
    37f0: 0a000004  beq 3808 <PcapDataTransfer+0x60>
    fsbl_printf(DEBUG_INFO,"PCAP_CLEAR_STATUS_FAIL \r\n");
    37f4: e3070e2c  movw  r0, #32300  ; 0x7e2c
    37f8: e3400001  movt  r0, #1
    37fc: eb000aff  bl  6400 <xil_printf>
    return XST_FAILURE;
    3800: e3a03001  mov r3, #1
    3804: ea00003f  b 3908 <PcapDataTransfer+0x160>
#endif

  /*
   * PCAP single DMA transfer setup
   */
  SourceDataPtr = (u32*)((u32)SourceDataPtr | PCAP_LAST_TRANSFER);
    3808: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    380c: e3833001  orr r3, r3, #1
    3810: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
  DestinationDataPtr = (u32*)((u32)DestinationDataPtr | PCAP_LAST_TRANSFER);
    3814: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3818: e3833001  orr r3, r3, #1
    381c: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4

  /*
   * Transfer using Device Configuration
   */
  Status = XDcfg_Transfer(DcfgInstPtr, (u8 *)SourceDataPtr,
    3820: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3824: e3403002  movt  r3, #2
    3828: e5932000  ldr r2, [r3]
    382c: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    3830: e58d3000  str r3, [sp]
    3834: e51b3008  ldr r3, [fp, #-8]
    3838: e58d3004  str r3, [sp, #4]
    383c: e1a00002  mov r0, r2
    3840: e51b1018  ldr r1, [fp, #-24]  ; 0xffffffe8
    3844: e51b2020  ldr r2, [fp, #-32]  ; 0xffffffe0
    3848: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    384c: eb000e96  bl  72ac <XDcfg_Transfer>
    3850: e50b000c  str r0, [fp, #-12]
          SourceLength,
          (u8 *)DestinationDataPtr,
          DestinationLength, PcapTransferType);
  if (Status != XST_SUCCESS) {
    3854: e51b300c  ldr r3, [fp, #-12]
    3858: e3530000  cmp r3, #0
    385c: 0a000005  beq 3878 <PcapDataTransfer+0xd0>
    fsbl_printf(DEBUG_INFO,"Status of XDcfg_Transfer = %d \r \n",Status);
    3860: e3070e48  movw  r0, #32328  ; 0x7e48
    3864: e3400001  movt  r0, #1
    3868: e51b100c  ldr r1, [fp, #-12]
    386c: eb000ae3  bl  6400 <xil_printf>
    return XST_FAILURE;
    3870: e3a03001  mov r3, #1
    3874: ea000023  b 3908 <PcapDataTransfer+0x160>
  }

  /*
   * Dump the PCAP registers
   */
  PcapDumpRegisters();
    3878: eb00017c  bl  3e70 <PcapDumpRegisters>

  /*
   * Poll for the DMA done
   */
  Status = XDcfgPollDone(XDCFG_IXR_DMA_DONE_MASK, MAX_COUNT);
    387c: e3a00a02  mov r0, #8192 ; 0x2000
    3880: e3a01cca  mov r1, #51712  ; 0xca00
    3884: e3431b9a  movt  r1, #15258  ; 0x3b9a
    3888: eb000214  bl  40e0 <XDcfgPollDone>
    388c: e1a03000  mov r3, r0
    3890: e50b300c  str r3, [fp, #-12]
  if (Status != XST_SUCCESS) {
    3894: e51b300c  ldr r3, [fp, #-12]
    3898: e3530000  cmp r3, #0
    389c: 0a000004  beq 38b4 <PcapDataTransfer+0x10c>
    fsbl_printf(DEBUG_INFO,"PCAP_DMA_DONE_FAIL \r\n");
    38a0: e3070e6c  movw  r0, #32364  ; 0x7e6c
    38a4: e3400001  movt  r0, #1
    38a8: eb000ad4  bl  6400 <xil_printf>
    return XST_FAILURE;
    38ac: e3a03001  mov r3, #1
    38b0: ea000014  b 3908 <PcapDataTransfer+0x160>
  }

  fsbl_printf(DEBUG_INFO,"DMA Done ! \n\r");
    38b4: e3070e84  movw  r0, #32388  ; 0x7e84
    38b8: e3400001  movt  r0, #1
    38bc: eb000acf  bl  6400 <xil_printf>
    
  /*
   * Check for errors
   */
  IntrStsReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    38c0: e3013a8c  movw  r3, #6796 ; 0x1a8c
    38c4: e3403002  movt  r3, #2
    38c8: e5933000  ldr r3, [r3]
    38cc: e1a00003  mov r0, r3
    38d0: eb000f90  bl  7718 <XDcfg_IntrGetStatus>
    38d4: e50b0010  str r0, [fp, #-16]
  if (IntrStsReg & FSBL_XDCFG_IXR_ERROR_FLAGS_MASK) {
    38d8: e51b2010  ldr r2, [fp, #-16]
    38dc: e30c3840  movw  r3, #51264  ; 0xc840
    38e0: e3403074  movt  r3, #116  ; 0x74
    38e4: e0033002  and r3, r3, r2
    38e8: e3530000  cmp r3, #0
    38ec: 0a000004  beq 3904 <PcapDataTransfer+0x15c>
    fsbl_printf(DEBUG_INFO,"Errors in PCAP \r\n");
    38f0: e3070e94  movw  r0, #32404  ; 0x7e94
    38f4: e3400001  movt  r0, #1
    38f8: eb000ac0  bl  6400 <xil_printf>
    return XST_FAILURE;
    38fc: e3a03001  mov r3, #1
    3900: ea000000  b 3908 <PcapDataTransfer+0x160>
  XTime tXferEnd = 0;
  fsbl_printf(DEBUG_GENERAL,"Time taken is ");
  FsblMeasurePerfTime(tXferCur,tXferEnd);
#endif

  return XST_SUCCESS;
    3904: e3a03000  mov r3, #0
}
    3908: e1a00003  mov r0, r3
    390c: e24bd004  sub sp, fp, #4
    3910: e8bd8800  pop {fp, pc}

00003914 <PcapLoadPartition>:
* @note    None
*
****************************************************************************/
u32 PcapLoadPartition(u32 *SourceDataPtr, u32 *DestinationDataPtr,
    u32 SourceLength, u32 DestinationLength, u32 SecureTransfer)
{
    3914: e92d4800  push  {fp, lr}
    3918: e28db004  add fp, sp, #4
    391c: e24dd028  sub sp, sp, #40 ; 0x28
    3920: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
    3924: e50b101c  str r1, [fp, #-28]  ; 0xffffffe4
    3928: e50b2020  str r2, [fp, #-32]  ; 0xffffffe0
    392c: e50b3024  str r3, [fp, #-36]  ; 0xffffffdc
  u32 Status;
  u32 IntrStsReg;
  u32 PcapTransferType = XDCFG_NON_SECURE_PCAP_WRITE;
    3930: e3a03001  mov r3, #1
    3934: e50b3008  str r3, [fp, #-8]

  /*
   * Check for secure transfer
   */
  if (SecureTransfer) {
    3938: e59b3004  ldr r3, [fp, #4]
    393c: e3530000  cmp r3, #0
    3940: 0a000001  beq 394c <PcapLoadPartition+0x38>
    PcapTransferType = XDCFG_SECURE_PCAP_WRITE;
    3944: e3a03002  mov r3, #2
    3948: e50b3008  str r3, [fp, #-8]
#endif

  /*
   * Clear the PCAP status registers
   */
  Status = ClearPcapStatus();
    394c: eb0000eb  bl  3d00 <ClearPcapStatus>
    3950: e50b000c  str r0, [fp, #-12]
  if (Status != XST_SUCCESS) {
    3954: e51b300c  ldr r3, [fp, #-12]
    3958: e3530000  cmp r3, #0
    395c: 0a000004  beq 3974 <PcapLoadPartition+0x60>
    fsbl_printf(DEBUG_INFO,"PCAP_CLEAR_STATUS_FAIL \r\n");
    3960: e3070e2c  movw  r0, #32300  ; 0x7e2c
    3964: e3400001  movt  r0, #1
    3968: eb000aa4  bl  6400 <xil_printf>
    return XST_FAILURE;
    396c: e3a03001  mov r3, #1
    3970: ea000053  b 3ac4 <PcapLoadPartition+0x1b0>
  }

  /*
   * For Bitstream case destination address will be 0xFFFFFFFF
   */
  DestinationDataPtr = (u32*)XDCFG_DMA_INVALID_ADDRESS;
    3974: e3e03000  mvn r3, #0
    3978: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4

  /*
   * New Bitstream download initialization sequence
   */
  FabricInit();
    397c: eb000076  bl  3b5c <FabricInit>
#endif

  /*
   * PCAP single DMA transfer setup
   */
  SourceDataPtr = (u32*)((u32)SourceDataPtr | PCAP_LAST_TRANSFER);
    3980: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    3984: e3833001  orr r3, r3, #1
    3988: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
  DestinationDataPtr = (u32*)((u32)DestinationDataPtr | PCAP_LAST_TRANSFER);
    398c: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    3990: e3833001  orr r3, r3, #1
    3994: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4

  /*
   * Transfer using Device Configuration
   */
  Status = XDcfg_Transfer(DcfgInstPtr, (u8 *)SourceDataPtr,
    3998: e3013a8c  movw  r3, #6796 ; 0x1a8c
    399c: e3403002  movt  r3, #2
    39a0: e5932000  ldr r2, [r3]
    39a4: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    39a8: e58d3000  str r3, [sp]
    39ac: e51b3008  ldr r3, [fp, #-8]
    39b0: e58d3004  str r3, [sp, #4]
    39b4: e1a00002  mov r0, r2
    39b8: e51b1018  ldr r1, [fp, #-24]  ; 0xffffffe8
    39bc: e51b2020  ldr r2, [fp, #-32]  ; 0xffffffe0
    39c0: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    39c4: eb000e38  bl  72ac <XDcfg_Transfer>
    39c8: e50b000c  str r0, [fp, #-12]
          SourceLength,
          (u8 *)DestinationDataPtr,
          DestinationLength, PcapTransferType);
  if (Status != XST_SUCCESS) {
    39cc: e51b300c  ldr r3, [fp, #-12]
    39d0: e3530000  cmp r3, #0
    39d4: 0a000005  beq 39f0 <PcapLoadPartition+0xdc>
    fsbl_printf(DEBUG_INFO,"Status of XDcfg_Transfer = %d \r \n",Status);
    39d8: e3070e48  movw  r0, #32328  ; 0x7e48
    39dc: e3400001  movt  r0, #1
    39e0: e51b100c  ldr r1, [fp, #-12]
    39e4: eb000a85  bl  6400 <xil_printf>
    return XST_FAILURE;
    39e8: e3a03001  mov r3, #1
    39ec: ea000034  b 3ac4 <PcapLoadPartition+0x1b0>


  /*
   * Dump the PCAP registers
   */
  PcapDumpRegisters();
    39f0: eb00011e  bl  3e70 <PcapDumpRegisters>


  /*
   * Poll for the DMA done
   */
  Status = XDcfgPollDone(XDCFG_IXR_DMA_DONE_MASK, MAX_COUNT);
    39f4: e3a00a02  mov r0, #8192 ; 0x2000
    39f8: e3a01cca  mov r1, #51712  ; 0xca00
    39fc: e3431b9a  movt  r1, #15258  ; 0x3b9a
    3a00: eb0001b6  bl  40e0 <XDcfgPollDone>
    3a04: e1a03000  mov r3, r0
    3a08: e50b300c  str r3, [fp, #-12]
  if (Status != XST_SUCCESS) {
    3a0c: e51b300c  ldr r3, [fp, #-12]
    3a10: e3530000  cmp r3, #0
    3a14: 0a000004  beq 3a2c <PcapLoadPartition+0x118>
    fsbl_printf(DEBUG_INFO,"PCAP_DMA_DONE_FAIL \r\n");
    3a18: e3070e6c  movw  r0, #32364  ; 0x7e6c
    3a1c: e3400001  movt  r0, #1
    3a20: eb000a76  bl  6400 <xil_printf>
    return XST_FAILURE;
    3a24: e3a03001  mov r3, #1
    3a28: ea000025  b 3ac4 <PcapLoadPartition+0x1b0>
  }

  fsbl_printf(DEBUG_INFO,"DMA Done ! \n\r");
    3a2c: e3070e84  movw  r0, #32388  ; 0x7e84
    3a30: e3400001  movt  r0, #1
    3a34: eb000a71  bl  6400 <xil_printf>

  /*
   * Poll for FPGA Done
   */
  Status = XDcfgPollDone(XDCFG_IXR_PCFG_DONE_MASK, MAX_COUNT);
    3a38: e3a00004  mov r0, #4
    3a3c: e3a01cca  mov r1, #51712  ; 0xca00
    3a40: e3431b9a  movt  r1, #15258  ; 0x3b9a
    3a44: eb0001a5  bl  40e0 <XDcfgPollDone>
    3a48: e1a03000  mov r3, r0
    3a4c: e50b300c  str r3, [fp, #-12]
  if (Status != XST_SUCCESS) {
    3a50: e51b300c  ldr r3, [fp, #-12]
    3a54: e3530000  cmp r3, #0
    3a58: 0a000004  beq 3a70 <PcapLoadPartition+0x15c>
    fsbl_printf(DEBUG_INFO,"PCAP_FPGA_DONE_FAIL\r\n");
    3a5c: e3070ea8  movw  r0, #32424  ; 0x7ea8
    3a60: e3400001  movt  r0, #1
    3a64: eb000a65  bl  6400 <xil_printf>
    return XST_FAILURE;
    3a68: e3a03001  mov r3, #1
    3a6c: ea000014  b 3ac4 <PcapLoadPartition+0x1b0>
  }

  fsbl_printf(DEBUG_INFO,"FPGA Done ! \n\r");
    3a70: e3070ec0  movw  r0, #32448  ; 0x7ec0
    3a74: e3400001  movt  r0, #1
    3a78: eb000a60  bl  6400 <xil_printf>
  
  /*
   * Check for errors
   */
  IntrStsReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    3a7c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3a80: e3403002  movt  r3, #2
    3a84: e5933000  ldr r3, [r3]
    3a88: e1a00003  mov r0, r3
    3a8c: eb000f21  bl  7718 <XDcfg_IntrGetStatus>
    3a90: e50b0010  str r0, [fp, #-16]
  if (IntrStsReg & FSBL_XDCFG_IXR_ERROR_FLAGS_MASK) {
    3a94: e51b2010  ldr r2, [fp, #-16]
    3a98: e30c3840  movw  r3, #51264  ; 0xc840
    3a9c: e3403074  movt  r3, #116  ; 0x74
    3aa0: e0033002  and r3, r3, r2
    3aa4: e3530000  cmp r3, #0
    3aa8: 0a000004  beq 3ac0 <PcapLoadPartition+0x1ac>
    fsbl_printf(DEBUG_INFO,"Errors in PCAP \r\n");
    3aac: e3070e94  movw  r0, #32404  ; 0x7e94
    3ab0: e3400001  movt  r0, #1
    3ab4: eb000a51  bl  6400 <xil_printf>
    return XST_FAILURE;
    3ab8: e3a03001  mov r3, #1
    3abc: ea000000  b 3ac4 <PcapLoadPartition+0x1b0>
  XTime tXferEnd = 0;
  fsbl_printf(DEBUG_GENERAL,"Time taken is ");
  FsblMeasurePerfTime(tXferCur,tXferEnd);
#endif

  return XST_SUCCESS;
    3ac0: e3a03000  mov r3, #0
}
    3ac4: e1a00003  mov r0, r3
    3ac8: e24bd004  sub sp, fp, #4
    3acc: e8bd8800  pop {fp, pc}

00003ad0 <InitPcap>:
*
* @note  none
*
****************************************************************************/
int InitPcap(void)
{
    3ad0: e92d4800  push  {fp, lr}
    3ad4: e28db004  add fp, sp, #4
    3ad8: e24dd008  sub sp, sp, #8
  XDcfg_Config *ConfigPtr;
  int Status = XST_SUCCESS;
    3adc: e3a03000  mov r3, #0
    3ae0: e50b3008  str r3, [fp, #-8]
  DcfgInstPtr = &DcfgInstance;
    3ae4: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3ae8: e3403002  movt  r3, #2
    3aec: e3012064  movw  r2, #4196 ; 0x1064
    3af0: e3402002  movt  r2, #2
    3af4: e5832000  str r2, [r3]

  /*
   * Initialize the Device Configuration Interface driver.
   */
  ConfigPtr = XDcfg_LookupConfig(DCFG_DEVICE_ID);
    3af8: e3a00000  mov r0, #0
    3afc: eb000f97  bl  7960 <XDcfg_LookupConfig>
    3b00: e50b000c  str r0, [fp, #-12]

  Status = XDcfg_CfgInitialize(DcfgInstPtr, ConfigPtr,
    3b04: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3b08: e3403002  movt  r3, #2
    3b0c: e5932000  ldr r2, [r3]
    3b10: e51b300c  ldr r3, [fp, #-12]
    3b14: e5933004  ldr r3, [r3, #4]
    3b18: e1a00002  mov r0, r2
    3b1c: e51b100c  ldr r1, [fp, #-12]
    3b20: e1a02003  mov r2, r3
    3b24: eb000b77  bl  6908 <XDcfg_CfgInitialize>
    3b28: e50b0008  str r0, [fp, #-8]
          ConfigPtr->BaseAddr);
  if (Status != XST_SUCCESS) {
    3b2c: e51b3008  ldr r3, [fp, #-8]
    3b30: e3530000  cmp r3, #0
    3b34: 0a000004  beq 3b4c <InitPcap+0x7c>
    fsbl_printf(DEBUG_INFO, "XDcfg_CfgInitialize failed \n\r");
    3b38: e3070ed0  movw  r0, #32464  ; 0x7ed0
    3b3c: e3400001  movt  r0, #1
    3b40: eb000a2e  bl  6400 <xil_printf>
    return XST_FAILURE;
    3b44: e3a03001  mov r3, #1
    3b48: ea000000  b 3b50 <InitPcap+0x80>
  }

  return XST_SUCCESS;
    3b4c: e3a03000  mov r3, #0
}
    3b50: e1a00003  mov r0, r3
    3b54: e24bd004  sub sp, fp, #4
    3b58: e8bd8800  pop {fp, pc}

00003b5c <FabricInit>:
*   - XST_FAILURE if the Fabric  initialization fails
* @note   None
*
****************************************************************************/
void FabricInit(void)
{
    3b5c: e92d4800  push  {fp, lr}
    3b60: e28db004  add fp, sp, #4
    3b64: e24dd010  sub sp, sp, #16
  u32 StatusReg;

  /*
   * Set Level Shifters DT618760 - PS to PL enabling
   */
  Xil_Out32(PS_LVL_SHFTR_EN, LVL_PS_PL);
    3b68: e3a00c09  mov r0, #2304 ; 0x900
    3b6c: e34f0800  movt  r0, #63488  ; 0xf800
    3b70: e3a0100a  mov r1, #10
    3b74: eb00098d  bl  61b0 <Xil_Out32>
  fsbl_printf(DEBUG_INFO,"Level Shifter Value = 0x%x \r\n",
    3b78: e3a00c09  mov r0, #2304 ; 0x900
    3b7c: e34f0800  movt  r0, #63488  ; 0xf800
    3b80: eb000984  bl  6198 <Xil_In32>
    3b84: e1a03000  mov r3, r0
    3b88: e3070ef0  movw  r0, #32496  ; 0x7ef0
    3b8c: e3400001  movt  r0, #1
    3b90: e1a01003  mov r1, r3
    3b94: eb000a19  bl  6400 <xil_printf>
        Xil_In32(PS_LVL_SHFTR_EN));

  /*
   * Get DEVCFG controller settings
   */
  PcapReg = XDcfg_ReadReg(DcfgInstPtr->Config.BaseAddr,
    3b98: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3b9c: e3403002  movt  r3, #2
    3ba0: e5933000  ldr r3, [r3]
    3ba4: e5933004  ldr r3, [r3, #4]
    3ba8: e1a00003  mov r0, r3
    3bac: eb000979  bl  6198 <Xil_In32>
    3bb0: e50b0008  str r0, [fp, #-8]
        XDCFG_CTRL_OFFSET);

  /*
   * Setting PCFG_PROG_B signal to high
   */
  XDcfg_WriteReg(DcfgInstPtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    3bb4: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3bb8: e3403002  movt  r3, #2
    3bbc: e5933000  ldr r3, [r3]
    3bc0: e5933004  ldr r3, [r3, #4]
    3bc4: e1a02003  mov r2, r3
    3bc8: e51b3008  ldr r3, [fp, #-8]
    3bcc: e3833101  orr r3, r3, #1073741824 ; 0x40000000
    3bd0: e1a00002  mov r0, r2
    3bd4: e1a01003  mov r1, r3
    3bd8: eb000974  bl  61b0 <Xil_Out32>
        (PcapReg | XDCFG_CTRL_PCFG_PROG_B_MASK));

  /*
   * Check for AES source key
   */
  PcapCtrlRegVal = XDcfg_GetControlRegister(DcfgInstPtr);
    3bdc: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3be0: e3403002  movt  r3, #2
    3be4: e5933000  ldr r3, [r3]
    3be8: e1a00003  mov r0, r3
    3bec: eb000c07  bl  6c10 <XDcfg_GetControlRegister>
    3bf0: e50b000c  str r0, [fp, #-12]
  if (PcapCtrlRegVal & XDCFG_CTRL_PCFG_AES_FUSE_MASK) {
    3bf4: e51b300c  ldr r3, [fp, #-12]
    3bf8: e2033a01  and r3, r3, #4096 ; 0x1000
    3bfc: e3530000  cmp r3, #0
    3c00: 0a000001  beq 3c0c <FabricInit+0xb0>
    /*
     * 5msec delay
     */
    usleep(5000);
    3c04: e3010388  movw  r0, #5000 ; 0x1388
    3c08: eb000680  bl  5610 <usleep>
  }
  
  /*
   * Setting PCFG_PROG_B signal to low
   */
  XDcfg_WriteReg(DcfgInstPtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    3c0c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3c10: e3403002  movt  r3, #2
    3c14: e5933000  ldr r3, [r3]
    3c18: e5933004  ldr r3, [r3, #4]
    3c1c: e1a02003  mov r2, r3
    3c20: e51b3008  ldr r3, [fp, #-8]
    3c24: e3c33101  bic r3, r3, #1073741824 ; 0x40000000
    3c28: e1a00002  mov r0, r2
    3c2c: e1a01003  mov r1, r3
    3c30: eb00095e  bl  61b0 <Xil_Out32>
        (PcapReg & ~XDCFG_CTRL_PCFG_PROG_B_MASK));

  /*
   * Check for AES source key
   */
  if (PcapCtrlRegVal & XDCFG_CTRL_PCFG_AES_FUSE_MASK) {
    3c34: e51b300c  ldr r3, [fp, #-12]
    3c38: e2033a01  and r3, r3, #4096 ; 0x1000
    3c3c: e3530000  cmp r3, #0
    3c40: 0a000001  beq 3c4c <FabricInit+0xf0>
    /*
     * 5msec delay
     */
    usleep(5000);
    3c44: e3010388  movw  r0, #5000 ; 0x1388
    3c48: eb000670  bl  5610 <usleep>
  }

  /*
   * Polling the PCAP_INIT status for Reset
   */
  while(XDcfg_GetStatusRegister(DcfgInstPtr) &
    3c4c: e1a00000  nop     ; (mov r0, r0)
    3c50: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3c54: e3403002  movt  r3, #2
    3c58: e5933000  ldr r3, [r3]
    3c5c: e1a00003  mov r0, r3
    3c60: eb000cac  bl  6f18 <XDcfg_GetStatusRegister>
    3c64: e1a03000  mov r3, r0
    3c68: e2033010  and r3, r3, #16
    3c6c: e3530000  cmp r3, #0
    3c70: 1afffff6  bne 3c50 <FabricInit+0xf4>
        XDCFG_STATUS_PCFG_INIT_MASK);

  /*
   * Setting PCFG_PROG_B signal to high
   */
  XDcfg_WriteReg(DcfgInstPtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    3c74: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3c78: e3403002  movt  r3, #2
    3c7c: e5933000  ldr r3, [r3]
    3c80: e5933004  ldr r3, [r3, #4]
    3c84: e1a02003  mov r2, r3
    3c88: e51b3008  ldr r3, [fp, #-8]
    3c8c: e3833101  orr r3, r3, #1073741824 ; 0x40000000
    3c90: e1a00002  mov r0, r2
    3c94: e1a01003  mov r1, r3
    3c98: eb000944  bl  61b0 <Xil_Out32>
      (PcapReg | XDCFG_CTRL_PCFG_PROG_B_MASK));

  /*
   * Polling the PCAP_INIT status for Set
   */
  while(!(XDcfg_GetStatusRegister(DcfgInstPtr) &
    3c9c: e1a00000  nop     ; (mov r0, r0)
    3ca0: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3ca4: e3403002  movt  r3, #2
    3ca8: e5933000  ldr r3, [r3]
    3cac: e1a00003  mov r0, r3
    3cb0: eb000c98  bl  6f18 <XDcfg_GetStatusRegister>
    3cb4: e1a03000  mov r3, r0
    3cb8: e2033010  and r3, r3, #16
    3cbc: e3530000  cmp r3, #0
    3cc0: 0afffff6  beq 3ca0 <FabricInit+0x144>
      XDCFG_STATUS_PCFG_INIT_MASK));

  /*
   * Get Device configuration status
   */
  StatusReg = XDcfg_GetStatusRegister(DcfgInstPtr);
    3cc4: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3cc8: e3403002  movt  r3, #2
    3ccc: e5933000  ldr r3, [r3]
    3cd0: e1a00003  mov r0, r3
    3cd4: eb000c8f  bl  6f18 <XDcfg_GetStatusRegister>
    3cd8: e50b0010  str r0, [fp, #-16]
  fsbl_printf(DEBUG_INFO,"Devcfg Status register = 0x%x \r\n",StatusReg);
    3cdc: e3070f10  movw  r0, #32528  ; 0x7f10
    3ce0: e3400001  movt  r0, #1
    3ce4: e51b1010  ldr r1, [fp, #-16]
    3ce8: eb0009c4  bl  6400 <xil_printf>

  fsbl_printf(DEBUG_INFO,"PCAP:Fabric is Initialized done\r\n");
    3cec: e3070f34  movw  r0, #32564  ; 0x7f34
    3cf0: e3400001  movt  r0, #1
    3cf4: eb0009c1  bl  6400 <xil_printf>
}
    3cf8: e24bd004  sub sp, fp, #4
    3cfc: e8bd8800  pop {fp, pc}

00003d00 <ClearPcapStatus>:
*   - XST_DEVICE_BUSY if Pcap device is busy
* @note   None
*
****************************************************************************/
u32 ClearPcapStatus(void)
{
    3d00: e92d4800  push  {fp, lr}
    3d04: e28db004  add fp, sp, #4
    3d08: e24dd008  sub sp, sp, #8
  u32 IntStatusReg;

  /*
   * Clear it all, so if Boot ROM comes back, it can proceed
   */
  XDcfg_IntrClear(DcfgInstPtr, 0xFFFFFFFF);
    3d0c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3d10: e3403002  movt  r3, #2
    3d14: e5933000  ldr r3, [r3]
    3d18: e1a00003  mov r0, r3
    3d1c: e3e01000  mvn r1, #0
    3d20: eb000e9d  bl  779c <XDcfg_IntrClear>

  /*
   * Get PCAP Interrupt Status Register
   */
  IntStatusReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    3d24: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3d28: e3403002  movt  r3, #2
    3d2c: e5933000  ldr r3, [r3]
    3d30: e1a00003  mov r0, r3
    3d34: eb000e77  bl  7718 <XDcfg_IntrGetStatus>
    3d38: e50b0008  str r0, [fp, #-8]
  if (IntStatusReg & FSBL_XDCFG_IXR_ERROR_FLAGS_MASK) {
    3d3c: e51b2008  ldr r2, [fp, #-8]
    3d40: e30c3840  movw  r3, #51264  ; 0xc840
    3d44: e3403074  movt  r3, #116  ; 0x74
    3d48: e0033002  and r3, r3, r2
    3d4c: e3530000  cmp r3, #0
    3d50: 0a000005  beq 3d6c <ClearPcapStatus+0x6c>
    fsbl_printf(DEBUG_INFO,"FATAL errors in PCAP %x\r\n",
    3d54: e3070f58  movw  r0, #32600  ; 0x7f58
    3d58: e3400001  movt  r0, #1
    3d5c: e51b1008  ldr r1, [fp, #-8]
    3d60: eb0009a6  bl  6400 <xil_printf>
        IntStatusReg);
    return XST_FAILURE;
    3d64: e3a03001  mov r3, #1
    3d68: ea00003d  b 3e64 <ClearPcapStatus+0x164>
  }

  /*
   * Read the PCAP status register for DMA status
   */
  StatusReg = XDcfg_GetStatusRegister(DcfgInstPtr);
    3d6c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3d70: e3403002  movt  r3, #2
    3d74: e5933000  ldr r3, [r3]
    3d78: e1a00003  mov r0, r3
    3d7c: eb000c65  bl  6f18 <XDcfg_GetStatusRegister>
    3d80: e50b000c  str r0, [fp, #-12]

  fsbl_printf(DEBUG_INFO,"PCAP:StatusReg = 0x%.8x\r\n", StatusReg);
    3d84: e3070f74  movw  r0, #32628  ; 0x7f74
    3d88: e3400001  movt  r0, #1
    3d8c: e51b100c  ldr r1, [fp, #-12]
    3d90: eb00099a  bl  6400 <xil_printf>

  /*
   * If the queue is full, return w/ XST_DEVICE_BUSY
   */
  if ((StatusReg & XDCFG_STATUS_DMA_CMD_Q_F_MASK) ==
    3d94: e51b300c  ldr r3, [fp, #-12]
    3d98: e3530000  cmp r3, #0
    3d9c: aa000004  bge 3db4 <ClearPcapStatus+0xb4>
      XDCFG_STATUS_DMA_CMD_Q_F_MASK) {

    fsbl_printf(DEBUG_INFO,"PCAP_DEVICE_BUSY\r\n");
    3da0: e3070f90  movw  r0, #32656  ; 0x7f90
    3da4: e3400001  movt  r0, #1
    3da8: eb000994  bl  6400 <xil_printf>
    return XST_DEVICE_BUSY;
    3dac: e3a03015  mov r3, #21
    3db0: ea00002b  b 3e64 <ClearPcapStatus+0x164>
  }

  fsbl_printf(DEBUG_INFO,"PCAP:device ready\r\n");
    3db4: e3070fa4  movw  r0, #32676  ; 0x7fa4
    3db8: e3400001  movt  r0, #1
    3dbc: eb00098f  bl  6400 <xil_printf>

  /*
   * There are unacknowledged DMA commands outstanding
   */
  if ((StatusReg & XDCFG_STATUS_DMA_CMD_Q_E_MASK) !=
    3dc0: e51b300c  ldr r3, [fp, #-12]
    3dc4: e2033101  and r3, r3, #1073741824 ; 0x40000000
    3dc8: e3530000  cmp r3, #0
    3dcc: 1a000014  bne 3e24 <ClearPcapStatus+0x124>
      XDCFG_STATUS_DMA_CMD_Q_E_MASK) {

    IntStatusReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    3dd0: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3dd4: e3403002  movt  r3, #2
    3dd8: e5933000  ldr r3, [r3]
    3ddc: e1a00003  mov r0, r3
    3de0: eb000e4c  bl  7718 <XDcfg_IntrGetStatus>
    3de4: e50b0008  str r0, [fp, #-8]

    if ((IntStatusReg & XDCFG_IXR_DMA_DONE_MASK) !=
    3de8: e51b3008  ldr r3, [fp, #-8]
    3dec: e2033a02  and r3, r3, #8192 ; 0x2000
    3df0: e3530000  cmp r3, #0
    3df4: 1a000004  bne 3e0c <ClearPcapStatus+0x10c>
        XDCFG_IXR_DMA_DONE_MASK){
      /*
       * Error state, transfer cannot occur
       */
      fsbl_printf(DEBUG_INFO,"PCAP:IntStatus indicates error\r\n");
    3df8: e3070fb8  movw  r0, #32696  ; 0x7fb8
    3dfc: e3400001  movt  r0, #1
    3e00: eb00097e  bl  6400 <xil_printf>
      return XST_FAILURE;
    3e04: e3a03001  mov r3, #1
    3e08: ea000015  b 3e64 <ClearPcapStatus+0x164>
    }
    else {
      /*
       * clear out the status
       */
      XDcfg_IntrClear(DcfgInstPtr, XDCFG_IXR_DMA_DONE_MASK);
    3e0c: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3e10: e3403002  movt  r3, #2
    3e14: e5933000  ldr r3, [r3]
    3e18: e1a00003  mov r0, r3
    3e1c: e3a01a02  mov r1, #8192 ; 0x2000
    3e20: eb000e5d  bl  779c <XDcfg_IntrClear>
    }
  }

  if ((StatusReg & XDCFG_STATUS_DMA_DONE_CNT_MASK) != 0) {
    3e24: e51b300c  ldr r3, [fp, #-12]
    3e28: e2033203  and r3, r3, #805306368  ; 0x30000000
    3e2c: e3530000  cmp r3, #0
    3e30: 0a000007  beq 3e54 <ClearPcapStatus+0x154>
    XDcfg_SetStatusRegister(DcfgInstPtr, StatusReg |
    3e34: e3013a8c  movw  r3, #6796 ; 0x1a8c
    3e38: e3403002  movt  r3, #2
    3e3c: e5932000  ldr r2, [r3]
    3e40: e51b300c  ldr r3, [fp, #-12]
    3e44: e3833203  orr r3, r3, #805306368  ; 0x30000000
    3e48: e1a00002  mov r0, r2
    3e4c: e1a01003  mov r1, r3
    3e50: eb000c10  bl  6e98 <XDcfg_SetStatusRegister>
        XDCFG_STATUS_DMA_DONE_CNT_MASK);
  }

  fsbl_printf(DEBUG_INFO,"PCAP:Clear done\r\n");
    3e54: e3070fdc  movw  r0, #32732  ; 0x7fdc
    3e58: e3400001  movt  r0, #1
    3e5c: eb000967  bl  6400 <xil_printf>

  return XST_SUCCESS;
    3e60: e3a03000  mov r3, #0
}
    3e64: e1a00003  mov r0, r3
    3e68: e24bd004  sub sp, fp, #4
    3e6c: e8bd8800  pop {fp, pc}

00003e70 <PcapDumpRegisters>:
* @return none
*
* @note   none
*
****************************************************************************/
void PcapDumpRegisters (void) {
    3e70: e92d4800  push  {fp, lr}
    3e74: e28db004  add fp, sp, #4

  fsbl_printf(DEBUG_INFO,"PCAP register dump:\r\n");
    3e78: e3070ff0  movw  r0, #32752  ; 0x7ff0
    3e7c: e3400001  movt  r0, #1
    3e80: eb00095e  bl  6400 <xil_printf>

  fsbl_printf(DEBUG_INFO,"PCAP CTRL 0x%x: 0x%08x\r\n",
    3e84: e3a00a07  mov r0, #28672  ; 0x7000
    3e88: e34f0800  movt  r0, #63488  ; 0xf800
    3e8c: eb0008c1  bl  6198 <Xil_In32>
    3e90: e1a03000  mov r3, r0
    3e94: e3080008  movw  r0, #32776  ; 0x8008
    3e98: e3400001  movt  r0, #1
    3e9c: e3a01a07  mov r1, #28672  ; 0x7000
    3ea0: e34f1800  movt  r1, #63488  ; 0xf800
    3ea4: e1a02003  mov r2, r3
    3ea8: eb000954  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_CTRL_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_CTRL_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP LOCK 0x%x: 0x%08x\r\n",
    3eac: e3070004  movw  r0, #28676  ; 0x7004
    3eb0: e34f0800  movt  r0, #63488  ; 0xf800
    3eb4: eb0008b7  bl  6198 <Xil_In32>
    3eb8: e1a03000  mov r3, r0
    3ebc: e3080024  movw  r0, #32804  ; 0x8024
    3ec0: e3400001  movt  r0, #1
    3ec4: e3071004  movw  r1, #28676  ; 0x7004
    3ec8: e34f1800  movt  r1, #63488  ; 0xf800
    3ecc: e1a02003  mov r2, r3
    3ed0: eb00094a  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_LOCK_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_LOCK_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP CONFIG 0x%x: 0x%08x\r\n",
    3ed4: e3070008  movw  r0, #28680  ; 0x7008
    3ed8: e34f0800  movt  r0, #63488  ; 0xf800
    3edc: eb0008ad  bl  6198 <Xil_In32>
    3ee0: e1a03000  mov r3, r0
    3ee4: e3080040  movw  r0, #32832  ; 0x8040
    3ee8: e3400001  movt  r0, #1
    3eec: e3071008  movw  r1, #28680  ; 0x7008
    3ef0: e34f1800  movt  r1, #63488  ; 0xf800
    3ef4: e1a02003  mov r2, r3
    3ef8: eb000940  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_CFG_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_CFG_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP ISR 0x%x: 0x%08x\r\n",
    3efc: e307000c  movw  r0, #28684  ; 0x700c
    3f00: e34f0800  movt  r0, #63488  ; 0xf800
    3f04: eb0008a3  bl  6198 <Xil_In32>
    3f08: e1a03000  mov r3, r0
    3f0c: e308005c  movw  r0, #32860  ; 0x805c
    3f10: e3400001  movt  r0, #1
    3f14: e307100c  movw  r1, #28684  ; 0x700c
    3f18: e34f1800  movt  r1, #63488  ; 0xf800
    3f1c: e1a02003  mov r2, r3
    3f20: eb000936  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_INT_STS_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_INT_STS_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP IMR 0x%x: 0x%08x\r\n",
    3f24: e3070010  movw  r0, #28688  ; 0x7010
    3f28: e34f0800  movt  r0, #63488  ; 0xf800
    3f2c: eb000899  bl  6198 <Xil_In32>
    3f30: e1a03000  mov r3, r0
    3f34: e3080074  movw  r0, #32884  ; 0x8074
    3f38: e3400001  movt  r0, #1
    3f3c: e3071010  movw  r1, #28688  ; 0x7010
    3f40: e34f1800  movt  r1, #63488  ; 0xf800
    3f44: e1a02003  mov r2, r3
    3f48: eb00092c  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_INT_MASK_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_INT_MASK_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP STATUS 0x%x: 0x%08x\r\n",
    3f4c: e3070014  movw  r0, #28692  ; 0x7014
    3f50: e34f0800  movt  r0, #63488  ; 0xf800
    3f54: eb00088f  bl  6198 <Xil_In32>
    3f58: e1a03000  mov r3, r0
    3f5c: e308008c  movw  r0, #32908  ; 0x808c
    3f60: e3400001  movt  r0, #1
    3f64: e3071014  movw  r1, #28692  ; 0x7014
    3f68: e34f1800  movt  r1, #63488  ; 0xf800
    3f6c: e1a02003  mov r2, r3
    3f70: eb000922  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_STATUS_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_STATUS_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP DMA SRC ADDR 0x%x: 0x%08x\r\n",
    3f74: e3070018  movw  r0, #28696  ; 0x7018
    3f78: e34f0800  movt  r0, #63488  ; 0xf800
    3f7c: eb000885  bl  6198 <Xil_In32>
    3f80: e1a03000  mov r3, r0
    3f84: e30800a8  movw  r0, #32936  ; 0x80a8
    3f88: e3400001  movt  r0, #1
    3f8c: e3071018  movw  r1, #28696  ; 0x7018
    3f90: e34f1800  movt  r1, #63488  ; 0xf800
    3f94: e1a02003  mov r2, r3
    3f98: eb000918  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_SRC_ADDR_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_SRC_ADDR_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP DMA DEST ADDR 0x%x: 0x%08x\r\n",
    3f9c: e307001c  movw  r0, #28700  ; 0x701c
    3fa0: e34f0800  movt  r0, #63488  ; 0xf800
    3fa4: eb00087b  bl  6198 <Xil_In32>
    3fa8: e1a03000  mov r3, r0
    3fac: e30800cc  movw  r0, #32972  ; 0x80cc
    3fb0: e3400001  movt  r0, #1
    3fb4: e307101c  movw  r1, #28700  ; 0x701c
    3fb8: e34f1800  movt  r1, #63488  ; 0xf800
    3fbc: e1a02003  mov r2, r3
    3fc0: eb00090e  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_DEST_ADDR_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_DEST_ADDR_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP DMA SRC LEN 0x%x: 0x%08x\r\n",
    3fc4: e3070020  movw  r0, #28704  ; 0x7020
    3fc8: e34f0800  movt  r0, #63488  ; 0xf800
    3fcc: eb000871  bl  6198 <Xil_In32>
    3fd0: e1a03000  mov r3, r0
    3fd4: e30800f0  movw  r0, #33008  ; 0x80f0
    3fd8: e3400001  movt  r0, #1
    3fdc: e3071020  movw  r1, #28704  ; 0x7020
    3fe0: e34f1800  movt  r1, #63488  ; 0xf800
    3fe4: e1a02003  mov r2, r3
    3fe8: eb000904  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_SRC_LEN_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_SRC_LEN_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP DMA DEST LEN 0x%x: 0x%08x\r\n",
    3fec: e3070024  movw  r0, #28708  ; 0x7024
    3ff0: e34f0800  movt  r0, #63488  ; 0xf800
    3ff4: eb000867  bl  6198 <Xil_In32>
    3ff8: e1a03000  mov r3, r0
    3ffc: e3080110  movw  r0, #33040  ; 0x8110
    4000: e3400001  movt  r0, #1
    4004: e3071024  movw  r1, #28708  ; 0x7024
    4008: e34f1800  movt  r1, #63488  ; 0xf800
    400c: e1a02003  mov r2, r3
    4010: eb0008fa  bl  6400 <xil_printf>
      XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_DEST_LEN_OFFSET,
      Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_DMA_DEST_LEN_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP ROM SHADOW CTRL 0x%x: 0x%08x\r\n",
    4014: e3070028  movw  r0, #28712  ; 0x7028
    4018: e34f0800  movt  r0, #63488  ; 0xf800
    401c: eb00085d  bl  6198 <Xil_In32>
    4020: e1a03000  mov r3, r0
    4024: e3080134  movw  r0, #33076  ; 0x8134
    4028: e3400001  movt  r0, #1
    402c: e3071028  movw  r1, #28712  ; 0x7028
    4030: e34f1800  movt  r1, #63488  ; 0xf800
    4034: e1a02003  mov r2, r3
    4038: eb0008f0  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_ROM_SHADOW_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_ROM_SHADOW_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP MBOOT 0x%x: 0x%08x\r\n",
    403c: e307002c  movw  r0, #28716  ; 0x702c
    4040: e34f0800  movt  r0, #63488  ; 0xf800
    4044: eb000853  bl  6198 <Xil_In32>
    4048: e1a03000  mov r3, r0
    404c: e3080158  movw  r0, #33112  ; 0x8158
    4050: e3400001  movt  r0, #1
    4054: e307102c  movw  r1, #28716  ; 0x702c
    4058: e34f1800  movt  r1, #63488  ; 0xf800
    405c: e1a02003  mov r2, r3
    4060: eb0008e6  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_MULTIBOOT_ADDR_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_MULTIBOOT_ADDR_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP SW ID 0x%x: 0x%08x\r\n",
    4064: e3070030  movw  r0, #28720  ; 0x7030
    4068: e34f0800  movt  r0, #63488  ; 0xf800
    406c: eb000849  bl  6198 <Xil_In32>
    4070: e1a03000  mov r3, r0
    4074: e3080174  movw  r0, #33140  ; 0x8174
    4078: e3400001  movt  r0, #1
    407c: e3071030  movw  r1, #28720  ; 0x7030
    4080: e34f1800  movt  r1, #63488  ; 0xf800
    4084: e1a02003  mov r2, r3
    4088: eb0008dc  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_SW_ID_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_SW_ID_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP UNLOCK 0x%x: 0x%08x\r\n",
    408c: e3070034  movw  r0, #28724  ; 0x7034
    4090: e34f0800  movt  r0, #63488  ; 0xf800
    4094: eb00083f  bl  6198 <Xil_In32>
    4098: e1a03000  mov r3, r0
    409c: e3080190  movw  r0, #33168  ; 0x8190
    40a0: e3400001  movt  r0, #1
    40a4: e3071034  movw  r1, #28724  ; 0x7034
    40a8: e34f1800  movt  r1, #63488  ; 0xf800
    40ac: e1a02003  mov r2, r3
    40b0: eb0008d2  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_UNLOCK_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_UNLOCK_OFFSET));
  fsbl_printf(DEBUG_INFO,"PCAP MCTRL 0x%x: 0x%08x\r\n",
    40b4: e3070080  movw  r0, #28800  ; 0x7080
    40b8: e34f0800  movt  r0, #63488  ; 0xf800
    40bc: eb000835  bl  6198 <Xil_In32>
    40c0: e1a03000  mov r3, r0
    40c4: e30801ac  movw  r0, #33196  ; 0x81ac
    40c8: e3400001  movt  r0, #1
    40cc: e3071080  movw  r1, #28800  ; 0x7080
    40d0: e34f1800  movt  r1, #63488  ; 0xf800
    40d4: e1a02003  mov r2, r3
    40d8: eb0008c8  bl  6400 <xil_printf>
    XPS_DEV_CFG_APB_BASEADDR + XDCFG_MCTRL_OFFSET,
    Xil_In32(XPS_DEV_CFG_APB_BASEADDR + XDCFG_MCTRL_OFFSET));
}
    40dc: e8bd8800  pop {fp, pc}

000040e0 <XDcfgPollDone>:
*
* @note   none
*
****************************************************************************/
int XDcfgPollDone(u32 MaskValue, u32 MaxCount)
{
    40e0: e92d4800  push  {fp, lr}
    40e4: e28db004  add fp, sp, #4
    40e8: e24dd010  sub sp, sp, #16
    40ec: e50b0010  str r0, [fp, #-16]
    40f0: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
  int Count = MaxCount;
    40f4: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    40f8: e50b3008  str r3, [fp, #-8]
  u32 IntrStsReg = 0;
    40fc: e3a03000  mov r3, #0
    4100: e50b300c  str r3, [fp, #-12]

  /*
   * poll for the DMA done
   */
  IntrStsReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    4104: e3013a8c  movw  r3, #6796 ; 0x1a8c
    4108: e3403002  movt  r3, #2
    410c: e5933000  ldr r3, [r3]
    4110: e1a00003  mov r0, r3
    4114: eb000d7f  bl  7718 <XDcfg_IntrGetStatus>
    4118: e50b000c  str r0, [fp, #-12]
  while ((IntrStsReg & MaskValue) !=
    411c: ea000025  b 41b8 <XDcfgPollDone+0xd8>
        MaskValue) {
    IntrStsReg = XDcfg_IntrGetStatus(DcfgInstPtr);
    4120: e3013a8c  movw  r3, #6796 ; 0x1a8c
    4124: e3403002  movt  r3, #2
    4128: e5933000  ldr r3, [r3]
    412c: e1a00003  mov r0, r3
    4130: eb000d78  bl  7718 <XDcfg_IntrGetStatus>
    4134: e50b000c  str r0, [fp, #-12]
    Count -=1;
    4138: e51b3008  ldr r3, [fp, #-8]
    413c: e2433001  sub r3, r3, #1
    4140: e50b3008  str r3, [fp, #-8]

    if (IntrStsReg & FSBL_XDCFG_IXR_ERROR_FLAGS_MASK) {
    4144: e51b200c  ldr r2, [fp, #-12]
    4148: e30c3840  movw  r3, #51264  ; 0xc840
    414c: e3403074  movt  r3, #116  ; 0x74
    4150: e0033002  and r3, r3, r2
    4154: e3530000  cmp r3, #0
    4158: 0a000006  beq 4178 <XDcfgPollDone+0x98>
        fsbl_printf(DEBUG_INFO,"FATAL errors in PCAP %x\r\n",
    415c: e3070f58  movw  r0, #32600  ; 0x7f58
    4160: e3400001  movt  r0, #1
    4164: e51b100c  ldr r1, [fp, #-12]
    4168: eb0008a4  bl  6400 <xil_printf>
            IntrStsReg);
        PcapDumpRegisters();
    416c: ebffff3f  bl  3e70 <PcapDumpRegisters>
        return XST_FAILURE;
    4170: e3a03001  mov r3, #1
    4174: ea000022  b 4204 <XDcfgPollDone+0x124>
    }

    if(!Count) {
    4178: e51b3008  ldr r3, [fp, #-8]
    417c: e3530000  cmp r3, #0
    4180: 1a000004  bne 4198 <XDcfgPollDone+0xb8>
      fsbl_printf(DEBUG_GENERAL,"PCAP transfer timed out \r\n");
    4184: e30801c8  movw  r0, #33224  ; 0x81c8
    4188: e3400001  movt  r0, #1
    418c: eb00089b  bl  6400 <xil_printf>
      return XST_FAILURE;
    4190: e3a03001  mov r3, #1
    4194: ea00001a  b 4204 <XDcfgPollDone+0x124>
    }
    if (Count > (MAX_COUNT-100)) {
    4198: e51b2008  ldr r2, [fp, #-8]
    419c: e30c399c  movw  r3, #51612  ; 0xc99c
    41a0: e3433b9a  movt  r3, #15258  ; 0x3b9a
    41a4: e1520003  cmp r2, r3
    41a8: da000002  ble 41b8 <XDcfgPollDone+0xd8>
      fsbl_printf(DEBUG_GENERAL,".");
    41ac: e30801e4  movw  r0, #33252  ; 0x81e4
    41b0: e3400001  movt  r0, #1
    41b4: eb000891  bl  6400 <xil_printf>

  /*
   * poll for the DMA done
   */
  IntrStsReg = XDcfg_IntrGetStatus(DcfgInstPtr);
  while ((IntrStsReg & MaskValue) !=
    41b8: e51b200c  ldr r2, [fp, #-12]
    41bc: e51b3010  ldr r3, [fp, #-16]
    41c0: e0022003  and r2, r2, r3
    41c4: e51b3010  ldr r3, [fp, #-16]
    41c8: e1520003  cmp r2, r3
    41cc: 1affffd3  bne 4120 <XDcfgPollDone+0x40>
    if (Count > (MAX_COUNT-100)) {
      fsbl_printf(DEBUG_GENERAL,".");
    }
  }

  fsbl_printf(DEBUG_GENERAL,"\n\r");
    41d0: e30801e8  movw  r0, #33256  ; 0x81e8
    41d4: e3400001  movt  r0, #1
    41d8: eb000888  bl  6400 <xil_printf>

  XDcfg_IntrClear(DcfgInstPtr, IntrStsReg & MaskValue);
    41dc: e3013a8c  movw  r3, #6796 ; 0x1a8c
    41e0: e3403002  movt  r3, #2
    41e4: e5931000  ldr r1, [r3]
    41e8: e51b200c  ldr r2, [fp, #-12]
    41ec: e51b3010  ldr r3, [fp, #-16]
    41f0: e0033002  and r3, r3, r2
    41f4: e1a00001  mov r0, r1
    41f8: e1a01003  mov r1, r3
    41fc: eb000d66  bl  779c <XDcfg_IntrClear>

  return XST_SUCCESS;
    4200: e3a03000  mov r3, #0
}
    4204: e1a00003  mov r0, r3
    4208: e24bd004  sub sp, fp, #4
    420c: e8bd8800  pop {fp, pc}

00004210 <getPS7MessageInfo>:

#include "xil_io.h"
#define PS7_MASK_POLL_TIME 100000000

char*
getPS7MessageInfo(unsigned key) {
    4210: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4214: e28db000  add fp, sp, #0
    4218: e24dd014  sub sp, sp, #20
    421c: e50b0010  str r0, [fp, #-16]

  char* err_msg = "";
    4220: e30831ec  movw  r3, #33260  ; 0x81ec
    4224: e3403001  movt  r3, #1
    4228: e50b3008  str r3, [fp, #-8]
  switch (key) {
    422c: e51b3010  ldr r3, [fp, #-16]
    4230: e3530005  cmp r3, #5
    4234: 979ff103  ldrls pc, [pc, r3, lsl #2]
    4238: ea00001d  b 42b4 <getPS7MessageInfo+0xa4>
    423c: 00004254  .word 0x00004254
    4240: 00004264  .word 0x00004264
    4244: 00004274  .word 0x00004274
    4248: 00004284  .word 0x00004284
    424c: 00004294  .word 0x00004294
    4250: 000042a4  .word 0x000042a4
    case PS7_INIT_SUCCESS:                  err_msg = "PS7 initialization successful"; break;
    4254: e30831f0  movw  r3, #33264  ; 0x81f0
    4258: e3403001  movt  r3, #1
    425c: e50b3008  str r3, [fp, #-8]
    4260: ea000017  b 42c4 <getPS7MessageInfo+0xb4>
    case PS7_INIT_CORRUPT:                  err_msg = "PS7 init Data Corrupted"; break;
    4264: e3083210  movw  r3, #33296  ; 0x8210
    4268: e3403001  movt  r3, #1
    426c: e50b3008  str r3, [fp, #-8]
    4270: ea000013  b 42c4 <getPS7MessageInfo+0xb4>
    case PS7_INIT_TIMEOUT:                  err_msg = "PS7 init mask poll timeout"; break;
    4274: e3083228  movw  r3, #33320  ; 0x8228
    4278: e3403001  movt  r3, #1
    427c: e50b3008  str r3, [fp, #-8]
    4280: ea00000f  b 42c4 <getPS7MessageInfo+0xb4>
    case PS7_POLL_FAILED_DDR_INIT:          err_msg = "Mask Poll failed for DDR Init"; break;
    4284: e3083244  movw  r3, #33348  ; 0x8244
    4288: e3403001  movt  r3, #1
    428c: e50b3008  str r3, [fp, #-8]
    4290: ea00000b  b 42c4 <getPS7MessageInfo+0xb4>
    case PS7_POLL_FAILED_DMA:               err_msg = "Mask Poll failed for PLL Init"; break;
    4294: e3083264  movw  r3, #33380  ; 0x8264
    4298: e3403001  movt  r3, #1
    429c: e50b3008  str r3, [fp, #-8]
    42a0: ea000007  b 42c4 <getPS7MessageInfo+0xb4>
    case PS7_POLL_FAILED_PLL:               err_msg = "Mask Poll failed for DMA done bit"; break;
    42a4: e3083284  movw  r3, #33412  ; 0x8284
    42a8: e3403001  movt  r3, #1
    42ac: e50b3008  str r3, [fp, #-8]
    42b0: ea000003  b 42c4 <getPS7MessageInfo+0xb4>
    default:                                err_msg = "Undefined error status"; break;
    42b4: e30832a8  movw  r3, #33448  ; 0x82a8
    42b8: e3403001  movt  r3, #1
    42bc: e50b3008  str r3, [fp, #-8]
    42c0: e1a00000  nop     ; (mov r0, r0)
  }
  
  return err_msg;  
    42c4: e51b3008  ldr r3, [fp, #-8]
}
    42c8: e1a00003  mov r0, r3
    42cc: e24bd000  sub sp, fp, #0
    42d0: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    42d4: e12fff1e  bx  lr

000042d8 <ps7GetSiliconVersion>:

unsigned long
ps7GetSiliconVersion () {
    42d8: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    42dc: e28db000  add fp, sp, #0
    42e0: e24dd014  sub sp, sp, #20
  // Read PS version from MCTRL register [31:28]
  unsigned long mask = 0xF0000000;
    42e4: e3a0320f  mov r3, #-268435456 ; 0xf0000000
    42e8: e50b3008  str r3, [fp, #-8]
  unsigned long *addr = (unsigned long*) 0XF8007080;    
    42ec: e3073080  movw  r3, #28800  ; 0x7080
    42f0: e34f3800  movt  r3, #63488  ; 0xf800
    42f4: e50b300c  str r3, [fp, #-12]
  unsigned long ps_version = (*addr & mask) >> 28;
    42f8: e51b300c  ldr r3, [fp, #-12]
    42fc: e5932000  ldr r2, [r3]
    4300: e51b3008  ldr r3, [fp, #-8]
    4304: e0033002  and r3, r3, r2
    4308: e1a03e23  lsr r3, r3, #28
    430c: e50b3010  str r3, [fp, #-16]
  return ps_version;
    4310: e51b3010  ldr r3, [fp, #-16]
}
    4314: e1a00003  mov r0, r3
    4318: e24bd000  sub sp, fp, #0
    431c: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4320: e12fff1e  bx  lr

00004324 <mask_write>:

void mask_write (unsigned long add , unsigned long  mask, unsigned long val ) {
    4324: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4328: e28db000  add fp, sp, #0
    432c: e24dd01c  sub sp, sp, #28
    4330: e50b0010  str r0, [fp, #-16]
    4334: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    4338: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8
        unsigned long *addr = (unsigned long*) add;
    433c: e51b3010  ldr r3, [fp, #-16]
    4340: e50b3008  str r3, [fp, #-8]
        *addr = ( val & mask ) | ( *addr & ~mask);
    4344: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    4348: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    434c: e0022003  and r2, r2, r3
    4350: e51b3008  ldr r3, [fp, #-8]
    4354: e5931000  ldr r1, [r3]
    4358: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    435c: e1e03003  mvn r3, r3
    4360: e0033001  and r3, r3, r1
    4364: e1822003  orr r2, r2, r3
    4368: e51b3008  ldr r3, [fp, #-8]
    436c: e5832000  str r2, [r3]
        //xil_printf("MaskWrite : 0x%x--> 0x%x \n \r" ,add, *addr);
}
    4370: e24bd000  sub sp, fp, #0
    4374: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4378: e12fff1e  bx  lr

0000437c <mask_poll>:


int mask_poll(unsigned long add , unsigned long mask ) {
    437c: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4380: e28db000  add fp, sp, #0
    4384: e24dd014  sub sp, sp, #20
    4388: e50b0010  str r0, [fp, #-16]
    438c: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
        volatile unsigned long *addr = (volatile unsigned long*) add;
    4390: e51b3010  ldr r3, [fp, #-16]
    4394: e50b300c  str r3, [fp, #-12]
        int i = 0;
    4398: e3a03000  mov r3, #0
    439c: e50b3008  str r3, [fp, #-8]
        while (!(*addr & mask)) {
    43a0: ea000009  b 43cc <mask_poll+0x50>
          if (i == PS7_MASK_POLL_TIME) {
    43a4: e51b2008  ldr r2, [fp, #-8]
    43a8: e3a03ce1  mov r3, #57600  ; 0xe100
    43ac: e34035f5  movt  r3, #1525 ; 0x5f5
    43b0: e1520003  cmp r2, r3
    43b4: 1a000001  bne 43c0 <mask_poll+0x44>
            return -1;
    43b8: e3e03000  mvn r3, #0
    43bc: ea000009  b 43e8 <mask_poll+0x6c>
          }
          i++;
    43c0: e51b3008  ldr r3, [fp, #-8]
    43c4: e2833001  add r3, r3, #1
    43c8: e50b3008  str r3, [fp, #-8]


int mask_poll(unsigned long add , unsigned long mask ) {
        volatile unsigned long *addr = (volatile unsigned long*) add;
        int i = 0;
        while (!(*addr & mask)) {
    43cc: e51b300c  ldr r3, [fp, #-12]
    43d0: e5932000  ldr r2, [r3]
    43d4: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    43d8: e0033002  and r3, r3, r2
    43dc: e3530000  cmp r3, #0
    43e0: 0affffef  beq 43a4 <mask_poll+0x28>
          if (i == PS7_MASK_POLL_TIME) {
            return -1;
          }
          i++;
        }
     return 1;   
    43e4: e3a03001  mov r3, #1
        //xil_printf("MaskPoll : 0x%x --> 0x%x \n \r" , add, *addr);
}
    43e8: e1a00003  mov r0, r3
    43ec: e24bd000  sub sp, fp, #0
    43f0: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    43f4: e12fff1e  bx  lr

000043f8 <mask_read>:

unsigned long mask_read(unsigned long add , unsigned long mask ) {
    43f8: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    43fc: e28db000  add fp, sp, #0
    4400: e24dd014  sub sp, sp, #20
    4404: e50b0010  str r0, [fp, #-16]
    4408: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
        unsigned long *addr = (unsigned long*) add;
    440c: e51b3010  ldr r3, [fp, #-16]
    4410: e50b3008  str r3, [fp, #-8]
        unsigned long val = (*addr & mask);
    4414: e51b3008  ldr r3, [fp, #-8]
    4418: e5932000  ldr r2, [r3]
    441c: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    4420: e0033002  and r3, r3, r2
    4424: e50b300c  str r3, [fp, #-12]
        //xil_printf("MaskRead : 0x%x --> 0x%x \n \r" , add, val);
        return val;
    4428: e51b300c  ldr r3, [fp, #-12]
}
    442c: e1a00003  mov r0, r3
    4430: e24bd000  sub sp, fp, #0
    4434: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4438: e12fff1e  bx  lr

0000443c <ps7_config>:



int
ps7_config(unsigned long * ps7_config_init) 
{
    443c: e92d4800  push  {fp, lr}
    4440: e28db004  add fp, sp, #4
    4444: e24dd070  sub sp, sp, #112  ; 0x70
    4448: e50b0070  str r0, [fp, #-112] ; 0xffffff90
    unsigned long *ptr = ps7_config_init;
    444c: e51b3070  ldr r3, [fp, #-112] ; 0xffffff90
    4450: e50b3008  str r3, [fp, #-8]
    int  j;                 // general purpose index

    volatile unsigned long *addr;         // some variable to make code readable
    unsigned long  val,mask;              // some variable to make code readable

    int finish = -1 ;           // loop while this is negative !
    4454: e3e03000  mvn r3, #0
    4458: e50b3010  str r3, [fp, #-16]
    int i = 0;                  // Timeout variable
    445c: e3a03000  mov r3, #0
    4460: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
    
    while( finish < 0 ) {
    4464: ea00007a  b 4654 <ps7_config+0x218>
        numargs = ptr[0] & 0xF;
    4468: e51b3008  ldr r3, [fp, #-8]
    446c: e5933000  ldr r3, [r3]
    4470: e203300f  and r3, r3, #15
    4474: e50b3018  str r3, [fp, #-24]  ; 0xffffffe8
        opcode = ptr[0] >> 4;
    4478: e51b3008  ldr r3, [fp, #-8]
    447c: e5933000  ldr r3, [r3]
    4480: e1a03223  lsr r3, r3, #4
    4484: e50b301c  str r3, [fp, #-28]  ; 0xffffffe4

        for( j = 0 ; j < numargs ; j ++ ) 
    4488: e3a03000  mov r3, #0
    448c: e50b300c  str r3, [fp, #-12]
    4490: ea00000d  b 44cc <ps7_config+0x90>
            args[j] = ptr[j+1];
    4494: e51b300c  ldr r3, [fp, #-12]
    4498: e2833001  add r3, r3, #1
    449c: e1a03103  lsl r3, r3, #2
    44a0: e51b2008  ldr r2, [fp, #-8]
    44a4: e0823003  add r3, r2, r3
    44a8: e5932000  ldr r2, [r3]
    44ac: e51b300c  ldr r3, [fp, #-12]
    44b0: e1a03103  lsl r3, r3, #2
    44b4: e24b1004  sub r1, fp, #4
    44b8: e0813003  add r3, r1, r3
    44bc: e5032068  str r2, [r3, #-104] ; 0xffffff98
    
    while( finish < 0 ) {
        numargs = ptr[0] & 0xF;
        opcode = ptr[0] >> 4;

        for( j = 0 ; j < numargs ; j ++ ) 
    44c0: e51b300c  ldr r3, [fp, #-12]
    44c4: e2833001  add r3, r3, #1
    44c8: e50b300c  str r3, [fp, #-12]
    44cc: e51b200c  ldr r2, [fp, #-12]
    44d0: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    44d4: e1520003  cmp r2, r3
    44d8: baffffed  blt 4494 <ps7_config+0x58>
            args[j] = ptr[j+1];
        ptr += numargs + 1;
    44dc: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    44e0: e2833001  add r3, r3, #1
    44e4: e1a03103  lsl r3, r3, #2
    44e8: e51b2008  ldr r2, [fp, #-8]
    44ec: e0823003  add r3, r2, r3
    44f0: e50b3008  str r3, [fp, #-8]
        
        
        switch ( opcode ) {
    44f4: e51b301c  ldr r3, [fp, #-28]  ; 0xffffffe4
    44f8: e3530005  cmp r3, #5
    44fc: 979ff103  ldrls pc, [pc, r3, lsl #2]
    4500: ea000050  b 4648 <ps7_config+0x20c>
    4504: 0000451c  .word 0x0000451c
    4508: 00004528  .word 0x00004528
    450c: 00004540  .word 0x00004540
    4510: 00004560  .word 0x00004560
    4514: 000045a8  .word 0x000045a8
    4518: 0000460c  .word 0x0000460c
            
        case OPCODE_EXIT:
            finish = PS7_INIT_SUCCESS;
    451c: e3a03000  mov r3, #0
    4520: e50b3010  str r3, [fp, #-16]
            break;
    4524: ea00004a  b 4654 <ps7_config+0x218>
            
        case OPCODE_CLEAR:
            addr = (unsigned long*) args[0];
    4528: e51b306c  ldr r3, [fp, #-108] ; 0xffffff94
    452c: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
            *addr = 0;
    4530: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    4534: e3a02000  mov r2, #0
    4538: e5832000  str r2, [r3]
            break;
    453c: ea000044  b 4654 <ps7_config+0x218>

        case OPCODE_WRITE:
            addr = (unsigned long*) args[0];
    4540: e51b306c  ldr r3, [fp, #-108] ; 0xffffff94
    4544: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
            val = args[1];
    4548: e51b3068  ldr r3, [fp, #-104] ; 0xffffff98
    454c: e50b3024  str r3, [fp, #-36]  ; 0xffffffdc
            *addr = val;
    4550: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    4554: e51b2024  ldr r2, [fp, #-36]  ; 0xffffffdc
    4558: e5832000  str r2, [r3]
            break;
    455c: ea00003c  b 4654 <ps7_config+0x218>

        case OPCODE_MASKWRITE:
            addr = (unsigned long*) args[0];
    4560: e51b306c  ldr r3, [fp, #-108] ; 0xffffff94
    4564: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
            mask = args[1];
    4568: e51b3068  ldr r3, [fp, #-104] ; 0xffffff98
    456c: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
            val = args[2];
    4570: e51b3064  ldr r3, [fp, #-100] ; 0xffffff9c
    4574: e50b3024  str r3, [fp, #-36]  ; 0xffffffdc
            *addr = ( val & mask ) | ( *addr & ~mask);
    4578: e51b2024  ldr r2, [fp, #-36]  ; 0xffffffdc
    457c: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    4580: e0022003  and r2, r2, r3
    4584: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    4588: e5931000  ldr r1, [r3]
    458c: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    4590: e1e03003  mvn r3, r3
    4594: e0033001  and r3, r3, r1
    4598: e1822003  orr r2, r2, r3
    459c: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    45a0: e5832000  str r2, [r3]
            break;
    45a4: ea00002a  b 4654 <ps7_config+0x218>

        case OPCODE_MASKPOLL:
            addr = (unsigned long*) args[0];
    45a8: e51b306c  ldr r3, [fp, #-108] ; 0xffffff94
    45ac: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
            mask = args[1];
    45b0: e51b3068  ldr r3, [fp, #-104] ; 0xffffff98
    45b4: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
            i = 0;
    45b8: e3a03000  mov r3, #0
    45bc: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
            while (!(*addr & mask)) {
    45c0: ea00000a  b 45f0 <ps7_config+0x1b4>
                if (i == PS7_MASK_POLL_TIME) {
    45c4: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    45c8: e3a03ce1  mov r3, #57600  ; 0xe100
    45cc: e34035f5  movt  r3, #1525 ; 0x5f5
    45d0: e1520003  cmp r2, r3
    45d4: 1a000002  bne 45e4 <ps7_config+0x1a8>
                    finish = PS7_INIT_TIMEOUT;
    45d8: e3a03002  mov r3, #2
    45dc: e50b3010  str r3, [fp, #-16]
                    break;
    45e0: ea000008  b 4608 <ps7_config+0x1cc>
                }
                i++;
    45e4: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    45e8: e2833001  add r3, r3, #1
    45ec: e50b3014  str r3, [fp, #-20]  ; 0xffffffec

        case OPCODE_MASKPOLL:
            addr = (unsigned long*) args[0];
            mask = args[1];
            i = 0;
            while (!(*addr & mask)) {
    45f0: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    45f4: e5932000  ldr r2, [r3]
    45f8: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    45fc: e0033002  and r3, r3, r2
    4600: e3530000  cmp r3, #0
    4604: 0affffee  beq 45c4 <ps7_config+0x188>
                    finish = PS7_INIT_TIMEOUT;
                    break;
                }
                i++;
            }
            break;
    4608: ea000011  b 4654 <ps7_config+0x218>
        case OPCODE_MASKDELAY:
            addr = (unsigned long*) args[0];
    460c: e51b306c  ldr r3, [fp, #-108] ; 0xffffff94
    4610: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
            mask = args[1];
    4614: e51b3068  ldr r3, [fp, #-104] ; 0xffffff98
    4618: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
            int delay = get_number_of_cycles_for_delay(mask);
    461c: e51b0028  ldr r0, [fp, #-40]  ; 0xffffffd8
    4620: eb000112  bl  4a70 <get_number_of_cycles_for_delay>
    4624: e50b002c  str r0, [fp, #-44]  ; 0xffffffd4
            perf_reset_and_start_timer(); 
    4628: eb000129  bl  4ad4 <perf_reset_and_start_timer>
            while ((*addr < delay)) {
    462c: e1a00000  nop     ; (mov r0, r0)
    4630: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    4634: e5932000  ldr r2, [r3]
    4638: e51b302c  ldr r3, [fp, #-44]  ; 0xffffffd4
    463c: e1520003  cmp r2, r3
    4640: 3afffffa  bcc 4630 <ps7_config+0x1f4>
            }
            break;
    4644: ea000002  b 4654 <ps7_config+0x218>
        default:
            finish = PS7_INIT_CORRUPT;
    4648: e3a03001  mov r3, #1
    464c: e50b3010  str r3, [fp, #-16]
            break;
    4650: e1a00000  nop     ; (mov r0, r0)
    unsigned long  val,mask;              // some variable to make code readable

    int finish = -1 ;           // loop while this is negative !
    int i = 0;                  // Timeout variable
    
    while( finish < 0 ) {
    4654: e51b3010  ldr r3, [fp, #-16]
    4658: e3530000  cmp r3, #0
    465c: baffff81  blt 4468 <ps7_config+0x2c>
        default:
            finish = PS7_INIT_CORRUPT;
            break;
        }
    }
    return finish;
    4660: e51b3010  ldr r3, [fp, #-16]
}
    4664: e1a00003  mov r0, r3
    4668: e24bd004  sub sp, fp, #4
    466c: e8bd8800  pop {fp, pc}

00004670 <ps7_post_config>:
unsigned long *ps7_ddr_init_data = ps7_ddr_init_data_3_0;
unsigned long *ps7_peripherals_init_data = ps7_peripherals_init_data_3_0;

int
ps7_post_config() 
{
    4670: e92d4800  push  {fp, lr}
    4674: e28db004  add fp, sp, #4
    4678: e24dd008  sub sp, sp, #8
  // Get the PS_VERSION on run time
  unsigned long si_ver = ps7GetSiliconVersion ();
    467c: ebffff15  bl  42d8 <ps7GetSiliconVersion>
    4680: e50b0008  str r0, [fp, #-8]
  int ret = -1;
    4684: e3e03000  mvn r3, #0
    4688: e50b300c  str r3, [fp, #-12]
  if (si_ver == PCW_SILICON_VERSION_1) {
    468c: e51b3008  ldr r3, [fp, #-8]
    4690: e3530000  cmp r3, #0
    4694: 1a000008  bne 46bc <ps7_post_config+0x4c>
      ret = ps7_config (ps7_post_config_1_0);   
    4698: e30b025c  movw  r0, #45660  ; 0xb25c
    469c: e3400001  movt  r0, #1
    46a0: ebffff65  bl  443c <ps7_config>
    46a4: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    46a8: e51b300c  ldr r3, [fp, #-12]
    46ac: e3530000  cmp r3, #0
    46b0: 0a000016  beq 4710 <ps7_post_config+0xa0>
    46b4: e51b300c  ldr r3, [fp, #-12]
    46b8: ea000015  b 4714 <ps7_post_config+0xa4>
  } else if (si_ver == PCW_SILICON_VERSION_2) {
    46bc: e51b3008  ldr r3, [fp, #-8]
    46c0: e3530001  cmp r3, #1
    46c4: 1a000008  bne 46ec <ps7_post_config+0x7c>
      ret = ps7_config (ps7_post_config_2_0);   
    46c8: e30a040c  movw  r0, #41996  ; 0xa40c
    46cc: e3400001  movt  r0, #1
    46d0: ebffff59  bl  443c <ps7_config>
    46d4: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    46d8: e51b300c  ldr r3, [fp, #-12]
    46dc: e3530000  cmp r3, #0
    46e0: 0a00000a  beq 4710 <ps7_post_config+0xa0>
    46e4: e51b300c  ldr r3, [fp, #-12]
    46e8: ea000009  b 4714 <ps7_post_config+0xa4>
  } else {
      ret = ps7_config (ps7_post_config_3_0);
    46ec: e309059c  movw  r0, #38300  ; 0x959c
    46f0: e3400001  movt  r0, #1
    46f4: ebffff50  bl  443c <ps7_config>
    46f8: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    46fc: e51b300c  ldr r3, [fp, #-12]
    4700: e3530000  cmp r3, #0
    4704: 0a000001  beq 4710 <ps7_post_config+0xa0>
    4708: e51b300c  ldr r3, [fp, #-12]
    470c: ea000000  b 4714 <ps7_post_config+0xa4>
  }
  return PS7_INIT_SUCCESS;
    4710: e3a03000  mov r3, #0
}
    4714: e1a00003  mov r0, r3
    4718: e24bd004  sub sp, fp, #4
    471c: e8bd8800  pop {fp, pc}

00004720 <ps7_debug>:

int
ps7_debug() 
{
    4720: e92d4800  push  {fp, lr}
    4724: e28db004  add fp, sp, #4
    4728: e24dd008  sub sp, sp, #8
  // Get the PS_VERSION on run time
  unsigned long si_ver = ps7GetSiliconVersion ();
    472c: ebfffee9  bl  42d8 <ps7GetSiliconVersion>
    4730: e50b0008  str r0, [fp, #-8]
  int ret = -1;
    4734: e3e03000  mvn r3, #0
    4738: e50b300c  str r3, [fp, #-12]
  if (si_ver == PCW_SILICON_VERSION_1) {
    473c: e51b3008  ldr r3, [fp, #-8]
    4740: e3530000  cmp r3, #0
    4744: 1a000008  bne 476c <ps7_debug+0x4c>
      ret = ps7_config (ps7_debug_1_0);   
    4748: e30b02a0  movw  r0, #45728  ; 0xb2a0
    474c: e3400001  movt  r0, #1
    4750: ebffff39  bl  443c <ps7_config>
    4754: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    4758: e51b300c  ldr r3, [fp, #-12]
    475c: e3530000  cmp r3, #0
    4760: 0a000016  beq 47c0 <ps7_debug+0xa0>
    4764: e51b300c  ldr r3, [fp, #-12]
    4768: ea000015  b 47c4 <ps7_debug+0xa4>
  } else if (si_ver == PCW_SILICON_VERSION_2) {
    476c: e51b3008  ldr r3, [fp, #-8]
    4770: e3530001  cmp r3, #1
    4774: 1a000008  bne 479c <ps7_debug+0x7c>
      ret = ps7_config (ps7_debug_2_0);   
    4778: e30a0450  movw  r0, #42064  ; 0xa450
    477c: e3400001  movt  r0, #1
    4780: ebffff2d  bl  443c <ps7_config>
    4784: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    4788: e51b300c  ldr r3, [fp, #-12]
    478c: e3530000  cmp r3, #0
    4790: 0a00000a  beq 47c0 <ps7_debug+0xa0>
    4794: e51b300c  ldr r3, [fp, #-12]
    4798: ea000009  b 47c4 <ps7_debug+0xa4>
  } else {
      ret = ps7_config (ps7_debug_3_0);
    479c: e30905e0  movw  r0, #38368  ; 0x95e0
    47a0: e3400001  movt  r0, #1
    47a4: ebffff24  bl  443c <ps7_config>
    47a8: e50b000c  str r0, [fp, #-12]
      if (ret != PS7_INIT_SUCCESS) return ret;
    47ac: e51b300c  ldr r3, [fp, #-12]
    47b0: e3530000  cmp r3, #0
    47b4: 0a000001  beq 47c0 <ps7_debug+0xa0>
    47b8: e51b300c  ldr r3, [fp, #-12]
    47bc: ea000000  b 47c4 <ps7_debug+0xa4>
  }
  return PS7_INIT_SUCCESS;
    47c0: e3a03000  mov r3, #0
}
    47c4: e1a00003  mov r0, r3
    47c8: e24bd004  sub sp, fp, #4
    47cc: e8bd8800  pop {fp, pc}

000047d0 <ps7_init>:

int
ps7_init() 
{
    47d0: e92d4800  push  {fp, lr}
    47d4: e28db004  add fp, sp, #4
    47d8: e24dd008  sub sp, sp, #8
  // Get the PS_VERSION on run time
  unsigned long si_ver = ps7GetSiliconVersion ();
    47dc: ebfffebd  bl  42d8 <ps7GetSiliconVersion>
    47e0: e50b0008  str r0, [fp, #-8]
  int ret;
  //int pcw_ver = 0;

  if (si_ver == PCW_SILICON_VERSION_1) {
    47e4: e51b3008  ldr r3, [fp, #-8]
    47e8: e3530000  cmp r3, #0
    47ec: 1a000019  bne 4858 <ps7_init+0x88>
    ps7_mio_init_data = ps7_mio_init_data_1_0;
    47f0: e30b32d4  movw  r3, #45780  ; 0xb2d4
    47f4: e3403001  movt  r3, #1
    47f8: e30a2c1c  movw  r2, #44060  ; 0xac1c
    47fc: e3402001  movt  r2, #1
    4800: e5832000  str r2, [r3]
    ps7_pll_init_data = ps7_pll_init_data_1_0;
    4804: e30b32d8  movw  r3, #45784  ; 0xb2d8
    4808: e3403001  movt  r3, #1
    480c: e30a2484  movw  r2, #42116  ; 0xa484
    4810: e3402001  movt  r2, #1
    4814: e5832000  str r2, [r3]
    ps7_clock_init_data = ps7_clock_init_data_1_0;
    4818: e30b32dc  movw  r3, #45788  ; 0xb2dc
    481c: e3403001  movt  r3, #1
    4820: e30a260c  movw  r2, #42508  ; 0xa60c
    4824: e3402001  movt  r2, #1
    4828: e5832000  str r2, [r3]
    ps7_ddr_init_data = ps7_ddr_init_data_1_0;
    482c: e30b32e0  movw  r3, #45792  ; 0xb2e0
    4830: e3403001  movt  r3, #1
    4834: e30a2700  movw  r2, #42752  ; 0xa700
    4838: e3402001  movt  r2, #1
    483c: e5832000  str r2, [r3]
    ps7_peripherals_init_data = ps7_peripherals_init_data_1_0;
    4840: e30b32e4  movw  r3, #45796  ; 0xb2e4
    4844: e3403001  movt  r3, #1
    4848: e30b20b0  movw  r2, #45232  ; 0xb0b0
    484c: e3402001  movt  r2, #1
    4850: e5832000  str r2, [r3]
    4854: ea000035  b 4930 <ps7_init+0x160>
    //pcw_ver = 1;

  } else if (si_ver == PCW_SILICON_VERSION_2) {
    4858: e51b3008  ldr r3, [fp, #-8]
    485c: e3530001  cmp r3, #1
    4860: 1a000019  bne 48cc <ps7_init+0xfc>
    ps7_mio_init_data = ps7_mio_init_data_2_0;
    4864: e30b32d4  movw  r3, #45780  ; 0xb2d4
    4868: e3403001  movt  r3, #1
    486c: e3092dcc  movw  r2, #40396  ; 0x9dcc
    4870: e3402001  movt  r2, #1
    4874: e5832000  str r2, [r3]
    ps7_pll_init_data = ps7_pll_init_data_2_0;
    4878: e30b32d8  movw  r3, #45784  ; 0xb2d8
    487c: e3403001  movt  r3, #1
    4880: e3092614  movw  r2, #38420  ; 0x9614
    4884: e3402001  movt  r2, #1
    4888: e5832000  str r2, [r3]
    ps7_clock_init_data = ps7_clock_init_data_2_0;
    488c: e30b32dc  movw  r3, #45788  ; 0xb2dc
    4890: e3403001  movt  r3, #1
    4894: e309279c  movw  r2, #38812  ; 0x979c
    4898: e3402001  movt  r2, #1
    489c: e5832000  str r2, [r3]
    ps7_ddr_init_data = ps7_ddr_init_data_2_0;
    48a0: e30b32e0  movw  r3, #45792  ; 0xb2e0
    48a4: e3403001  movt  r3, #1
    48a8: e3092890  movw  r2, #39056  ; 0x9890
    48ac: e3402001  movt  r2, #1
    48b0: e5832000  str r2, [r3]
    ps7_peripherals_init_data = ps7_peripherals_init_data_2_0;
    48b4: e30b32e4  movw  r3, #45796  ; 0xb2e4
    48b8: e3403001  movt  r3, #1
    48bc: e30a2260  movw  r2, #41568  ; 0xa260
    48c0: e3402001  movt  r2, #1
    48c4: e5832000  str r2, [r3]
    48c8: ea000018  b 4930 <ps7_init+0x160>
    //pcw_ver = 2;

  } else {
    ps7_mio_init_data = ps7_mio_init_data_3_0;
    48cc: e30b32d4  movw  r3, #45780  ; 0xb2d4
    48d0: e3403001  movt  r3, #1
    48d4: e3082f5c  movw  r2, #36700  ; 0x8f5c
    48d8: e3402001  movt  r2, #1
    48dc: e5832000  str r2, [r3]
    ps7_pll_init_data = ps7_pll_init_data_3_0;
    48e0: e30b32d8  movw  r3, #45784  ; 0xb2d8
    48e4: e3403001  movt  r3, #1
    48e8: e30827b4  movw  r2, #34740  ; 0x87b4
    48ec: e3402001  movt  r2, #1
    48f0: e5832000  str r2, [r3]
    ps7_clock_init_data = ps7_clock_init_data_3_0;
    48f4: e30b32dc  movw  r3, #45788  ; 0xb2dc
    48f8: e3403001  movt  r3, #1
    48fc: e308293c  movw  r2, #35132  ; 0x893c
    4900: e3402001  movt  r2, #1
    4904: e5832000  str r2, [r3]
    ps7_ddr_init_data = ps7_ddr_init_data_3_0;
    4908: e30b32e0  movw  r3, #45792  ; 0xb2e0
    490c: e3403001  movt  r3, #1
    4910: e3082a30  movw  r2, #35376  ; 0x8a30
    4914: e3402001  movt  r2, #1
    4918: e5832000  str r2, [r3]
    ps7_peripherals_init_data = ps7_peripherals_init_data_3_0;
    491c: e30b32e4  movw  r3, #45796  ; 0xb2e4
    4920: e3403001  movt  r3, #1
    4924: e30923f0  movw  r2, #37872  ; 0x93f0
    4928: e3402001  movt  r2, #1
    492c: e5832000  str r2, [r3]
    //pcw_ver = 3;
  }

  // MIO init
  ret = ps7_config (ps7_mio_init_data);  
    4930: e30b32d4  movw  r3, #45780  ; 0xb2d4
    4934: e3403001  movt  r3, #1
    4938: e5933000  ldr r3, [r3]
    493c: e1a00003  mov r0, r3
    4940: ebfffebd  bl  443c <ps7_config>
    4944: e50b000c  str r0, [fp, #-12]
  if (ret != PS7_INIT_SUCCESS) return ret;
    4948: e51b300c  ldr r3, [fp, #-12]
    494c: e3530000  cmp r3, #0
    4950: 0a000001  beq 495c <ps7_init+0x18c>
    4954: e51b300c  ldr r3, [fp, #-12]
    4958: ea00002c  b 4a10 <ps7_init+0x240>

  // PLL init
  ret = ps7_config (ps7_pll_init_data); 
    495c: e30b32d8  movw  r3, #45784  ; 0xb2d8
    4960: e3403001  movt  r3, #1
    4964: e5933000  ldr r3, [r3]
    4968: e1a00003  mov r0, r3
    496c: ebfffeb2  bl  443c <ps7_config>
    4970: e50b000c  str r0, [fp, #-12]
  if (ret != PS7_INIT_SUCCESS) return ret;
    4974: e51b300c  ldr r3, [fp, #-12]
    4978: e3530000  cmp r3, #0
    497c: 0a000001  beq 4988 <ps7_init+0x1b8>
    4980: e51b300c  ldr r3, [fp, #-12]
    4984: ea000021  b 4a10 <ps7_init+0x240>

  // Clock init
  ret = ps7_config (ps7_clock_init_data);
    4988: e30b32dc  movw  r3, #45788  ; 0xb2dc
    498c: e3403001  movt  r3, #1
    4990: e5933000  ldr r3, [r3]
    4994: e1a00003  mov r0, r3
    4998: ebfffea7  bl  443c <ps7_config>
    499c: e50b000c  str r0, [fp, #-12]
  if (ret != PS7_INIT_SUCCESS) return ret;
    49a0: e51b300c  ldr r3, [fp, #-12]
    49a4: e3530000  cmp r3, #0
    49a8: 0a000001  beq 49b4 <ps7_init+0x1e4>
    49ac: e51b300c  ldr r3, [fp, #-12]
    49b0: ea000016  b 4a10 <ps7_init+0x240>

  // DDR init
  ret = ps7_config (ps7_ddr_init_data);
    49b4: e30b32e0  movw  r3, #45792  ; 0xb2e0
    49b8: e3403001  movt  r3, #1
    49bc: e5933000  ldr r3, [r3]
    49c0: e1a00003  mov r0, r3
    49c4: ebfffe9c  bl  443c <ps7_config>
    49c8: e50b000c  str r0, [fp, #-12]
  if (ret != PS7_INIT_SUCCESS) return ret;
    49cc: e51b300c  ldr r3, [fp, #-12]
    49d0: e3530000  cmp r3, #0
    49d4: 0a000001  beq 49e0 <ps7_init+0x210>
    49d8: e51b300c  ldr r3, [fp, #-12]
    49dc: ea00000b  b 4a10 <ps7_init+0x240>



  // Peripherals init
  ret = ps7_config (ps7_peripherals_init_data);
    49e0: e30b32e4  movw  r3, #45796  ; 0xb2e4
    49e4: e3403001  movt  r3, #1
    49e8: e5933000  ldr r3, [r3]
    49ec: e1a00003  mov r0, r3
    49f0: ebfffe91  bl  443c <ps7_config>
    49f4: e50b000c  str r0, [fp, #-12]
  if (ret != PS7_INIT_SUCCESS) return ret;
    49f8: e51b300c  ldr r3, [fp, #-12]
    49fc: e3530000  cmp r3, #0
    4a00: 0a000001  beq 4a0c <ps7_init+0x23c>
    4a04: e51b300c  ldr r3, [fp, #-12]
    4a08: ea000000  b 4a10 <ps7_init+0x240>
  //xil_printf ("\n PCW Silicon Version : %d.0", pcw_ver);
  return PS7_INIT_SUCCESS;
    4a0c: e3a03000  mov r3, #0
}
    4a10: e1a00003  mov r0, r3
    4a14: e24bd004  sub sp, fp, #4
    4a18: e8bd8800  pop {fp, pc}

00004a1c <perf_start_clock>:

/* For delay calculation using global timer */

/* start timer */
 void perf_start_clock(void)
{
    4a1c: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4a20: e28db000  add fp, sp, #0
  *(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = ((1 << 0) | // Timer Enable
    4a24: e3a03f82  mov r3, #520  ; 0x208
    4a28: e34f38f0  movt  r3, #63728  ; 0xf8f0
    4a2c: e3a02009  mov r2, #9
    4a30: e5832000  str r2, [r3]
                  (1 << 3) | // Auto-increment
                  (0 << 8) // Pre-scale
  ); 
}
    4a34: e24bd000  sub sp, fp, #0
    4a38: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4a3c: e12fff1e  bx  lr

00004a40 <perf_reset_clock>:

/* stop timer and reset timer count regs */
 void perf_reset_clock(void)
{
    4a40: e92d4800  push  {fp, lr}
    4a44: e28db004  add fp, sp, #4
  perf_disable_clock();
    4a48: eb000018  bl  4ab0 <perf_disable_clock>
  *(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_L32 = 0;
    4a4c: e3a03c02  mov r3, #512  ; 0x200
    4a50: e34f38f0  movt  r3, #63728  ; 0xf8f0
    4a54: e3a02000  mov r2, #0
    4a58: e5832000  str r2, [r3]
  *(volatile unsigned int*)SCU_GLOBAL_TIMER_COUNT_U32 = 0;
    4a5c: e3a03f81  mov r3, #516  ; 0x204
    4a60: e34f38f0  movt  r3, #63728  ; 0xf8f0
    4a64: e3a02000  mov r2, #0
    4a68: e5832000  str r2, [r3]
}
    4a6c: e8bd8800  pop {fp, pc}

00004a70 <get_number_of_cycles_for_delay>:

/* Compute mask for given delay in miliseconds*/
int get_number_of_cycles_for_delay(unsigned int delay) 
{
    4a70: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4a74: e28db000  add fp, sp, #0
    4a78: e24dd00c  sub sp, sp, #12
    4a7c: e50b0008  str r0, [fp, #-8]
  // GTC is always clocked at 1/2 of the CPU frequency (CPU_3x2x)
  return (APU_FREQ*delay/(2*1000));
    4a80: e51b2008  ldr r2, [fp, #-8]
    4a84: e30836bf  movw  r3, #34495  ; 0x86bf
    4a88: e34237bc  movt  r3, #10172  ; 0x27bc
    4a8c: e0020293  mul r2, r3, r2
    4a90: e3043dd3  movw  r3, #19923  ; 0x4dd3
    4a94: e3413062  movt  r3, #4194 ; 0x1062
    4a98: e0832392  umull r2, r3, r2, r3
    4a9c: e1a033a3  lsr r3, r3, #7
   
}
    4aa0: e1a00003  mov r0, r3
    4aa4: e24bd000  sub sp, fp, #0
    4aa8: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4aac: e12fff1e  bx  lr

00004ab0 <perf_disable_clock>:

/* stop timer */
 void perf_disable_clock(void)
{
    4ab0: e52db004  push  {fp}    ; (str fp, [sp, #-4]!)
    4ab4: e28db000  add fp, sp, #0
  *(volatile unsigned int*)SCU_GLOBAL_TIMER_CONTROL = 0;
    4ab8: e3a03f82  mov r3, #520  ; 0x208
    4abc: e34f38f0  movt  r3, #63728  ; 0xf8f0
    4ac0: e3a02000  mov r2, #0
    4ac4: e5832000  str r2, [r3]
}
    4ac8: e24bd000  sub sp, fp, #0
    4acc: e49db004  pop {fp}    ; (ldr fp, [sp], #4)
    4ad0: e12fff1e  bx  lr

00004ad4 <perf_reset_and_start_timer>:

void perf_reset_and_start_timer() 
{
    4ad4: e92d4800  push  {fp, lr}
    4ad8: e28db004  add fp, sp, #4
        perf_reset_clock();
    4adc: ebffffd7  bl  4a40 <perf_reset_clock>
      perf_start_clock();
    4ae0: ebffffcd  bl  4a1c <perf_start_clock>
}
    4ae4: e8bd8800  pop {fp, pc}

00004ae8 <InitQspi>:
*
* @note   None
*
****************************************************************************/
u32 InitQspi(void)
{
    4ae8: e92d4800  push  {fp, lr}
    4aec: e28db004  add fp, sp, #4
    4af0: e24dd008  sub sp, sp, #8
  XQspiPs_Config *QspiConfig;
  int Status;

  QspiInstancePtr = &QspiInstance;
    4af4: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4af8: e3403002  movt  r3, #2
    4afc: e3022aac  movw  r2, #10924  ; 0x2aac
    4b00: e3402002  movt  r2, #2
    4b04: e5832000  str r2, [r3]

  /*
   * Set up the base address for access
   */
  FlashReadBaseAddress = XPS_QSPI_LINEAR_BASEADDR;
    4b08: e301305c  movw  r3, #4188 ; 0x105c
    4b0c: e3403002  movt  r3, #2
    4b10: e3a0233f  mov r2, #-67108864  ; 0xfc000000
    4b14: e5832000  str r2, [r3]

  /*
   * Initialize the QSPI driver so that it's ready to use
   */
  QspiConfig = XQspiPs_LookupConfig(QSPI_DEVICE_ID);
    4b18: e3a00000  mov r0, #0
    4b1c: eb001015  bl  8b78 <XQspiPs_LookupConfig>
    4b20: e50b0008  str r0, [fp, #-8]
  if (NULL == QspiConfig) {
    4b24: e51b3008  ldr r3, [fp, #-8]
    4b28: e3530000  cmp r3, #0
    4b2c: 1a000001  bne 4b38 <InitQspi+0x50>
    return XST_FAILURE;
    4b30: e3a03001  mov r3, #1
    4b34: ea00005c  b 4cac <InitQspi+0x1c4>
  }

  Status = XQspiPs_CfgInitialize(QspiInstancePtr, QspiConfig,
    4b38: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4b3c: e3403002  movt  r3, #2
    4b40: e5932000  ldr r2, [r3]
    4b44: e51b3008  ldr r3, [fp, #-8]
    4b48: e5933004  ldr r3, [r3, #4]
    4b4c: e1a00002  mov r0, r2
    4b50: e51b1008  ldr r1, [fp, #-8]
    4b54: e1a02003  mov r2, r3
    4b58: eb000c1a  bl  7bc8 <XQspiPs_CfgInitialize>
    4b5c: e50b000c  str r0, [fp, #-12]
          QspiConfig->BaseAddress);
  if (Status != XST_SUCCESS) {
    4b60: e51b300c  ldr r3, [fp, #-12]
    4b64: e3530000  cmp r3, #0
    4b68: 0a000001  beq 4b74 <InitQspi+0x8c>
    return XST_FAILURE;
    4b6c: e3a03001  mov r3, #1
    4b70: ea00004d  b 4cac <InitQspi+0x1c4>
  }

  /*
   * Set Manual Chip select options and drive HOLD_B pin high.
   */
  XQspiPs_SetOptions(QspiInstancePtr, XQSPIPS_FORCE_SSELECT_OPTION |
    4b74: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4b78: e3403002  movt  r3, #2
    4b7c: e5933000  ldr r3, [r3]
    4b80: e1a00003  mov r0, r3
    4b84: e3a01e11  mov r1, #272  ; 0x110
    4b88: eb001001  bl  8b94 <XQspiPs_SetOptions>
      XQSPIPS_HOLD_B_DRIVE_OPTION);

  /*
   * Set the prescaler for QSPI clock
   */
  XQspiPs_SetClkPrescaler(QspiInstancePtr, XQSPIPS_CLK_PRESCALE_8);
    4b8c: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4b90: e3403002  movt  r3, #2
    4b94: e5933000  ldr r3, [r3]
    4b98: e1a00003  mov r0, r3
    4b9c: e3a01002  mov r1, #2
    4ba0: eb001075  bl  8d7c <XQspiPs_SetClkPrescaler>

  /*
   * Assert the FLASH chip select.
   */
  XQspiPs_SetSlaveSelect(QspiInstancePtr);
    4ba4: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4ba8: e3403002  movt  r3, #2
    4bac: e5933000  ldr r3, [r3]
    4bb0: e1a00003  mov r0, r3
    4bb4: eb000eb6  bl  8694 <XQspiPs_SetSlaveSelect>

  /*
   * Read Flash ID and extract Manufacture and Size information
   */
  Status = FlashReadID();
    4bb8: eb00003e  bl  4cb8 <FlashReadID>
    4bbc: e1a03000  mov r3, r0
    4bc0: e50b300c  str r3, [fp, #-12]
  if (Status != XST_SUCCESS) {
    4bc4: e51b300c  ldr r3, [fp, #-12]
    4bc8: e3530000  cmp r3, #0
    4bcc: 0a000001  beq 4bd8 <InitQspi+0xf0>
    return XST_FAILURE;
    4bd0: e3a03001  mov r3, #1
    4bd4: ea000034  b 4cac <InitQspi+0x1c4>
  }

  if (XPAR_PS7_QSPI_0_QSPI_MODE == SINGLE_FLASH_CONNECTION) {

    fsbl_printf(DEBUG_INFO,"QSPI is in single flash connection\r\n");
    4bd8: e30802c0  movw  r0, #33472  ; 0x82c0
    4bdc: e3400001  movt  r0, #1
    4be0: eb000606  bl  6400 <xil_printf>
    /*
     * For Flash size <128Mbit controller configured in linear mode
     */
    if (QspiFlashSize <= FLASH_SIZE_16MB) {
    4be4: e3023aa4  movw  r3, #10916  ; 0x2aa4
    4be8: e3403002  movt  r3, #2
    4bec: e5933000  ldr r3, [r3]
    4bf0: e3530401  cmp r3, #16777216 ; 0x1000000
    4bf4: 8a00001b  bhi 4c68 <InitQspi+0x180>
      LinearBootDeviceFlag = 1;
    4bf8: e3013060  movw  r3, #4192 ; 0x1060
    4bfc: e3403002  movt  r3, #2
    4c00: e3a02001  mov r2, #1
    4c04: e5c32000  strb  r2, [r3]

      /*
       * Enable linear mode
       */
      XQspiPs_SetOptions(QspiInstancePtr,  XQSPIPS_LQSPI_MODE_OPTION |
    4c08: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4c0c: e3403002  movt  r3, #2
    4c10: e5933000  ldr r3, [r3]
    4c14: e1a00003  mov r0, r3
    4c18: e3a01d06  mov r1, #384  ; 0x180
    4c1c: eb000fdc  bl  8b94 <XQspiPs_SetOptions>
          XQSPIPS_HOLD_B_DRIVE_OPTION);

      /*
       * Single linear read
       */
      XQspiPs_SetLqspiConfigReg(QspiInstancePtr, SINGLE_QSPI_CONFIG_QUAD_READ);
    4c20: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4c24: e3403002  movt  r3, #2
    4c28: e5933000  ldr r3, [r3]
    4c2c: e5933004  ldr r3, [r3, #4]
    4c30: e28330a0  add r3, r3, #160  ; 0xa0
    4c34: e1a00003  mov r0, r3
    4c38: e300116b  movw  r1, #363  ; 0x16b
    4c3c: e3481000  movt  r1, #32768  ; 0x8000
    4c40: eb00055a  bl  61b0 <Xil_Out32>

      /*
       * Enable the controller
       */
      XQspiPs_Enable(QspiInstancePtr);
    4c44: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4c48: e3403002  movt  r3, #2
    4c4c: e5933000  ldr r3, [r3]
    4c50: e5933004  ldr r3, [r3, #4]
    4c54: e2833014  add r3, r3, #20
    4c58: e1a00003  mov r0, r3
    4c5c: e3a01001  mov r1, #1
    4c60: eb000552  bl  61b0 <Xil_Out32>
    4c64: ea00000f  b 4ca8 <InitQspi+0x1c0>
    } else {
      /*
       * Single flash IO read
       */
      XQspiPs_SetLqspiConfigReg(QspiInstancePtr, SINGLE_QSPI_IO_CONFIG_QUAD_READ);
    4c68: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4c6c: e3403002  movt  r3, #2
    4c70: e5933000  ldr r3, [r3]
    4c74: e5933004  ldr r3, [r3, #4]
    4c78: e28330a0  add r3, r3, #160  ; 0xa0
    4c7c: e1a00003  mov r0, r3
    4c80: e300116b  movw  r1, #363  ; 0x16b
    4c84: eb000549  bl  61b0 <Xil_Out32>

      /*
       * Enable the controller
       */
      XQspiPs_Enable(QspiInstancePtr);
    4c88: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4c8c: e3403002  movt  r3, #2
    4c90: e5933000  ldr r3, [r3]
    4c94: e5933004  ldr r3, [r3, #4]
    4c98: e2833014  add r3, r3, #20
    4c9c: e1a00003  mov r0, r3
    4ca0: e3a01001  mov r1, #1
    4ca4: eb000541  bl  61b0 <Xil_Out32>
     * Enable two flash memories on separate buses
     */
    XQspiPs_SetLqspiConfigReg(QspiInstancePtr, DUAL_STACK_CONFIG_READ);
  }

  return XST_SUCCESS;
    4ca8: e3a03000  mov r3, #0
}
    4cac: e1a00003  mov r0, r3
    4cb0: e24bd004  sub sp, fp, #4
    4cb4: e8bd8800  pop {fp, pc}

00004cb8 <FlashReadID>:
*
* @note   None.
*
******************************************************************************/
u32 FlashReadID(void)
{
    4cb8: e92d4800  push  {fp, lr}
    4cbc: e28db004  add fp, sp, #4
    4cc0: e24dd008  sub sp, sp, #8
  u32 Status;

  /*
   * Read ID in Auto mode.
   */
  WriteBuffer[COMMAND_OFFSET]   = READ_ID_CMD;
    4cc4: e3013a90  movw  r3, #6800 ; 0x1a90
    4cc8: e3403002  movt  r3, #2
    4ccc: e3e02060  mvn r2, #96 ; 0x60
    4cd0: e5c32000  strb  r2, [r3]
  WriteBuffer[ADDRESS_1_OFFSET] = 0x00;   /* 3 dummy bytes */
    4cd4: e3013a90  movw  r3, #6800 ; 0x1a90
    4cd8: e3403002  movt  r3, #2
    4cdc: e3a02000  mov r2, #0
    4ce0: e5c32001  strb  r2, [r3, #1]
  WriteBuffer[ADDRESS_2_OFFSET] = 0x00;
    4ce4: e3013a90  movw  r3, #6800 ; 0x1a90
    4ce8: e3403002  movt  r3, #2
    4cec: e3a02000  mov r2, #0
    4cf0: e5c32002  strb  r2, [r3, #2]
  WriteBuffer[ADDRESS_3_OFFSET] = 0x00;
    4cf4: e3013a90  movw  r3, #6800 ; 0x1a90
    4cf8: e3403002  movt  r3, #2
    4cfc: e3a02000  mov r2, #0
    4d00: e5c32003  strb  r2, [r3, #3]

  Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, ReadBuffer,
    4d04: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4d08: e3403002  movt  r3, #2
    4d0c: e5933000  ldr r3, [r3]
    4d10: e1a00003  mov r0, r3
    4d14: e3011a90  movw  r1, #6800 ; 0x1a90
    4d18: e3401002  movt  r1, #2
    4d1c: e3012a98  movw  r2, #6808 ; 0x1a98
    4d20: e3402002  movt  r2, #2
    4d24: e3a03004  mov r3, #4
    4d28: eb000cc8  bl  8050 <XQspiPs_PolledTransfer>
    4d2c: e1a03000  mov r3, r0
    4d30: e50b3008  str r3, [fp, #-8]
        RD_ID_SIZE);
  if (Status != XST_SUCCESS) {
    4d34: e51b3008  ldr r3, [fp, #-8]
    4d38: e3530000  cmp r3, #0
    4d3c: 0a000001  beq 4d48 <FlashReadID+0x90>
    return XST_FAILURE;
    4d40: e3a03001  mov r3, #1
    4d44: ea00006a  b 4ef4 <FlashReadID+0x23c>
  }

  fsbl_printf(DEBUG_INFO,"Single Flash Information\r\n");
    4d48: e30802e8  movw  r0, #33512  ; 0x82e8
    4d4c: e3400001  movt  r0, #1
    4d50: eb0005aa  bl  6400 <xil_printf>

  fsbl_printf(DEBUG_INFO,"FlashID=0x%x 0x%x 0x%x\r\n", ReadBuffer[1],
    4d54: e3013a98  movw  r3, #6808 ; 0x1a98
    4d58: e3403002  movt  r3, #2
    4d5c: e5d33001  ldrb  r3, [r3, #1]
    4d60: e1a01003  mov r1, r3
    4d64: e3013a98  movw  r3, #6808 ; 0x1a98
    4d68: e3403002  movt  r3, #2
    4d6c: e5d33002  ldrb  r3, [r3, #2]
    4d70: e1a02003  mov r2, r3
    4d74: e3013a98  movw  r3, #6808 ; 0x1a98
    4d78: e3403002  movt  r3, #2
    4d7c: e5d33003  ldrb  r3, [r3, #3]
    4d80: e3080304  movw  r0, #33540  ; 0x8304
    4d84: e3400001  movt  r0, #1
    4d88: eb00059c  bl  6400 <xil_printf>
      ReadBuffer[3]);

  /*
   * Deduce flash make
   */
  if (ReadBuffer[1] == MICRON_ID) {
    4d8c: e3013a98  movw  r3, #6808 ; 0x1a98
    4d90: e3403002  movt  r3, #2
    4d94: e5d33001  ldrb  r3, [r3, #1]
    4d98: e3530020  cmp r3, #32
    4d9c: 1a000007  bne 4dc0 <FlashReadID+0x108>
    QspiFlashMake = MICRON_ID;
    4da0: e3023aa0  movw  r3, #10912  ; 0x2aa0
    4da4: e3403002  movt  r3, #2
    4da8: e3a02020  mov r2, #32
    4dac: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "MICRON ");
    4db0: e3080320  movw  r0, #33568  ; 0x8320
    4db4: e3400001  movt  r0, #1
    4db8: eb000590  bl  6400 <xil_printf>
    4dbc: ea000018  b 4e24 <FlashReadID+0x16c>
  } else if(ReadBuffer[1] == SPANSION_ID) {
    4dc0: e3013a98  movw  r3, #6808 ; 0x1a98
    4dc4: e3403002  movt  r3, #2
    4dc8: e5d33001  ldrb  r3, [r3, #1]
    4dcc: e3530001  cmp r3, #1
    4dd0: 1a000007  bne 4df4 <FlashReadID+0x13c>
    QspiFlashMake = SPANSION_ID;
    4dd4: e3023aa0  movw  r3, #10912  ; 0x2aa0
    4dd8: e3403002  movt  r3, #2
    4ddc: e3a02001  mov r2, #1
    4de0: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "SPANSION ");
    4de4: e3080328  movw  r0, #33576  ; 0x8328
    4de8: e3400001  movt  r0, #1
    4dec: eb000583  bl  6400 <xil_printf>
    4df0: ea00000b  b 4e24 <FlashReadID+0x16c>
  } else if(ReadBuffer[1] == WINBOND_ID) {
    4df4: e3013a98  movw  r3, #6808 ; 0x1a98
    4df8: e3403002  movt  r3, #2
    4dfc: e5d33001  ldrb  r3, [r3, #1]
    4e00: e35300ef  cmp r3, #239  ; 0xef
    4e04: 1a000006  bne 4e24 <FlashReadID+0x16c>
    QspiFlashMake = WINBOND_ID;
    4e08: e3023aa0  movw  r3, #10912  ; 0x2aa0
    4e0c: e3403002  movt  r3, #2
    4e10: e3a020ef  mov r2, #239  ; 0xef
    4e14: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "WINBOND ");
    4e18: e3080334  movw  r0, #33588  ; 0x8334
    4e1c: e3400001  movt  r0, #1
    4e20: eb000576  bl  6400 <xil_printf>
  }

  /*
   * Deduce flash Size
   */
  if (ReadBuffer[3] == FLASH_SIZE_ID_128M) {
    4e24: e3013a98  movw  r3, #6808 ; 0x1a98
    4e28: e3403002  movt  r3, #2
    4e2c: e5d33003  ldrb  r3, [r3, #3]
    4e30: e3530018  cmp r3, #24
    4e34: 1a000007  bne 4e58 <FlashReadID+0x1a0>
    QspiFlashSize = FLASH_SIZE_128M;
    4e38: e3023aa4  movw  r3, #10916  ; 0x2aa4
    4e3c: e3403002  movt  r3, #2
    4e40: e3a02401  mov r2, #16777216 ; 0x1000000
    4e44: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "128M Bits\r\n");
    4e48: e3080340  movw  r0, #33600  ; 0x8340
    4e4c: e3400001  movt  r0, #1
    4e50: eb00056a  bl  6400 <xil_printf>
    4e54: ea000025  b 4ef0 <FlashReadID+0x238>
  } else if (ReadBuffer[3] == FLASH_SIZE_ID_256M) {
    4e58: e3013a98  movw  r3, #6808 ; 0x1a98
    4e5c: e3403002  movt  r3, #2
    4e60: e5d33003  ldrb  r3, [r3, #3]
    4e64: e3530019  cmp r3, #25
    4e68: 1a000007  bne 4e8c <FlashReadID+0x1d4>
    QspiFlashSize = FLASH_SIZE_256M;
    4e6c: e3023aa4  movw  r3, #10916  ; 0x2aa4
    4e70: e3403002  movt  r3, #2
    4e74: e3a02402  mov r2, #33554432 ; 0x2000000
    4e78: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "256M Bits\r\n");
    4e7c: e308034c  movw  r0, #33612  ; 0x834c
    4e80: e3400001  movt  r0, #1
    4e84: eb00055d  bl  6400 <xil_printf>
    4e88: ea000018  b 4ef0 <FlashReadID+0x238>
  } else if (ReadBuffer[3] == FLASH_SIZE_ID_512M) {
    4e8c: e3013a98  movw  r3, #6808 ; 0x1a98
    4e90: e3403002  movt  r3, #2
    4e94: e5d33003  ldrb  r3, [r3, #3]
    4e98: e3530020  cmp r3, #32
    4e9c: 1a000007  bne 4ec0 <FlashReadID+0x208>
    QspiFlashSize = FLASH_SIZE_512M;
    4ea0: e3023aa4  movw  r3, #10916  ; 0x2aa4
    4ea4: e3403002  movt  r3, #2
    4ea8: e3a02301  mov r2, #67108864 ; 0x4000000
    4eac: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "512M Bits\r\n");
    4eb0: e3080358  movw  r0, #33624  ; 0x8358
    4eb4: e3400001  movt  r0, #1
    4eb8: eb000550  bl  6400 <xil_printf>
    4ebc: ea00000b  b 4ef0 <FlashReadID+0x238>
  } else if (ReadBuffer[3] == FLASH_SIZE_ID_1G) {
    4ec0: e3013a98  movw  r3, #6808 ; 0x1a98
    4ec4: e3403002  movt  r3, #2
    4ec8: e5d33003  ldrb  r3, [r3, #3]
    4ecc: e3530021  cmp r3, #33 ; 0x21
    4ed0: 1a000006  bne 4ef0 <FlashReadID+0x238>
    QspiFlashSize = FLASH_SIZE_1G;
    4ed4: e3023aa4  movw  r3, #10916  ; 0x2aa4
    4ed8: e3403002  movt  r3, #2
    4edc: e3a02302  mov r2, #134217728  ; 0x8000000
    4ee0: e5832000  str r2, [r3]
    fsbl_printf(DEBUG_INFO, "1G Bits\r\n");
    4ee4: e3080364  movw  r0, #33636  ; 0x8364
    4ee8: e3400001  movt  r0, #1
    4eec: eb000543  bl  6400 <xil_printf>
  }

  return XST_SUCCESS;
    4ef0: e3a03000  mov r3, #0
}
    4ef4: e1a00003  mov r0, r3
    4ef8: e24bd004  sub sp, fp, #4
    4efc: e8bd8800  pop {fp, pc}

00004f00 <FlashRead>:
*
* @note   None.
*
******************************************************************************/
void FlashRead(u32 Address, u32 ByteCount)
{
    4f00: e92d4800  push  {fp, lr}
    4f04: e28db004  add fp, sp, #4
    4f08: e24dd008  sub sp, sp, #8
    4f0c: e50b0008  str r0, [fp, #-8]
    4f10: e50b100c  str r1, [fp, #-12]
  /*
   * Setup the write command with the specified address and data for the
   * FLASH
   */
  WriteBuffer[COMMAND_OFFSET]   = QUAD_READ_CMD;
    4f14: e3013a90  movw  r3, #6800 ; 0x1a90
    4f18: e3403002  movt  r3, #2
    4f1c: e3a0206b  mov r2, #107  ; 0x6b
    4f20: e5c32000  strb  r2, [r3]
  WriteBuffer[ADDRESS_1_OFFSET] = (u8)((Address & 0xFF0000) >> 16);
    4f24: e51b3008  ldr r3, [fp, #-8]
    4f28: e20338ff  and r3, r3, #16711680 ; 0xff0000
    4f2c: e1a03823  lsr r3, r3, #16
    4f30: e6ef2073  uxtb  r2, r3
    4f34: e3013a90  movw  r3, #6800 ; 0x1a90
    4f38: e3403002  movt  r3, #2
    4f3c: e5c32001  strb  r2, [r3, #1]
  WriteBuffer[ADDRESS_2_OFFSET] = (u8)((Address & 0xFF00) >> 8);
    4f40: e51b3008  ldr r3, [fp, #-8]
    4f44: e2033cff  and r3, r3, #65280  ; 0xff00
    4f48: e1a03423  lsr r3, r3, #8
    4f4c: e6ef2073  uxtb  r2, r3
    4f50: e3013a90  movw  r3, #6800 ; 0x1a90
    4f54: e3403002  movt  r3, #2
    4f58: e5c32002  strb  r2, [r3, #2]
  WriteBuffer[ADDRESS_3_OFFSET] = (u8)(Address & 0xFF);
    4f5c: e51b3008  ldr r3, [fp, #-8]
    4f60: e6ef2073  uxtb  r2, r3
    4f64: e3013a90  movw  r3, #6800 ; 0x1a90
    4f68: e3403002  movt  r3, #2
    4f6c: e5c32003  strb  r2, [r3, #3]

  ByteCount += DUMMY_SIZE;
    4f70: e51b300c  ldr r3, [fp, #-12]
    4f74: e2833001  add r3, r3, #1
    4f78: e50b300c  str r3, [fp, #-12]
  /*
   * Send the read command to the FLASH to read the specified number
   * of bytes from the FLASH, send the read command and address and
   * receive the specified number of bytes of data in the data buffer
   */
  XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, ReadBuffer,
    4f7c: e3023aa8  movw  r3, #10920  ; 0x2aa8
    4f80: e3403002  movt  r3, #2
    4f84: e5932000  ldr r2, [r3]
        ByteCount + OVERHEAD_SIZE);
    4f88: e51b300c  ldr r3, [fp, #-12]
    4f8c: e2833004  add r3, r3, #4
  /*
   * Send the read command to the FLASH to read the specified number
   * of bytes from the FLASH, send the read command and address and
   * receive the specified number of bytes of data in the data buffer
   */
  XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, ReadBuffer,
    4f90: e1a00002  mov r0, r2
    4f94: e3011a90  movw  r1, #6800 ; 0x1a90
    4f98: e3401002  movt  r1, #2
    4f9c: e3012a98  movw  r2, #6808 ; 0x1a98
    4fa0: e3402002  movt  r2, #2
    4fa4: eb000c29  bl  8050 <XQspiPs_PolledTransfer>
        ByteCount + OVERHEAD_SIZE);
}
    4fa8: e24bd004  sub sp, fp, #4
    4fac: e8bd8800  pop {fp, pc}

00004fb0 <QspiAccess>:
*
* @note none.
*
****************************************************************************/
u32 QspiAccess( u32 SourceAddress, u32 DestinationAddress, u32 LengthBytes)
{
    4fb0: e92d4800  push  {fp, lr}
    4fb4: e28db004  add fp, sp, #4
    4fb8: e24dd028  sub sp, sp, #40 ; 0x28
    4fbc: e50b0020  str r0, [fp, #-32]  ; 0xffffffe0
    4fc0: e50b1024  str r1, [fp, #-36]  ; 0xffffffdc
    4fc4: e50b2028  str r2, [fp, #-40]  ; 0xffffffd8
  u8  *BufferPtr;
  u32 Length = 0;
    4fc8: e3a03000  mov r3, #0
    4fcc: e50b300c  str r3, [fp, #-12]
  u32 BankSel = 0;
    4fd0: e3a03000  mov r3, #0
    4fd4: e50b3014  str r3, [fp, #-20]  ; 0xffffffec
  u32 LqspiCrReg;
  u32 Status;
  u8 BankSwitchFlag = 1;
    4fd8: e3a03001  mov r3, #1
    4fdc: e54b300d  strb  r3, [fp, #-13]

  /*
   * Linear access check
   */
  if (LinearBootDeviceFlag == 1) {
    4fe0: e3013060  movw  r3, #4192 ; 0x1060
    4fe4: e3403002  movt  r3, #2
    4fe8: e5d33000  ldrb  r3, [r3]
    4fec: e3530001  cmp r3, #1
    4ff0: 1a000012  bne 5040 <QspiAccess+0x90>
    /*
     * Check for non-word tail, add bytes to cover the end
     */
    if ((LengthBytes%4) != 0){
    4ff4: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    4ff8: e2033003  and r3, r3, #3
    4ffc: e3530000  cmp r3, #0
    5000: 0a000003  beq 5014 <QspiAccess+0x64>
      LengthBytes += (4 - (LengthBytes & 0x00000003));
    5004: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    5008: e3c33003  bic r3, r3, #3
    500c: e2833004  add r3, r3, #4
    5010: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
    }

    memcpy((void*)DestinationAddress,
    5014: e51b1024  ldr r1, [fp, #-36]  ; 0xffffffdc
          (const void*)(SourceAddress + FlashReadBaseAddress),
    5018: e301305c  movw  r3, #4188 ; 0x105c
    501c: e3403002  movt  r3, #2
    5020: e5932000  ldr r2, [r3]
    5024: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    5028: e0823003  add r3, r2, r3
     */
    if ((LengthBytes%4) != 0){
      LengthBytes += (4 - (LengthBytes & 0x00000003));
    }

    memcpy((void*)DestinationAddress,
    502c: e1a00001  mov r0, r1
    5030: e1a01003  mov r1, r3
    5034: e51b2028  ldr r2, [fp, #-40]  ; 0xffffffd8
    5038: eb001210  bl  9880 <memcpy>
    503c: ea000057  b 51a0 <QspiAccess+0x1f0>
          (size_t)LengthBytes);
  } else {
    /*
     * Non Linear access
     */
    BufferPtr = (u8*)DestinationAddress;
    5040: e51b3024  ldr r3, [fp, #-36]  ; 0xffffffdc
    5044: e50b3008  str r3, [fp, #-8]
     */
    if (XPAR_PS7_QSPI_0_QSPI_MODE == DUAL_PARALLEL_CONNECTION) {
      SourceAddress = SourceAddress/2;
    }

    while(LengthBytes > 0) {
    5048: ea000046  b 5168 <QspiAccess+0x1b8>
      /*
       * Local of DATA_SIZE size used for read/write buffer
       */
      if(LengthBytes > DATA_SIZE) {
    504c: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    5050: e3530a01  cmp r3, #4096 ; 0x1000
    5054: 9a000002  bls 5064 <QspiAccess+0xb4>
        Length = DATA_SIZE;
    5058: e3a03a01  mov r3, #4096 ; 0x1000
    505c: e50b300c  str r3, [fp, #-12]
    5060: ea000001  b 506c <QspiAccess+0xbc>
      } else {
        Length = LengthBytes;
    5064: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    5068: e50b300c  str r3, [fp, #-12]
      }

      /*
       * Select bank
       */
      if ((SourceAddress >= FLASH_SIZE_16MB) && (BankSwitchFlag == 1)) {
    506c: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    5070: e3530401  cmp r3, #16777216 ; 0x1000000
    5074: 3a000018  bcc 50dc <QspiAccess+0x12c>
    5078: e55b300d  ldrb  r3, [fp, #-13]
    507c: e3530001  cmp r3, #1
    5080: 1a000015  bne 50dc <QspiAccess+0x12c>
        BankSel = SourceAddress/FLASH_SIZE_16MB;
    5084: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    5088: e1a03c23  lsr r3, r3, #24
    508c: e50b3014  str r3, [fp, #-20]  ; 0xffffffec

        fsbl_printf(DEBUG_INFO, "Bank Selection %d\n\r", BankSel);
    5090: e3080370  movw  r0, #33648  ; 0x8370
    5094: e3400001  movt  r0, #1
    5098: e51b1014  ldr r1, [fp, #-20]  ; 0xffffffec
    509c: eb0004d7  bl  6400 <xil_printf>

        Status = SendBankSelect(BankSel);
    50a0: e51b3014  ldr r3, [fp, #-20]  ; 0xffffffec
    50a4: e6ef3073  uxtb  r3, r3
    50a8: e1a00003  mov r0, r3
    50ac: eb000040  bl  51b4 <SendBankSelect>
    50b0: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
        if (Status != XST_SUCCESS) {
    50b4: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    50b8: e3530000  cmp r3, #0
    50bc: 0a000004  beq 50d4 <QspiAccess+0x124>
          fsbl_printf(DEBUG_INFO, "Bank Selection Failed\n\r");
    50c0: e3080384  movw  r0, #33668  ; 0x8384
    50c4: e3400001  movt  r0, #1
    50c8: eb0004cc  bl  6400 <xil_printf>
          return XST_FAILURE;
    50cc: e3a03001  mov r3, #1
    50d0: ea000033  b 51a4 <QspiAccess+0x1f4>
        }

        BankSwitchFlag = 0;
    50d4: e3a03000  mov r3, #0
    50d8: e54b300d  strb  r3, [fp, #-13]
           */
          Length = Length * 2;
          BankSwitchFlag = 1;
        }
      } else {
        if((SourceAddress & BANKMASK) != ((SourceAddress + Length) & BANKMASK))
    50dc: e51b2020  ldr r2, [fp, #-32]  ; 0xffffffe0
    50e0: e51b300c  ldr r3, [fp, #-12]
    50e4: e0822003  add r2, r2, r3
    50e8: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    50ec: e0233002  eor r3, r3, r2
    50f0: e203340f  and r3, r3, #251658240  ; 0xf000000
    50f4: e3530000  cmp r3, #0
    50f8: 0a000007  beq 511c <QspiAccess+0x16c>
        {
          Length = (SourceAddress & BANKMASK) + FLASH_SIZE_16MB - SourceAddress;
    50fc: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    5100: e203240f  and r2, r3, #251658240  ; 0xf000000
    5104: e51b3020  ldr r3, [fp, #-32]  ; 0xffffffe0
    5108: e0633002  rsb r3, r3, r2
    510c: e2833401  add r3, r3, #16777216 ; 0x1000000
    5110: e50b300c  str r3, [fp, #-12]
          BankSwitchFlag = 1;
    5114: e3a03001  mov r3, #1
    5118: e54b300d  strb  r3, [fp, #-13]
      }

      /*
       * Copying the image to local buffer
       */
      FlashRead(SourceAddress, Length);
    511c: e51b0020  ldr r0, [fp, #-32]  ; 0xffffffe0
    5120: e51b100c  ldr r1, [fp, #-12]
    5124: ebffff75  bl  4f00 <FlashRead>

      /*
       * Moving the data from local buffer to DDR destination address
       */
      memcpy(BufferPtr, &ReadBuffer[DATA_OFFSET + DUMMY_SIZE], Length);
    5128: e51b0008  ldr r0, [fp, #-8]
    512c: e59f107c  ldr r1, [pc, #124]  ; 51b0 <QspiAccess+0x200>
    5130: e51b200c  ldr r2, [fp, #-12]
    5134: eb0011d1  bl  9880 <memcpy>

      /*
       * Updated the variables
       */
      LengthBytes -= Length;
    5138: e51b2028  ldr r2, [fp, #-40]  ; 0xffffffd8
    513c: e51b300c  ldr r3, [fp, #-12]
    5140: e0633002  rsb r3, r3, r2
    5144: e50b3028  str r3, [fp, #-40]  ; 0xffffffd8
       * For Dual parallel connection address increment should be half
       */
      if (XPAR_PS7_QSPI_0_QSPI_MODE == DUAL_PARALLEL_CONNECTION) {
        SourceAddress += Length/2;
      } else {
        SourceAddress += Length;
    5148: e51b2020  ldr r2, [fp, #-32]  ; 0xffffffe0
    514c: e51b300c  ldr r3, [fp, #-12]
    5150: e0823003  add r3, r2, r3
    5154: e50b3020  str r3, [fp, #-32]  ; 0xffffffe0
      }

      BufferPtr = (u8*)((u32)BufferPtr + Length);
    5158: e51b2008  ldr r2, [fp, #-8]
    515c: e51b300c  ldr r3, [fp, #-12]
    5160: e0823003  add r3, r2, r3
    5164: e50b3008  str r3, [fp, #-8]
     */
    if (XPAR_PS7_QSPI_0_QSPI_MODE == DUAL_PARALLEL_CONNECTION) {
      SourceAddress = SourceAddress/2;
    }

    while(LengthBytes > 0) {
    5168: e51b3028  ldr r3, [fp, #-40]  ; 0xffffffd8
    516c: e3530000  cmp r3, #0
    5170: 1affffb5  bne 504c <QspiAccess+0x9c>
    }

    /*
     * Reset Bank selection to zero
     */
    Status = SendBankSelect(0);
    5174: e3a00000  mov r0, #0
    5178: eb00000d  bl  51b4 <SendBankSelect>
    517c: e50b0018  str r0, [fp, #-24]  ; 0xffffffe8
    if (Status != XST_SUCCESS) {
    5180: e51b3018  ldr r3, [fp, #-24]  ; 0xffffffe8
    5184: e3530000  cmp r3, #0
    5188: 0a000004  beq 51a0 <QspiAccess+0x1f0>
      fsbl_printf(DEBUG_INFO, "Bank Selection Reset Failed\n\r");
    518c: e308039c  movw  r0, #33692  ; 0x839c
    5190: e3400001  movt  r0, #1
    5194: eb000499  bl  6400 <xil_printf>
      return XST_FAILURE;
    5198: e3a03001  mov r3, #1
    519c: ea000000  b 51a4 <QspiAccess+0x1f4>
       */
      XQspiPs_SetSlaveSelect(QspiInstancePtr);
    }
  }

  return XST_SUCCESS;
    51a0: e3a03000  mov r3, #0
}
    51a4: e1a00003  mov r0, r3
    51a8: e24bd004  sub sp, fp, #4
    51ac: e8bd8800  pop {fp, pc}
    51b0: 00021a9d  .word 0x00021a9d

000051b4 <SendBankSelect>:
*     XST_FAILURE if selection failed
* @note   None.
*
******************************************************************************/
u32 SendBankSelect(u8 BankSel)
{
    51b4: e92d4800  push  {fp, lr}
    51b8: e28db004  add fp, sp, #4
    51bc: e24dd010  sub sp, sp, #16
    51c0: e1a03000  mov r3, r0
    51c4: e54b300d  strb  r3, [fp, #-13]
  u32 Status;

  /*
   * bank select commands for Micron and Spansion are different
   */
  if (QspiFlashMake == MICRON_ID) {
    51c8: e3023aa0  movw  r3, #10912  ; 0x2aa0
    51cc: e3403002  movt  r3, #2
    51d0: e5933000  ldr r3, [r3]
    51d4: e3530020  cmp r3, #32
    51d8: 1a00002b  bne 528c <SendBankSelect+0xd8>
    /*
     * For micron command WREN should be sent first
     * except for some specific feature set
     */
    WriteBuffer[COMMAND_OFFSET] = WRITE_ENABLE_CMD;
    51dc: e3013a90  movw  r3, #6800 ; 0x1a90
    51e0: e3403002  movt  r3, #2
    51e4: e3a02006  mov r2, #6
    51e8: e5c32000  strb  r2, [r3]
    Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, NULL,
    51ec: e3023aa8  movw  r3, #10920  ; 0x2aa8
    51f0: e3403002  movt  r3, #2
    51f4: e5933000  ldr r3, [r3]
    51f8: e1a00003  mov r0, r3
    51fc: e3011a90  movw  r1, #6800 ; 0x1a90
    5200: e3401002  movt  r1, #2
    5204: e3a02000  mov r2, #0
    5208: e3a03001  mov r3, #1
    520c: eb000b8f  bl  8050 <XQspiPs_PolledTransfer>
    5210: e1a03000  mov r3, r0
    5214: e50b3008  str r3, [fp, #-8]
        WRITE_ENABLE_CMD_SIZE);
    if (Status != XST_SUCCESS) {
    5218: e51b3008  ldr r3, [fp, #-8]
    521c: e3530000  cmp r3, #0
    5220: 0a000001  beq 522c <SendBankSelect+0x78>
      return XST_FAILURE;
    5224: e3a03001  mov r3, #1
    5228: ea000082  b 5438 <SendBankSelect+0x284>

    /*
     * Send the Extended address register write command
     * written, no receive buffer required
     */
    WriteBuffer[COMMAND_OFFSET]   = EXTADD_REG_WR;
    522c: e3013a90  movw  r3, #6800 ; 0x1a90
    5230: e3403002  movt  r3, #2
    5234: e3e0203a  mvn r2, #58 ; 0x3a
    5238: e5c32000  strb  r2, [r3]
    WriteBuffer[ADDRESS_1_OFFSET] = BankSel;
    523c: e3013a90  movw  r3, #6800 ; 0x1a90
    5240: e3403002  movt  r3, #2
    5244: e55b200d  ldrb  r2, [fp, #-13]
    5248: e5c32001  strb  r2, [r3, #1]
    Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, NULL,
    524c: e3023aa8  movw  r3, #10920  ; 0x2aa8
    5250: e3403002  movt  r3, #2
    5254: e5933000  ldr r3, [r3]
    5258: e1a00003  mov r0, r3
    525c: e3011a90  movw  r1, #6800 ; 0x1a90
    5260: e3401002  movt  r1, #2
    5264: e3a02000  mov r2, #0
    5268: e3a03002  mov r3, #2
    526c: eb000b77  bl  8050 <XQspiPs_PolledTransfer>
    5270: e1a03000  mov r3, r0
    5274: e50b3008  str r3, [fp, #-8]
        BANK_SEL_SIZE);
    if (Status != XST_SUCCESS) {
    5278: e51b3008  ldr r3, [fp, #-8]
    527c: e3530000  cmp r3, #0
    5280: 0a000001  beq 528c <SendBankSelect+0xd8>
      return XST_FAILURE;
    5284: e3a03001  mov r3, #1
    5288: ea00006a  b 5438 <SendBankSelect+0x284>
    }
  }

  if (QspiFlashMake == SPANSION_ID) {
    528c: e3023aa0  movw  r3, #10912  ; 0x2aa0
    5290: e3403002  movt  r3, #2
    5294: e5933000  ldr r3, [r3]
    5298: e3530001  cmp r3, #1
    529c: 1a000017  bne 5300 <SendBankSelect+0x14c>
    WriteBuffer[COMMAND_OFFSET]   = BANK_REG_WR;
    52a0: e3013a90  movw  r3, #6800 ; 0x1a90
    52a4: e3403002  movt  r3, #2
    52a8: e3a02017  mov r2, #23
    52ac: e5c32000  strb  r2, [r3]
    WriteBuffer[ADDRESS_1_OFFSET] = BankSel;
    52b0: e3013a90  movw  r3, #6800 ; 0x1a90
    52b4: e3403002  movt  r3, #2
    52b8: e55b200d  ldrb  r2, [fp, #-13]
    52bc: e5c32001  strb  r2, [r3, #1]

    /*
     * Send the Extended address register write command
     * written, no receive buffer required
     */
    Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, NULL,
    52c0: e3023aa8  movw  r3, #10920  ; 0x2aa8
    52c4: e3403002  movt  r3, #2
    52c8: e5933000  ldr r3, [r3]
    52cc: e1a00003  mov r0, r3
    52d0: e3011a90  movw  r1, #6800 ; 0x1a90
    52d4: e3401002  movt  r1, #2
    52d8: e3a02000  mov r2, #0
    52dc: e3a03002  mov r3, #2
    52e0: eb000b5a  bl  8050 <XQspiPs_PolledTransfer>
    52e4: e1a03000  mov r3, r0
    52e8: e50b3008  str r3, [fp, #-8]
        BANK_SEL_SIZE);
    if (Status != XST_SUCCESS) {
    52ec: e51b3008  ldr r3, [fp, #-8]
    52f0: e3530000  cmp r3, #0
    52f4: 0a000001  beq 5300 <SendBankSelect+0x14c>
      return XST_FAILURE;
    52f8: e3a03001  mov r3, #1
    52fc: ea00004d  b 5438 <SendBankSelect+0x284>
  }

  /*
   * For testing - Read bank to verify
   */
  if (QspiFlashMake == SPANSION_ID) {
    5300: e3023aa0  movw  r3, #10912  ; 0x2aa0
    5304: e3403002  movt  r3, #2
    5308: e5933000  ldr r3, [r3]
    530c: e3530001  cmp r3, #1
    5310: 1a000018  bne 5378 <SendBankSelect+0x1c4>
    WriteBuffer[COMMAND_OFFSET]   = BANK_REG_RD;
    5314: e3013a90  movw  r3, #6800 ; 0x1a90
    5318: e3403002  movt  r3, #2
    531c: e3a02016  mov r2, #22
    5320: e5c32000  strb  r2, [r3]
    WriteBuffer[ADDRESS_1_OFFSET] = 0x00;
    5324: e3013a90  movw  r3, #6800 ; 0x1a90
    5328: e3403002  movt  r3, #2
    532c: e3a02000  mov r2, #0
    5330: e5c32001  strb  r2, [r3, #1]

    /*
     * Send the Extended address register write command
     * written, no receive buffer required
     */
    Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, ReadBuffer,
    5334: e3023aa8  movw  r3, #10920  ; 0x2aa8
    5338: e3403002  movt  r3, #2
    533c: e5933000  ldr r3, [r3]
    5340: e1a00003  mov r0, r3
    5344: e3011a90  movw  r1, #6800 ; 0x1a90
    5348: e3401002  movt  r1, #2
    534c: e3012a98  movw  r2, #6808 ; 0x1a98
    5350: e3402002  movt  r2, #2
    5354: e3a03002  mov r3, #2
    5358: eb000b3c  bl  8050 <XQspiPs_PolledTransfer>
    535c: e1a03000  mov r3, r0
    5360: e50b3008  str r3, [fp, #-8]
        BANK_SEL_SIZE);
    if (Status != XST_SUCCESS) {
    5364: e51b3008  ldr r3, [fp, #-8]
    5368: e3530000  cmp r3, #0
    536c: 0a000001  beq 5378 <SendBankSelect+0x1c4>
      return XST_FAILURE;
    5370: e3a03001  mov r3, #1
    5374: ea00002f  b 5438 <SendBankSelect+0x284>
    }
  }

  if (QspiFlashMake == MICRON_ID) {
    5378: e3023aa0  movw  r3, #10912  ; 0x2aa0
    537c: e3403002  movt  r3, #2
    5380: e5933000  ldr r3, [r3]
    5384: e3530020  cmp r3, #32
    5388: 1a000018  bne 53f0 <SendBankSelect+0x23c>
    WriteBuffer[COMMAND_OFFSET]   = EXTADD_REG_RD;
    538c: e3013a90  movw  r3, #6800 ; 0x1a90
    5390: e3403002  movt  r3, #2
    5394: e3e02037  mvn r2, #55 ; 0x37
    5398: e5c32000  strb  r2, [r3]
    WriteBuffer[ADDRESS_1_OFFSET] = 0x00;
    539c: e3013a90  movw  r3, #6800 ; 0x1a90
    53a0: e3403002  movt  r3, #2
    53a4: e3a02000  mov r2, #0
    53a8: e5c32001  strb  r2, [r3, #1]

    /*
     * Send the Extended address register write command
     * written, no receive buffer required
     */
    Status = XQspiPs_PolledTransfer(QspiInstancePtr, WriteBuffer, ReadBuffer,
    53ac: e3023aa8  movw  r3, #10920  ; 0x2aa8
    53b0: e3403002  movt  r3, #2
    53b4: e5933000  ldr r3, [r3]
    53b8: e1a00003  mov r0, r3
    53bc: e3011a90  movw  r1, #6800 ; 0x1a90
    53c0: e3401002  movt  r1, #2
    53c4: e3012a98  movw  r2, #6808 ; 0x1a98
    53c8: e3402002  movt  r2, #2
    53cc: e3a03002  mov r3, #2
    53d0: eb000b1e  bl  8050 <XQspiPs_PolledTransfer>
    53d4: e1a03000  mov r3, r0
    53d8: e50b3008  str r3, [fp, #-8]
        BANK_SEL_SIZE);
    if (Status != XST_SUCCESS) {
    53dc: e51b3008  ldr r3, [fp, #-8]
    53e0: e3530000  cmp r3, #0
    53e4: 0a000001  beq 53f0 <SendBankSelect+0x23c>
      return XST_FAILURE;
    53e8: e3a03001  mov r3, #1
    53ec: ea000011  b 5438 <SendBankSelect+0x284>
    }
  }

  if (ReadBuffer[1] != BankSel) {
    53f0: e3013a98  movw  r3, #6808 ; 0x1a98
    53f4: e3403002  movt  r3, #2
    53f8: e5d33001  ldrb  r3, [r3, #1]
    53fc: e55b200d  ldrb  r2, [fp, #-13]
    5400: e1520003  cmp r2, r3
    5404: 0a00000a  beq 5434 <SendBankSelect+0x280>
    fsbl_printf(DEBUG_INFO, "BankSel %d != Register Read %d\n\r", BankSel,
    5408: e55b200d  ldrb  r2, [fp, #-13]
    540c: e3013a98  movw  r3, #6808 ; 0x1a98
    5410: e3403002  movt  r3, #2
    5414: e5d33001  ldrb  r3, [r3, #1]
    5418: e30803bc  movw  r0, #33724  ; 0x83bc
    541c: e3400001  movt  r0, #1
    5420: e1a01002  mov r1, r2
    5424: e1a02003  mov r2, r3
    5428: eb0003f4  bl  6400 <xil_printf>
        ReadBuffer[1]);
    return XST_FAILURE;
    542c: e3a03001  mov r3, #1
    5430: ea000000  b 5438 <SendBankSelect+0x284>
  }

  return XST_SUCCESS;
    5434: e3a03000  mov r3, #0
}
    5438: e1a00003  mov r0, r3
    543c: e24bd004  sub sp, fp, #4
    5440: e8bd8800  pop {fp, pc}

00005444 <InitSD>:
*
* @note   None.
*
****************************************************************************/
u32 InitSD(const char *filename)
{
    5444: e92d4800  push  {fp, lr}
    5448: e28db004  add fp, sp, #4
    544c: e24dd010  sub sp, sp, #16
    5450: e50b0010  str r0, [fp, #-16]

  FRESULT rc;
  TCHAR *path = "0:/"; /* Logical drive number is 0 */
    5454: e30833e0  movw  r3, #33760  ; 0x83e0
    5458: e3403001  movt  r3, #1
    545c: e50b3008  str r3, [fp, #-8]

  /* Register volume work area, initialize device */
  rc = f_mount(&fatfs, path, 0);
    5460: e30102c0  movw  r0, #4800 ; 0x12c0
    5464: e3400002  movt  r0, #2
    5468: e51b1008  ldr r1, [fp, #-8]
    546c: e3a02000  mov r2, #0
    5470: eb003b94  bl  142c8 <f_mount>
    5474: e1a03000  mov r3, r0
    5478: e54b3009  strb  r3, [fp, #-9]
  fsbl_printf(DEBUG_INFO,"SD: rc= %.8x\n\r", rc);
    547c: e55b3009  ldrb  r3, [fp, #-9]
    5480: e30803e4  movw  r0, #33764  ; 0x83e4
    5484: e3400001  movt  r0, #1
    5488: e1a01003  mov r1, r3
    548c: eb0003db  bl  6400 <xil_printf>

  if (rc != FR_OK) {
    5490: e55b3009  ldrb  r3, [fp, #-9]
    5494: e3530000  cmp r3, #0
    5498: 0a000001  beq 54a4 <InitSD+0x60>
    return XST_FAILURE;
    549c: e3a03001  mov r3, #1
    54a0: ea000026  b 5540 <InitSD+0xfc>
  }

  strcpy_rom(buffer, filename);
    54a4: e3010500  movw  r0, #5376 ; 0x1500
    54a8: e3400002  movt  r0, #2
    54ac: e51b1010  ldr r1, [fp, #-16]
    54b0: ebfff220  bl  1d38 <strcpy_rom>
  boot_file = (char *)buffer;
    54b4: e30b32e8  movw  r3, #45800  ; 0xb2e8
    54b8: e3403001  movt  r3, #1
    54bc: e3012500  movw  r2, #5376 ; 0x1500
    54c0: e3402002  movt  r2, #2
    54c4: e5832000  str r2, [r3]
  FlashReadBaseAddress = XPAR_PS7_SD_0_S_AXI_BASEADDR;
    54c8: e301205c  movw  r2, #4188 ; 0x105c
    54cc: e3402002  movt  r2, #2
    54d0: e3a03000  mov r3, #0
    54d4: e34e3010  movt  r3, #57360  ; 0xe010
    54d8: e5823000  str r3, [r2]

  rc = f_open(&fil, boot_file, FA_READ);
    54dc: e30b32e8  movw  r3, #45800  ; 0xb2e8
    54e0: e3403001  movt  r3, #1
    54e4: e5933000  ldr r3, [r3]
    54e8: e3010080  movw  r0, #4224 ; 0x1080
    54ec: e3400002  movt  r0, #2
    54f0: e1a01003  mov r1, r3
    54f4: e3a02001  mov r2, #1
    54f8: eb003b97  bl  1435c <f_open>
    54fc: e1a03000  mov r3, r0
    5500: e54b3009  strb  r3, [fp, #-9]
  if (rc) {
    5504: e55b3009  ldrb  r3, [fp, #-9]
    5508: e3530000  cmp r3, #0
    550c: 0a00000a  beq 553c <InitSD+0xf8>
    fsbl_printf(DEBUG_GENERAL,"SD: Unable to open file %s: %d\n", boot_file, rc);
    5510: e30b32e8  movw  r3, #45800  ; 0xb2e8
    5514: e3403001  movt  r3, #1
    5518: e5932000  ldr r2, [r3]
    551c: e55b3009  ldrb  r3, [fp, #-9]
    5520: e30803f4  movw  r0, #33780  ; 0x83f4
    5524: e3400001  movt  r0, #1
    5528: e1a01002  mov r1, r2
    552c: e1a02003  mov r2, r3
    5530: eb0003b2  bl  6400 <xil_printf>
    return XST_FAILURE;
    5534: e3a03001  mov r3, #1
    5538: ea000000  b 5540 <InitSD+0xfc>
  }

  return XST_SUCCESS;
    553c: e3a03000  mov r3, #0

}
    5540: e1a00003  mov r0, r3
    5544: e24bd004  sub sp, fp, #4
    5548: e8bd8800  pop {fp, pc}

0000554c <SDAccess>:
*
* @note   None.
*
****************************************************************************/
u32 SDAccess( u32 SourceAddress, u32 DestinationAddress, u32 LengthBytes)
{
    554c: e92d4800  push  {fp, lr}
    5550: e28db004  add fp, sp, #4
    5554: e24dd018  sub sp, sp, #24
    5558: e50b0010  str r0, [fp, #-16]
    555c: e50b1014  str r1, [fp, #-20]  ; 0xffffffec
    5560: e50b2018  str r2, [fp, #-24]  ; 0xffffffe8

  FRESULT rc;  /* Result code */
  UINT br;

  rc = f_lseek(&fil, SourceAddress);
    5564: e3010080  movw  r0, #4224 ; 0x1080
    5568: e3400002  movt  r0, #2
    556c: e51b1010  ldr r1, [fp, #-16]
    5570: eb003dc7  bl  14c94 <f_lseek>
    5574: e1a03000  mov r3, r0
    5578: e54b3005  strb  r3, [fp, #-5]
  if (rc) {
    557c: e55b3005  ldrb  r3, [fp, #-5]
    5580: e3530000  cmp r3, #0
    5584: 0a000005  beq 55a0 <SDAccess+0x54>
    fsbl_printf(DEBUG_INFO,"SD: Unable to seek to %x\n", SourceAddress);
    5588: e3080414  movw  r0, #33812  ; 0x8414
    558c: e3400001  movt  r0, #1
    5590: e51b1010  ldr r1, [fp, #-16]
    5594: eb000399  bl  6400 <xil_printf>
    return XST_FAILURE;
    5598: e3a03001  mov r3, #1
    559c: ea000011  b 55e8 <SDAccess+0x9c>
  }

  rc = f_read(&fil, (void*)DestinationAddress, LengthBytes, &br);
    55a0: e51b2014  ldr r2, [fp, #-20]  ; 0xffffffec
    55a4: e24b300c  sub r3, fp, #12
    55a8: e3010080  movw  r0, #4224 ; 0x1080
    55ac: e3400002  movt  r0, #2
    55b0: e1a01002  mov r1, r2
    55b4: e51b2018  ldr r2, [fp, #-24]  ; 0xffffffe8
    55b8: eb003c0e  bl  145f8 <f_read>
    55bc: e1a03000  mov r3, r0
    55c0: e54b3005  strb  r3, [fp, #-5]

  if (rc) {
    55c4: e55b3005  ldrb  r3, [fp, #-5]
    55c8: e3530000  cmp r3, #0
    55cc: 0a000004  beq 55e4 <SDAccess+0x98>
    fsbl_printf(DEBUG_GENERAL,"*** ERROR: f_read returned %d\r\n", rc);
    55d0: e55b3005  ldrb  r3, [fp, #-5]
    55d4: e3080430  movw  r0, #33840  ; 0x8430
    55d8: e3400001  movt  r0, #1
    55dc: e1a01003  mov r1, r3
    55e0: eb000386  bl  6400 <xil_printf>
  }

  return XST_SUCCESS;
    55e4: e3a03000  mov r3, #0

} /* End of SDAccess */
    55e8: e1a00003  mov r0, r3
    55ec: e24bd004  sub sp, fp, #4
    55f0: e8bd8800  pop {fp, pc}

000055f4 <ReleaseSD>:
* @return None.
*
* @note   None.
*
****************************************************************************/
void ReleaseSD(void) {
    55f4: e92d4800  push  {fp, lr}
    55f8: e28db004  add fp, sp, #4

  f_close(&fil);
    55fc: e3010080  movw  r0, #4224 ; 0x1080
    5600: e3400002  movt  r0, #2
    5604: eb003d98  bl  14c6c <f_close>
  return;
    5608: e1a00000  nop     ; (mov r0, r0)


}
    560c: e8bd8800  pop {fp, pc}

00005610 <usleep>:
*
* @note   None.
*
****************************************************************************/
s32 usleep(u32 useconds)
{
    5610: e92d4070  push  {r4, r5, r6, lr}
    5614: e24dd008  sub sp, sp, #8
    5618: e1a06000  mov r6, r0
  XTime tEnd, tCur;

  XTime_GetTime(&tCur);
    561c: e1a0000d  mov r0, sp
    5620: eb0004a4  bl  68b8 <XTime_GetTime>
  tEnd = tCur + (((XTime) useconds) * COUNTS_PER_USECOND);
    5624: e1cd40d0  ldrd  r4, [sp]
    5628: e300314d  movw  r3, #333  ; 0x14d
    562c: e0a54693  umlal r4, r5, r3, r6
  do
  {
    XTime_GetTime(&tCur);
    5630: e1a0000d  mov r0, sp
    5634: eb00049f  bl  68b8 <XTime_GetTime>
  } while (tCur < tEnd);
    5638: e1cd20d0  ldrd  r2, [sp]
    563c: e1550003  cmp r5, r3
    5640: 01540002  cmpeq r4, r2
    5644: 8afffff9  bhi 5630 <usleep+0x20>

  return 0;
}
    5648: e3a00000  mov r0, #0
    564c: e28dd008  add sp, sp, #8
    5650: e8bd8070  pop {r4, r5, r6, pc}

00005654 <FIQInterrupt>:
* @note   None.
*
******************************************************************************/
void FIQInterrupt(void)
{
  XExc_VectorTable[XIL_EXCEPTION_ID_FIQ_INT].Handler(XExc_VectorTable[
    5654: e30b32ec  movw  r3, #45804  ; 0xb2ec
    5658: e3403001  movt  r3, #1
    565c: e5932030  ldr r2, [r3, #48] ; 0x30
    5660: e5930034  ldr r0, [r3, #52] ; 0x34
    5664: e12fff12  bx  r2

00005668 <IRQInterrupt>:
* @note   None.
*
******************************************************************************/
void IRQInterrupt(void)
{
  XExc_VectorTable[XIL_EXCEPTION_ID_IRQ_INT].Handler(XExc_VectorTable[
    5668: e30b32ec  movw  r3, #45804  ; 0xb2ec
    566c: e3403001  movt  r3, #1
    5670: e5932028  ldr r2, [r3, #40] ; 0x28
    5674: e593002c  ldr r0, [r3, #44] ; 0x2c
    5678: e12fff12  bx  r2

0000567c <SWInterrupt>:
* @note   None.
*
******************************************************************************/
void SWInterrupt(void)
{
  XExc_VectorTable[XIL_EXCEPTION_ID_SWI_INT].Handler(XExc_VectorTable[
    567c: e30b32ec  movw  r3, #45804  ; 0xb2ec
    5680: e3403001  movt  r3, #1
    5684: e5932010  ldr r2, [r3, #16]
    5688: e5930014  ldr r0, [r3, #20]
    568c: e12fff12  bx  r2

00005690 <DataAbortInterrupt>:
* @note   None.
*
******************************************************************************/
void DataAbortInterrupt(void)
{
  XExc_VectorTable[XIL_EXCEPTION_ID_DATA_ABORT_INT].Handler(
    5690: e30b32ec  movw  r3, #45804  ; 0xb2ec
    5694: e3403001  movt  r3, #1
    5698: e5932020  ldr r2, [r3, #32]
    569c: e5930024  ldr r0, [r3, #36] ; 0x24
    56a0: e12fff12  bx  r2

000056a4 <PrefetchAbortInterrupt>:
* @note   None.
*
******************************************************************************/
void PrefetchAbortInterrupt(void)
{
  XExc_VectorTable[XIL_EXCEPTION_ID_PREFETCH_ABORT_INT].Handler(
    56a4: e30b32ec  movw  r3, #45804  ; 0xb2ec
    56a8: e3403001  movt  r3, #1
    56ac: e5932018  ldr r2, [r3, #24]
    56b0: e593001c  ldr r0, [r3, #28]
    56b4: e12fff12  bx  r2
    56b8: 00021040  .word 0x00021040
    56bc: 00021040  .word 0x00021040
    56c0: 00021040  .word 0x00021040
    56c4: 00022af0  .word 0x00022af0
    56c8: ffff6000  .word 0xffff6000

000056cc <_start>:
  .long __stack


  .globl  _start
_start:
  bl      __cpu_init    /* Initialize the CPU first (BSP provides this) */
    56cc: eb000e5c  bl  9044 <__cpu_init>

  mov r0, #0
    56d0: e3a00000  mov r0, #0

  /* clear sbss */
  ldr   r1,.Lsbss_start   /* calculate beginning of the SBSS */
    56d4: e51f1024  ldr r1, [pc, #-36]  ; 56b8 <PrefetchAbortInterrupt+0x14>
  ldr r2,.Lsbss_end   /* calculate end of the SBSS */
    56d8: e51f2024  ldr r2, [pc, #-36]  ; 56bc <PrefetchAbortInterrupt+0x18>

.Lloop_sbss:
  cmp r1,r2
    56dc: e1510002  cmp r1, r2
  bge .Lenclsbss    /* If no SBSS, no clearing required */
    56e0: aa000001  bge 56ec <_start+0x20>
  str r0, [r1], #4
    56e4: e4810004  str r0, [r1], #4
  b .Lloop_sbss
    56e8: eafffffb  b 56dc <_start+0x10>

.Lenclsbss:
  /* clear bss */
  ldr r1,.Lbss_start    /* calculate beginning of the BSS */
    56ec: e51f1034  ldr r1, [pc, #-52]  ; 56c0 <PrefetchAbortInterrupt+0x1c>
  ldr r2,.Lbss_end    /* calculate end of the BSS */
    56f0: e51f2034  ldr r2, [pc, #-52]  ; 56c4 <PrefetchAbortInterrupt+0x20>

.Lloop_bss:
  cmp r1,r2
    56f4: e1510002  cmp r1, r2
  bge .Lenclbss   /* If no BSS, no clearing required */
    56f8: aa000001  bge 5704 <_start+0x38>
  str r0, [r1], #4
    56fc: e4810004  str r0, [r1], #4
  b .Lloop_bss
    5700: eafffffb  b 56f4 <_start+0x28>

.Lenclbss:

  /* set stack pointer */
  ldr r13,.Lstack   /* stack address */
    5704: e51fd044  ldr sp, [pc, #-68]  ; 56c8 <PrefetchAbortInterrupt+0x24>

    /* Reset and start Global Timer */
  mov r0, #0x0
    5708: e3a00000  mov r0, #0
  mov r1, #0x0
    570c: e3a01000  mov r1, #0
    bl XTime_SetTime
    5710: eb000454  bl  6868 <XTime_SetTime>
  /* Setup profiling stuff */
  bl  _profile_init
#endif /* PROFILING */

   /* run global constructors */
   bl __libc_init_array
    5714: eb001034  bl  97ec <__libc_init_array>

  /* make sure argc and argv are valid */
  mov r0, #0
    5718: e3a00000  mov r0, #0
  mov r1, #0
    571c: e3a01000  mov r1, #0

  /* Let her rip */
  bl  main
    5720: ebfff0f0  bl  1ae8 <main>

   /* Cleanup global constructors */
   bl __libc_fini_array
    5724: eb001020  bl  97ac <__libc_fini_array>
  /* Cleanup profiling stuff */
  bl  _profile_clean
#endif /* PROFILING */

        /* All done */
  bl  exit
    5728: eb001012  bl  9778 <exit>

.Lexit: /* should never get here */
  b .Lexit
    572c: eafffffe  b 572c <_start+0x60>

00005730 <Xil_DCacheInvalidateLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_DCacheInvalidateLine(u32 adr)
{
    5730: e92d4038  push  {r3, r4, r5, lr}
    5734: e1a04000  mov r4, r0
  u32 currmask;

  currmask = mfcpsr();
    5738: e10f5000  mrs r5, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    573c: e38530c0  orr r3, r5, #192  ; 0xc0
    5740: e129f003  msr CPSR_fc, r3
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheInvalidateLine(u32 adr)
{
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_PA_OFFSET, (u32)adr);
    5744: e3020770  movw  r0, #10096  ; 0x2770
    5748: e1a01004  mov r1, r4
    574c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5750: eb000296  bl  61b0 <Xil_Out32>
  /* synchronize the processor */
  dsb();
    5754: f57ff04f  dsb sy
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheInvalidateLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5758: e3a03000  mov r3, #0
    575c: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5760: e3c4401f  bic r4, r4, #31
    5764: ee074f36  mcr 15, 0, r4, cr7, cr6, {1}

  /* Wait for L1 invalidate to complete */
  dsb();
    5768: f57ff04f  dsb sy
  mtcpsr(currmask | IRQ_FIQ_MASK);

  Xil_L2CacheInvalidateLine(adr);
  Xil_L1DCacheInvalidateLine(adr);

  mtcpsr(currmask);
    576c: e129f005  msr CPSR_fc, r5
    5770: e8bd8038  pop {r3, r4, r5, pc}

00005774 <Xil_DCacheFlushRange>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheFlushRange(INTPTR adr, u32 len)
{
    5774: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  u32 end;
  u32 currmask;
  volatile u32 *L2CCOffset = (volatile u32 *)(XPS_L2CC_BASEADDR +
            XPS_L2CC_CACHE_INV_CLN_PA_OFFSET);

  currmask = mfcpsr();
    5778: e10f7000  mrs r7, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    577c: e38730c0  orr r3, r7, #192  ; 0xc0
    5780: e129f003  msr CPSR_fc, r3

  if (len != 0U) {
    5784: e3510000  cmp r1, #0
    5788: 0a00000e  beq 57c8 <Xil_DCacheFlushRange+0x54>
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    578c: e0805001  add r5, r0, r1
    LocalAddr &= ~(cacheline - 1U);
    5790: e3c0401f  bic r4, r0, #31

    while (LocalAddr < end) {
    5794: e1550004  cmp r5, r4
    5798: 9a00000a  bls 57c8 <Xil_DCacheFlushRange+0x54>
      { volatile register u32 Reg
        __asm(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC);
        Reg = LocalAddr; }
#endif
      /* Flush L2 cache line */
      *L2CCOffset = LocalAddr;
    579c: e3a06a02  mov r6, #8192 ; 0x2000
    57a0: e34f68f0  movt  r6, #63728  ; 0xf8f0
    LocalAddr &= ~(cacheline - 1U);

    while (LocalAddr < end) {
#ifdef __GNUC__
      /* Flush L1 Data cache line */
      __asm__ __volatile__("mcr " \
    57a4: ee074f3e  mcr 15, 0, r4, cr7, cr14, {1}
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    57a8: e3a00d9d  mov r0, #10048  ; 0x2740
      { volatile register u32 Reg
        __asm(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC);
        Reg = LocalAddr; }
#endif
      /* Flush L2 cache line */
      *L2CCOffset = LocalAddr;
    57ac: e58647f0  str r4, [r6, #2032] ; 0x7f0
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    57b0: e34f08f0  movt  r0, #63728  ; 0xf8f0
        Reg = LocalAddr; }
#endif
      /* Flush L2 cache line */
      *L2CCOffset = LocalAddr;
      Xil_L2CacheSync();
      LocalAddr += cacheline;
    57b4: e2844020  add r4, r4, #32
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    57b8: e3a01000  mov r1, #0
    57bc: eb00027b  bl  61b0 <Xil_Out32>
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr &= ~(cacheline - 1U);

    while (LocalAddr < end) {
    57c0: e1550004  cmp r5, r4
    57c4: 8afffff6  bhi 57a4 <Xil_DCacheFlushRange+0x30>
      *L2CCOffset = LocalAddr;
      Xil_L2CacheSync();
      LocalAddr += cacheline;
    }
  }
  dsb();
    57c8: f57ff04f  dsb sy
  mtcpsr(currmask);
    57cc: e129f007  msr CPSR_fc, r7
    57d0: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

000057d4 <Xil_DCacheStoreLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_DCacheStoreLine(u32 adr)
{
    57d4: e92d4010  push  {r4, lr}
    57d8: e1a01000  mov r1, r0
  u32 currmask;

  currmask = mfcpsr();
    57dc: e10f4000  mrs r4, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    57e0: e38430c0  orr r3, r4, #192  ; 0xc0
    57e4: e129f003  msr CPSR_fc, r3
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheStoreLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    57e8: e3a03000  mov r3, #0
    57ec: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    57f0: e3c0301f  bic r3, r0, #31
    57f4: ee073f3a  mcr 15, 0, r3, cr7, cr10, {1}

  /* Wait for L1 store to complete */
  dsb();
    57f8: f57ff04f  dsb sy
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheStoreLine(u32 adr)
{
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_CLEAN_PA_OFFSET, adr);
    57fc: e30207b0  movw  r0, #10160  ; 0x27b0
    5800: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5804: eb000269  bl  61b0 <Xil_Out32>
  /* synchronize the processor */
  dsb();
    5808: f57ff04f  dsb sy
  currmask = mfcpsr();
  mtcpsr(currmask | IRQ_FIQ_MASK);

  Xil_L1DCacheStoreLine(adr);
  Xil_L2CacheStoreLine(adr);
  mtcpsr(currmask);
    580c: e129f004  msr CPSR_fc, r4
    5810: e8bd8010  pop {r4, pc}

00005814 <Xil_ICacheInvalidateLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_ICacheInvalidateLine(u32 adr)
{
    5814: e92d4038  push  {r3, r4, r5, lr}
    5818: e1a04000  mov r4, r0
  u32 currmask;

  currmask = mfcpsr();
    581c: e10f5000  mrs r5, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5820: e38530c0  orr r3, r5, #192  ; 0xc0
    5824: e129f003  msr CPSR_fc, r3
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheInvalidateLine(u32 adr)
{
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_PA_OFFSET, (u32)adr);
    5828: e3020770  movw  r0, #10096  ; 0x2770
    582c: e1a01004  mov r1, r4
    5830: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5834: eb00025d  bl  61b0 <Xil_Out32>
  /* synchronize the processor */
  dsb();
    5838: f57ff04f  dsb sy
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1ICacheInvalidateLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    583c: e3a03001  mov r3, #1
    5840: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_INVAL_IC_LINE_MVA_POU, (adr & (~0x1FU)));
    5844: e3c4401f  bic r4, r4, #31
    5848: ee074f35  mcr 15, 0, r4, cr7, cr5, {1}

  /* Wait for L1 invalidate to complete */
  dsb();
    584c: f57ff04f  dsb sy

  currmask = mfcpsr();
  mtcpsr(currmask | IRQ_FIQ_MASK);
  Xil_L2CacheInvalidateLine(adr);
  Xil_L1ICacheInvalidateLine(adr);
  mtcpsr(currmask);
    5850: e129f005  msr CPSR_fc, r5
    5854: e8bd8038  pop {r3, r4, r5, pc}

00005858 <Xil_ICacheInvalidateRange>:
  volatile u32 *L2CCOffset = (volatile u32 *)(XPS_L2CC_BASEADDR +
            XPS_L2CC_CACHE_INVLD_PA_OFFSET);

  u32 currmask;

  currmask = mfcpsr();
    5858: e10f2000  mrs r2, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    585c: e38230c0  orr r3, r2, #192  ; 0xc0
    5860: e129f003  msr CPSR_fc, r3
  if (len != 0U) {
    5864: e3510000  cmp r1, #0
    5868: 0a00000d  beq 58a4 <Xil_ICacheInvalidateRange+0x4c>
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    586c: e0801001  add r1, r0, r1
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5870: e3a03001  mov r3, #1
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    5874: e3c0001f  bic r0, r0, #31

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5878: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}

    while (LocalAddr < end) {
    587c: e1510000  cmp r1, r0
    5880: 9a000007  bls 58a4 <Xil_ICacheInvalidateRange+0x4c>
    /* Invalidate L2 cache line */
    *L2CCOffset = LocalAddr;
    5884: e3a03a02  mov r3, #8192 ; 0x2000
    5888: e34f38f0  movt  r3, #63728  ; 0xf8f0
    588c: e5830770  str r0, [r3, #1904] ; 0x770
    dsb();
    5890: f57ff04f  dsb sy
#ifdef __GNUC__
      /* Invalidate L1 I-cache line */
      __asm__ __volatile__("mcr " \
    5894: ee070f35  mcr 15, 0, r0, cr7, cr5, {1}
      { volatile register u32 Reg
        __asm(XREG_CP15_INVAL_IC_LINE_MVA_POU);
        Reg = LocalAddr; }
#endif

      LocalAddr += cacheline;
    5898: e2800020  add r0, r0, #32
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);

    while (LocalAddr < end) {
    589c: e1510000  cmp r1, r0
    58a0: 8afffff9  bhi 588c <Xil_ICacheInvalidateRange+0x34>
      LocalAddr += cacheline;
    }
  }

  /* Wait for L1 and L2 invalidate to complete */
  dsb();
    58a4: f57ff04f  dsb sy
  mtcpsr(currmask);
    58a8: e129f002  msr CPSR_fc, r2
    58ac: e12fff1e  bx  lr

000058b0 <Xil_L1DCacheInvalidate>:
*   the whole D-cache. This function invalidates each line by
*   set/way.
*
****************************************************************************/
void Xil_L1DCacheInvalidate(void)
{
    58b0: e92d40f8  push  {r3, r4, r5, r6, r7, lr}

#ifdef __GNUC__
  u32 stack_start,stack_end,stack_size;
#endif

  currmask = mfcpsr();
    58b4: e10f6000  mrs r6, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    58b8: e38630c0  orr r3, r6, #192  ; 0xc0
    58bc: e129f003  msr CPSR_fc, r3
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    58c0: e3000000  movw  r0, #0
  mtcpsr(currmask | IRQ_FIQ_MASK);

#ifdef __GNUC__
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;
    58c4: e30d1400  movw  r1, #54272  ; 0xd400

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    58c8: e34f0fff  movt  r0, #65535  ; 0xffff
  mtcpsr(currmask | IRQ_FIQ_MASK);

#ifdef __GNUC__
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;
    58cc: e34f1fff  movt  r1, #65535  ; 0xffff

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    58d0: e0601001  rsb r1, r0, r1
#endif

  /* Select cache level 0 and D cache in CSSR */
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    58d4: e3a07000  mov r7, #0
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    58d8: ebffffa5  bl  5774 <Xil_DCacheFlushRange>
#endif

  /* Select cache level 0 and D cache in CSSR */
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    58dc: ee407f10  mcr 15, 2, r7, cr0, cr0, {0}

#ifdef __GNUC__
  CsidReg = mfcp(XREG_CP15_CACHE_SIZE_ID);
    58e0: ee304f10  mrc 15, 1, r4, cr0, cr0, {0}
#else
  { volatile register u32 Reg __asm(XREG_CP15_CACHE_SIZE_ID);
    CsidReg = Reg; }
#endif
  /* Determine Cache Size */
  CacheSize = (CsidReg >> 13U) & 0x1FFU;
    58e4: e7e806d4  ubfx  r0, r4, #13, #9
  CacheSize +=1U;
  CacheSize *=128U;    /* to get number of bytes */

  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
    58e8: e7e651d4  ubfx  r5, r4, #3, #7
  { volatile register u32 Reg __asm(XREG_CP15_CACHE_SIZE_ID);
    CsidReg = Reg; }
#endif
  /* Determine Cache Size */
  CacheSize = (CsidReg >> 13U) & 0x1FFU;
  CacheSize +=1U;
    58ec: e2800001  add r0, r0, #1
  CacheSize *=128U;    /* to get number of bytes */

  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
  NumWays += 1U;
    58f0: e2855001  add r5, r5, #1

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;

  NumSet = CacheSize/NumWays;
    58f4: e1a00380  lsl r0, r0, #7
    58f8: e1a01005  mov r1, r5
    58fc: eb000e2b  bl  91b0 <__aeabi_uidiv>
  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
  NumWays += 1U;

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;
    5900: e2043007  and r3, r4, #7
    5904: e2833004  add r3, r3, #4
    5908: e3a01001  mov r1, #1
    590c: e1a01311  lsl r1, r1, r3

  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    5910: e1a04007  mov r4, r7

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;

  NumSet = CacheSize/NumWays;
  NumSet /= (0x00000001U << LineSize);
    5914: e1a00330  lsr r0, r0, r3
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    5918: e3500000  cmp r0, #0
    591c: e1a0ef04  lsl lr, r4, #30
    5920: 13a03000  movne r3, #0
    5924: 11a02003  movne r2, r3
    5928: 0a000005  beq 5944 <Xil_L1DCacheInvalidate+0x94>
      C7Reg = Way | Set;
    592c: e182c00e  orr ip, r2, lr
#ifdef __GNUC__
      /* Invalidate by Set/Way */
      __asm__ __volatile__("mcr " \
    5930: ee07cf56  mcr 15, 0, ip, cr7, cr6, {2}
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    5934: e2833001  add r3, r3, #1
      /*mtcp(XREG_CP15_INVAL_DC_LINE_SW, C7Reg), */
      { volatile register u32 Reg
        __asm(XREG_CP15_INVAL_DC_LINE_SW);
        Reg = C7Reg; }
#endif
      Set += (0x00000001U << LineSize);
    5938: e0822001  add r2, r2, r1
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    593c: e1530000  cmp r3, r0
    5940: 1afffff9  bne 592c <Xil_L1DCacheInvalidate+0x7c>

  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    5944: e2844001  add r4, r4, #1
    5948: e1550004  cmp r5, r4
    594c: 1afffff1  bne 5918 <Xil_L1DCacheInvalidate+0x68>
    Set=0U;
    Way += 0x40000000U;
  }

  /* Wait for L1 invalidate to complete */
  dsb();
    5950: f57ff04f  dsb sy
  mtcpsr(currmask);
    5954: e129f006  msr CPSR_fc, r6
    5958: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

0000595c <Xil_L1DCacheEnable>:
*
* @note   None.
*
****************************************************************************/
void Xil_L1DCacheEnable(void)
{
    595c: e92d4010  push  {r4, lr}
  register u32 CtrlReg;

  /* enable caches only if they are disabled */
#ifdef __GNUC__
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5960: ee114f10  mrc 15, 0, r4, cr1, cr0, {0}
  mfcp(XREG_CP15_SYS_CONTROL, CtrlReg);
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif
  if ((CtrlReg & (XREG_CP15_CONTROL_C_BIT)) != 0U) {
    5964: e3140004  tst r4, #4
    5968: 18bd8010  popne {r4, pc}
    return;
  }

  /* clean and invalidate the Data cache */
  Xil_L1DCacheInvalidate();
    596c: ebffffcf  bl  58b0 <Xil_L1DCacheInvalidate>

  /* enable the Data cache */
  CtrlReg |= (XREG_CP15_CONTROL_C_BIT);
    5970: e3844004  orr r4, r4, #4

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5974: ee014f10  mcr 15, 0, r4, cr1, cr0, {0}
    5978: e8bd8010  pop {r4, pc}

0000597c <Xil_L1DCacheInvalidateLine>:
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheInvalidateLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    597c: e3a03000  mov r3, #0
    5980: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5984: e3c0001f  bic r0, r0, #31
    5988: ee070f36  mcr 15, 0, r0, cr7, cr6, {1}

  /* Wait for L1 invalidate to complete */
  dsb();
    598c: f57ff04f  dsb sy
    5990: e12fff1e  bx  lr

00005994 <Xil_L1DCacheInvalidateRange>:
  u32 LocalAddr = adr;
  const u32 cacheline = 32U;
  u32 end;
  u32 currmask;

  currmask = mfcpsr();
    5994: e10f3000  mrs r3, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5998: e38320c0  orr r2, r3, #192  ; 0xc0
    599c: e129f002  msr CPSR_fc, r2

  if (len != 0U) {
    59a0: e3510000  cmp r1, #0
    59a4: 0a000009  beq 59d0 <Xil_L1DCacheInvalidateRange+0x3c>
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    59a8: e0801001  add r1, r0, r1
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0);
    59ac: e3a02000  mov r2, #0
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    59b0: e3c0001f  bic r0, r0, #31

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0);
    59b4: ee402f10  mcr 15, 2, r2, cr0, cr0, {0}

    while (LocalAddr < end) {
    59b8: e1510000  cmp r1, r0
    59bc: 9a000003  bls 59d0 <Xil_L1DCacheInvalidateRange+0x3c>
#ifdef __GNUC__
      __asm__ __volatile__("mcr " \
    59c0: ee070f36  mcr 15, 0, r0, cr7, cr6, {1}
#else
      { volatile register u32 Reg
        __asm(XREG_CP15_INVAL_DC_LINE_MVA_POC);
        Reg = LocalAddr; }
#endif
      LocalAddr += cacheline;
    59c4: e2800020  add r0, r0, #32
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0);

    while (LocalAddr < end) {
    59c8: e1510000  cmp r1, r0
    59cc: 8afffffb  bhi 59c0 <Xil_L1DCacheInvalidateRange+0x2c>
      LocalAddr += cacheline;
    }
  }

  /* Wait for L1 invalidate to complete */
  dsb();
    59d0: f57ff04f  dsb sy
  mtcpsr(currmask);
    59d4: e129f003  msr CPSR_fc, r3
    59d8: e12fff1e  bx  lr

000059dc <Xil_L1DCacheFlush>:
* @note   In Cortex A9, there is no cp instruction for flushing
*   the whole D-cache. Need to flush each line.
*
****************************************************************************/
void Xil_L1DCacheFlush(void)
{
    59dc: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  u32 CacheSize, LineSize, NumWays;
  u32 Way;
  u32 WayIndex, Set, SetIndex, NumSet;
  u32 currmask;

  currmask = mfcpsr();
    59e0: e10f6000  mrs r6, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    59e4: e38630c0  orr r3, r6, #192  ; 0xc0
    59e8: e129f003  msr CPSR_fc, r3

  /* Select cache level 0 and D cache in CSSR */
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0);
    59ec: e3a07000  mov r7, #0
    59f0: ee407f10  mcr 15, 2, r7, cr0, cr0, {0}

#ifdef __GNUC__
  CsidReg = mfcp(XREG_CP15_CACHE_SIZE_ID);
    59f4: ee304f10  mrc 15, 1, r4, cr0, cr0, {0}
    CsidReg = Reg; }
#endif

  /* Determine Cache Size */

  CacheSize = (CsidReg >> 13U) & 0x1FFU;
    59f8: e7e806d4  ubfx  r0, r4, #13, #9
  CacheSize +=1U;
  CacheSize *=128U;    /* to get number of bytes */

  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
    59fc: e7e651d4  ubfx  r5, r4, #3, #7
#endif

  /* Determine Cache Size */

  CacheSize = (CsidReg >> 13U) & 0x1FFU;
  CacheSize +=1U;
    5a00: e2800001  add r0, r0, #1
  CacheSize *=128U;    /* to get number of bytes */

  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
  NumWays += 1U;
    5a04: e2855001  add r5, r5, #1

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;

  NumSet = CacheSize/NumWays;
    5a08: e1a00380  lsl r0, r0, #7
    5a0c: e1a01005  mov r1, r5
    5a10: eb000de6  bl  91b0 <__aeabi_uidiv>
  /* Number of Ways */
  NumWays = (CsidReg & 0x3ffU) >> 3U;
  NumWays += 1U;

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;
    5a14: e2043007  and r3, r4, #7
    5a18: e2833004  add r3, r3, #4
    5a1c: e3a01001  mov r1, #1
    5a20: e1a01311  lsl r1, r1, r3

  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    5a24: e1a04007  mov r4, r7

  /* Get the cacheline size, way size, index size from csidr */
  LineSize = (CsidReg & 0x07U) + 4U;

  NumSet = CacheSize/NumWays;
  NumSet /= (0x00000001U << LineSize);
    5a28: e1a00330  lsr r0, r0, r3
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    5a2c: e3500000  cmp r0, #0
    5a30: e1a0ef04  lsl lr, r4, #30
    5a34: 13a03000  movne r3, #0
    5a38: 11a02003  movne r2, r3
    5a3c: 0a000005  beq 5a58 <Xil_L1DCacheFlush+0x7c>
      C7Reg = Way | Set;
    5a40: e182c00e  orr ip, r2, lr
      /* Flush by Set/Way */
#ifdef __GNUC__
      __asm__ __volatile__("mcr " \
    5a44: ee07cf5e  mcr 15, 0, ip, cr7, cr14, {2}
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    5a48: e2833001  add r3, r3, #1
#else
      { volatile register u32 Reg
        __asm(XREG_CP15_CLEAN_INVAL_DC_LINE_SW);
        Reg = C7Reg; }
#endif
      Set += (0x00000001U << LineSize);
    5a4c: e0822001  add r2, r2, r1
  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    for (SetIndex =0U; SetIndex < NumSet; SetIndex++) {
    5a50: e1530000  cmp r3, r0
    5a54: 1afffff9  bne 5a40 <Xil_L1DCacheFlush+0x64>

  Way = 0U;
  Set = 0U;

  /* Invalidate all the cachelines */
  for (WayIndex =0U; WayIndex < NumWays; WayIndex++) {
    5a58: e2844001  add r4, r4, #1
    5a5c: e1550004  cmp r5, r4
    5a60: 1afffff1  bne 5a2c <Xil_L1DCacheFlush+0x50>
    Set = 0U;
    Way += 0x40000000U;
  }

  /* Wait for L1 flush to complete */
  dsb();
    5a64: f57ff04f  dsb sy
  mtcpsr(currmask);
    5a68: e129f006  msr CPSR_fc, r6
    5a6c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

00005a70 <Xil_L1DCacheDisable>:
*
* @note   None.
*
****************************************************************************/
void Xil_L1DCacheDisable(void)
{
    5a70: e92d4008  push  {r3, lr}
  register u32 CtrlReg;

  /* clean and invalidate the Data cache */
  Xil_L1DCacheFlush();
    5a74: ebffffd8  bl  59dc <Xil_L1DCacheFlush>

#ifdef __GNUC__
  /* disable the Data cache */
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5a78: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif

  CtrlReg &= ~(XREG_CP15_CONTROL_C_BIT);
    5a7c: e3c33004  bic r3, r3, #4

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5a80: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
    5a84: e8bd8008  pop {r3, pc}

00005a88 <Xil_L1DCacheFlushLine>:
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheFlushLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5a88: e3a03000  mov r3, #0
    5a8c: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5a90: e3c0001f  bic r0, r0, #31
    5a94: ee070f3e  mcr 15, 0, r0, cr7, cr14, {1}

  /* Wait for L1 flush to complete */
  dsb();
    5a98: f57ff04f  dsb sy
    5a9c: e12fff1e  bx  lr

00005aa0 <Xil_L1DCacheFlushRange>:
  u32 LocalAddr = adr;
  const u32 cacheline = 32U;
  u32 end;
  u32 currmask;

  currmask = mfcpsr();
    5aa0: e10f3000  mrs r3, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5aa4: e38320c0  orr r2, r3, #192  ; 0xc0
    5aa8: e129f002  msr CPSR_fc, r2

  if (len != 0U) {
    5aac: e3510000  cmp r1, #0
    5ab0: 0a000009  beq 5adc <Xil_L1DCacheFlushRange+0x3c>
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    5ab4: e0801001  add r1, r0, r1
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5ab8: e3a02000  mov r2, #0
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    5abc: e3c0001f  bic r0, r0, #31

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5ac0: ee402f10  mcr 15, 2, r2, cr0, cr0, {0}

    while (LocalAddr < end) {
    5ac4: e1510000  cmp r1, r0
    5ac8: 9a000003  bls 5adc <Xil_L1DCacheFlushRange+0x3c>
#ifdef __GNUC__
      __asm__ __volatile__("mcr " \
    5acc: ee070f3e  mcr 15, 0, r0, cr7, cr14, {1}
#else
      { volatile register u32 Reg
        __asm(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC);
        Reg = LocalAddr; }
#endif
      LocalAddr += cacheline;
    5ad0: e2800020  add r0, r0, #32
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 D-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);

    while (LocalAddr < end) {
    5ad4: e1510000  cmp r1, r0
    5ad8: 8afffffb  bhi 5acc <Xil_L1DCacheFlushRange+0x2c>
      LocalAddr += cacheline;
    }
  }

  /* Wait for L1 flush to complete */
  dsb();
    5adc: f57ff04f  dsb sy
  mtcpsr(currmask);
    5ae0: e129f003  msr CPSR_fc, r3
    5ae4: e12fff1e  bx  lr

00005ae8 <Xil_L1DCacheStoreLine>:
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheStoreLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5ae8: e3a03000  mov r3, #0
    5aec: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5af0: e3c0001f  bic r0, r0, #31
    5af4: ee070f3a  mcr 15, 0, r0, cr7, cr10, {1}

  /* Wait for L1 store to complete */
  dsb();
    5af8: f57ff04f  dsb sy
    5afc: e12fff1e  bx  lr

00005b00 <Xil_L1ICacheEnable>:
{
  register u32 CtrlReg;

  /* enable caches only if they are disabled */
#ifdef __GNUC__
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5b00: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
  mfcp(XREG_CP15_SYS_CONTROL, CtrlReg);
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif
  if ((CtrlReg & (XREG_CP15_CONTROL_I_BIT)) != 0U) {
    5b04: e2132a01  ands  r2, r3, #4096 ; 0x1000
    5b08: 112fff1e  bxne  lr
    return;
  }

  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5b0c: ee072f15  mcr 15, 0, r2, cr7, cr5, {0}

  /* enable the instruction cache */
  CtrlReg |= (XREG_CP15_CONTROL_I_BIT);
    5b10: e3833a01  orr r3, r3, #4096 ; 0x1000

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5b14: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
    5b18: e12fff1e  bx  lr

00005b1c <Xil_L1ICacheDisable>:
****************************************************************************/
void Xil_L1ICacheDisable(void)
{
  register u32 CtrlReg;

  dsb();
    5b1c: f57ff04f  dsb sy

  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5b20: e3a03000  mov r3, #0
    5b24: ee073f15  mcr 15, 0, r3, cr7, cr5, {0}

  /* disable the instruction cache */
#ifdef __GNUC__
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5b28: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
  mfcp(XREG_CP15_SYS_CONTROL, CtrlReg);
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif
  CtrlReg &= ~(XREG_CP15_CONTROL_I_BIT);
    5b2c: e3c33a01  bic r3, r3, #4096 ; 0x1000

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5b30: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
    5b34: e12fff1e  bx  lr

00005b38 <Xil_L1ICacheInvalidate>:
* @note   None.
*
****************************************************************************/
void Xil_L1ICacheInvalidate(void)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5b38: e3a03001  mov r3, #1
    5b3c: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5b40: e3a03000  mov r3, #0
    5b44: ee073f15  mcr 15, 0, r3, cr7, cr5, {0}

  /* Wait for L1 invalidate to complete */
  dsb();
    5b48: f57ff04f  dsb sy
    5b4c: e12fff1e  bx  lr

00005b50 <Xil_L1ICacheInvalidateLine>:
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1ICacheInvalidateLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5b50: e3a03001  mov r3, #1
    5b54: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  mtcp(XREG_CP15_INVAL_IC_LINE_MVA_POU, (adr & (~0x1FU)));
    5b58: e3c0001f  bic r0, r0, #31
    5b5c: ee070f35  mcr 15, 0, r0, cr7, cr5, {1}

  /* Wait for L1 invalidate to complete */
  dsb();
    5b60: f57ff04f  dsb sy
    5b64: e12fff1e  bx  lr

00005b68 <Xil_L1ICacheInvalidateRange>:
  u32 LocalAddr = adr;
  const u32 cacheline = 32U;
  u32 end;
  u32 currmask;

  currmask = mfcpsr();
    5b68: e10f3000  mrs r3, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5b6c: e38320c0  orr r2, r3, #192  ; 0xc0
    5b70: e129f002  msr CPSR_fc, r2

  if (len != 0U) {
    5b74: e3510000  cmp r1, #0
    5b78: 0a000009  beq 5ba4 <Xil_L1ICacheInvalidateRange+0x3c>
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    5b7c: e0801001  add r1, r0, r1
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5b80: e3a02001  mov r2, #1
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    5b84: e3c0001f  bic r0, r0, #31

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5b88: ee402f10  mcr 15, 2, r2, cr0, cr0, {0}

    while (LocalAddr < end) {
    5b8c: e1510000  cmp r1, r0
    5b90: 9a000003  bls 5ba4 <Xil_L1ICacheInvalidateRange+0x3c>
#ifdef __GNUC__
      __asm__ __volatile__("mcr " \
    5b94: ee070f35  mcr 15, 0, r0, cr7, cr5, {1}
#else
      { volatile register u32 Reg
        __asm(XREG_CP15_INVAL_IC_LINE_MVA_POU);
        Reg = LocalAddr; }
#endif
      LocalAddr += cacheline;
    5b98: e2800020  add r0, r0, #32
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Select cache L0 I-cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);

    while (LocalAddr < end) {
    5b9c: e1510000  cmp r1, r0
    5ba0: 8afffffb  bhi 5b94 <Xil_L1ICacheInvalidateRange+0x2c>
      LocalAddr += cacheline;
    }
  }

  /* Wait for L1 invalidate to complete */
  dsb();
    5ba4: f57ff04f  dsb sy
  mtcpsr(currmask);
    5ba8: e129f003  msr CPSR_fc, r3
    5bac: e12fff1e  bx  lr

00005bb0 <Xil_L2CacheInvalidate>:
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    5bb0: e3000000  movw  r0, #0
{
  #ifdef __GNUC__
  u32 stack_start,stack_end,stack_size;
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;
    5bb4: e30d1400  movw  r1, #54272  ; 0xd400

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    5bb8: e34f0fff  movt  r0, #65535  ; 0xffff
{
  #ifdef __GNUC__
  u32 stack_start,stack_end,stack_size;
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;
    5bbc: e34f1fff  movt  r1, #65535  ; 0xffff
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheInvalidate(void)
{
    5bc0: e92d4008  push  {r3, lr}
  stack_end = (u32)&_stack_end;
  stack_start = (u32)&__undef_stack;
  stack_size=stack_start-stack_end;

  /*Flush stack memory to save return address*/
  Xil_DCacheFlushRange(stack_end, stack_size);
    5bc4: e0601001  rsb r1, r0, r1
    5bc8: ebfffee9  bl  5774 <Xil_DCacheFlushRange>
  #endif
  u32 ResultDCache;
  /* Invalidate the caches */
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_WAY_OFFSET,
    5bcc: e302077c  movw  r0, #10108  ; 0x277c
    5bd0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5bd4: e30f1fff  movw  r1, #65535  ; 0xffff
    5bd8: eb000174  bl  61b0 <Xil_Out32>
      0x0000FFFFU);
  ResultDCache = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_WAY_OFFSET)
    5bdc: e302077c  movw  r0, #10108  ; 0x277c
    5be0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5be4: eb00016b  bl  6198 <Xil_In32>
    5be8: e6ff0070  uxth  r0, r0
              & 0x0000FFFFU;
  while(ResultDCache != (u32)0U) {
    5bec: e3500000  cmp r0, #0
    5bf0: 1afffff9  bne 5bdc <Xil_L2CacheInvalidate+0x2c>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5bf4: e3a00d9d  mov r0, #10048  ; 0x2740
    5bf8: e3a01000  mov r1, #0
    5bfc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5c00: eb00016a  bl  61b0 <Xil_Out32>

  /* Wait for the invalidate to complete */
  Xil_L2CacheSync();

  /* synchronize the processor */
  dsb();
    5c04: f57ff04f  dsb sy
    5c08: e8bd8008  pop {r3, pc}

00005c0c <Xil_DCacheInvalidate>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheInvalidate(void)
{
    5c0c: e92d4010  push  {r4, lr}
  u32 currmask;

  currmask = mfcpsr();
    5c10: e10f4000  mrs r4, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5c14: e38430c0  orr r3, r4, #192  ; 0xc0
    5c18: e129f003  msr CPSR_fc, r3

  Xil_L2CacheInvalidate();
    5c1c: ebffffe3  bl  5bb0 <Xil_L2CacheInvalidate>
  Xil_L1DCacheInvalidate();
    5c20: ebffff22  bl  58b0 <Xil_L1DCacheInvalidate>

  mtcpsr(currmask);
    5c24: e129f004  msr CPSR_fc, r4
    5c28: e8bd8010  pop {r4, pc}

00005c2c <Xil_ICacheInvalidate>:
*
* @note   None.
*
****************************************************************************/
void Xil_ICacheInvalidate(void)
{
    5c2c: e92d4010  push  {r4, lr}
  u32 currmask;

  currmask = mfcpsr();
    5c30: e10f4000  mrs r4, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5c34: e38430c0  orr r3, r4, #192  ; 0xc0
    5c38: e129f003  msr CPSR_fc, r3

  Xil_L2CacheInvalidate();
    5c3c: ebffffdb  bl  5bb0 <Xil_L2CacheInvalidate>
* @note   None.
*
****************************************************************************/
void Xil_L1ICacheInvalidate(void)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 1U);
    5c40: e3a03001  mov r3, #1
    5c44: ee403f10  mcr 15, 2, r3, cr0, cr0, {0}
  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5c48: e3a03000  mov r3, #0
    5c4c: ee073f15  mcr 15, 0, r3, cr7, cr5, {0}

  /* Wait for L1 invalidate to complete */
  dsb();
    5c50: f57ff04f  dsb sy
  mtcpsr(currmask | IRQ_FIQ_MASK);

  Xil_L2CacheInvalidate();
  Xil_L1ICacheInvalidate();

  mtcpsr(currmask);
    5c54: e129f004  msr CPSR_fc, r4
    5c58: e8bd8010  pop {r4, pc}

00005c5c <Xil_L2CacheEnable>:
****************************************************************************/
void Xil_L2CacheEnable(void)
{
  register u32 L2CCReg;

  L2CCReg = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET);
    5c5c: e3a00c21  mov r0, #8448 ; 0x2100
*
* @note   None.
*
****************************************************************************/
void Xil_L2CacheEnable(void)
{
    5c60: e92d4010  push  {r4, lr}
  register u32 L2CCReg;

  L2CCReg = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET);
    5c64: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5c68: eb00014a  bl  6198 <Xil_In32>

  /* only enable if L2CC is currently disabled */
  if ((L2CCReg & 0x01U) == 0U) {
    5c6c: e2104001  ands  r4, r0, #1
    5c70: 18bd8010  popne {r4, pc}
    /* set up the way size and latencies */
    L2CCReg = Xil_In32(XPS_L2CC_BASEADDR +
    5c74: e3020104  movw  r0, #8452 ; 0x2104
    5c78: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5c7c: eb000145  bl  6198 <Xil_In32>
           XPS_L2CC_AUX_CNTRL_OFFSET);
    L2CCReg &= XPS_L2CC_AUX_REG_ZERO_MASK;
    5c80: e3c0180e  bic r1, r0, #917504 ; 0xe0000
    L2CCReg |= XPS_L2CC_AUX_REG_DEFAULT_MASK;
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_AUX_CNTRL_OFFSET,
    5c84: e3020104  movw  r0, #8452 ; 0x2104
    5c88: e3811472  orr r1, r1, #1912602624 ; 0x72000000
    5c8c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5c90: e3811836  orr r1, r1, #3538944  ; 0x360000
    5c94: eb000145  bl  61b0 <Xil_Out32>
        L2CCReg);
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_TAG_RAM_CNTRL_OFFSET,
    5c98: e3020108  movw  r0, #8456 ; 0x2108
    5c9c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5ca0: e3001111  movw  r1, #273  ; 0x111
    5ca4: eb000141  bl  61b0 <Xil_Out32>
        XPS_L2CC_TAG_RAM_DEFAULT_MASK);
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DATA_RAM_CNTRL_OFFSET,
    5ca8: e302010c  movw  r0, #8460 ; 0x210c
    5cac: e3001121  movw  r1, #289  ; 0x121
    5cb0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5cb4: eb00013d  bl  61b0 <Xil_Out32>
        XPS_L2CC_DATA_RAM_DEFAULT_MASK);

    /* Clear the pending interrupts */
    L2CCReg = Xil_In32(XPS_L2CC_BASEADDR +
    5cb8: e302021c  movw  r0, #8732 ; 0x221c
    5cbc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5cc0: eb000134  bl  6198 <Xil_In32>
    5cc4: e1a01000  mov r1, r0
           XPS_L2CC_ISR_OFFSET);
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_IAR_OFFSET, L2CCReg);
    5cc8: e3020220  movw  r0, #8736 ; 0x2220
    5ccc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5cd0: eb000136  bl  61b0 <Xil_Out32>

    Xil_L2CacheInvalidate();
    5cd4: ebffffb5  bl  5bb0 <Xil_L2CacheInvalidate>
    /* Enable the L2CC */
    L2CCReg = Xil_In32(XPS_L2CC_BASEADDR +
    5cd8: e3a00c21  mov r0, #8448 ; 0x2100
    5cdc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5ce0: eb00012c  bl  6198 <Xil_In32>
           XPS_L2CC_CNTRL_OFFSET);
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET,
    5ce4: e3801001  orr r1, r0, #1
    5ce8: e3a00c21  mov r0, #8448 ; 0x2100
    5cec: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5cf0: eb00012e  bl  61b0 <Xil_Out32>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5cf4: e3a00d9d  mov r0, #10048  ; 0x2740
    5cf8: e1a01004  mov r1, r4
    5cfc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5d00: eb00012a  bl  61b0 <Xil_Out32>
    Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET,
        (L2CCReg | (0x01U)));

        Xil_L2CacheSync();
        /* synchronize the processor */
      dsb();
    5d04: f57ff04f  dsb sy
    5d08: e8bd8010  pop {r4, pc}

00005d0c <Xil_DCacheEnable>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheEnable(void)
{
    5d0c: e92d4008  push  {r3, lr}
  Xil_L1DCacheEnable();
    5d10: ebffff11  bl  595c <Xil_L1DCacheEnable>
  Xil_L2CacheEnable();
}
    5d14: e8bd4008  pop {r3, lr}
*
****************************************************************************/
void Xil_DCacheEnable(void)
{
  Xil_L1DCacheEnable();
  Xil_L2CacheEnable();
    5d18: eaffffcf  b 5c5c <Xil_L2CacheEnable>

00005d1c <Xil_ICacheEnable>:
{
  register u32 CtrlReg;

  /* enable caches only if they are disabled */
#ifdef __GNUC__
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5d1c: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
  mfcp(XREG_CP15_SYS_CONTROL, CtrlReg);
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif
  if ((CtrlReg & (XREG_CP15_CONTROL_I_BIT)) != 0U) {
    5d20: e2132a01  ands  r2, r3, #4096 ; 0x1000
    5d24: 1a000002  bne 5d34 <Xil_ICacheEnable+0x18>
    return;
  }

  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5d28: ee072f15  mcr 15, 0, r2, cr7, cr5, {0}

  /* enable the instruction cache */
  CtrlReg |= (XREG_CP15_CONTROL_I_BIT);
    5d2c: e3833a01  orr r3, r3, #4096 ; 0x1000

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5d30: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
*
****************************************************************************/
void Xil_ICacheEnable(void)
{
  Xil_L1ICacheEnable();
  Xil_L2CacheEnable();
    5d34: eaffffc8  b 5c5c <Xil_L2CacheEnable>

00005d38 <Xil_L2CacheInvalidateLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheInvalidateLine(u32 adr)
{
    5d38: e1a01000  mov r1, r0
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_PA_OFFSET, (u32)adr);
    5d3c: e3020770  movw  r0, #10096  ; 0x2770
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheInvalidateLine(u32 adr)
{
    5d40: e92d4008  push  {r3, lr}
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_PA_OFFSET, (u32)adr);
    5d44: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5d48: eb000118  bl  61b0 <Xil_Out32>
  /* synchronize the processor */
  dsb();
    5d4c: f57ff04f  dsb sy
    5d50: e8bd8008  pop {r3, pc}

00005d54 <Xil_L2CacheInvalidateRange>:
*
* @note   None.
*
****************************************************************************/
void Xil_L2CacheInvalidateRange(u32 adr, u32 len)
{
    5d54: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  volatile u32 *L2CCOffset = (volatile u32 *)(XPS_L2CC_BASEADDR +
            XPS_L2CC_CACHE_INVLD_PA_OFFSET);

  u32 currmask;

  currmask = mfcpsr();
    5d58: e10f7000  mrs r7, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5d5c: e38730c0  orr r3, r7, #192  ; 0xc0
    5d60: e129f003  msr CPSR_fc, r3

  if (len != 0U) {
    5d64: e3510000  cmp r1, #0
    5d68: 1a000002  bne 5d78 <Xil_L2CacheInvalidateRange+0x24>
    /* Enable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x0U);
  }

  /* synchronize the processor */
  dsb();
    5d6c: f57ff04f  dsb sy
  mtcpsr(currmask);
    5d70: e129f007  msr CPSR_fc, r7
    5d74: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    5d78: e1a04000  mov r4, r0
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5d7c: e3a00dbd  mov r0, #12096  ; 0x2f40

  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    5d80: e0845001  add r5, r4, r1
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5d84: e34f08f0  movt  r0, #63728  ; 0xf8f0
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    5d88: e3c4401f  bic r4, r4, #31
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5d8c: e3a01003  mov r1, #3
    5d90: eb000106  bl  61b0 <Xil_Out32>
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    5d94: e1550004  cmp r5, r4
      *L2CCOffset = LocalAddr;
    5d98: 83a06a02  movhi r6, #8192 ; 0x2000
    5d9c: 834f68f0  movthi  r6, #63728  ; 0xf8f0
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    5da0: 9a000007  bls 5dc4 <Xil_L2CacheInvalidateRange+0x70>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5da4: e3a00d9d  mov r0, #10048  ; 0x2740

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
      *L2CCOffset = LocalAddr;
    5da8: e5864770  str r4, [r6, #1904] ; 0x770
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5dac: e34f08f0  movt  r0, #63728  ; 0xf8f0
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
      *L2CCOffset = LocalAddr;
      Xil_L2CacheSync();
      LocalAddr += cacheline;
    5db0: e2844020  add r4, r4, #32
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5db4: e3a01000  mov r1, #0
    5db8: eb0000fc  bl  61b0 <Xil_Out32>
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    5dbc: e1550004  cmp r5, r4
    5dc0: 8afffff7  bhi 5da4 <Xil_L2CacheInvalidateRange+0x50>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5dc4: e3a00dbd  mov r0, #12096  ; 0x2f40
    5dc8: e3a01000  mov r1, #0
    5dcc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5dd0: eb0000f6  bl  61b0 <Xil_Out32>
    5dd4: eaffffe4  b 5d6c <Xil_L2CacheInvalidateRange+0x18>

00005dd8 <Xil_L2CacheFlush>:
    5dd8: e3a00dbd  mov r0, #12096  ; 0x2f40
    5ddc: e3a01003  mov r1, #3
    5de0: e34f08f0  movt  r0, #63728  ; 0xf8f0
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheFlush(void)
{
    5de4: e92d4008  push  {r3, lr}
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5de8: eb0000f0  bl  61b0 <Xil_Out32>
  /* Flush the caches */

  /* Disable Write-back and line fills */
  Xil_L2WriteDebugCtrl(0x3U);

  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INV_CLN_WAY_OFFSET,
    5dec: e30207fc  movw  r0, #10236  ; 0x27fc
    5df0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5df4: e30f1fff  movw  r1, #65535  ; 0xffff
    5df8: eb0000ec  bl  61b0 <Xil_Out32>
      0x0000FFFFU);
  ResultL2Cache = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INV_CLN_WAY_OFFSET)
    5dfc: e30207fc  movw  r0, #10236  ; 0x27fc
    5e00: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e04: eb0000e3  bl  6198 <Xil_In32>
    5e08: e6ff0070  uxth  r0, r0
              & 0x0000FFFFU;

  while(ResultL2Cache != (u32)0U) {
    5e0c: e3500000  cmp r0, #0
    5e10: 1afffff9  bne 5dfc <Xil_L2CacheFlush+0x24>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5e14: e3a00d9d  mov r0, #10048  ; 0x2740
    5e18: e3a01000  mov r1, #0
    5e1c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e20: eb0000e2  bl  61b0 <Xil_Out32>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5e24: e3a00dbd  mov r0, #12096  ; 0x2f40
    5e28: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e2c: e3a01000  mov r1, #0
    5e30: eb0000de  bl  61b0 <Xil_Out32>
  Xil_L2CacheSync();
  /* Enable Write-back and line fills */
  Xil_L2WriteDebugCtrl(0x0U);

  /* synchronize the processor */
  dsb();
    5e34: f57ff04f  dsb sy
    5e38: e8bd8008  pop {r3, pc}

00005e3c <Xil_DCacheFlush>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheFlush(void)
{
    5e3c: e92d4010  push  {r4, lr}
  u32 currmask;

  currmask = mfcpsr();
    5e40: e10f4000  mrs r4, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5e44: e38430c0  orr r3, r4, #192  ; 0xc0
    5e48: e129f003  msr CPSR_fc, r3
  Xil_L1DCacheFlush();
    5e4c: ebfffee2  bl  59dc <Xil_L1DCacheFlush>
  Xil_L2CacheFlush();
    5e50: ebffffe0  bl  5dd8 <Xil_L2CacheFlush>

  mtcpsr(currmask);
    5e54: e129f004  msr CPSR_fc, r4
    5e58: e8bd8010  pop {r4, pc}

00005e5c <Xil_L2CacheDisable>:
****************************************************************************/
void Xil_L2CacheDisable(void)
{
    register u32 L2CCReg;

  L2CCReg = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET);
    5e5c: e3a00c21  mov r0, #8448 ; 0x2100
*
* @note   None.
*
****************************************************************************/
void Xil_L2CacheDisable(void)
{
    5e60: e92d4008  push  {r3, lr}
    register u32 L2CCReg;

  L2CCReg = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET);
    5e64: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e68: eb0000ca  bl  6198 <Xil_In32>

    if((L2CCReg & 0x1U) != 0U) {
    5e6c: e3100001  tst r0, #1
    5e70: 08bd8008  popeq {r3, pc}

        /* Clean and Invalidate L2 Cache */
        Xil_L2CacheFlush();
    5e74: ebffffd7  bl  5dd8 <Xil_L2CacheFlush>

      /* Disable the L2CC */
  L2CCReg = Xil_In32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET);
    5e78: e3a00c21  mov r0, #8448 ; 0x2100
    5e7c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e80: eb0000c4  bl  6198 <Xil_In32>
      Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CNTRL_OFFSET,
    5e84: e3c01001  bic r1, r0, #1
    5e88: e3a00c21  mov r0, #8448 ; 0x2100
    5e8c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5e90: eb0000c6  bl  61b0 <Xil_Out32>
          (L2CCReg & (~0x01U)));
    /* Wait for the cache operations to complete */

    dsb();
    5e94: f57ff04f  dsb sy
    5e98: e8bd8008  pop {r3, pc}

00005e9c <Xil_DCacheDisable>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheDisable(void)
{
    5e9c: e92d4008  push  {r3, lr}
  Xil_L2CacheDisable();
    5ea0: ebffffed  bl  5e5c <Xil_L2CacheDisable>
void Xil_L1DCacheDisable(void)
{
  register u32 CtrlReg;

  /* clean and invalidate the Data cache */
  Xil_L1DCacheFlush();
    5ea4: ebfffecc  bl  59dc <Xil_L1DCacheFlush>

#ifdef __GNUC__
  /* disable the Data cache */
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5ea8: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif

  CtrlReg &= ~(XREG_CP15_CONTROL_C_BIT);
    5eac: e3c33004  bic r3, r3, #4

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5eb0: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
    5eb4: e8bd8008  pop {r3, pc}

00005eb8 <Xil_ICacheDisable>:
*
* @note   None.
*
****************************************************************************/
void Xil_ICacheDisable(void)
{
    5eb8: e92d4008  push  {r3, lr}
  Xil_L2CacheDisable();
    5ebc: ebffffe6  bl  5e5c <Xil_L2CacheDisable>
****************************************************************************/
void Xil_L1ICacheDisable(void)
{
  register u32 CtrlReg;

  dsb();
    5ec0: f57ff04f  dsb sy

  /* invalidate the instruction cache */
  mtcp(XREG_CP15_INVAL_IC_POU, 0U);
    5ec4: e3a03000  mov r3, #0
    5ec8: ee073f15  mcr 15, 0, r3, cr7, cr5, {0}

  /* disable the instruction cache */
#ifdef __GNUC__
  CtrlReg = mfcp(XREG_CP15_SYS_CONTROL);
    5ecc: ee113f10  mrc 15, 0, r3, cr1, cr0, {0}
  mfcp(XREG_CP15_SYS_CONTROL, CtrlReg);
#else
  { volatile register u32 Reg __asm(XREG_CP15_SYS_CONTROL);
    CtrlReg = Reg; }
#endif
  CtrlReg &= ~(XREG_CP15_CONTROL_I_BIT);
    5ed0: e3c33a01  bic r3, r3, #4096 ; 0x1000

  mtcp(XREG_CP15_SYS_CONTROL, CtrlReg);
    5ed4: ee013f10  mcr 15, 0, r3, cr1, cr0, {0}
    5ed8: e8bd8008  pop {r3, pc}

00005edc <Xil_L2CacheFlushLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheFlushLine(u32 adr)
{
    5edc: e92d4010  push  {r4, lr}
    5ee0: e1a04000  mov r4, r0
#ifdef CONFIG_PL310_ERRATA_588369
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_CLEAN_PA_OFFSET, adr);
    5ee4: e30207b0  movw  r0, #10160  ; 0x27b0
    5ee8: e1a01004  mov r1, r4
    5eec: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5ef0: eb0000ae  bl  61b0 <Xil_Out32>
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INVLD_PA_OFFSET, adr);
    5ef4: e3020770  movw  r0, #10096  ; 0x2770
    5ef8: e1a01004  mov r1, r4
    5efc: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5f00: eb0000aa  bl  61b0 <Xil_Out32>
#else
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_INV_CLN_PA_OFFSET, adr);
#endif
  /* synchronize the processor */
  dsb();
    5f04: f57ff04f  dsb sy
    5f08: e8bd8010  pop {r4, pc}

00005f0c <Xil_DCacheInvalidateRange>:
*
* @note   None.
*
****************************************************************************/
void Xil_DCacheInvalidateRange(INTPTR adr, u32 len)
{
    5f0c: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
  u32 tempend;
  u32 currmask;
  volatile u32 *L2CCOffset = (volatile u32 *)(XPS_L2CC_BASEADDR +
            XPS_L2CC_CACHE_INVLD_PA_OFFSET);

  currmask = mfcpsr();
    5f10: e10f7000  mrs r7, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    5f14: e38730c0  orr r3, r7, #192  ; 0xc0
    5f18: e129f003  msr CPSR_fc, r3

  if (len != 0U) {
    5f1c: e3510000  cmp r1, #0
    5f20: 0a000014  beq 5f78 <Xil_DCacheInvalidateRange+0x6c>
****************************************************************************/
void Xil_DCacheInvalidateRange(INTPTR adr, u32 len)
{
  const u32 cacheline = 32U;
  u32 end;
  u32 tempadr = adr;
    5f24: e1a04000  mov r4, r0

  if (len != 0U) {
    end = tempadr + len;
    tempend = end;
    /* Select L1 Data cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5f28: e3a06000  mov r6, #0

  currmask = mfcpsr();
  mtcpsr(currmask | IRQ_FIQ_MASK);

  if (len != 0U) {
    end = tempadr + len;
    5f2c: e0805001  add r5, r0, r1
    tempend = end;
    /* Select L1 Data cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5f30: ee406f10  mcr 15, 2, r6, cr0, cr0, {0}

    if ((tempadr & (cacheline-1U)) != 0U) {
    5f34: e310001f  tst r0, #31
    5f38: 1a000025  bne 5fd4 <Xil_DCacheInvalidateRange+0xc8>
      /* Enable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
      tempadr += cacheline;
    }
    if ((tempend & (cacheline-1U)) != 0U) {
    5f3c: e315001f  tst r5, #31
    5f40: 1a00000f  bne 5f84 <Xil_DCacheInvalidateRange+0x78>
      /* Enable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
    }

    while (tempadr < tempend) {
    5f44: e1540005  cmp r4, r5
    5f48: 2a00000a  bcs 5f78 <Xil_DCacheInvalidateRange+0x6c>
      /* Invalidate L2 cache line */
      *L2CCOffset = tempadr;
    5f4c: e3a06a02  mov r6, #8192 ; 0x2000
    5f50: e34f68f0  movt  r6, #63728  ; 0xf8f0
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5f54: e3a00d9d  mov r0, #10048  ; 0x2740
      Xil_L2CacheSync();
    }

    while (tempadr < tempend) {
      /* Invalidate L2 cache line */
      *L2CCOffset = tempadr;
    5f58: e5864770  str r4, [r6, #1904] ; 0x770
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5f5c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5f60: e3a01000  mov r1, #0
    5f64: eb000091  bl  61b0 <Xil_Out32>
      /* Invalidate L2 cache line */
      *L2CCOffset = tempadr;
      Xil_L2CacheSync();
#ifdef __GNUC__
      /* Invalidate L1 Data cache line */
      __asm__ __volatile__("mcr " \
    5f68: ee074f36  mcr 15, 0, r4, cr7, cr6, {1}
#else
      { volatile register u32 Reg
        __asm(XREG_CP15_INVAL_DC_LINE_MVA_POC);
        Reg = tempadr; }
#endif
      tempadr += cacheline;
    5f6c: e2844020  add r4, r4, #32
      /* Enable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
    }

    while (tempadr < tempend) {
    5f70: e1540005  cmp r4, r5
    5f74: 3afffff6  bcc 5f54 <Xil_DCacheInvalidateRange+0x48>
#endif
      tempadr += cacheline;
    }
  }

  dsb();
    5f78: f57ff04f  dsb sy
  mtcpsr(currmask);
    5f7c: e129f007  msr CPSR_fc, r7
    5f80: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
      tempadr += cacheline;
    }
    if ((tempend & (cacheline-1U)) != 0U) {
      tempend &= (~(cacheline - 1U));
    5f84: e3c5501f  bic r5, r5, #31
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheFlushLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5f88: e3a06000  mov r6, #0
    5f8c: ee406f10  mcr 15, 2, r6, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5f90: ee075f3e  mcr 15, 0, r5, cr7, cr14, {1}

  /* Wait for L1 flush to complete */
  dsb();
    5f94: f57ff04f  dsb sy
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5f98: e3a00dbd  mov r0, #12096  ; 0x2f40
    5f9c: e3a01003  mov r1, #3
    5fa0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5fa4: eb000081  bl  61b0 <Xil_Out32>
      tempend &= (~(cacheline - 1U));

      Xil_L1DCacheFlushLine(tempend);
      /* Disable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x3U);
      Xil_L2CacheFlushLine(tempend);
    5fa8: e1a00005  mov r0, r5
    5fac: ebffffca  bl  5edc <Xil_L2CacheFlushLine>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5fb0: e3a00dbd  mov r0, #12096  ; 0x2f40
    5fb4: e1a01006  mov r1, r6
    5fb8: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5fbc: eb00007b  bl  61b0 <Xil_Out32>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    5fc0: e3a00d9d  mov r0, #10048  ; 0x2740
    5fc4: e1a01006  mov r1, r6
    5fc8: e34f08f0  movt  r0, #63728  ; 0xf8f0
    5fcc: eb000077  bl  61b0 <Xil_Out32>
    5fd0: eaffffdb  b 5f44 <Xil_DCacheInvalidateRange+0x38>
    tempend = end;
    /* Select L1 Data cache in CSSR */
    mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);

    if ((tempadr & (cacheline-1U)) != 0U) {
      tempadr &= (~(cacheline - 1U));
    5fd4: e3c0801f  bic r8, r0, #31
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheFlushLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    5fd8: ee406f10  mcr 15, 2, r6, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    5fdc: ee078f3e  mcr 15, 0, r8, cr7, cr14, {1}

  /* Wait for L1 flush to complete */
  dsb();
    5fe0: f57ff04f  dsb sy
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5fe4: e3a00dbd  mov r0, #12096  ; 0x2f40
    5fe8: e3a01003  mov r1, #3
    5fec: e34f08f0  movt  r0, #63728  ; 0xf8f0
      Xil_L2WriteDebugCtrl(0x3U);
      Xil_L2CacheFlushLine(tempadr);
      /* Enable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
      tempadr += cacheline;
    5ff0: e2884020  add r4, r8, #32
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    5ff4: eb00006d  bl  61b0 <Xil_Out32>
      tempadr &= (~(cacheline - 1U));

      Xil_L1DCacheFlushLine(tempadr);
      /* Disable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x3U);
      Xil_L2CacheFlushLine(tempadr);
    5ff8: e1a00008  mov r0, r8
    5ffc: ebffffb6  bl  5edc <Xil_L2CacheFlushLine>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    6000: e3a00dbd  mov r0, #12096  ; 0x2f40
    6004: e1a01006  mov r1, r6
    6008: e34f08f0  movt  r0, #63728  ; 0xf8f0
    600c: eb000067  bl  61b0 <Xil_Out32>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    6010: e3a00d9d  mov r0, #10048  ; 0x2740
    6014: e1a01006  mov r1, r6
    6018: e34f08f0  movt  r0, #63728  ; 0xf8f0
    601c: eb000063  bl  61b0 <Xil_Out32>
      /* Enable Write-back and line fills */
      Xil_L2WriteDebugCtrl(0x0U);
      Xil_L2CacheSync();
      tempadr += cacheline;
    }
    if ((tempend & (cacheline-1U)) != 0U) {
    6020: e315001f  tst r5, #31
    6024: 0affffc6  beq 5f44 <Xil_DCacheInvalidateRange+0x38>
    6028: eaffffd5  b 5f84 <Xil_DCacheInvalidateRange+0x78>

0000602c <Xil_DCacheFlushLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_DCacheFlushLine(u32 adr)
{
    602c: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
    6030: e1a07000  mov r7, r0
  u32 currmask;

  currmask = mfcpsr();
    6034: e10f6000  mrs r6, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    6038: e38630c0  orr r3, r6, #192  ; 0xc0
    603c: e129f003  msr CPSR_fc, r3
* @note   The bottom 5 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L1DCacheFlushLine(u32 adr)
{
  mtcp(XREG_CP15_CACHE_SIZE_SEL, 0U);
    6040: e3a04000  mov r4, #0
    6044: ee404f10  mcr 15, 2, r4, cr0, cr0, {0}
  mtcp(XREG_CP15_CLEAN_INVAL_DC_LINE_MVA_POC, (adr & (~0x1FU)));
    6048: e3c0301f  bic r3, r0, #31
    604c: ee073f3e  mcr 15, 0, r3, cr7, cr14, {1}

  /* Wait for L1 flush to complete */
  dsb();
    6050: f57ff04f  dsb sy
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    6054: e3a05dbd  mov r5, #12096  ; 0x2f40
    6058: e3a01003  mov r1, #3
    605c: e34f58f0  movt  r5, #63728  ; 0xf8f0
    6060: e1a00005  mov r0, r5
    6064: eb000051  bl  61b0 <Xil_Out32>
  Xil_L1DCacheFlushLine(adr);

  /* Disable Write-back and line fills */
  Xil_L2WriteDebugCtrl(0x3U);

  Xil_L2CacheFlushLine(adr);
    6068: e1a00007  mov r0, r7
    606c: ebffff9a  bl  5edc <Xil_L2CacheFlushLine>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    6070: e1a00005  mov r0, r5
    6074: e1a01004  mov r1, r4
    6078: eb00004c  bl  61b0 <Xil_Out32>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    607c: e3a00d9d  mov r0, #10048  ; 0x2740
    6080: e1a01004  mov r1, r4
    6084: e34f08f0  movt  r0, #63728  ; 0xf8f0
    6088: eb000048  bl  61b0 <Xil_Out32>
  Xil_L2CacheFlushLine(adr);

  /* Enable Write-back and line fills */
  Xil_L2WriteDebugCtrl(0x0U);
  Xil_L2CacheSync();
  mtcpsr(currmask);
    608c: e129f006  msr CPSR_fc, r6
    6090: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

00006094 <Xil_L2CacheFlushRange>:
*
* @note   None.
*
****************************************************************************/
void Xil_L2CacheFlushRange(u32 adr, u32 len)
{
    6094: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  volatile u32 *L2CCOffset = (volatile u32 *)(XPS_L2CC_BASEADDR +
            XPS_L2CC_CACHE_INV_CLN_PA_OFFSET);

  u32 currmask;

  currmask = mfcpsr();
    6098: e10f7000  mrs r7, CPSR
  mtcpsr(currmask | IRQ_FIQ_MASK);
    609c: e38730c0  orr r3, r7, #192  ; 0xc0
    60a0: e129f003  msr CPSR_fc, r3
  if (len != 0U) {
    60a4: e3510000  cmp r1, #0
    60a8: 1a000002  bne 60b8 <Xil_L2CacheFlushRange+0x24>

    /* Enable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x0U);
  }
  /* synchronize the processor */
  dsb();
    60ac: f57ff04f  dsb sy
  mtcpsr(currmask);
    60b0: e129f007  msr CPSR_fc, r7
    60b4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    60b8: e1a04000  mov r4, r0
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    60bc: e3a00dbd  mov r0, #12096  ; 0x2f40
  mtcpsr(currmask | IRQ_FIQ_MASK);
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    60c0: e0845001  add r5, r4, r1
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    60c4: e34f08f0  movt  r0, #63728  ; 0xf8f0
  if (len != 0U) {
    /* Back the starting address up to the start of a cache line
     * perform cache operations until adr+len
     */
    end = LocalAddr + len;
    LocalAddr = LocalAddr & ~(cacheline - 1U);
    60c8: e3c4401f  bic r4, r4, #31
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    60cc: e3a01003  mov r1, #3
    60d0: eb000036  bl  61b0 <Xil_Out32>
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    60d4: e1550004  cmp r5, r4
      *L2CCOffset = LocalAddr;
    60d8: 83a06a02  movhi r6, #8192 ; 0x2000
    60dc: 834f68f0  movthi  r6, #63728  ; 0xf8f0
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    60e0: 9a000007  bls 6104 <Xil_L2CacheFlushRange+0x70>
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    60e4: e3a00d9d  mov r0, #10048  ; 0x2740

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
      *L2CCOffset = LocalAddr;
    60e8: e58647f0  str r4, [r6, #2032] ; 0x7f0
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    60ec: e34f08f0  movt  r0, #63728  ; 0xf8f0
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
      *L2CCOffset = LocalAddr;
      Xil_L2CacheSync();
      LocalAddr += cacheline;
    60f0: e2844020  add r4, r4, #32
#else
static void Xil_L2CacheSync(void)
#endif
{
#ifdef CONFIG_PL310_ERRATA_753970
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DUMMY_CACHE_SYNC_OFFSET, 0x0U);
    60f4: e3a01000  mov r1, #0
    60f8: eb00002c  bl  61b0 <Xil_Out32>
    LocalAddr = LocalAddr & ~(cacheline - 1U);

    /* Disable Write-back and line fills */
    Xil_L2WriteDebugCtrl(0x3U);

    while (LocalAddr < end) {
    60fc: e1550004  cmp r5, r4
    6100: 8afffff7  bhi 60e4 <Xil_L2CacheFlushRange+0x50>
#else
static void Xil_L2WriteDebugCtrl(u32 Value)
#endif
{
#if defined(CONFIG_PL310_ERRATA_588369) || defined(CONFIG_PL310_ERRATA_727915)
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_DEBUG_CTRL_OFFSET, Value);
    6104: e3a00dbd  mov r0, #12096  ; 0x2f40
    6108: e3a01000  mov r1, #0
    610c: e34f08f0  movt  r0, #63728  ; 0xf8f0
    6110: eb000026  bl  61b0 <Xil_Out32>
    6114: eaffffe4  b 60ac <Xil_L2CacheFlushRange+0x18>

00006118 <Xil_L2CacheStoreLine>:
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheStoreLine(u32 adr)
{
    6118: e1a01000  mov r1, r0
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_CLEAN_PA_OFFSET, adr);
    611c: e30207b0  movw  r0, #10160  ; 0x27b0
*
* @note   The bottom 4 bits are set to 0, forced by architecture.
*
****************************************************************************/
void Xil_L2CacheStoreLine(u32 adr)
{
    6120: e92d4008  push  {r3, lr}
  Xil_Out32(XPS_L2CC_BASEADDR + XPS_L2CC_CACHE_CLEAN_PA_OFFSET, adr);
    6124: e34f08f0  movt  r0, #63728  ; 0xf8f0
    6128: eb000020  bl  61b0 <Xil_Out32>
  /* synchronize the processor */
  dsb();
    612c: f57ff04f  dsb sy
    6130: e8bd8008  pop {r3, pc}

00006134 <Xil_ExceptionNullHandler>:
*
*****************************************************************************/
static void Xil_ExceptionNullHandler(void *Data)
{
  (void *)Data;
DieLoop: goto DieLoop;
    6134: eafffffe  b 6134 <Xil_ExceptionNullHandler>

00006138 <Xil_DataAbortHandler>:
****************************************************************************/

void Xil_DataAbortHandler(void *CallBackRef){
  u32 FaultStatus;
  #ifdef __GNUC__
    FaultStatus = mfcp(XREG_CP15_DATA_FAULT_STATUS);
    6138: ee153f10  mrc 15, 0, r3, cr5, cr0, {0}
  #endif
  xdbg_printf(XDBG_DEBUG_GENERAL, "Data abort with Data Fault Status Register  %x\n",FaultStatus);
  xdbg_printf(XDBG_DEBUG_GENERAL, "Address of Instrcution causing Data abort %x\n",DataAbortAddr);
  while(1) {
    ;
  }
    613c: eafffffe  b 613c <Xil_DataAbortHandler+0x4>

00006140 <Xil_PrefetchAbortHandler>:
*
****************************************************************************/
void Xil_PrefetchAbortHandler(void *CallBackRef){
  u32 FaultStatus;
  #ifdef __GNUC__
    FaultStatus = mfcp(XREG_CP15_INST_FAULT_STATUS);
    6140: ee153f30  mrc 15, 0, r3, cr5, cr0, {1}
  #endif
  xdbg_printf(XDBG_DEBUG_GENERAL, "Prefetch abort with Instruction Fault Status Register  %x\n",FaultStatus);
  xdbg_printf(XDBG_DEBUG_GENERAL, "Address of Instrcution causing Prefetch abort %x\n",PrefetchAbortAddr);
  while(1) {
    ;
  }
    6144: eafffffe  b 6144 <Xil_PrefetchAbortHandler+0x4>

00006148 <Xil_ExceptionInit>:
*
* @note   None.
*
*****************************************************************************/
void Xil_ExceptionInit(void)
{
    6148: e12fff1e  bx  lr

0000614c <Xil_ExceptionRegisterHandler>:
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Exception_id,
            Xil_ExceptionHandler Handler,
            void *Data)
{
  XExc_VectorTable[Exception_id].Handler = Handler;
    614c: e30b32ec  movw  r3, #45804  ; 0xb2ec
    6150: e3403001  movt  r3, #1
  XExc_VectorTable[Exception_id].Data = Data;
    6154: e083c180  add ip, r3, r0, lsl #3
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Exception_id,
            Xil_ExceptionHandler Handler,
            void *Data)
{
  XExc_VectorTable[Exception_id].Handler = Handler;
    6158: e7831180  str r1, [r3, r0, lsl #3]
  XExc_VectorTable[Exception_id].Data = Data;
    615c: e58c2004  str r2, [ip, #4]
    6160: e12fff1e  bx  lr

00006164 <Xil_ExceptionRemoveHandler>:
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Exception_id,
            Xil_ExceptionHandler Handler,
            void *Data)
{
  XExc_VectorTable[Exception_id].Handler = Handler;
    6164: e30b32ec  movw  r3, #45804  ; 0xb2ec
    6168: e3062134  movw  r2, #24884  ; 0x6134
    616c: e3403001  movt  r3, #1
  XExc_VectorTable[Exception_id].Data = Data;
    6170: e0831180  add r1, r3, r0, lsl #3
    6174: e3a0c000  mov ip, #0
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Exception_id,
            Xil_ExceptionHandler Handler,
            void *Data)
{
  XExc_VectorTable[Exception_id].Handler = Handler;
    6178: e3402000  movt  r2, #0
  XExc_VectorTable[Exception_id].Data = Data;
    617c: e581c004  str ip, [r1, #4]
****************************************************************************/
void Xil_ExceptionRegisterHandler(u32 Exception_id,
            Xil_ExceptionHandler Handler,
            void *Data)
{
  XExc_VectorTable[Exception_id].Handler = Handler;
    6180: e7832180  str r2, [r3, r0, lsl #3]
    6184: e12fff1e  bx  lr

00006188 <Xil_In8>:
* @note   None.
*
******************************************************************************/
u8 Xil_In8(INTPTR Addr)
{
  return *(volatile u8 *) Addr;
    6188: e5d00000  ldrb  r0, [r0]
}
    618c: e12fff1e  bx  lr

00006190 <Xil_In16>:
* @note   None.
*
******************************************************************************/
u16 Xil_In16(INTPTR Addr)
{
  return *(volatile u16 *) Addr;
    6190: e1d000b0  ldrh  r0, [r0]
}
    6194: e12fff1e  bx  lr

00006198 <Xil_In32>:
* @note   None.
*
******************************************************************************/
u32 Xil_In32(INTPTR Addr)
{
  return *(volatile u32 *) Addr;
    6198: e5900000  ldr r0, [r0]
}
    619c: e12fff1e  bx  lr

000061a0 <Xil_Out8>:
*
******************************************************************************/
void Xil_Out8(INTPTR Addr, u8 Value)
{
  u8 *LocalAddr = (u8 *)Addr;
  *LocalAddr = Value;
    61a0: e5c01000  strb  r1, [r0]
    61a4: e12fff1e  bx  lr

000061a8 <Xil_Out16>:
*
******************************************************************************/
void Xil_Out16(INTPTR Addr, u16 Value)
{
  u16 *LocalAddr = (u16 *)Addr;
  *LocalAddr = Value;
    61a8: e1c010b0  strh  r1, [r0]
    61ac: e12fff1e  bx  lr

000061b0 <Xil_Out32>:
*
******************************************************************************/
void Xil_Out32(INTPTR Addr, u32 Value)
{
  u32 *LocalAddr = (u32 *)Addr;
  *LocalAddr = Value;
    61b0: e5801000  str r1, [r0]
    61b4: e12fff1e  bx  lr

000061b8 <Xil_In16BE>:
* @note   None.
*
******************************************************************************/
u16 Xil_In16(INTPTR Addr)
{
  return *(volatile u16 *) Addr;
    61b8: e1d000b0  ldrh  r0, [r0]
* @note   None.
*
******************************************************************************/
u16 Xil_EndianSwap16(u16 Data)
{
  return (u16) (((Data & 0xFF00U) >> 8U) | ((Data & 0x00FFU) << 8U));
    61bc: e1a03420  lsr r3, r0, #8
    61c0: e1830400  orr r0, r3, r0, lsl #8
  temp = Xil_In16(Addr);

  result = Xil_EndianSwap16(temp);

  return result;
}
    61c4: e6ff0070  uxth  r0, r0
    61c8: e12fff1e  bx  lr

000061cc <Xil_In32BE>:
* @note   None.
*
******************************************************************************/
u32 Xil_In32(INTPTR Addr)
{
  return *(volatile u32 *) Addr;
    61cc: e5900000  ldr r0, [r0]
  temp = Xil_In32(Addr);

  result = Xil_EndianSwap32(temp);

  return result;
}
    61d0: e6bf0f30  rev r0, r0
    61d4: e12fff1e  bx  lr

000061d8 <Xil_Out16BE>:
* @note   None.
*
******************************************************************************/
u16 Xil_EndianSwap16(u16 Data)
{
  return (u16) (((Data & 0xFF00U) >> 8U) | ((Data & 0x00FFU) << 8U));
    61d8: e1a03421  lsr r3, r1, #8
    61dc: e1831401  orr r1, r3, r1, lsl #8
*
******************************************************************************/
void Xil_Out16(INTPTR Addr, u16 Value)
{
  u16 *LocalAddr = (u16 *)Addr;
  *LocalAddr = Value;
    61e0: e1c010b0  strh  r1, [r0]
    61e4: e12fff1e  bx  lr

000061e8 <Xil_Out32BE>:
*
* @note   None.
*
******************************************************************************/
void Xil_Out32BE(INTPTR Addr, u32 Value)
{
    61e8: e6bf1f31  rev r1, r1
*
******************************************************************************/
void Xil_Out32(INTPTR Addr, u32 Value)
{
  u32 *LocalAddr = (u32 *)Addr;
  *LocalAddr = Value;
    61ec: e5801000  str r1, [r0]
    61f0: e12fff1e  bx  lr

000061f4 <Xil_EndianSwap16>:
* @note   None.
*
******************************************************************************/
u16 Xil_EndianSwap16(u16 Data)
{
  return (u16) (((Data & 0xFF00U) >> 8U) | ((Data & 0x00FFU) << 8U));
    61f4: e1a03420  lsr r3, r0, #8
    61f8: e1830400  orr r0, r3, r0, lsl #8
}
    61fc: e6ff0070  uxth  r0, r0
    6200: e12fff1e  bx  lr

00006204 <Xil_EndianSwap32>:
  HiWord = (((HiWord & 0xFF00U) >> 8U) | ((HiWord & 0x00FFU) << 8U));

  /* swap the half words before returning the value */

  return ((((u32)LoWord) << (u32)16U) | (u32)HiWord);
}
    6204: e6bf0f30  rev r0, r0
    6208: e12fff1e  bx  lr

0000620c <getnum>:
{
    s32 n;
    s32 ResultIsDigit = 0;
    charptr cptr;
    n = 0;
    cptr = *linep;
    620c: e590c000  ldr ip, [r0]
  if(cptr != NULL){
    6210: e35c0000  cmp ip, #0
    6214: 0a000016  beq 6274 <getnum+0x68>
    ResultIsDigit = isdigit(((s32)*cptr));
    6218: e30b238c  movw  r2, #45964  ; 0xb38c
    621c: e3402001  movt  r2, #1
/*                                                   */
/* This routine gets a number from the format        */
/* string.                                           */
/*                                                   */
static s32 getnum( charptr* linep)
{
    6220: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
    s32 ResultIsDigit = 0;
    charptr cptr;
    n = 0;
    cptr = *linep;
  if(cptr != NULL){
    ResultIsDigit = isdigit(((s32)*cptr));
    6224: e592e000  ldr lr, [r2]
    6228: e5dc3000  ldrb  r3, [ip]
    622c: e08e3003  add r3, lr, r3
    6230: e5d33001  ldrb  r3, [r3, #1]
    6234: e2033004  and r3, r3, #4
  }
    while (ResultIsDigit != 0) {
    6238: e21330ff  ands  r3, r3, #255  ; 0xff
    623c: 0a000009  beq 6268 <getnum+0x5c>
    6240: e3a03000  mov r3, #0
    if(cptr != NULL){
      n = ((n*10) + (((s32)*cptr) - (s32)'0'));
    6244: e5dc1000  ldrb  r1, [ip]
    6248: e0833103  add r3, r3, r3, lsl #2
      cptr += 1;
      if(cptr != NULL){
        ResultIsDigit = isdigit(((s32)*cptr));
      }
    }
    ResultIsDigit = isdigit(((s32)*cptr));
    624c: e5fc2001  ldrb  r2, [ip, #1]!
  if(cptr != NULL){
    ResultIsDigit = isdigit(((s32)*cptr));
  }
    while (ResultIsDigit != 0) {
    if(cptr != NULL){
      n = ((n*10) + (((s32)*cptr) - (s32)'0'));
    6250: e2411030  sub r1, r1, #48 ; 0x30
      cptr += 1;
      if(cptr != NULL){
        ResultIsDigit = isdigit(((s32)*cptr));
      }
    }
    ResultIsDigit = isdigit(((s32)*cptr));
    6254: e08e2002  add r2, lr, r2
  if(cptr != NULL){
    ResultIsDigit = isdigit(((s32)*cptr));
  }
    while (ResultIsDigit != 0) {
    if(cptr != NULL){
      n = ((n*10) + (((s32)*cptr) - (s32)'0'));
    6258: e0813083  add r3, r1, r3, lsl #1
      cptr += 1;
      if(cptr != NULL){
        ResultIsDigit = isdigit(((s32)*cptr));
      }
    }
    ResultIsDigit = isdigit(((s32)*cptr));
    625c: e5d22001  ldrb  r2, [r2, #1]
    n = 0;
    cptr = *linep;
  if(cptr != NULL){
    ResultIsDigit = isdigit(((s32)*cptr));
  }
    while (ResultIsDigit != 0) {
    6260: e3120004  tst r2, #4
    6264: 1afffff6  bne 6244 <getnum+0x38>
        ResultIsDigit = isdigit(((s32)*cptr));
      }
    }
    ResultIsDigit = isdigit(((s32)*cptr));
  }
    *linep = ((charptr )(cptr));
    6268: e580c000  str ip, [r0]
    return(n);
}
    626c: e1a00003  mov r0, r3
    6270: e49df004  pop {pc}    ; (ldr pc, [sp], #4)
        ResultIsDigit = isdigit(((s32)*cptr));
      }
    }
    ResultIsDigit = isdigit(((s32)*cptr));
  }
    *linep = ((charptr )(cptr));
    6274: e580c000  str ip, [r0]
    return(n);
}
    6278: e1a0000c  mov r0, ip
    627c: e12fff1e  bx  lr

00006280 <padding.part.0>:
/*---------------------------------------------------*/
/*                                                   */
/* This routine puts pad characters into the output  */
/* buffer.                                           */
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
    6280: e92d4038  push  {r3, r4, r5, lr}
    6284: e1a05000  mov r5, r0
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    6288: e5904000  ldr r4, [r0]
    628c: e5903004  ldr r3, [r0, #4]
    6290: e1540003  cmp r4, r3
    6294: a8bd8038  popge {r3, r4, r5, pc}
    i=(par->len);
        for (; i<(par->num1); i++) {
#ifdef STDOUT_BASEADDRESS
            outbyte( par->pad_character);
    6298: e5d5000c  ldrb  r0, [r5, #12]
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    i=(par->len);
        for (; i<(par->num1); i++) {
    629c: e2844001  add r4, r4, #1
#ifdef STDOUT_BASEADDRESS
            outbyte( par->pad_character);
    62a0: eb000b76  bl  9080 <outbyte>
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    i=(par->len);
        for (; i<(par->num1); i++) {
    62a4: e5953004  ldr r3, [r5, #4]
    62a8: e1540003  cmp r4, r3
    62ac: bafffff9  blt 6298 <padding.part.0+0x18>
    62b0: e8bd8038  pop {r3, r4, r5, pc}

000062b4 <outnum>:
/* This routine moves a number to the output buffer  */
/* as directed by the padding and positioning flags. */
/*                                                   */

static void outnum( const s32 n, const s32 base, struct params_s *par)
{
    62b4: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
    charptr cp;
    s32 negative;
  s32 i;
    char8 outbuf[32];
    const char8 digits[] = "0123456789ABCDEF";
    62b8: e30896e8  movw  r9, #34536  ; 0x86e8
    62bc: e3409001  movt  r9, #1
/* This routine moves a number to the output buffer  */
/* as directed by the padding and positioning flags. */
/*                                                   */

static void outnum( const s32 n, const s32 base, struct params_s *par)
{
    62c0: e1a05000  mov r5, r0
    62c4: e1a07001  mov r7, r1
    62c8: e1a08002  mov r8, r2
    charptr cp;
    s32 negative;
  s32 i;
    char8 outbuf[32];
    const char8 digits[] = "0123456789ABCDEF";
    62cc: e8b9000f  ldm r9!, {r0, r1, r2, r3}
/* This routine moves a number to the output buffer  */
/* as directed by the padding and positioning flags. */
/*                                                   */

static void outnum( const s32 n, const s32 base, struct params_s *par)
{
    62d0: e24dd038  sub sp, sp, #56 ; 0x38
    62d4: e28d6017  add r6, sp, #23
    charptr cp;
    s32 negative;
  s32 i;
    char8 outbuf[32];
    const char8 digits[] = "0123456789ABCDEF";
    62d8: e28da004  add sl, sp, #4
    62dc: e28d4037  add r4, sp, #55 ; 0x37
    u32 num;
    for(i = 0; i<32; i++) {
  outbuf[i] = '0';
    62e0: e3a0e030  mov lr, #48 ; 0x30
{
    charptr cp;
    s32 negative;
  s32 i;
    char8 outbuf[32];
    const char8 digits[] = "0123456789ABCDEF";
    62e4: e1a0c006  mov ip, r6
    62e8: e5999000  ldr r9, [r9]
    62ec: e8aa000f  stmia sl!, {r0, r1, r2, r3}
    62f0: e5ca9000  strb  r9, [sl]
    u32 num;
    for(i = 0; i<32; i++) {
  outbuf[i] = '0';
    62f4: e5ece001  strb  lr, [ip, #1]!
    s32 negative;
  s32 i;
    char8 outbuf[32];
    const char8 digits[] = "0123456789ABCDEF";
    u32 num;
    for(i = 0; i<32; i++) {
    62f8: e15c0004  cmp ip, r4
    62fc: 1afffffc  bne 62f4 <outnum+0x40>
  outbuf[i] = '0';
    }

    /* Check if number is negative                   */
    if ((base == 10) && (n < 0L)) {
    6300: e1a0afa5  lsr sl, r5, #31
        num = n;
        negative = 0;
    }

    /* Build number (backwards) in outbuf            */
    i = 0;
    6304: e3a09000  mov r9, #0
    for(i = 0; i<32; i++) {
  outbuf[i] = '0';
    }

    /* Check if number is negative                   */
    if ((base == 10) && (n < 0L)) {
    6308: e357000a  cmp r7, #10
    630c: 13a0a000  movne sl, #0
    6310: 020aa001  andeq sl, sl, #1
    6314: e35a0000  cmp sl, #0
        negative = 1;
    num =(-(n));
    6318: 12655000  rsbne r5, r5, #0
  outbuf[i] = '0';
    }

    /* Check if number is negative                   */
    if ((base == 10) && (n < 0L)) {
        negative = 1;
    631c: 13a0a001  movne sl, #1
    6320: ea000000  b 6328 <outnum+0x74>

    /* Build number (backwards) in outbuf            */
    i = 0;
    do {
    outbuf[i] = digits[(num % base)];
    i++;
    6324: e1a09004  mov r9, r4
    }

    /* Build number (backwards) in outbuf            */
    i = 0;
    do {
    outbuf[i] = digits[(num % base)];
    6328: e1a00005  mov r0, r5
    632c: e1a01007  mov r1, r7
    6330: eb000c19  bl  939c <__aeabi_uidivmod>
    6334: e28d3038  add r3, sp, #56 ; 0x38
    i++;
    num /= base;
    6338: e1a00005  mov r0, r5

    /* Build number (backwards) in outbuf            */
    i = 0;
    do {
    outbuf[i] = digits[(num % base)];
    i++;
    633c: e2894001  add r4, r9, #1
    }

    /* Build number (backwards) in outbuf            */
    i = 0;
    do {
    outbuf[i] = digits[(num % base)];
    6340: e0833001  add r3, r3, r1
    i++;
    num /= base;
    6344: e1a01007  mov r1, r7
    }

    /* Build number (backwards) in outbuf            */
    i = 0;
    do {
    outbuf[i] = digits[(num % base)];
    6348: e5533034  ldrb  r3, [r3, #-52]  ; 0xffffffcc
    634c: e5e63001  strb  r3, [r6, #1]!
    i++;
    num /= base;
    6350: eb000b96  bl  91b0 <__aeabi_uidiv>
    } while (num > 0);
    6354: e2505000  subs  r5, r0, #0
    6358: 1afffff1  bne 6324 <outnum+0x70>

    if (negative != 0) {
    635c: e35a0000  cmp sl, #0
    outbuf[i] = 0;
    i--;

    /* Move the converted number to the buffer and   */
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    6360: e28d5018  add r5, sp, #24
    i++;
    num /= base;
    } while (num > 0);

    if (negative != 0) {
    outbuf[i] = '-';
    6364: 128d3038  addne r3, sp, #56 ; 0x38
    6368: 10833004  addne r3, r3, r4
    636c: 13a0202d  movne r2, #45 ; 0x2d
    i++;
    6370: 12894002  addne r4, r9, #2
    outbuf[i] = 0;
    i--;

    /* Move the converted number to the buffer and   */
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    6374: e1a00005  mov r0, r5
    i++;
    num /= base;
    } while (num > 0);

    if (negative != 0) {
    outbuf[i] = '-';
    6378: 15432020  strbne  r2, [r3, #-32]  ; 0xffffffe0
    i++;
  }

    outbuf[i] = 0;
    637c: e28d3038  add r3, sp, #56 ; 0x38
    6380: e0833004  add r3, r3, r4
    6384: e3a02000  mov r2, #0
    6388: e5432020  strb  r2, [r3, #-32]  ; 0xffffffe0
    i--;

    /* Move the converted number to the buffer and   */
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    638c: fa000e9b  blx 9e00 <strlen>
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    6390: e5983010  ldr r3, [r8, #16]
    6394: e5982014  ldr r2, [r8, #20]
    6398: e2933000  adds  r3, r3, #0
    639c: 13a03001  movne r3, #1
    63a0: e3520000  cmp r2, #0
    63a4: 13a03000  movne r3, #0
    63a8: e3530000  cmp r3, #0
    outbuf[i] = 0;
    i--;

    /* Move the converted number to the buffer and   */
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    63ac: e5880000  str r0, [r8]
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    63b0: 1a00000f  bne 63f4 <outnum+0x140>
    63b4: e0854004  add r4, r5, r4
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    padding( !(par->left_flag), par);
    while (&outbuf[i] >= outbuf) {
#ifdef STDOUT_BASEADDRESS
  outbyte( outbuf[i] );
    63b8: e5740001  ldrb  r0, [r4, #-1]!
    63bc: eb000b2f  bl  9080 <outbyte>

    /* Move the converted number to the buffer and   */
    /* add in the padding where needed.              */
    par->len = (s32)strlen(outbuf);
    padding( !(par->left_flag), par);
    while (&outbuf[i] >= outbuf) {
    63c0: e1540005  cmp r4, r5
    63c4: 1afffffb  bne 63b8 <outnum+0x104>
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    63c8: e5982010  ldr r2, [r8, #16]
    63cc: e5983014  ldr r3, [r8, #20]
    63d0: e3520000  cmp r2, #0
    63d4: 13530000  cmpne r3, #0
    63d8: 1a000001  bne 63e4 <outnum+0x130>
  outbyte( outbuf[i] );
    i--;
#endif
}
    padding( par->left_flag, par);
}
    63dc: e28dd038  add sp, sp, #56 ; 0x38
    63e0: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
    63e4: e1a00008  mov r0, r8
    63e8: ebffffa4  bl  6280 <padding.part.0>
    63ec: e28dd038  add sp, sp, #56 ; 0x38
    63f0: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
    63f4: e1a00008  mov r0, r8
    63f8: ebffffa0  bl  6280 <padding.part.0>
    63fc: eaffffec  b 63b4 <outnum+0x100>

00006400 <xil_printf>:
/*                                                   */

/* void esp_printf( const func_ptr f_ptr,
   const charptr ctrl1, ...) */
void xil_printf( const char8 *ctrl1, ...)
{
    6400: e92d000f  push  {r0, r1, r2, r3}
    6404: e92d40f0  push  {r4, r5, r6, r7, lr}
    6408: e24dd024  sub sp, sp, #36 ; 0x24
    }
    else {
      ch = *ctrl;
    }

        if (isdigit((s32)ch) != 0) {
    640c: e30b438c  movw  r4, #45964  ; 0xb38c
        }

        /* initialize all the flags for this format.   */
        dot_flag = 0;
    long_flag = 0;
    par.left_flag = 0;
    6410: e3a05000  mov r5, #0
/*                                                   */

/* void esp_printf( const func_ptr f_ptr,
   const charptr ctrl1, ...) */
void xil_printf( const char8 *ctrl1, ...)
{
    6414: e59d2038  ldr r2, [sp, #56] ; 0x38
    }
    else {
      ch = *ctrl;
    }

        if (isdigit((s32)ch) != 0) {
    6418: e3404001  movt  r4, #1

    char8 ch;
    va_list argp;
    char8 *ctrl = (char8 *)ctrl1;

    va_start( argp, ctrl1);
    641c: e28d303c  add r3, sp, #60 ; 0x3c
    6420: e58d3000  str r3, [sp]

    params_t par;

    char8 ch;
    va_list argp;
    char8 *ctrl = (char8 *)ctrl1;
    6424: e58d2004  str r2, [sp, #4]

    va_start( argp, ctrl1);

    while ((ctrl != NULL) && (*ctrl != (char8)0)) {
    6428: e3520000  cmp r2, #0
    642c: 0a00000a  beq 645c <xil_printf+0x5c>
    6430: e5d20000  ldrb  r0, [r2]
    6434: e3500000  cmp r0, #0
    6438: 0a000007  beq 645c <xil_printf+0x5c>

        /* move format string chars to buffer until a  */
        /* format control is found.                    */
        if (*ctrl != '%') {
    643c: e3500025  cmp r0, #37 ; 0x25
    6440: 0a000009  beq 646c <xil_printf+0x6c>
#ifdef STDOUT_BASEADDRESS
            outbyte(*ctrl);
    6444: eb000b0d  bl  9080 <outbyte>
      ctrl += 1;
    6448: e59d2004  ldr r2, [sp, #4]
    644c: e2822001  add r2, r2, #1
    6450: e58d2004  str r2, [sp, #4]
    va_list argp;
    char8 *ctrl = (char8 *)ctrl1;

    va_start( argp, ctrl1);

    while ((ctrl != NULL) && (*ctrl != (char8)0)) {
    6454: e3520000  cmp r2, #0
    6458: 1afffff4  bne 6430 <xil_printf+0x30>
                continue;
        }
        goto try_next;
    }
    va_end( argp);
}
    645c: e28dd024  add sp, sp, #36 ; 0x24
    6460: e8bd40f0  pop {r4, r5, r6, r7, lr}
    6464: e28dd010  add sp, sp, #16
    6468: e12fff1e  bx  lr
    par.left_flag = 0;
    par.do_padding = 0;
        par.pad_character = ' ';
        par.num2=32767;
    par.num1=0;
    par.len=0;
    646c: e1a03002  mov r3, r2
        /* initialize all the flags for this format.   */
        dot_flag = 0;
    long_flag = 0;
    par.left_flag = 0;
    par.do_padding = 0;
        par.pad_character = ' ';
    6470: e3a01020  mov r1, #32
        par.num2=32767;
    6474: e3072fff  movw  r2, #32767  ; 0x7fff
        }

        /* initialize all the flags for this format.   */
        dot_flag = 0;
    long_flag = 0;
    par.left_flag = 0;
    6478: e58d501c  str r5, [sp, #28]
    par.do_padding = 0;
    647c: e58d5018  str r5, [sp, #24]
#endif
            continue;
        }

        /* initialize all the flags for this format.   */
        dot_flag = 0;
    6480: e3a06000  mov r6, #0
    long_flag = 0;
    par.left_flag = 0;
    par.do_padding = 0;
        par.pad_character = ' ';
        par.num2=32767;
    par.num1=0;
    6484: e58d500c  str r5, [sp, #12]
                par.left_flag = 1;
                Check = 0;
                break;

            case '.':
                dot_flag = 1;
    6488: e3a07001  mov r7, #1
    par.left_flag = 0;
    par.do_padding = 0;
        par.pad_character = ' ';
        par.num2=32767;
    par.num1=0;
    par.len=0;
    648c: e58d5008  str r5, [sp, #8]
        /* initialize all the flags for this format.   */
        dot_flag = 0;
    long_flag = 0;
    par.left_flag = 0;
    par.do_padding = 0;
        par.pad_character = ' ';
    6490: e5cd1014  strb  r1, [sp, #20]
        par.num2=32767;
    6494: e58d2010  str r2, [sp, #16]
    6498: ea00000e  b 64d8 <xil_printf+0xd8>
    else {
      ch = *ctrl;
    }

        if (isdigit((s32)ch) != 0) {
            if (dot_flag != 0) {
    649c: e3560000  cmp r6, #0
    64a0: 1a0000e8  bne 6848 <xil_printf+0x448>
                par.num2 = getnum(&ctrl);
      }
            else {
                if (ch == '0') {
    64a4: e3500030  cmp r0, #48 ; 0x30
                    par.pad_character = '0';
    64a8: 05cd0014  strbeq  r0, [sp, #20]
        }
        if(ctrl != NULL) {
      par.num1 = getnum(&ctrl);
    64ac: e28d0004  add r0, sp, #4
    64b0: ebffff55  bl  620c <getnum>
    64b4: e59d3004  ldr r3, [sp, #4]
        }
                par.do_padding = 1;
    64b8: e58d7018  str r7, [sp, #24]
            else {
                if (ch == '0') {
                    par.pad_character = '0';
        }
        if(ctrl != NULL) {
      par.num1 = getnum(&ctrl);
    64bc: e58d000c  str r0, [sp, #12]
        }
                par.do_padding = 1;
            }
            if(ctrl != NULL) {
    64c0: e3530000  cmp r3, #0
    64c4: 0a000071  beq 6690 <xil_printf+0x290>
      ctrl -= 1;
    64c8: e2433001  sub r3, r3, #1
    64cc: e58d3004  str r3, [sp, #4]
        par.num2=32767;
    par.num1=0;
    par.len=0;

 try_next:
    if(ctrl != NULL) {
    64d0: e3530000  cmp r3, #0
    64d4: 0a00006d  beq 6690 <xil_printf+0x290>
      ctrl += 1;
    64d8: e2832001  add r2, r3, #1
    64dc: e58d2004  str r2, [sp, #4]
    }
    if(ctrl != NULL) {
    64e0: e3520000  cmp r2, #0
    64e4: 0a000069  beq 6690 <xil_printf+0x290>
      ch = *ctrl;
    64e8: e5d30001  ldrb  r0, [r3, #1]
    }
    else {
      ch = *ctrl;
    }

        if (isdigit((s32)ch) != 0) {
    64ec: e5943000  ldr r3, [r4]
    64f0: e0833000  add r3, r3, r0
    64f4: e5d33001  ldrb  r3, [r3, #1]
    64f8: e3130004  tst r3, #4
    64fc: 1affffe6  bne 649c <xil_printf+0x9c>
      ctrl -= 1;
      }
            goto try_next;
        }

        switch (tolower((s32)ch)) {
    6500: e2033003  and r3, r3, #3
    6504: e3530001  cmp r3, #1
    6508: 02803020  addeq r3, r0, #32
    650c: 11a03000  movne r3, r0
    6510: e2433025  sub r3, r3, #37 ; 0x25
    6514: e3530053  cmp r3, #83 ; 0x53
    6518: 979ff103  ldrls pc, [pc, r3, lsl #2]
    651c: ea000069  b 66c8 <xil_printf+0x2c8>
    6520: 00006750  .word 0x00006750
    6524: 000066c8  .word 0x000066c8
    6528: 000066c8  .word 0x000066c8
    652c: 000066c8  .word 0x000066c8
    6530: 000066c8  .word 0x000066c8
    6534: 000066c8  .word 0x000066c8
    6538: 000066c8  .word 0x000066c8
    653c: 000066c8  .word 0x000066c8
    6540: 00006760  .word 0x00006760
    6544: 0000669c  .word 0x0000669c
    6548: 000066c8  .word 0x000066c8
    654c: 000066c8  .word 0x000066c8
    6550: 000066c8  .word 0x000066c8
    6554: 000066c8  .word 0x000066c8
    6558: 000066c8  .word 0x000066c8
    655c: 000066c8  .word 0x000066c8
    6560: 000066c8  .word 0x000066c8
    6564: 000066c8  .word 0x000066c8
    6568: 000066c8  .word 0x000066c8
    656c: 000066c8  .word 0x000066c8
    6570: 000066c8  .word 0x000066c8
    6574: 000066c8  .word 0x000066c8
    6578: 000066c8  .word 0x000066c8
    657c: 000066c8  .word 0x000066c8
    6580: 000066c8  .word 0x000066c8
    6584: 000066c8  .word 0x000066c8
    6588: 000066c8  .word 0x000066c8
    658c: 000066c8  .word 0x000066c8
    6590: 000066c8  .word 0x000066c8
    6594: 000066c8  .word 0x000066c8
    6598: 000066c8  .word 0x000066c8
    659c: 000066c8  .word 0x000066c8
    65a0: 000066c8  .word 0x000066c8
    65a4: 000066c8  .word 0x000066c8
    65a8: 000066c8  .word 0x000066c8
    65ac: 000066c8  .word 0x000066c8
    65b0: 000066c8  .word 0x000066c8
    65b4: 000066c8  .word 0x000066c8
    65b8: 000066c8  .word 0x000066c8
    65bc: 000066c8  .word 0x000066c8
    65c0: 000066c8  .word 0x000066c8
    65c4: 000066c8  .word 0x000066c8
    65c8: 000066c8  .word 0x000066c8
    65cc: 000066c8  .word 0x000066c8
    65d0: 000066c8  .word 0x000066c8
    65d4: 000066c8  .word 0x000066c8
    65d8: 000066c8  .word 0x000066c8
    65dc: 000066c8  .word 0x000066c8
    65e0: 000066c8  .word 0x000066c8
    65e4: 000066c8  .word 0x000066c8
    65e8: 000066c8  .word 0x000066c8
    65ec: 000066c8  .word 0x000066c8
    65f0: 000066c8  .word 0x000066c8
    65f4: 000066c8  .word 0x000066c8
    65f8: 000066c8  .word 0x000066c8
    65fc: 000066d4  .word 0x000066d4
    6600: 000066c8  .word 0x000066c8
    6604: 000066c8  .word 0x000066c8
    6608: 000066c8  .word 0x000066c8
    660c: 000066c8  .word 0x000066c8
    6610: 000066c8  .word 0x000066c8
    6614: 000066c8  .word 0x000066c8
    6618: 000066a8  .word 0x000066a8
    661c: 0000672c  .word 0x0000672c
    6620: 000066c8  .word 0x000066c8
    6624: 000066c8  .word 0x000066c8
    6628: 000066c8  .word 0x000066c8
    662c: 000066c8  .word 0x000066c8
    6630: 000066c8  .word 0x000066c8
    6634: 000066c8  .word 0x000066c8
    6638: 000066c8  .word 0x000066c8
    663c: 00006684  .word 0x00006684
    6640: 000066c8  .word 0x000066c8
    6644: 000066c8  .word 0x000066c8
    6648: 000066c8  .word 0x000066c8
    664c: 000066c8  .word 0x000066c8
    6650: 000066c8  .word 0x000066c8
    6654: 000066c8  .word 0x000066c8
    6658: 00006778  .word 0x00006778
    665c: 000066c8  .word 0x000066c8
    6660: 000066c8  .word 0x000066c8
    6664: 000066c8  .word 0x000066c8
    6668: 000066c8  .word 0x000066c8
    666c: 0000676c  .word 0x0000676c
                        outbyte( ((char8)0x08));
#endif
                        break;
                    case 'r':
#ifdef STDOUT_BASEADDRESS
                        outbyte( ((char8)0x0D));
    6670: e3a0000d  mov r0, #13
    6674: eb000a81  bl  9080 <outbyte>
#ifdef STDOUT_BASEADDRESS
                        outbyte( *ctrl);
#endif
                        break;
                }
                ctrl += 1;
    6678: e59d2004  ldr r2, [sp, #4]
    667c: e2822001  add r2, r2, #1
    6680: e58d2004  str r2, [sp, #4]
/*                                                   */

/* void esp_printf( const func_ptr f_ptr,
   const charptr ctrl1, ...) */
void xil_printf( const char8 *ctrl1, ...)
{
    6684: e1a03002  mov r3, r2
        par.num2=32767;
    par.num1=0;
    par.len=0;

 try_next:
    if(ctrl != NULL) {
    6688: e3530000  cmp r3, #0
    668c: 1affff91  bne 64d8 <xil_printf+0xd8>
    }
    if(ctrl != NULL) {
      ch = *ctrl;
    }
    else {
      ch = *ctrl;
    6690: e3a03000  mov r3, #0
    6694: e5d33000  ldrb  r3, [r3]
    6698: e7f000f0  udf #0
                par.left_flag = 1;
                Check = 0;
                break;

            case '.':
                dot_flag = 1;
    669c: e3a06001  mov r6, #1
/*                                                   */

/* void esp_printf( const func_ptr f_ptr,
   const charptr ctrl1, ...) */
void xil_printf( const char8 *ctrl1, ...)
{
    66a0: e1a03002  mov r3, r2
    66a4: eafffff7  b 6688 <xil_printf+0x288>
                Check = 1;
                break;

            case 'c':
#ifdef STDOUT_BASEADDRESS
                outbyte( va_arg( argp, s32));
    66a8: e59d3000  ldr r3, [sp]
    66ac: e2832004  add r2, r3, #4
    66b0: e58d2000  str r2, [sp]
    66b4: e5d30000  ldrb  r0, [r3]
    66b8: eb000a70  bl  9080 <outbyte>
    66bc: e59d2004  ldr r2, [sp, #4]
            default:
    Check = 1;
    break;
        }
        if(Check == 1) {
      if(ctrl != NULL) {
    66c0: e3520000  cmp r2, #0
    66c4: 0affff64  beq 645c <xil_printf+0x5c>
        ctrl += 1;
    66c8: e2822001  add r2, r2, #1
    66cc: e58d2004  str r2, [sp, #4]
    66d0: eaffff54  b 6428 <xil_printf+0x28>
#endif
                Check = 1;
                break;

            case '\\':
                switch (*ctrl) {
    66d4: e2403061  sub r3, r0, #97 ; 0x61
    66d8: e3530011  cmp r3, #17
    66dc: 979ff103  ldrls pc, [pc, r3, lsl #2]
    66e0: ea000056  b 6840 <xil_printf+0x440>
    66e4: 00006834  .word 0x00006834
    66e8: 00006840  .word 0x00006840
    66ec: 00006840  .word 0x00006840
    66f0: 00006840  .word 0x00006840
    66f4: 00006840  .word 0x00006840
    66f8: 00006840  .word 0x00006840
    66fc: 00006840  .word 0x00006840
    6700: 00006828  .word 0x00006828
    6704: 00006840  .word 0x00006840
    6708: 00006840  .word 0x00006840
    670c: 00006840  .word 0x00006840
    6710: 00006840  .word 0x00006840
    6714: 00006840  .word 0x00006840
    6718: 00006814  .word 0x00006814
    671c: 00006840  .word 0x00006840
    6720: 00006840  .word 0x00006840
    6724: 00006840  .word 0x00006840
    6728: 00006670  .word 0x00006670
                Check = 0;
                break;

            case 'd':
                if ((long_flag != 0) || (ch == 'D')) {
                    outnum( va_arg(argp, s32), 10L, &par);
    672c: e59d3000  ldr r3, [sp]
    6730: e3a0100a  mov r1, #10
                    outnum( va_arg(argp, s32), 10L, &par);
                }
        Check = 1;
                break;
            case 'x':
                outnum((s32)va_arg(argp, s32), 16L, &par);
    6734: e2830004  add r0, r3, #4
    6738: e28d2008  add r2, sp, #8
    673c: e58d0000  str r0, [sp]
    6740: e5930000  ldr r0, [r3]
    6744: ebfffeda  bl  62b4 <outnum>
    6748: e59d2004  ldr r2, [sp, #4]
                Check = 1;
                break;
    674c: eaffffdb  b 66c0 <xil_printf+0x2c0>
        }

        switch (tolower((s32)ch)) {
            case '%':
#ifdef STDOUT_BASEADDRESS
                outbyte( '%');
    6750: e3a00025  mov r0, #37 ; 0x25
    6754: eb000a49  bl  9080 <outbyte>
    6758: e59d2004  ldr r2, [sp, #4]
#endif
                Check = 1;
                break;
    675c: eaffffd7  b 66c0 <xil_printf+0x2c0>

            case '-':
                par.left_flag = 1;
    6760: e58d701c  str r7, [sp, #28]
/*                                                   */

/* void esp_printf( const func_ptr f_ptr,
   const charptr ctrl1, ...) */
void xil_printf( const char8 *ctrl1, ...)
{
    6764: e1a03002  mov r3, r2
    6768: eaffffc6  b 6688 <xil_printf+0x288>
                    outnum( va_arg(argp, s32), 10L, &par);
                }
        Check = 1;
                break;
            case 'x':
                outnum((s32)va_arg(argp, s32), 16L, &par);
    676c: e59d3000  ldr r3, [sp]
    6770: e3a01010  mov r1, #16
    6774: eaffffee  b 6734 <xil_printf+0x334>
                Check = 1;
                break;

            case 's':
                outs( va_arg( argp, char *), &par);
    6778: e59d3000  ldr r3, [sp]
    677c: e2832004  add r2, r3, #4
    6780: e58d2000  str r2, [sp]
    6784: e5936000  ldr r6, [r3]
static void outs(const charptr lp, struct params_s *par)
{
    charptr LocalPtr;
  LocalPtr = lp;
    /* pad on left if needed                         */
  if(LocalPtr != NULL) {
    6788: e3560000  cmp r6, #0
    678c: 0a000002  beq 679c <xil_printf+0x39c>
    par->len = (s32)strlen( LocalPtr);
    6790: e1a00006  mov r0, r6
    6794: fa000d99  blx 9e00 <strlen>
    6798: e58d0008  str r0, [sp, #8]
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    679c: e59d3018  ldr r3, [sp, #24]
    67a0: e59d201c  ldr r2, [sp, #28]
    67a4: e2933000  adds  r3, r3, #0
    67a8: 13a03001  movne r3, #1
    67ac: e3520000  cmp r2, #0
    67b0: 13a03000  movne r3, #0
    67b4: e3530000  cmp r3, #0
    67b8: 1a000027  bne 685c <xil_printf+0x45c>
    par->len = (s32)strlen( LocalPtr);
  }
    padding( !(par->left_flag), par);

    /* Move string to the buffer                     */
    while (((*LocalPtr) != (char8)0) && ((par->num2) != 0)) {
    67bc: e5d63000  ldrb  r3, [r6]
    67c0: e3530000  cmp r3, #0
    67c4: 1a000007  bne 67e8 <xil_printf+0x3e8>
    67c8: ea000009  b 67f4 <xil_printf+0x3f4>
    (par->num2)--;
    67cc: e2433001  sub r3, r3, #1
    67d0: e58d3010  str r3, [sp, #16]
#ifdef STDOUT_BASEADDRESS
        outbyte(*LocalPtr);
    67d4: e5d60000  ldrb  r0, [r6]
    67d8: eb000a28  bl  9080 <outbyte>
    par->len = (s32)strlen( LocalPtr);
  }
    padding( !(par->left_flag), par);

    /* Move string to the buffer                     */
    while (((*LocalPtr) != (char8)0) && ((par->num2) != 0)) {
    67dc: e5f63001  ldrb  r3, [r6, #1]!
    67e0: e3530000  cmp r3, #0
    67e4: 0a000002  beq 67f4 <xil_printf+0x3f4>
    67e8: e59d3010  ldr r3, [sp, #16]
    67ec: e3530000  cmp r3, #0
    67f0: 1afffff5  bne 67cc <xil_printf+0x3cc>
/*                                                   */
static void padding( const s32 l_flag, const struct params_s *par)
{
    s32 i;

    if ((par->do_padding != 0) && (l_flag != 0) && (par->len < par->num1)) {
    67f4: e59d2018  ldr r2, [sp, #24]
    67f8: e59d301c  ldr r3, [sp, #28]
    67fc: e3520000  cmp r2, #0
    6800: 13530000  cmpne r3, #0
    6804: 0affffcf  beq 6748 <xil_printf+0x348>
    6808: e28d0008  add r0, sp, #8
    680c: ebfffe9b  bl  6280 <padding.part.0>
    6810: eaffffcc  b 6748 <xil_printf+0x348>
                        outbyte( ((char8)0x0D));
#endif
                        break;
                    case 'n':
#ifdef STDOUT_BASEADDRESS
                        outbyte( ((char8)0x0D));
    6814: e3a0000d  mov r0, #13
    6818: eb000a18  bl  9080 <outbyte>
                        outbyte( ((char8)0x0A));
    681c: e3a0000a  mov r0, #10
    6820: eb000a16  bl  9080 <outbyte>
#endif
                        break;
    6824: eaffff93  b 6678 <xil_printf+0x278>
                        outbyte( ((char8)0x07));
#endif
                        break;
                    case 'h':
#ifdef STDOUT_BASEADDRESS
                        outbyte( ((char8)0x08));
    6828: e3a00008  mov r0, #8
    682c: eb000a13  bl  9080 <outbyte>
#endif
                        break;
    6830: eaffff90  b 6678 <xil_printf+0x278>

            case '\\':
                switch (*ctrl) {
                    case 'a':
#ifdef STDOUT_BASEADDRESS
                        outbyte( ((char8)0x07));
    6834: e3a00007  mov r0, #7
    6838: eb000a10  bl  9080 <outbyte>
#endif
                        break;
    683c: eaffff8d  b 6678 <xil_printf+0x278>
                        outbyte( ((char8)0x0A));
#endif
                        break;
                    default:
#ifdef STDOUT_BASEADDRESS
                        outbyte( *ctrl);
    6840: eb000a0e  bl  9080 <outbyte>
#endif
                        break;
    6844: eaffff8b  b 6678 <xil_printf+0x278>
      ch = *ctrl;
    }

        if (isdigit((s32)ch) != 0) {
            if (dot_flag != 0) {
                par.num2 = getnum(&ctrl);
    6848: e28d0004  add r0, sp, #4
    684c: ebfffe6e  bl  620c <getnum>
    6850: e59d3004  ldr r3, [sp, #4]
    6854: e58d0010  str r0, [sp, #16]
    6858: eaffff18  b 64c0 <xil_printf+0xc0>
    685c: e28d0008  add r0, sp, #8
    6860: ebfffe86  bl  6280 <padding.part.0>
    6864: eaffffd4  b 67bc <xil_printf+0x3bc>

00006868 <XTime_SetTime>:
* @note   In multiprocessor environment reference time will reset/lost for
*   all processors, when this function called by any one processor.
*
****************************************************************************/
void XTime_SetTime(XTime Xtime_Global)
{
    6868: e92d4070  push  {r4, r5, r6, lr}
  /* Disable Global Timer */
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_CONTROL_OFFSET, (u32)0x0);
    686c: e3a04f82  mov r4, #520  ; 0x208
    6870: e34f48f0  movt  r4, #63728  ; 0xf8f0
* @note   In multiprocessor environment reference time will reset/lost for
*   all processors, when this function called by any one processor.
*
****************************************************************************/
void XTime_SetTime(XTime Xtime_Global)
{
    6874: e1a06000  mov r6, r0
    6878: e1a05001  mov r5, r1
  /* Disable Global Timer */
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_CONTROL_OFFSET, (u32)0x0);
    687c: e1a00004  mov r0, r4
    6880: e3a01000  mov r1, #0
    6884: ebfffe49  bl  61b0 <Xil_Out32>

  /* Updating Global Timer Counter Register */
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_COUNTER_LOWER_OFFSET, (u32)Xtime_Global);
    6888: e3a00c02  mov r0, #512  ; 0x200
    688c: e1a01006  mov r1, r6
    6890: e34f08f0  movt  r0, #63728  ; 0xf8f0
    6894: ebfffe45  bl  61b0 <Xil_Out32>
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_COUNTER_UPPER_OFFSET,
    6898: e3a00f81  mov r0, #516  ; 0x204
    689c: e1a01005  mov r1, r5
    68a0: e34f08f0  movt  r0, #63728  ; 0xf8f0
    68a4: ebfffe41  bl  61b0 <Xil_Out32>
    (u32)((u32)(Xtime_Global>>32U)));

  /* Enable Global Timer */
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_CONTROL_OFFSET, (u32)0x1);
    68a8: e1a00004  mov r0, r4
    68ac: e3a01001  mov r1, #1
}
    68b0: e8bd4070  pop {r4, r5, r6, lr}
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_COUNTER_LOWER_OFFSET, (u32)Xtime_Global);
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_COUNTER_UPPER_OFFSET,
    (u32)((u32)(Xtime_Global>>32U)));

  /* Enable Global Timer */
  Xil_Out32((u32)GLOBAL_TMR_BASEADDR + (u32)GTIMER_CONTROL_OFFSET, (u32)0x1);
    68b4: eafffe3d  b 61b0 <Xil_Out32>

000068b8 <XTime_GetTime>:
*
* @note   None.
*
****************************************************************************/
void XTime_GetTime(XTime *Xtime_Global)
{
    68b8: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    68bc: e1a08000  mov r8, r0
  u32 high;

  /* Reading Global Timer Counter Register */
  do
  {
    high = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET);
    68c0: e3a00f81  mov r0, #516  ; 0x204
    68c4: e34f08f0  movt  r0, #63728  ; 0xf8f0
    68c8: ebfffe32  bl  6198 <Xil_In32>
    68cc: e1a04000  mov r4, r0
    low = Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_LOWER_OFFSET);
    68d0: e3a00c02  mov r0, #512  ; 0x200
    68d4: e34f08f0  movt  r0, #63728  ; 0xf8f0
    68d8: ebfffe2e  bl  6198 <Xil_In32>
    68dc: e1a05000  mov r5, r0
  } while(Xil_In32(GLOBAL_TMR_BASEADDR + GTIMER_COUNTER_UPPER_OFFSET) != high);
    68e0: e3a00f81  mov r0, #516  ; 0x204
    68e4: e34f08f0  movt  r0, #63728  ; 0xf8f0
    68e8: ebfffe2a  bl  6198 <Xil_In32>
    68ec: e1500004  cmp r0, r4
    68f0: 1afffff2  bne 68c0 <XTime_GetTime+0x8>

  *Xtime_Global = (((XTime) high) << 32U) | (XTime) low;
    68f4: e3a06000  mov r6, #0
    68f8: e1a07000  mov r7, r0
    68fc: e1866005  orr r6, r6, r5
    6900: e1c860f0  strd  r6, [r8]
    6904: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

00006908 <XDcfg_CfgInitialize>:
*     3. SoC debug fully enabled
*
******************************************************************************/
int XDcfg_CfgInitialize(XDcfg *InstancePtr,
       XDcfg_Config *ConfigPtr, u32 EffectiveAddress)
{
    6908: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  Xil_AssertNonvoid(InstancePtr != NULL);
    690c: e2506000  subs  r6, r0, #0
    6910: 0a00001a  beq 6980 <XDcfg_CfgInitialize+0x78>
    6914: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(ConfigPtr != NULL);
    6918: e3510000  cmp r1, #0
*
******************************************************************************/
int XDcfg_CfgInitialize(XDcfg *InstancePtr,
       XDcfg_Config *ConfigPtr, u32 EffectiveAddress)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    691c: e3405002  movt  r5, #2
    6920: e3a04000  mov r4, #0
    6924: e1a07001  mov r7, r1
    6928: e5854000  str r4, [r5]
  Xil_AssertNonvoid(ConfigPtr != NULL);
    692c: 0a00001d  beq 69a8 <XDcfg_CfgInitialize+0xa0>
   * If the device is started, disallow the initialize and return a
   * status indicating it is started. This allows the user to stop the
   * device and reinitialize, but prevents a user from inadvertently
   * initializing.
   */
  if (InstancePtr->IsStarted == XIL_COMPONENT_IS_STARTED) {
    6930: e596100c  ldr r1, [r6, #12]
    6934: e3023222  movw  r3, #8738 ; 0x2222
    6938: e3423222  movt  r3, #8738 ; 0x2222
    693c: e1510003  cmp r1, r3
    6940: 1a000001  bne 694c <XDcfg_CfgInitialize+0x44>
    return XST_DEVICE_IS_STARTED;
    6944: e3a00005  mov r0, #5
   * Indicate the instance is ready to use, successfully initialized.
   */
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

  return XST_SUCCESS;
}
    6948: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  }

  /*
   * Copy configuration into instance.
   */
  InstancePtr->Config.DeviceId = ConfigPtr->DeviceId;
    694c: e1d730b0  ldrh  r3, [r7]
  InstancePtr->Config.BaseAddr = EffectiveAddress;
  InstancePtr->IsStarted = 0;


  /* Unlock the Device Configuration Interface */
  XDcfg_Unlock(InstancePtr);
    6950: e30d1f0d  movw  r1, #57101  ; 0xdf0d
    6954: e2820034  add r0, r2, #52 ; 0x34

  /*
   * Save the base address pointer such that the registers of the block
   * can be accessed and indicate it has not been started yet.
   */
  InstancePtr->Config.BaseAddr = EffectiveAddress;
    6958: e5862004  str r2, [r6, #4]
  InstancePtr->IsStarted = 0;
    695c: e586400c  str r4, [r6, #12]


  /* Unlock the Device Configuration Interface */
  XDcfg_Unlock(InstancePtr);
    6960: e347157b  movt  r1, #30075  ; 0x757b
  }

  /*
   * Copy configuration into instance.
   */
  InstancePtr->Config.DeviceId = ConfigPtr->DeviceId;
    6964: e1c630b0  strh  r3, [r6]
  InstancePtr->Config.BaseAddr = EffectiveAddress;
  InstancePtr->IsStarted = 0;


  /* Unlock the Device Configuration Interface */
  XDcfg_Unlock(InstancePtr);
    6968: ebfffe10  bl  61b0 <Xil_Out32>
  /*
   * Indicate the instance is ready to use, successfully initialized.
   */
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

  return XST_SUCCESS;
    696c: e1a00004  mov r0, r4
  XDcfg_Unlock(InstancePtr);

  /*
   * Indicate the instance is ready to use, successfully initialized.
   */
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    6970: e3013111  movw  r3, #4369 ; 0x1111
    6974: e7df3813  bfi r3, r3, #16, #16
    6978: e5863008  str r3, [r6, #8]

  return XST_SUCCESS;
    697c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
*
******************************************************************************/
int XDcfg_CfgInitialize(XDcfg *InstancePtr,
       XDcfg_Config *ConfigPtr, u32 EffectiveAddress)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    6980: e30806fc  movw  r0, #34556  ; 0x86fc
    6984: e3a01087  mov r1, #135  ; 0x87
    6988: e3400001  movt  r0, #1
    698c: eb0009bf  bl  9090 <Xil_Assert>
    6990: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6994: e3403002  movt  r3, #2
    6998: e3a02001  mov r2, #1
    699c: e1a00006  mov r0, r6
    69a0: e5832000  str r2, [r3]
    69a4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  Xil_AssertNonvoid(ConfigPtr != NULL);
    69a8: e30806fc  movw  r0, #34556  ; 0x86fc
    69ac: e3a01088  mov r1, #136  ; 0x88
    69b0: e3400001  movt  r0, #1
    69b4: eb0009b5  bl  9090 <Xil_Assert>
    69b8: e3a03001  mov r3, #1
    69bc: e1a00007  mov r0, r7
    69c0: e5853000  str r3, [r5]
    69c4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

000069c8 <XDcfg_EnablePCAP>:
*   except for ICAP. The user needs to ensure that the FPGA is
*   programmed through either PCAP or ICAP.
*
*****************************************************************************/
void XDcfg_EnablePCAP(XDcfg *InstancePtr)
{
    69c8: e92d4038  push  {r3, r4, r5, lr}
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    69cc: e2505000  subs  r5, r0, #0
    69d0: 0a000015  beq 6a2c <XDcfg_EnablePCAP+0x64>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    69d4: e5952008  ldr r2, [r5, #8]
    69d8: e3013111  movw  r3, #4369 ; 0x1111
    69dc: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    69e0: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    69e4: e1520003  cmp r2, r3
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    69e8: e3404002  movt  r4, #2
    69ec: e3a03000  mov r3, #0
    69f0: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    69f4: 0a000006  beq 6a14 <XDcfg_EnablePCAP+0x4c>
    69f8: e30806fc  movw  r0, #34556  ; 0x86fc
    69fc: e3a010c3  mov r1, #195  ; 0xc3
    6a00: e3400001  movt  r0, #1
    6a04: eb0009a1  bl  9090 <Xil_Assert>
    6a08: e3a03001  mov r3, #1
    6a0c: e5843000  str r3, [r4]
    6a10: e8bd8038  pop {r3, r4, r5, pc}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    6a14: e5950004  ldr r0, [r5, #4]
    6a18: ebfffdde  bl  6198 <Xil_In32>
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6a1c: e3801301  orr r1, r0, #67108864 ; 0x4000000
    6a20: e5950004  ldr r0, [r5, #4]
      (CtrlReg | XDCFG_CTRL_PCAP_MODE_MASK));

}
    6a24: e8bd4038  pop {r3, r4, r5, lr}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6a28: eafffde0  b 61b0 <Xil_Out32>
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6a2c: e30806fc  movw  r0, #34556  ; 0x86fc
    6a30: e3a010c2  mov r1, #194  ; 0xc2
    6a34: e3400001  movt  r0, #1
    6a38: eb000994  bl  9090 <Xil_Assert>
    6a3c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6a40: e3403002  movt  r3, #2
    6a44: e3a02001  mov r2, #1
    6a48: e5832000  str r2, [r3]
    6a4c: e8bd8038  pop {r3, r4, r5, pc}

00006a50 <XDcfg_DisablePCAP>:
*
* @note   None.
*
*****************************************************************************/
void XDcfg_DisablePCAP(XDcfg *InstancePtr)
{
    6a50: e92d4038  push  {r3, r4, r5, lr}
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6a54: e2505000  subs  r5, r0, #0
    6a58: 0a000015  beq 6ab4 <XDcfg_DisablePCAP+0x64>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6a5c: e5952008  ldr r2, [r5, #8]
    6a60: e3013111  movw  r3, #4369 ; 0x1111
    6a64: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6a68: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6a6c: e1520003  cmp r2, r3
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6a70: e3404002  movt  r4, #2
    6a74: e3a03000  mov r3, #0
    6a78: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6a7c: 0a000006  beq 6a9c <XDcfg_DisablePCAP+0x4c>
    6a80: e30806fc  movw  r0, #34556  ; 0x86fc
    6a84: e3a010e2  mov r1, #226  ; 0xe2
    6a88: e3400001  movt  r0, #1
    6a8c: eb00097f  bl  9090 <Xil_Assert>
    6a90: e3a03001  mov r3, #1
    6a94: e5843000  str r3, [r4]
    6a98: e8bd8038  pop {r3, r4, r5, pc}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    6a9c: e5950004  ldr r0, [r5, #4]
    6aa0: ebfffdbc  bl  6198 <Xil_In32>
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6aa4: e3c01301  bic r1, r0, #67108864 ; 0x4000000
    6aa8: e5950004  ldr r0, [r5, #4]
      (CtrlReg & ( ~XDCFG_CTRL_PCAP_MODE_MASK)));

}
    6aac: e8bd4038  pop {r3, r4, r5, lr}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6ab0: eafffdbe  b 61b0 <Xil_Out32>
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ab4: e30806fc  movw  r0, #34556  ; 0x86fc
    6ab8: e3a010e1  mov r1, #225  ; 0xe1
    6abc: e3400001  movt  r0, #1
    6ac0: eb000972  bl  9090 <Xil_Assert>
    6ac4: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6ac8: e3403002  movt  r3, #2
    6acc: e3a02001  mov r2, #1
    6ad0: e5832000  str r2, [r3]
    6ad4: e8bd8038  pop {r3, r4, r5, pc}

00006ad8 <XDcfg_SetControlRegister>:
*
* @note   None.
*
*****************************************************************************/
void XDcfg_SetControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    6ad8: e92d4030  push  {r4, r5, lr}
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6adc: e2505000  subs  r5, r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_SetControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    6ae0: e24dd00c  sub sp, sp, #12
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ae4: 0a000019  beq 6b50 <XDcfg_SetControlRegister+0x78>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6ae8: e5952008  ldr r2, [r5, #8]
    6aec: e3013111  movw  r3, #4369 ; 0x1111
    6af0: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6af4: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6af8: e1520003  cmp r2, r3
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6afc: e3404002  movt  r4, #2
    6b00: e3a03000  mov r3, #0
    6b04: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6b08: 0a000007  beq 6b2c <XDcfg_SetControlRegister+0x54>
    6b0c: e30806fc  movw  r0, #34556  ; 0x86fc
    6b10: e3001102  movw  r1, #258  ; 0x102
    6b14: e3400001  movt  r0, #1
    6b18: eb00095c  bl  9090 <Xil_Assert>
    6b1c: e3a03001  mov r3, #1
    6b20: e5843000  str r3, [r4]
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
      (CtrlReg | Mask));

}
    6b24: e28dd00c  add sp, sp, #12
    6b28: e8bd8030  pop {r4, r5, pc}
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    6b2c: e5950004  ldr r0, [r5, #4]
    6b30: e58d1004  str r1, [sp, #4]
    6b34: ebfffd97  bl  6198 <Xil_In32>
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6b38: e59d1004  ldr r1, [sp, #4]
    6b3c: e1801001  orr r1, r0, r1
    6b40: e5950004  ldr r0, [r5, #4]
      (CtrlReg | Mask));

}
    6b44: e28dd00c  add sp, sp, #12
    6b48: e8bd4030  pop {r4, r5, lr}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6b4c: eafffd97  b 61b0 <Xil_Out32>
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6b50: e30806fc  movw  r0, #34556  ; 0x86fc
    6b54: e3001101  movw  r1, #257  ; 0x101
    6b58: e3400001  movt  r0, #1
    6b5c: eb00094b  bl  9090 <Xil_Assert>
    6b60: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6b64: e3403002  movt  r3, #2
    6b68: e3a02001  mov r2, #1
    6b6c: e5832000  str r2, [r3]
    6b70: eaffffeb  b 6b24 <XDcfg_SetControlRegister+0x4c>

00006b74 <XDcfg_ClearControlRegister>:
*
* @note   None.
*
*****************************************************************************/
void XDcfg_ClearControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    6b74: e92d4030  push  {r4, r5, lr}
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6b78: e2505000  subs  r5, r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_ClearControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    6b7c: e24dd00c  sub sp, sp, #12
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6b80: 0a000019  beq 6bec <XDcfg_ClearControlRegister+0x78>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6b84: e5952008  ldr r2, [r5, #8]
    6b88: e3013111  movw  r3, #4369 ; 0x1111
    6b8c: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6b90: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6b94: e1520003  cmp r2, r3
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6b98: e3404002  movt  r4, #2
    6b9c: e3a03000  mov r3, #0
    6ba0: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6ba4: 0a000007  beq 6bc8 <XDcfg_ClearControlRegister+0x54>
    6ba8: e30806fc  movw  r0, #34556  ; 0x86fc
    6bac: e3001121  movw  r1, #289  ; 0x121
    6bb0: e3400001  movt  r0, #1
    6bb4: eb000935  bl  9090 <Xil_Assert>
    6bb8: e3a03001  mov r3, #1
    6bbc: e5843000  str r3, [r4]
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
      (CtrlReg & ~Mask));

}
    6bc0: e28dd00c  add sp, sp, #12
    6bc4: e8bd8030  pop {r4, r5, pc}
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    6bc8: e5950004  ldr r0, [r5, #4]
    6bcc: e58d1004  str r1, [sp, #4]
    6bd0: ebfffd70  bl  6198 <Xil_In32>
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6bd4: e59d1004  ldr r1, [sp, #4]
    6bd8: e1c01001  bic r1, r0, r1
    6bdc: e5950004  ldr r0, [r5, #4]
      (CtrlReg & ~Mask));

}
    6be0: e28dd00c  add sp, sp, #12
    6be4: e8bd4030  pop {r4, r5, lr}


  CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_CTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET,
    6be8: eafffd70  b 61b0 <Xil_Out32>
{
  u32 CtrlReg;
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6bec: e30806fc  movw  r0, #34556  ; 0x86fc
    6bf0: e3a01e12  mov r1, #288  ; 0x120
    6bf4: e3400001  movt  r0, #1
    6bf8: eb000924  bl  9090 <Xil_Assert>
    6bfc: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6c00: e3403002  movt  r3, #2
    6c04: e3a02001  mov r2, #1
    6c08: e5832000  str r2, [r3]
    6c0c: eaffffeb  b 6bc0 <XDcfg_ClearControlRegister+0x4c>

00006c10 <XDcfg_GetControlRegister>:
u32 XDcfg_GetControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6c10: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_GetControlRegister(XDcfg *InstancePtr)
{
    6c14: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6c18: 0a000013  beq 6c6c <XDcfg_GetControlRegister+0x5c>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6c1c: e5902008  ldr r2, [r0, #8]
    6c20: e3013111  movw  r3, #4369 ; 0x1111
    6c24: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6c28: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6c2c: e1520003  cmp r2, r3
u32 XDcfg_GetControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6c30: e3404002  movt  r4, #2
    6c34: e3a03000  mov r3, #0
    6c38: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6c3c: 0a000007  beq 6c60 <XDcfg_GetControlRegister+0x50>
    6c40: e30806fc  movw  r0, #34556  ; 0x86fc
    6c44: e3001141  movw  r1, #321  ; 0x141
    6c48: e3400001  movt  r0, #1
    6c4c: eb00090f  bl  9090 <Xil_Assert>
    6c50: e3a03001  mov r3, #1
    6c54: e5843000  str r3, [r4]

  /*
   * Read the Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET);
}
    6c58: e3a00000  mov r0, #0
    6c5c: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET);
    6c60: e5900004  ldr r0, [r0, #4]
}
    6c64: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CTRL_OFFSET);
    6c68: eafffd4a  b 6198 <Xil_In32>
u32 XDcfg_GetControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6c6c: e30806fc  movw  r0, #34556  ; 0x86fc
    6c70: e3a01d05  mov r1, #320  ; 0x140
    6c74: e3400001  movt  r0, #1
    6c78: eb000904  bl  9090 <Xil_Assert>
    6c7c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6c80: e3403002  movt  r3, #2
    6c84: e3a02001  mov r2, #1
    6c88: e5832000  str r2, [r3]
    6c8c: eafffff1  b 6c58 <XDcfg_GetControlRegister+0x48>

00006c90 <XDcfg_SetLockRegister>:
void XDcfg_SetLockRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6c90: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_SetLockRegister(XDcfg *InstancePtr, u32 Data)
{
    6c94: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6c98: 0a000013  beq 6cec <XDcfg_SetLockRegister+0x5c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6c9c: e5902008  ldr r2, [r0, #8]
    6ca0: e3013111  movw  r3, #4369 ; 0x1111
    6ca4: e3413111  movt  r3, #4369 ; 0x1111
void XDcfg_SetLockRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ca8: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6cac: e1520003  cmp r2, r3
void XDcfg_SetLockRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6cb0: e3404002  movt  r4, #2
    6cb4: e3a03000  mov r3, #0
    6cb8: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6cbc: 0a000006  beq 6cdc <XDcfg_SetLockRegister+0x4c>
    6cc0: e30806fc  movw  r0, #34556  ; 0x86fc
    6cc4: e300115d  movw  r1, #349  ; 0x15d
    6cc8: e3400001  movt  r0, #1
    6ccc: eb0008ef  bl  9090 <Xil_Assert>
    6cd0: e3a03001  mov r3, #1
    6cd4: e5843000  str r3, [r4]
    6cd8: e8bd8010  pop {r4, pc}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_LOCK_OFFSET, Data);
    6cdc: e5900004  ldr r0, [r0, #4]

}
    6ce0: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_LOCK_OFFSET, Data);
    6ce4: e2800004  add r0, r0, #4
    6ce8: eafffd30  b 61b0 <Xil_Out32>
void XDcfg_SetLockRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6cec: e30806fc  movw  r0, #34556  ; 0x86fc
    6cf0: e3a01f57  mov r1, #348  ; 0x15c
    6cf4: e3400001  movt  r0, #1
    6cf8: eb0008e4  bl  9090 <Xil_Assert>
    6cfc: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6d00: e3403002  movt  r3, #2
    6d04: e3a02001  mov r2, #1
    6d08: e5832000  str r2, [r3]
    6d0c: e8bd8010  pop {r4, pc}

00006d10 <XDcfg_GetLockRegister>:
u32 XDcfg_GetLockRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6d10: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_GetLockRegister(XDcfg *InstancePtr)
{
    6d14: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6d18: 0a000014  beq 6d70 <XDcfg_GetLockRegister+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6d1c: e5902008  ldr r2, [r0, #8]
    6d20: e3013111  movw  r3, #4369 ; 0x1111
    6d24: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetLockRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6d28: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6d2c: e1520003  cmp r2, r3
u32 XDcfg_GetLockRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6d30: e3404002  movt  r4, #2
    6d34: e3a03000  mov r3, #0
    6d38: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6d3c: 0a000007  beq 6d60 <XDcfg_GetLockRegister+0x50>
    6d40: e30806fc  movw  r0, #34556  ; 0x86fc
    6d44: e3a01f5e  mov r1, #376  ; 0x178
    6d48: e3400001  movt  r0, #1
    6d4c: eb0008cf  bl  9090 <Xil_Assert>
    6d50: e3a03001  mov r3, #1
    6d54: e5843000  str r3, [r4]

  /*
   * Read the Lock Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_LOCK_OFFSET);
}
    6d58: e3a00000  mov r0, #0
    6d5c: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Lock Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_LOCK_OFFSET);
    6d60: e5900004  ldr r0, [r0, #4]
}
    6d64: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Lock Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_LOCK_OFFSET);
    6d68: e2800004  add r0, r0, #4
    6d6c: eafffd09  b 6198 <Xil_In32>
u32 XDcfg_GetLockRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6d70: e30806fc  movw  r0, #34556  ; 0x86fc
    6d74: e3001177  movw  r1, #375  ; 0x177
    6d78: e3400001  movt  r0, #1
    6d7c: eb0008c3  bl  9090 <Xil_Assert>
    6d80: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6d84: e3403002  movt  r3, #2
    6d88: e3a02001  mov r2, #1
    6d8c: e5832000  str r2, [r3]
    6d90: eafffff0  b 6d58 <XDcfg_GetLockRegister+0x48>

00006d94 <XDcfg_SetConfigRegister>:
void XDcfg_SetConfigRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6d94: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_SetConfigRegister(XDcfg *InstancePtr, u32 Data)
{
    6d98: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6d9c: 0a000013  beq 6df0 <XDcfg_SetConfigRegister+0x5c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6da0: e5902008  ldr r2, [r0, #8]
    6da4: e3013111  movw  r3, #4369 ; 0x1111
    6da8: e3413111  movt  r3, #4369 ; 0x1111
void XDcfg_SetConfigRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6dac: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6db0: e1520003  cmp r2, r3
void XDcfg_SetConfigRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6db4: e3404002  movt  r4, #2
    6db8: e3a03000  mov r3, #0
    6dbc: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6dc0: 0a000006  beq 6de0 <XDcfg_SetConfigRegister+0x4c>
    6dc4: e30806fc  movw  r0, #34556  ; 0x86fc
    6dc8: e3a01f65  mov r1, #404  ; 0x194
    6dcc: e3400001  movt  r0, #1
    6dd0: eb0008ae  bl  9090 <Xil_Assert>
    6dd4: e3a03001  mov r3, #1
    6dd8: e5843000  str r3, [r4]
    6ddc: e8bd8010  pop {r4, pc}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CFG_OFFSET, Data);
    6de0: e5900004  ldr r0, [r0, #4]

}
    6de4: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_CFG_OFFSET, Data);
    6de8: e2800008  add r0, r0, #8
    6dec: eafffcef  b 61b0 <Xil_Out32>
void XDcfg_SetConfigRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6df0: e30806fc  movw  r0, #34556  ; 0x86fc
    6df4: e3001193  movw  r1, #403  ; 0x193
    6df8: e3400001  movt  r0, #1
    6dfc: eb0008a3  bl  9090 <Xil_Assert>
    6e00: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6e04: e3403002  movt  r3, #2
    6e08: e3a02001  mov r2, #1
    6e0c: e5832000  str r2, [r3]
    6e10: e8bd8010  pop {r4, pc}

00006e14 <XDcfg_GetConfigRegister>:
u32 XDcfg_GetConfigRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6e14: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_GetConfigRegister(XDcfg *InstancePtr)
{
    6e18: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6e1c: 0a000014  beq 6e74 <XDcfg_GetConfigRegister+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6e20: e5902008  ldr r2, [r0, #8]
    6e24: e3013111  movw  r3, #4369 ; 0x1111
    6e28: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetConfigRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6e2c: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6e30: e1520003  cmp r2, r3
u32 XDcfg_GetConfigRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6e34: e3404002  movt  r4, #2
    6e38: e3a03000  mov r3, #0
    6e3c: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6e40: 0a000007  beq 6e64 <XDcfg_GetConfigRegister+0x50>
    6e44: e30806fc  movw  r0, #34556  ; 0x86fc
    6e48: e3a01e1b  mov r1, #432  ; 0x1b0
    6e4c: e3400001  movt  r0, #1
    6e50: eb00088e  bl  9090 <Xil_Assert>
    6e54: e3a03001  mov r3, #1
    6e58: e5843000  str r3, [r4]

  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CFG_OFFSET);

}
    6e5c: e3a00000  mov r0, #0
    6e60: e8bd8010  pop {r4, pc}
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CFG_OFFSET);
    6e64: e5900004  ldr r0, [r0, #4]

}
    6e68: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_CFG_OFFSET);
    6e6c: e2800008  add r0, r0, #8
    6e70: eafffcc8  b 6198 <Xil_In32>
u32 XDcfg_GetConfigRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6e74: e30806fc  movw  r0, #34556  ; 0x86fc
    6e78: e30011af  movw  r1, #431  ; 0x1af
    6e7c: e3400001  movt  r0, #1
    6e80: eb000882  bl  9090 <Xil_Assert>
    6e84: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6e88: e3403002  movt  r3, #2
    6e8c: e3a02001  mov r2, #1
    6e90: e5832000  str r2, [r3]
    6e94: eafffff0  b 6e5c <XDcfg_GetConfigRegister+0x48>

00006e98 <XDcfg_SetStatusRegister>:
void XDcfg_SetStatusRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6e98: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_SetStatusRegister(XDcfg *InstancePtr, u32 Data)
{
    6e9c: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ea0: 0a000013  beq 6ef4 <XDcfg_SetStatusRegister+0x5c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6ea4: e5902008  ldr r2, [r0, #8]
    6ea8: e3013111  movw  r3, #4369 ; 0x1111
    6eac: e3413111  movt  r3, #4369 ; 0x1111
void XDcfg_SetStatusRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6eb0: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6eb4: e1520003  cmp r2, r3
void XDcfg_SetStatusRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6eb8: e3404002  movt  r4, #2
    6ebc: e3a03000  mov r3, #0
    6ec0: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6ec4: 0a000006  beq 6ee4 <XDcfg_SetStatusRegister+0x4c>
    6ec8: e30806fc  movw  r0, #34556  ; 0x86fc
    6ecc: e30011c9  movw  r1, #457  ; 0x1c9
    6ed0: e3400001  movt  r0, #1
    6ed4: eb00086d  bl  9090 <Xil_Assert>
    6ed8: e3a03001  mov r3, #1
    6edc: e5843000  str r3, [r4]
    6ee0: e8bd8010  pop {r4, pc}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET, Data);
    6ee4: e5900004  ldr r0, [r0, #4]

}
    6ee8: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET, Data);
    6eec: e2800014  add r0, r0, #20
    6ef0: eafffcae  b 61b0 <Xil_Out32>
void XDcfg_SetStatusRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ef4: e30806fc  movw  r0, #34556  ; 0x86fc
    6ef8: e3a01f72  mov r1, #456  ; 0x1c8
    6efc: e3400001  movt  r0, #1
    6f00: eb000862  bl  9090 <Xil_Assert>
    6f04: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6f08: e3403002  movt  r3, #2
    6f0c: e3a02001  mov r2, #1
    6f10: e5832000  str r2, [r3]
    6f14: e8bd8010  pop {r4, pc}

00006f18 <XDcfg_GetStatusRegister>:
u32 XDcfg_GetStatusRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6f18: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_GetStatusRegister(XDcfg *InstancePtr)
{
    6f1c: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6f20: 0a000014  beq 6f78 <XDcfg_GetStatusRegister+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6f24: e5902008  ldr r2, [r0, #8]
    6f28: e3013111  movw  r3, #4369 ; 0x1111
    6f2c: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetStatusRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6f30: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6f34: e1520003  cmp r2, r3
u32 XDcfg_GetStatusRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6f38: e3404002  movt  r4, #2
    6f3c: e3a03000  mov r3, #0
    6f40: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6f44: 0a000007  beq 6f68 <XDcfg_GetStatusRegister+0x50>
    6f48: e30806fc  movw  r0, #34556  ; 0x86fc
    6f4c: e3a01f79  mov r1, #484  ; 0x1e4
    6f50: e3400001  movt  r0, #1
    6f54: eb00084d  bl  9090 <Xil_Assert>
    6f58: e3a03001  mov r3, #1
    6f5c: e5843000  str r3, [r4]

  /*
   * Read the Status Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET);
}
    6f60: e3a00000  mov r0, #0
    6f64: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Status Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET);
    6f68: e5900004  ldr r0, [r0, #4]
}
    6f6c: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Status Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET);
    6f70: e2800014  add r0, r0, #20
    6f74: eafffc87  b 6198 <Xil_In32>
u32 XDcfg_GetStatusRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    6f78: e30806fc  movw  r0, #34556  ; 0x86fc
    6f7c: e30011e3  movw  r1, #483  ; 0x1e3
    6f80: e3400001  movt  r0, #1
    6f84: eb000841  bl  9090 <Xil_Assert>
    6f88: e3023ae8  movw  r3, #10984  ; 0x2ae8
    6f8c: e3403002  movt  r3, #2
    6f90: e3a02001  mov r2, #1
    6f94: e5832000  str r2, [r3]
    6f98: eafffff0  b 6f60 <XDcfg_GetStatusRegister+0x48>

00006f9c <XDcfg_SetRomShadowRegister>:
void XDcfg_SetRomShadowRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6f9c: e3500000  cmp r0, #0
* @note   This register is can only be written and is used to control the
*   RAM shadow of 32 bit 4K page ROM pages in user mode
*
*****************************************************************************/
void XDcfg_SetRomShadowRegister(XDcfg *InstancePtr, u32 Data)
{
    6fa0: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6fa4: 0a000013  beq 6ff8 <XDcfg_SetRomShadowRegister+0x5c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6fa8: e5902008  ldr r2, [r0, #8]
    6fac: e3013111  movw  r3, #4369 ; 0x1111
    6fb0: e3413111  movt  r3, #4369 ; 0x1111
void XDcfg_SetRomShadowRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6fb4: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6fb8: e1520003  cmp r2, r3
void XDcfg_SetRomShadowRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6fbc: e3404002  movt  r4, #2
    6fc0: e3a03000  mov r3, #0
    6fc4: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    6fc8: 0a000006  beq 6fe8 <XDcfg_SetRomShadowRegister+0x4c>
    6fcc: e30806fc  movw  r0, #34556  ; 0x86fc
    6fd0: e3a01c02  mov r1, #512  ; 0x200
    6fd4: e3400001  movt  r0, #1
    6fd8: eb00082c  bl  9090 <Xil_Assert>
    6fdc: e3a03001  mov r3, #1
    6fe0: e5843000  str r3, [r4]
    6fe4: e8bd8010  pop {r4, pc}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_ROM_SHADOW_OFFSET,
    6fe8: e5900004  ldr r0, [r0, #4]
        Data);

}
    6fec: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_ROM_SHADOW_OFFSET,
    6ff0: e2800028  add r0, r0, #40 ; 0x28
    6ff4: eafffc6d  b 61b0 <Xil_Out32>
void XDcfg_SetRomShadowRegister(XDcfg *InstancePtr, u32 Data)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    6ff8: e30806fc  movw  r0, #34556  ; 0x86fc
    6ffc: e30011ff  movw  r1, #511  ; 0x1ff
    7000: e3400001  movt  r0, #1
    7004: eb000821  bl  9090 <Xil_Assert>
    7008: e3023ae8  movw  r3, #10984  ; 0x2ae8
    700c: e3403002  movt  r3, #2
    7010: e3a02001  mov r2, #1
    7014: e5832000  str r2, [r3]
    7018: e8bd8010  pop {r4, pc}

0000701c <XDcfg_GetSoftwareIdRegister>:
u32 XDcfg_GetSoftwareIdRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    701c: e3500000  cmp r0, #0
* @note   This register is locked for write once the system enters
*   usermode. Hence API for reading the register only is provided.
*
*****************************************************************************/
u32 XDcfg_GetSoftwareIdRegister(XDcfg *InstancePtr)
{
    7020: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7024: 0a000014  beq 707c <XDcfg_GetSoftwareIdRegister+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7028: e5902008  ldr r2, [r0, #8]
    702c: e3013111  movw  r3, #4369 ; 0x1111
    7030: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetSoftwareIdRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7034: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7038: e1520003  cmp r2, r3
u32 XDcfg_GetSoftwareIdRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    703c: e3404002  movt  r4, #2
    7040: e3a03000  mov r3, #0
    7044: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7048: 0a000007  beq 706c <XDcfg_GetSoftwareIdRegister+0x50>
    704c: e30806fc  movw  r0, #34556  ; 0x86fc
    7050: e300121a  movw  r1, #538  ; 0x21a
    7054: e3400001  movt  r0, #1
    7058: eb00080c  bl  9090 <Xil_Assert>
    705c: e3a03001  mov r3, #1
    7060: e5843000  str r3, [r4]

  /*
   * Read the Software ID Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_SW_ID_OFFSET);
}
    7064: e3a00000  mov r0, #0
    7068: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Software ID Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_SW_ID_OFFSET);
    706c: e5900004  ldr r0, [r0, #4]
}
    7070: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Software ID Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_SW_ID_OFFSET);
    7074: e2800030  add r0, r0, #48 ; 0x30
    7078: eafffc46  b 6198 <Xil_In32>
u32 XDcfg_GetSoftwareIdRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    707c: e30806fc  movw  r0, #34556  ; 0x86fc
    7080: e3001219  movw  r1, #537  ; 0x219
    7084: e3400001  movt  r0, #1
    7088: eb000800  bl  9090 <Xil_Assert>
    708c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7090: e3403002  movt  r3, #2
    7094: e3a02001  mov r2, #1
    7098: e5832000  str r2, [r3]
    709c: eafffff0  b 7064 <XDcfg_GetSoftwareIdRegister+0x48>

000070a0 <XDcfg_SetMiscControlRegister>:
*
* @note   None
*
*****************************************************************************/
void XDcfg_SetMiscControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    70a0: e92d4030  push  {r4, r5, lr}
  u32 RegData;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    70a4: e2505000  subs  r5, r0, #0
*
* @note   None
*
*****************************************************************************/
void XDcfg_SetMiscControlRegister(XDcfg *InstancePtr, u32 Mask)
{
    70a8: e24dd00c  sub sp, sp, #12
  u32 RegData;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    70ac: 0a00001b  beq 7120 <XDcfg_SetMiscControlRegister+0x80>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    70b0: e5952008  ldr r2, [r5, #8]
    70b4: e3013111  movw  r3, #4369 ; 0x1111
    70b8: e3413111  movt  r3, #4369 ; 0x1111
  u32 RegData;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    70bc: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    70c0: e1520003  cmp r2, r3
  u32 RegData;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    70c4: e3404002  movt  r4, #2
    70c8: e3a03000  mov r3, #0
    70cc: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    70d0: 0a000007  beq 70f4 <XDcfg_SetMiscControlRegister+0x54>
    70d4: e30806fc  movw  r0, #34556  ; 0x86fc
    70d8: e3a01f8e  mov r1, #568  ; 0x238
    70dc: e3400001  movt  r0, #1
    70e0: eb0007ea  bl  9090 <Xil_Assert>
    70e4: e3a03001  mov r3, #1
    70e8: e5843000  str r3, [r4]
  RegData = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_MCTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET,
        (RegData | Mask));
}
    70ec: e28dd00c  add sp, sp, #12
    70f0: e8bd8030  pop {r4, r5, pc}
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);


  RegData = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    70f4: e5950004  ldr r0, [r5, #4]
    70f8: e58d1004  str r1, [sp, #4]
    70fc: e2800080  add r0, r0, #128  ; 0x80
    7100: ebfffc24  bl  6198 <Xil_In32>
          XDCFG_MCTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET,
    7104: e5953004  ldr r3, [r5, #4]
    7108: e59d1004  ldr r1, [sp, #4]
    710c: e1801001  orr r1, r0, r1
    7110: e2830080  add r0, r3, #128  ; 0x80
        (RegData | Mask));
}
    7114: e28dd00c  add sp, sp, #12
    7118: e8bd4030  pop {r4, r5, lr}


  RegData = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
          XDCFG_MCTRL_OFFSET);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET,
    711c: eafffc23  b 61b0 <Xil_Out32>
  u32 RegData;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7120: e30806fc  movw  r0, #34556  ; 0x86fc
    7124: e3001237  movw  r1, #567  ; 0x237
    7128: e3400001  movt  r0, #1
    712c: eb0007d7  bl  9090 <Xil_Assert>
    7130: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7134: e3403002  movt  r3, #2
    7138: e3a02001  mov r2, #1
    713c: e5832000  str r2, [r3]
    7140: eaffffe9  b 70ec <XDcfg_SetMiscControlRegister+0x4c>

00007144 <XDcfg_GetMiscControlRegister>:
u32 XDcfg_GetMiscControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7144: e3500000  cmp r0, #0
* @note   This register is locked for write once the system enters
*   usermode. Hence API to reading the register only is provided.
*
*****************************************************************************/
u32 XDcfg_GetMiscControlRegister(XDcfg *InstancePtr)
{
    7148: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    714c: 0a000014  beq 71a4 <XDcfg_GetMiscControlRegister+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7150: e5902008  ldr r2, [r0, #8]
    7154: e3013111  movw  r3, #4369 ; 0x1111
    7158: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_GetMiscControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    715c: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7160: e1520003  cmp r2, r3
u32 XDcfg_GetMiscControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7164: e3404002  movt  r4, #2
    7168: e3a03000  mov r3, #0
    716c: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7170: 0a000007  beq 7194 <XDcfg_GetMiscControlRegister+0x50>
    7174: e30806fc  movw  r0, #34556  ; 0x86fc
    7178: e3001255  movw  r1, #597  ; 0x255
    717c: e3400001  movt  r0, #1
    7180: eb0007c2  bl  9090 <Xil_Assert>
    7184: e3a03001  mov r3, #1
    7188: e5843000  str r3, [r4]

  /*
   * Read the Miscellaneous Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET);
}
    718c: e3a00000  mov r0, #0
    7190: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Miscellaneous Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET);
    7194: e5900004  ldr r0, [r0, #4]
}
    7198: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Read the Miscellaneous Control Register and return the value.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_MCTRL_OFFSET);
    719c: e2800080  add r0, r0, #128  ; 0x80
    71a0: eafffbfc  b 6198 <Xil_In32>
u32 XDcfg_GetMiscControlRegister(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    71a4: e30806fc  movw  r0, #34556  ; 0x86fc
    71a8: e3a01f95  mov r1, #596  ; 0x254
    71ac: e3400001  movt  r0, #1
    71b0: eb0007b6  bl  9090 <Xil_Assert>
    71b4: e3023ae8  movw  r3, #10984  ; 0x2ae8
    71b8: e3403002  movt  r3, #2
    71bc: e3a02001  mov r2, #1
    71c0: e5832000  str r2, [r3]
    71c4: eafffff0  b 718c <XDcfg_GetMiscControlRegister+0x48>

000071c8 <XDcfg_IsDmaBusy>:
*
* @note   The DMA queue has a depth of two.
*
****************************************************************************/
u32 XDcfg_IsDmaBusy(XDcfg *InstancePtr)
{
    71c8: e92d4070  push  {r4, r5, r6, lr}

  u32 RegData;

  Xil_AssertNonvoid(InstancePtr != NULL);
    71cc: e2506000  subs  r6, r0, #0
    71d0: 0a000016  beq 7230 <XDcfg_IsDmaBusy+0x68>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    71d4: e5962008  ldr r2, [r6, #8]
    71d8: e3013111  movw  r3, #4369 ; 0x1111
    71dc: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_IsDmaBusy(XDcfg *InstancePtr)
{

  u32 RegData;

  Xil_AssertNonvoid(InstancePtr != NULL);
    71e0: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    71e4: e1520003  cmp r2, r3
u32 XDcfg_IsDmaBusy(XDcfg *InstancePtr)
{

  u32 RegData;

  Xil_AssertNonvoid(InstancePtr != NULL);
    71e8: e3405002  movt  r5, #2
    71ec: e3a04000  mov r4, #0
    71f0: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    71f4: 0a000007  beq 7218 <XDcfg_IsDmaBusy+0x50>
    71f8: e30806fc  movw  r0, #34556  ; 0x86fc
    71fc: e3a01e27  mov r1, #624  ; 0x270
    7200: e3400001  movt  r0, #1
    7204: eb0007a1  bl  9090 <Xil_Assert>
    7208: e3a03001  mov r3, #1
    720c: e1a00004  mov r0, r4
    7210: e5853000  str r3, [r5]
        XDCFG_STATUS_DMA_CMD_Q_F_MASK){
    return XST_SUCCESS;
  }

  return XST_FAILURE;
}
    7214: e8bd8070  pop {r4, r5, r6, pc}

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /* Read the PCAP status register for DMA status */
  RegData = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7218: e5960004  ldr r0, [r6, #4]
    721c: e2800014  add r0, r0, #20
    7220: ebfffbdc  bl  6198 <Xil_In32>
          XDCFG_STATUS_OFFSET);

  if ((RegData & XDCFG_STATUS_DMA_CMD_Q_F_MASK) ==
    7224: e1e00000  mvn r0, r0
    7228: e1a00fa0  lsr r0, r0, #31
    722c: e8bd8070  pop {r4, r5, r6, pc}
u32 XDcfg_IsDmaBusy(XDcfg *InstancePtr)
{

  u32 RegData;

  Xil_AssertNonvoid(InstancePtr != NULL);
    7230: e30806fc  movw  r0, #34556  ; 0x86fc
    7234: e300126f  movw  r1, #623  ; 0x26f
    7238: e3400001  movt  r0, #1
    723c: eb000793  bl  9090 <Xil_Assert>
    7240: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7244: e3403002  movt  r3, #2
    7248: e3a02001  mov r2, #1
    724c: e1a00006  mov r0, r6
    7250: e5832000  str r2, [r3]
    7254: e8bd8070  pop {r4, r5, r6, pc}

00007258 <XDcfg_InitiateDma>:
*   an overall transfer.
*
****************************************************************************/
void XDcfg_InitiateDma(XDcfg *InstancePtr, u32 SourcePtr, u32 DestPtr,
        u32 SrcWordLength, u32 DestWordLength)
{
    7258: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
    725c: e1a04000  mov r4, r0

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7260: e5900004  ldr r0, [r0, #4]
*   an overall transfer.
*
****************************************************************************/
void XDcfg_InitiateDma(XDcfg *InstancePtr, u32 SourcePtr, u32 DestPtr,
        u32 SrcWordLength, u32 DestWordLength)
{
    7264: e1a07002  mov r7, r2
    7268: e1a06003  mov r6, r3
    726c: e59d5018  ldr r5, [sp, #24]

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7270: e2800018  add r0, r0, #24
    7274: ebfffbcd  bl  61b0 <Xil_Out32>
        XDCFG_DMA_SRC_ADDR_OFFSET,
        SourcePtr);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7278: e5940004  ldr r0, [r4, #4]
    727c: e1a01007  mov r1, r7
    7280: e280001c  add r0, r0, #28
    7284: ebfffbc9  bl  61b0 <Xil_Out32>
        XDCFG_DMA_DEST_ADDR_OFFSET,
        DestPtr);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7288: e5940004  ldr r0, [r4, #4]
    728c: e1a01006  mov r1, r6
    7290: e2800020  add r0, r0, #32
    7294: ebfffbc5  bl  61b0 <Xil_Out32>
        XDCFG_DMA_SRC_LEN_OFFSET,
        SrcWordLength);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7298: e5940004  ldr r0, [r4, #4]
    729c: e1a01005  mov r1, r5
    72a0: e2800024  add r0, r0, #36 ; 0x24
        XDCFG_DMA_DEST_LEN_OFFSET,
        DestWordLength);
}
    72a4: e8bd40f8  pop {r3, r4, r5, r6, r7, lr}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
        XDCFG_DMA_SRC_LEN_OFFSET,
        SrcWordLength);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    72a8: eafffbc0  b 61b0 <Xil_Out32>

000072ac <XDcfg_Transfer>:
*****************************************************************************/
u32 XDcfg_Transfer(XDcfg *InstancePtr,
      void *SourcePtr, u32 SrcWordLength,
      void *DestPtr, u32 DestWordLength,
      u32 TransferType)
{
    72ac: e92d43f0  push  {r4, r5, r6, r7, r8, r9, lr}

  u32 CtrlReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    72b0: e2506000  subs  r6, r0, #0
*****************************************************************************/
u32 XDcfg_Transfer(XDcfg *InstancePtr,
      void *SourcePtr, u32 SrcWordLength,
      void *DestPtr, u32 DestWordLength,
      u32 TransferType)
{
    72b4: e24dd00c  sub sp, sp, #12

  u32 CtrlReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    72b8: 0a00002f  beq 737c <XDcfg_Transfer+0xd0>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    72bc: e596e008  ldr lr, [r6, #8]
    72c0: e301c111  movw  ip, #4369 ; 0x1111
    72c4: e341c111  movt  ip, #4369 ; 0x1111
      u32 TransferType)
{

  u32 CtrlReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    72c8: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    72cc: e15e000c  cmp lr, ip
      u32 TransferType)
{

  u32 CtrlReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    72d0: e3405002  movt  r5, #2
    72d4: e3a04000  mov r4, #0
    72d8: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    72dc: 0a000008  beq 7304 <XDcfg_Transfer+0x58>
    72e0: e30806fc  movw  r0, #34556  ; 0x86fc
    72e4: e300131d  movw  r1, #797  ; 0x31d
    72e8: e3400001  movt  r0, #1
    72ec: eb000767  bl  9090 <Xil_Assert>
    72f0: e1a00004  mov r0, r4
    72f4: e3a03001  mov r3, #1
    72f8: e5853000  str r3, [r5]
    XDcfg_InitiateDma(InstancePtr, (u32)SourcePtr,
        (u32)DestPtr, SrcWordLength, DestWordLength);
  }

  return XST_SUCCESS;
}
    72fc: e28dd00c  add sp, sp, #12
    7300: e8bd83f0  pop {r4, r5, r6, r7, r8, r9, pc}
    7304: e1a08001  mov r8, r1
    7308: e1a09002  mov r9, r2
    730c: e1a07003  mov r7, r3

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);


  if (XDcfg_IsDmaBusy(InstancePtr) == XST_SUCCESS) {
    7310: ebffffac  bl  71c8 <XDcfg_IsDmaBusy>
    7314: e3500000  cmp r0, #0
    return XST_DEVICE_BUSY;
    7318: 03a00015  moveq r0, #21

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);


  if (XDcfg_IsDmaBusy(InstancePtr) == XST_SUCCESS) {
    731c: 0afffff6  beq 72fc <XDcfg_Transfer+0x50>
  }

  /*
   * Check whether the fabric is in initialized state
   */
  if ((XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET)
    7320: e5960004  ldr r0, [r6, #4]
    7324: e2800014  add r0, r0, #20
    7328: ebfffb9a  bl  6198 <Xil_In32>
      & XDCFG_STATUS_PCFG_INIT_MASK) == 0) {
    /*
     * We don't need to check PCFG_INIT to be high for
     * non-encrypted loopback transfers.
     */
    if (TransferType != XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    732c: e59d302c  ldr r3, [sp, #44] ; 0x2c
    7330: e2533005  subs  r3, r3, #5
    7334: 13a03001  movne r3, #1
  }

  /*
   * Check whether the fabric is in initialized state
   */
  if ((XDcfg_ReadReg(InstancePtr->Config.BaseAddr, XDCFG_STATUS_OFFSET)
    7338: e2200010  eor r0, r0, #16
      & XDCFG_STATUS_PCFG_INIT_MASK) == 0) {
    /*
     * We don't need to check PCFG_INIT to be high for
     * non-encrypted loopback transfers.
     */
    if (TransferType != XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    733c: e0133220  ands  r3, r3, r0, lsr #4
      return XST_FAILURE;
    7340: 13a00001  movne r0, #1
      & XDCFG_STATUS_PCFG_INIT_MASK) == 0) {
    /*
     * We don't need to check PCFG_INIT to be high for
     * non-encrypted loopback transfers.
     */
    if (TransferType != XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    7344: 1affffec  bne 72fc <XDcfg_Transfer+0x50>
      return XST_FAILURE;
    }
  }

  if ((TransferType == XDCFG_SECURE_PCAP_WRITE) ||
    7348: e59d302c  ldr r3, [sp, #44] ; 0x2c
    734c: e2433001  sub r3, r3, #1
    7350: e3530001  cmp r3, #1
    7354: 9a000012  bls 73a4 <XDcfg_Transfer+0xf8>
    XDcfg_InitiateDma(InstancePtr, (u32)SourcePtr,
        (u32)DestPtr, SrcWordLength, DestWordLength);

  }

  if (TransferType == XDCFG_PCAP_READBACK) {
    7358: e59d302c  ldr r3, [sp, #44] ; 0x2c
    735c: e3530003  cmp r3, #3
    7360: 0a000014  beq 73b8 <XDcfg_Transfer+0x10c>
           (u32)SourcePtr, SrcWordLength,
           (u32)DestPtr,   DestWordLength);
  }


  if ((TransferType == XDCFG_CONCURRENT_SECURE_READ_WRITE) ||
    7364: e59d302c  ldr r3, [sp, #44] ; 0x2c
    7368: e2433004  sub r3, r3, #4
    736c: e3530001  cmp r3, #1
    7370: 9a00003b  bls 7464 <XDcfg_Transfer+0x1b8>

    XDcfg_InitiateDma(InstancePtr, (u32)SourcePtr,
        (u32)DestPtr, SrcWordLength, DestWordLength);
  }

  return XST_SUCCESS;
    7374: e3a00000  mov r0, #0
    7378: eaffffdf  b 72fc <XDcfg_Transfer+0x50>
      u32 TransferType)
{

  u32 CtrlReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    737c: e30806fc  movw  r0, #34556  ; 0x86fc
    7380: e3a01fc7  mov r1, #796  ; 0x31c
    7384: e3400001  movt  r0, #1
    7388: eb000740  bl  9090 <Xil_Assert>
    738c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7390: e3403002  movt  r3, #2
    7394: e3a02001  mov r2, #1
    7398: e1a00006  mov r0, r6
    739c: e5832000  str r2, [r3]
    73a0: eaffffd5  b 72fc <XDcfg_Transfer+0x50>

  if ((TransferType == XDCFG_SECURE_PCAP_WRITE) ||
    (TransferType == XDCFG_NON_SECURE_PCAP_WRITE)) {

    /* Check for valid source pointer and length */
    if ((!SourcePtr) || (SrcWordLength == 0)) {
    73a4: e3590000  cmp r9, #0
    73a8: 13580000  cmpne r8, #0
    73ac: 1a000048  bne 74d4 <XDcfg_Transfer+0x228>
      return XST_INVALID_PARAM;
    73b0: e3a0000f  mov r0, #15
    73b4: eaffffd0  b 72fc <XDcfg_Transfer+0x50>

  }

  if (TransferType == XDCFG_PCAP_READBACK) {

    if ((!DestPtr) || (DestWordLength == 0)) {
    73b8: e59d3028  ldr r3, [sp, #40] ; 0x28
    73bc: e3530000  cmp r3, #0
    73c0: 13570000  cmpne r7, #0
    73c4: 03a04001  moveq r4, #1
    73c8: 13a04000  movne r4, #0
    73cc: 0afffff7  beq 73b0 <XDcfg_Transfer+0x104>

      return XST_INVALID_PARAM;
    }

    /* Clear internal PCAP loopback */
    CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    73d0: e5960004  ldr r0, [r6, #4]
    73d4: e2800080  add r0, r0, #128  ; 0x80
    73d8: ebfffb6e  bl  6198 <Xil_In32>
          XDCFG_MCTRL_OFFSET);
    XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    73dc: e5963004  ldr r3, [r6, #4]
    73e0: e3c01010  bic r1, r0, #16
    73e4: e2830080  add r0, r3, #128  ; 0x80
    73e8: ebfffb70  bl  61b0 <Xil_Out32>
  u32 IntrReg;

  /*
   * Send READ Frame command to FPGA
   */
  XDcfg_InitiateDma(InstancePtr, SourcePtr, XDCFG_DMA_INVALID_ADDRESS,
    73ec: e1a01008  mov r1, r8
    73f0: e58d4000  str r4, [sp]
    73f4: e1a03009  mov r3, r9
    73f8: e1a00006  mov r0, r6
    73fc: e3e02000  mvn r2, #0
    7400: ebffff94  bl  7258 <XDcfg_InitiateDma>

  /*
   * Store the enabled interrupts to enable before the actual read
   * transfer is initiated and Disable all the interrupts temporarily.
   */
  IntrReg = XDcfg_IntrGetEnabled(InstancePtr);
    7404: e1a00006  mov r0, r6
    7408: eb00009f  bl  768c <XDcfg_IntrGetEnabled>
  XDcfg_IntrDisable(InstancePtr, XDCFG_IXR_ALL_MASK);
    740c: e30f18ef  movw  r1, #63727  ; 0xf8ef
    7410: e34010f7  movt  r1, #247  ; 0xf7

  /*
   * Store the enabled interrupts to enable before the actual read
   * transfer is initiated and Disable all the interrupts temporarily.
   */
  IntrReg = XDcfg_IntrGetEnabled(InstancePtr);
    7414: e1a04000  mov r4, r0
  XDcfg_IntrDisable(InstancePtr, XDCFG_IXR_ALL_MASK);
    7418: e1a00006  mov r0, r6
    741c: eb00006e  bl  75dc <XDcfg_IntrDisable>

  /*
   * Wait till you get the DMA done for the read command sent
   */
   while ((XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7420: e5960004  ldr r0, [r6, #4]
    7424: e280000c  add r0, r0, #12
    7428: ebfffb5a  bl  6198 <Xil_In32>
    742c: e3100a01  tst r0, #4096 ; 0x1000
    7430: 0afffffa  beq 7420 <XDcfg_Transfer+0x174>
      XDCFG_IXR_D_P_DONE_MASK) !=
      XDCFG_IXR_D_P_DONE_MASK);
  /*
   * Enable the previously stored Interrupts .
   */
  XDcfg_IntrEnable(InstancePtr, IntrReg);
    7434: e1a01004  mov r1, r4
    7438: e1a00006  mov r0, r6
    743c: eb00003a  bl  752c <XDcfg_IntrEnable>

  /*
   * Initiate the DMA write command.
   */
  XDcfg_InitiateDma(InstancePtr, XDCFG_DMA_INVALID_ADDRESS, (u32)DestPtr,
    7440: e59d3028  ldr r3, [sp, #40] ; 0x28
    7444: e1a00006  mov r0, r6
    7448: e1a02007  mov r2, r7
    744c: e3e01000  mvn r1, #0
    7450: e58d3000  str r3, [sp]
    7454: e3a03000  mov r3, #0
    7458: ebffff7e  bl  7258 <XDcfg_InitiateDma>
     * from the FPGA is captured if pcap_radata_v is active.A DMA
     * read transfer is required to obtain the readback command,
     * which is then sent to the FPGA, followed by a DMA write
     * transfer to support this mode of operation.
     */
    return XDcfg_PcapReadback(InstancePtr,
    745c: e3a00000  mov r0, #0
    7460: eaffffa5  b 72fc <XDcfg_Transfer+0x50>


  if ((TransferType == XDCFG_CONCURRENT_SECURE_READ_WRITE) ||
    (TransferType == XDCFG_CONCURRENT_NONSEC_READ_WRITE)) {

    if ((!SourcePtr) || (SrcWordLength == 0) ||
    7464: e3590000  cmp r9, #0
    7468: 13580000  cmpne r8, #0
    746c: 0affffcf  beq 73b0 <XDcfg_Transfer+0x104>
      (!DestPtr) || (DestWordLength == 0)) {
    7470: e59d3028  ldr r3, [sp, #40] ; 0x28
    7474: e3530000  cmp r3, #0
    7478: 13570000  cmpne r7, #0
    747c: 0affffcb  beq 73b0 <XDcfg_Transfer+0x104>
      return XST_INVALID_PARAM;
    }

    if (TransferType == XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    7480: e59d302c  ldr r3, [sp, #44] ; 0x2c
      /* Enable internal PCAP loopback */
      CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7484: e5960004  ldr r0, [r6, #4]
    if ((!SourcePtr) || (SrcWordLength == 0) ||
      (!DestPtr) || (DestWordLength == 0)) {
      return XST_INVALID_PARAM;
    }

    if (TransferType == XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    7488: e3530005  cmp r3, #5
      /* Enable internal PCAP loopback */
      CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    748c: e2800080  add r0, r0, #128  ; 0x80
    if ((!SourcePtr) || (SrcWordLength == 0) ||
      (!DestPtr) || (DestWordLength == 0)) {
      return XST_INVALID_PARAM;
    }

    if (TransferType == XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
    7490: 0a00001f  beq 7514 <XDcfg_Transfer+0x268>
            ~XDCFG_CTRL_PCAP_RATE_EN_MASK));

    }
    if (TransferType == XDCFG_CONCURRENT_SECURE_READ_WRITE) {
      /* Clear internal PCAP loopback */
      CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7494: ebfffb3f  bl  6198 <Xil_In32>
            XDCFG_MCTRL_OFFSET);
      XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7498: e5963004  ldr r3, [r6, #4]
    749c: e3c01010  bic r1, r0, #16
    74a0: e2830080  add r0, r3, #128  ; 0x80
    74a4: ebfffb41  bl  61b0 <Xil_Out32>
      /*
       * Set the QUARTER_PCAP_RATE_EN bit
       * so that the PCAP data is transmitted every 4 clock
       * cycles, this is required for encrypted data.
       */
      XDcfg_SetControlRegister(InstancePtr,
    74a8: e1a00006  mov r0, r6
    74ac: e3a01402  mov r1, #33554432 ; 0x2000000
    74b0: ebfffd88  bl  6ad8 <XDcfg_SetControlRegister>
       */
      XDcfg_SetControlRegister(InstancePtr,
            XDCFG_CTRL_PCAP_RATE_EN_MASK);
    }

    XDcfg_InitiateDma(InstancePtr, (u32)SourcePtr,
    74b4: e59d3028  ldr r3, [sp, #40] ; 0x28
    74b8: e1a00006  mov r0, r6
    74bc: e1a01008  mov r1, r8
    74c0: e1a02007  mov r2, r7
    74c4: e58d3000  str r3, [sp]
    74c8: e1a03009  mov r3, r9
    74cc: ebffff61  bl  7258 <XDcfg_InitiateDma>
    74d0: eaffffa7  b 7374 <XDcfg_Transfer+0xc8>
    if ((!SourcePtr) || (SrcWordLength == 0)) {
      return XST_INVALID_PARAM;
    }

    /* Clear internal PCAP loopback */
    CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    74d4: e5960004  ldr r0, [r6, #4]
    74d8: e2800080  add r0, r0, #128  ; 0x80
    74dc: ebfffb2d  bl  6198 <Xil_In32>
          XDCFG_MCTRL_OFFSET);
    XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    74e0: e5963004  ldr r3, [r6, #4]
    74e4: e3c01010  bic r1, r0, #16
    74e8: e2830080  add r0, r3, #128  ; 0x80
    74ec: ebfffb2f  bl  61b0 <Xil_Out32>
        XDCFG_MCTRL_OFFSET, (CtrlReg &
        ~(XDCFG_MCTRL_PCAP_LPBK_MASK)));

    if (TransferType == XDCFG_NON_SECURE_PCAP_WRITE) {
    74f0: e59d302c  ldr r3, [sp, #44] ; 0x2c
    74f4: e3530001  cmp r3, #1
    74f8: 1affffea  bne 74a8 <XDcfg_Transfer+0x1fc>
      /*
       * Clear QUARTER_PCAP_RATE_EN bit
       * so that the PCAP data is transmitted every clock
       */
      CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    74fc: e5960004  ldr r0, [r6, #4]
    7500: ebfffb24  bl  6198 <Xil_In32>
            XDCFG_CTRL_OFFSET);

      XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7504: e3c01402  bic r1, r0, #33554432 ; 0x2000000
    7508: e5960004  ldr r0, [r6, #4]
    750c: ebfffb27  bl  61b0 <Xil_Out32>
    7510: eaffffe7  b 74b4 <XDcfg_Transfer+0x208>
      return XST_INVALID_PARAM;
    }

    if (TransferType == XDCFG_CONCURRENT_NONSEC_READ_WRITE) {
      /* Enable internal PCAP loopback */
      CtrlReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7514: ebfffb1f  bl  6198 <Xil_In32>
          XDCFG_MCTRL_OFFSET);
      XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7518: e5963004  ldr r3, [r6, #4]
    751c: e3801010  orr r1, r0, #16
    7520: e2830080  add r0, r3, #128  ; 0x80
    7524: ebfffb21  bl  61b0 <Xil_Out32>
    7528: eafffff3  b 74fc <XDcfg_Transfer+0x250>

0000752c <XDcfg_IntrEnable>:
*
* @note   None.
*
*****************************************************************************/
void XDcfg_IntrEnable(XDcfg *InstancePtr, u32 Mask)
{
    752c: e92d4030  push  {r4, r5, lr}
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7530: e2505000  subs  r5, r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_IntrEnable(XDcfg *InstancePtr, u32 Mask)
{
    7534: e24dd00c  sub sp, sp, #12
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7538: 0a00001e  beq 75b8 <XDcfg_IntrEnable+0x8c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    753c: e5952008  ldr r2, [r5, #8]
    7540: e3013111  movw  r3, #4369 ; 0x1111
    7544: e3413111  movt  r3, #4369 ; 0x1111
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7548: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    754c: e1520003  cmp r2, r3
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7550: e3404002  movt  r4, #2
    7554: e3a03000  mov r3, #0
    7558: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    755c: 0a000007  beq 7580 <XDcfg_IntrEnable+0x54>
    7560: e3080708  movw  r0, #34568  ; 0x8708
    7564: e3a0105b  mov r1, #91 ; 0x5b
    7568: e3400001  movt  r0, #1
    756c: eb0006c7  bl  9090 <Xil_Assert>
    7570: e3a03001  mov r3, #1
    7574: e5843000  str r3, [r4]
            XDCFG_INT_MASK_OFFSET);
  RegValue &= ~(Mask & XDCFG_IXR_ALL_MASK);
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
        XDCFG_INT_MASK_OFFSET,
        RegValue);
}
    7578: e28dd00c  add sp, sp, #12
    757c: e8bd8030  pop {r4, r5, pc}
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Enable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7580: e5950004  ldr r0, [r5, #4]
    7584: e58d1004  str r1, [sp, #4]
    7588: e2800010  add r0, r0, #16
    758c: ebfffb01  bl  6198 <Xil_In32>
            XDCFG_INT_MASK_OFFSET);
  RegValue &= ~(Mask & XDCFG_IXR_ALL_MASK);
    7590: e59d1004  ldr r1, [sp, #4]
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7594: e5952004  ldr r2, [r5, #4]
  /*
   * Enable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
            XDCFG_INT_MASK_OFFSET);
  RegValue &= ~(Mask & XDCFG_IXR_ALL_MASK);
    7598: e30f38ef  movw  r3, #63727  ; 0xf8ef
    759c: e34030f7  movt  r3, #247  ; 0xf7
    75a0: e0033001  and r3, r3, r1
    75a4: e1c01003  bic r1, r0, r3
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    75a8: e2820010  add r0, r2, #16
        XDCFG_INT_MASK_OFFSET,
        RegValue);
}
    75ac: e28dd00c  add sp, sp, #12
    75b0: e8bd4030  pop {r4, r5, lr}
   * Enable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
            XDCFG_INT_MASK_OFFSET);
  RegValue &= ~(Mask & XDCFG_IXR_ALL_MASK);
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    75b4: eafffafd  b 61b0 <Xil_Out32>
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    75b8: e3080708  movw  r0, #34568  ; 0x8708
    75bc: e3a0105a  mov r1, #90 ; 0x5a
    75c0: e3400001  movt  r0, #1
    75c4: eb0006b1  bl  9090 <Xil_Assert>
    75c8: e3023ae8  movw  r3, #10984  ; 0x2ae8
    75cc: e3403002  movt  r3, #2
    75d0: e3a02001  mov r2, #1
    75d4: e5832000  str r2, [r3]
    75d8: eaffffe6  b 7578 <XDcfg_IntrEnable+0x4c>

000075dc <XDcfg_IntrDisable>:
*
* @note   None.
*
*****************************************************************************/
void XDcfg_IntrDisable(XDcfg *InstancePtr, u32 Mask)
{
    75dc: e92d4030  push  {r4, r5, lr}
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    75e0: e2505000  subs  r5, r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_IntrDisable(XDcfg *InstancePtr, u32 Mask)
{
    75e4: e24dd00c  sub sp, sp, #12
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    75e8: 0a00001e  beq 7668 <XDcfg_IntrDisable+0x8c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    75ec: e5952008  ldr r2, [r5, #8]
    75f0: e3013111  movw  r3, #4369 ; 0x1111
    75f4: e3413111  movt  r3, #4369 ; 0x1111
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    75f8: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    75fc: e1520003  cmp r2, r3
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7600: e3404002  movt  r4, #2
    7604: e3a03000  mov r3, #0
    7608: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    760c: 0a000007  beq 7630 <XDcfg_IntrDisable+0x54>
    7610: e3080708  movw  r0, #34568  ; 0x8708
    7614: e3a01081  mov r1, #129  ; 0x81
    7618: e3400001  movt  r0, #1
    761c: eb00069b  bl  9090 <Xil_Assert>
    7620: e3a03001  mov r3, #1
    7624: e5843000  str r3, [r4]
            XDCFG_INT_MASK_OFFSET);
  RegValue |= (Mask & XDCFG_IXR_ALL_MASK);
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
        XDCFG_INT_MASK_OFFSET,
        RegValue);
}
    7628: e28dd00c  add sp, sp, #12
    762c: e8bd8030  pop {r4, r5, pc}
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Disable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7630: e5950004  ldr r0, [r5, #4]
    7634: e58d1004  str r1, [sp, #4]
    7638: e2800010  add r0, r0, #16
    763c: ebfffad5  bl  6198 <Xil_In32>
            XDCFG_INT_MASK_OFFSET);
  RegValue |= (Mask & XDCFG_IXR_ALL_MASK);
    7640: e59d1004  ldr r1, [sp, #4]
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7644: e5952004  ldr r2, [r5, #4]
  /*
   * Disable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
            XDCFG_INT_MASK_OFFSET);
  RegValue |= (Mask & XDCFG_IXR_ALL_MASK);
    7648: e30f38ef  movw  r3, #63727  ; 0xf8ef
    764c: e34030f7  movt  r3, #247  ; 0xf7
    7650: e0033001  and r3, r3, r1
    7654: e1801003  orr r1, r0, r3
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7658: e2820010  add r0, r2, #16
        XDCFG_INT_MASK_OFFSET,
        RegValue);
}
    765c: e28dd00c  add sp, sp, #12
    7660: e8bd4030  pop {r4, r5, lr}
   * Disable the specified interrupts in the Interrupt Mask Register.
   */
  RegValue = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
            XDCFG_INT_MASK_OFFSET);
  RegValue |= (Mask & XDCFG_IXR_ALL_MASK);
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7664: eafffad1  b 61b0 <Xil_Out32>
  u32 RegValue;

  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7668: e3080708  movw  r0, #34568  ; 0x8708
    766c: e3a01080  mov r1, #128  ; 0x80
    7670: e3400001  movt  r0, #1
    7674: eb000685  bl  9090 <Xil_Assert>
    7678: e3023ae8  movw  r3, #10984  ; 0x2ae8
    767c: e3403002  movt  r3, #2
    7680: e3a02001  mov r2, #1
    7684: e5832000  str r2, [r3]
    7688: eaffffe6  b 7628 <XDcfg_IntrDisable+0x4c>

0000768c <XDcfg_IntrGetEnabled>:
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_IntrGetEnabled(XDcfg *InstancePtr)
{
    768c: e92d4070  push  {r4, r5, r6, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7690: e2506000  subs  r6, r0, #0
    7694: 0a000015  beq 76f0 <XDcfg_IntrGetEnabled+0x64>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7698: e5962008  ldr r2, [r6, #8]
    769c: e3013111  movw  r3, #4369 ; 0x1111
    76a0: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_IntrGetEnabled(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    76a4: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    76a8: e1520003  cmp r2, r3
u32 XDcfg_IntrGetEnabled(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    76ac: e3405002  movt  r5, #2
    76b0: e3a04000  mov r4, #0
    76b4: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    76b8: 0a000007  beq 76dc <XDcfg_IntrGetEnabled+0x50>
    76bc: e3080708  movw  r0, #34568  ; 0x8708
    76c0: e3a010a1  mov r1, #161  ; 0xa1
    76c4: e3400001  movt  r0, #1
    76c8: eb000670  bl  9090 <Xil_Assert>
    76cc: e3a03001  mov r3, #1
    76d0: e1a00004  mov r0, r4
    76d4: e5853000  str r3, [r5]
  /*
   * Return the value read from the Interrupt Mask Register.
   */
  return (~ XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
        XDCFG_INT_MASK_OFFSET));
}
    76d8: e8bd8070  pop {r4, r5, r6, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Return the value read from the Interrupt Mask Register.
   */
  return (~ XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    76dc: e5960004  ldr r0, [r6, #4]
    76e0: e2800010  add r0, r0, #16
    76e4: ebfffaab  bl  6198 <Xil_In32>
    76e8: e1e00000  mvn r0, r0
    76ec: e8bd8070  pop {r4, r5, r6, pc}
u32 XDcfg_IntrGetEnabled(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    76f0: e3080708  movw  r0, #34568  ; 0x8708
    76f4: e3a010a0  mov r1, #160  ; 0xa0
    76f8: e3400001  movt  r0, #1
    76fc: eb000663  bl  9090 <Xil_Assert>
    7700: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7704: e3403002  movt  r3, #2
    7708: e3a02001  mov r2, #1
    770c: e1a00006  mov r0, r6
    7710: e5832000  str r2, [r3]
    7714: e8bd8070  pop {r4, r5, r6, pc}

00007718 <XDcfg_IntrGetStatus>:
u32 XDcfg_IntrGetStatus(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7718: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
u32 XDcfg_IntrGetStatus(XDcfg *InstancePtr)
{
    771c: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7720: 0a000014  beq 7778 <XDcfg_IntrGetStatus+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7724: e5902008  ldr r2, [r0, #8]
    7728: e3013111  movw  r3, #4369 ; 0x1111
    772c: e3413111  movt  r3, #4369 ; 0x1111
u32 XDcfg_IntrGetStatus(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7730: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7734: e1520003  cmp r2, r3
u32 XDcfg_IntrGetStatus(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7738: e3404002  movt  r4, #2
    773c: e3a03000  mov r3, #0
    7740: e5843000  str r3, [r4]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7744: 0a000007  beq 7768 <XDcfg_IntrGetStatus+0x50>
    7748: e3080708  movw  r0, #34568  ; 0x8708
    774c: e3a010bf  mov r1, #191  ; 0xbf
    7750: e3400001  movt  r0, #1
    7754: eb00064d  bl  9090 <Xil_Assert>
    7758: e3a03001  mov r3, #1
    775c: e5843000  str r3, [r4]
  /*
   * Return the value read from the Interrupt Status register.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
        XDCFG_INT_STS_OFFSET);
}
    7760: e3a00000  mov r0, #0
    7764: e8bd8010  pop {r4, pc}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Return the value read from the Interrupt Status register.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7768: e5900004  ldr r0, [r0, #4]
        XDCFG_INT_STS_OFFSET);
}
    776c: e8bd4010  pop {r4, lr}
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Return the value read from the Interrupt Status register.
   */
  return XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7770: e280000c  add r0, r0, #12
    7774: eafffa87  b 6198 <Xil_In32>
u32 XDcfg_IntrGetStatus(XDcfg *InstancePtr)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7778: e3080708  movw  r0, #34568  ; 0x8708
    777c: e3a010be  mov r1, #190  ; 0xbe
    7780: e3400001  movt  r0, #1
    7784: eb000641  bl  9090 <Xil_Assert>
    7788: e3023ae8  movw  r3, #10984  ; 0x2ae8
    778c: e3403002  movt  r3, #2
    7790: e3a02001  mov r2, #1
    7794: e5832000  str r2, [r3]
    7798: eafffff0  b 7760 <XDcfg_IntrGetStatus+0x48>

0000779c <XDcfg_IntrClear>:
void XDcfg_IntrClear(XDcfg *InstancePtr, u32 Mask)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    779c: e3500000  cmp r0, #0
*
* @note   None.
*
*****************************************************************************/
void XDcfg_IntrClear(XDcfg *InstancePtr, u32 Mask)
{
    77a0: e92d4010  push  {r4, lr}
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    77a4: 0a000013  beq 77f8 <XDcfg_IntrClear+0x5c>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    77a8: e5902008  ldr r2, [r0, #8]
    77ac: e3013111  movw  r3, #4369 ; 0x1111
    77b0: e3413111  movt  r3, #4369 ; 0x1111
void XDcfg_IntrClear(XDcfg *InstancePtr, u32 Mask)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    77b4: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    77b8: e1520003  cmp r2, r3
void XDcfg_IntrClear(XDcfg *InstancePtr, u32 Mask)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    77bc: e3404002  movt  r4, #2
    77c0: e3a03000  mov r3, #0
    77c4: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    77c8: 0a000006  beq 77e8 <XDcfg_IntrClear+0x4c>
    77cc: e3080708  movw  r0, #34568  ; 0x8708
    77d0: e3a010df  mov r1, #223  ; 0xdf
    77d4: e3400001  movt  r0, #1
    77d8: eb00062c  bl  9090 <Xil_Assert>
    77dc: e3a03001  mov r3, #1
    77e0: e5843000  str r3, [r4]
    77e4: e8bd8010  pop {r4, pc}

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    77e8: e5900004  ldr r0, [r0, #4]
        XDCFG_INT_STS_OFFSET,
        Mask);

}
    77ec: e8bd4010  pop {r4, lr}
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    77f0: e280000c  add r0, r0, #12
    77f4: eafffa6d  b 61b0 <Xil_Out32>
void XDcfg_IntrClear(XDcfg *InstancePtr, u32 Mask)
{
  /*
   * Assert the arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    77f8: e3080708  movw  r0, #34568  ; 0x8708
    77fc: e3a010de  mov r1, #222  ; 0xde
    7800: e3400001  movt  r0, #1
    7804: eb000621  bl  9090 <Xil_Assert>
    7808: e3023ae8  movw  r3, #10984  ; 0x2ae8
    780c: e3403002  movt  r3, #2
    7810: e3a02001  mov r2, #1
    7814: e5832000  str r2, [r3]
    7818: e8bd8010  pop {r4, pc}

0000781c <XDcfg_InterruptHandler>:
*
* @note   None.
*
****************************************************************************/
void XDcfg_InterruptHandler(XDcfg *InstancePtr)
{
    781c: e92d4070  push  {r4, r5, r6, lr}
  u32 IntrStatusReg;

  /*
   * Assert validates the input arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7820: e2505000  subs  r5, r0, #0
    7824: 0a00001c  beq 789c <XDcfg_InterruptHandler+0x80>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7828: e5952008  ldr r2, [r5, #8]
    782c: e3013111  movw  r3, #4369 ; 0x1111
    7830: e3413111  movt  r3, #4369 ; 0x1111
  u32 IntrStatusReg;

  /*
   * Assert validates the input arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7834: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7838: e1520003  cmp r2, r3
  u32 IntrStatusReg;

  /*
   * Assert validates the input arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    783c: e3404002  movt  r4, #2
    7840: e3a03000  mov r3, #0
    7844: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7848: 0a000006  beq 7868 <XDcfg_InterruptHandler+0x4c>
    784c: e3080708  movw  r0, #34568  ; 0x8708
    7850: e3a010fd  mov r1, #253  ; 0xfd
    7854: e3400001  movt  r0, #1
    7858: eb00060c  bl  9090 <Xil_Assert>
    785c: e3a03001  mov r3, #1
    7860: e5843000  str r3, [r4]
    7864: e8bd8070  pop {r4, r5, r6, pc}

  /*
   * Read the Interrupt status register.
   */
  IntrStatusReg = XDcfg_ReadReg(InstancePtr->Config.BaseAddr,
    7868: e5950004  ldr r0, [r5, #4]
    786c: e280000c  add r0, r0, #12
    7870: ebfffa48  bl  6198 <Xil_In32>
    7874: e1a04000  mov r4, r0
  /*
   * Write the status back to clear the interrupts so that no
   * subsequent interrupts are missed while processing this interrupt.
   * This also does the DMA acknowledgment automatically.
   */
  XDcfg_WriteReg(InstancePtr->Config.BaseAddr,
    7878: e5950004  ldr r0, [r5, #4]
    787c: e1a01004  mov r1, r4
    7880: e280000c  add r0, r0, #12
    7884: ebfffa49  bl  61b0 <Xil_Out32>
        XDCFG_INT_STS_OFFSET, IntrStatusReg);

  /*
   * Signal application that there are events to handle.
   */
  InstancePtr->StatusHandler(InstancePtr->CallBackRef,
    7888: e1a01004  mov r1, r4
    788c: e5953010  ldr r3, [r5, #16]
    7890: e5950014  ldr r0, [r5, #20]
             IntrStatusReg);

}
    7894: e8bd4070  pop {r4, r5, r6, lr}
        XDCFG_INT_STS_OFFSET, IntrStatusReg);

  /*
   * Signal application that there are events to handle.
   */
  InstancePtr->StatusHandler(InstancePtr->CallBackRef,
    7898: e12fff13  bx  r3
  u32 IntrStatusReg;

  /*
   * Assert validates the input arguments.
   */
  Xil_AssertVoid(InstancePtr != NULL);
    789c: e3080708  movw  r0, #34568  ; 0x8708
    78a0: e3a010fc  mov r1, #252  ; 0xfc
    78a4: e3400001  movt  r0, #1
    78a8: eb0005f8  bl  9090 <Xil_Assert>
    78ac: e3023ae8  movw  r3, #10984  ; 0x2ae8
    78b0: e3403002  movt  r3, #2
    78b4: e3a02001  mov r2, #1
    78b8: e5832000  str r2, [r3]
    78bc: e8bd8070  pop {r4, r5, r6, pc}

000078c0 <XDcfg_SetHandler>:
{
  /*
   * Asserts validate the input arguments
   * CallBackRef not checked, no way to know what is valid
   */
  Xil_AssertVoid(InstancePtr != NULL);
    78c0: e3500000  cmp r0, #0
*
*
*****************************************************************************/
void XDcfg_SetHandler(XDcfg *InstancePtr, void *CallBackFunc,
        void *CallBackRef)
{
    78c4: e92d4010  push  {r4, lr}
  /*
   * Asserts validate the input arguments
   * CallBackRef not checked, no way to know what is valid
   */
  Xil_AssertVoid(InstancePtr != NULL);
    78c8: 0a000014  beq 7920 <XDcfg_SetHandler+0x60>
    78cc: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(CallBackFunc != NULL);
    78d0: e3510000  cmp r1, #0
{
  /*
   * Asserts validate the input arguments
   * CallBackRef not checked, no way to know what is valid
   */
  Xil_AssertVoid(InstancePtr != NULL);
    78d4: e3404002  movt  r4, #2
    78d8: e3a03000  mov r3, #0
    78dc: e5843000  str r3, [r4]
  Xil_AssertVoid(CallBackFunc != NULL);
    78e0: 0a000017  beq 7944 <XDcfg_SetHandler+0x84>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    78e4: e590c008  ldr ip, [r0, #8]
    78e8: e3013111  movw  r3, #4369 ; 0x1111
    78ec: e3413111  movt  r3, #4369 ; 0x1111
    78f0: e15c0003  cmp ip, r3
    78f4: 0a000006  beq 7914 <XDcfg_SetHandler+0x54>
    78f8: e3080708  movw  r0, #34568  ; 0x8708
    78fc: e300112f  movw  r1, #303  ; 0x12f
    7900: e3400001  movt  r0, #1
    7904: eb0005e1  bl  9090 <Xil_Assert>
    7908: e3a03001  mov r3, #1
    790c: e5843000  str r3, [r4]
    7910: e8bd8010  pop {r4, pc}

  InstancePtr->StatusHandler = (XDcfg_IntrHandler) CallBackFunc;
    7914: e5801010  str r1, [r0, #16]
  InstancePtr->CallBackRef = CallBackRef;
    7918: e5802014  str r2, [r0, #20]
    791c: e8bd8010  pop {r4, pc}
{
  /*
   * Asserts validate the input arguments
   * CallBackRef not checked, no way to know what is valid
   */
  Xil_AssertVoid(InstancePtr != NULL);
    7920: e3080708  movw  r0, #34568  ; 0x8708
    7924: e300112d  movw  r1, #301  ; 0x12d
    7928: e3400001  movt  r0, #1
    792c: eb0005d7  bl  9090 <Xil_Assert>
    7930: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7934: e3403002  movt  r3, #2
    7938: e3a02001  mov r2, #1
    793c: e5832000  str r2, [r3]
    7940: e8bd8010  pop {r4, pc}
  Xil_AssertVoid(CallBackFunc != NULL);
    7944: e3080708  movw  r0, #34568  ; 0x8708
    7948: e300112e  movw  r1, #302  ; 0x12e
    794c: e3400001  movt  r0, #1
    7950: eb0005ce  bl  9090 <Xil_Assert>
    7954: e3a03001  mov r3, #1
    7958: e5843000  str r3, [r4]
    795c: e8bd8010  pop {r4, pc}

00007960 <XDcfg_LookupConfig>:
  extern XDcfg_Config XDcfg_ConfigTable[];
  XDcfg_Config *CfgPtr = NULL;
  int Index;

  for (Index = 0; Index < XPAR_XDCFG_NUM_INSTANCES; Index++) {
    if (XDcfg_ConfigTable[Index].DeviceId == DeviceId) {
    7960: e30b3324  movw  r3, #45860  ; 0xb324
    7964: e3403001  movt  r3, #1
    7968: e1d320b0  ldrh  r2, [r3]
      break;
    }
  }

  return (CfgPtr);
}
    796c: e1520000  cmp r2, r0
    7970: 01a00003  moveq r0, r3
    7974: 13a00000  movne r0, #0
    7978: e12fff1e  bx  lr

0000797c <XQspiPs_GetReadData>:
******************************************************************************/
static void XQspiPs_GetReadData(XQspiPs *InstancePtr, u32 Data, u8 Size)
{
  u8 DataByte3;

  if (InstancePtr->RecvBufferPtr) {
    797c: e5903018  ldr r3, [r0, #24]
*
* @note   None.
*
******************************************************************************/
static void XQspiPs_GetReadData(XQspiPs *InstancePtr, u32 Data, u8 Size)
{
    7980: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
  u8 DataByte3;

  if (InstancePtr->RecvBufferPtr) {
    7984: e3530000  cmp r3, #0
    7988: 0a000005  beq 79a4 <XQspiPs_GetReadData+0x28>
    switch (Size) {
    798c: e3520002  cmp r2, #2
    7990: 0a00001f  beq 7a14 <XQspiPs_GetReadData+0x98>
    7994: e3520003  cmp r2, #3
    7998: 0a000008  beq 79c0 <XQspiPs_GetReadData+0x44>
    799c: e3520001  cmp r2, #1
    79a0: 0a000016  beq 7a00 <XQspiPs_GetReadData+0x84>
      /* This will never execute */
      break;
    }
  }
  InstancePtr->ShiftReadData  = 0;
  InstancePtr->RequestedBytes -= Size;
    79a4: e590301c  ldr r3, [r0, #28]
    default:
      /* This will never execute */
      break;
    }
  }
  InstancePtr->ShiftReadData  = 0;
    79a8: e3a01000  mov r1, #0
    79ac: e5801030  str r1, [r0, #48] ; 0x30
  InstancePtr->RequestedBytes -= Size;
    79b0: e0533002  subs  r3, r3, r2
    79b4: 41a03001  movmi r3, r1
    79b8: e580301c  str r3, [r0, #28]
    79bc: e49df004  pop {pc}    ; (ldr pc, [sp], #4)
          (Data & 0xFFFF);
      }
      InstancePtr->RecvBufferPtr += 2;
      break;
    case 3:
      if (InstancePtr->ShiftReadData == 1) {
    79c0: e590c030  ldr ip, [r0, #48] ; 0x30
    79c4: e35c0001  cmp ip, #1
        *((u16 *)InstancePtr->RecvBufferPtr) =
    79c8: e1a0c003  mov ip, r3
          ((Data & 0x00FFFF00) >> 8);
    79cc: 07efe451  ubfxeq  lr, r1, #8, #16
        InstancePtr->RecvBufferPtr += 2;
        DataByte3 = ((Data & 0xFF000000) >> 24);
        *((u8 *)InstancePtr->RecvBufferPtr) = DataByte3;
      } else {
        *((u16 *)InstancePtr->RecvBufferPtr) =
    79d0: 10cc10b2  strhne  r1, [ip], #2
      }
      InstancePtr->RecvBufferPtr += 2;
      break;
    case 3:
      if (InstancePtr->ShiftReadData == 1) {
        *((u16 *)InstancePtr->RecvBufferPtr) =
    79d4: 00cce0b2  strheq  lr, [ip], #2
          ((Data & 0x00FFFF00) >> 8);
        InstancePtr->RecvBufferPtr += 2;
        DataByte3 = ((Data & 0xFF000000) >> 24);
    79d8: 01a01c21  lsreq r1, r1, #24
      break;
    case 3:
      if (InstancePtr->ShiftReadData == 1) {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          ((Data & 0x00FFFF00) >> 8);
        InstancePtr->RecvBufferPtr += 2;
    79dc: 0580c018  streq ip, [r0, #24]
        *((u8 *)InstancePtr->RecvBufferPtr) = DataByte3;
      } else {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          (Data & 0xFFFF);
        InstancePtr->RecvBufferPtr += 2;
        DataByte3 = ((Data & 0x00FF0000) >> 16);
    79e0: 17e7e851  ubfxne  lr, r1, #16, #8
        DataByte3 = ((Data & 0xFF000000) >> 24);
        *((u8 *)InstancePtr->RecvBufferPtr) = DataByte3;
      } else {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          (Data & 0xFFFF);
        InstancePtr->RecvBufferPtr += 2;
    79e4: 1580c018  strne ip, [r0, #24]
    case 3:
      if (InstancePtr->ShiftReadData == 1) {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          ((Data & 0x00FFFF00) >> 8);
        InstancePtr->RecvBufferPtr += 2;
        DataByte3 = ((Data & 0xFF000000) >> 24);
    79e8: 05c31002  strbeq  r1, [r3, #2]
        *((u8 *)InstancePtr->RecvBufferPtr) = DataByte3;
      } else {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          (Data & 0xFFFF);
        InstancePtr->RecvBufferPtr += 2;
        DataByte3 = ((Data & 0x00FF0000) >> 16);
    79ec: 15c3e002  strbne  lr, [r3, #2]
        *((u8 *)InstancePtr->RecvBufferPtr) = DataByte3;
      }
      InstancePtr->RecvBufferPtr += 1;
    79f0: e5903018  ldr r3, [r0, #24]
    79f4: e2833001  add r3, r3, #1
    79f8: e5803018  str r3, [r0, #24]
      break;
    79fc: eaffffe8  b 79a4 <XQspiPs_GetReadData+0x28>
  u8 DataByte3;

  if (InstancePtr->RecvBufferPtr) {
    switch (Size) {
    case 1:
      if (InstancePtr->ShiftReadData == 1) {
    7a00: e590c030  ldr ip, [r0, #48] ; 0x30
    7a04: e35c0001  cmp ip, #1
        *((u8 *)InstancePtr->RecvBufferPtr) =
          ((Data & 0xFF000000) >> 24);
    7a08: 01a01c21  lsreq r1, r1, #24
      } else {
        *((u8 *)InstancePtr->RecvBufferPtr) =
    7a0c: e5c31000  strb  r1, [r3]
    7a10: eafffff6  b 79f0 <XQspiPs_GetReadData+0x74>
          (Data & 0xFF);
      }
      InstancePtr->RecvBufferPtr += 1;
      break;
    case 2:
      if (InstancePtr->ShiftReadData == 1) {
    7a14: e590c030  ldr ip, [r0, #48] ; 0x30
          ((Data & 0xFFFF0000) >> 16);
      } else  {
        *((u16 *)InstancePtr->RecvBufferPtr) =
          (Data & 0xFFFF);
      }
      InstancePtr->RecvBufferPtr += 2;
    7a18: e2833002  add r3, r3, #2
          (Data & 0xFF);
      }
      InstancePtr->RecvBufferPtr += 1;
      break;
    case 2:
      if (InstancePtr->ShiftReadData == 1) {
    7a1c: e35c0001  cmp ip, #1
        *((u16 *)InstancePtr->RecvBufferPtr) =
          ((Data & 0xFFFF0000) >> 16);
    7a20: 01a01821  lsreq r1, r1, #16
      } else  {
        *((u16 *)InstancePtr->RecvBufferPtr) =
    7a24: e14310b2  strh  r1, [r3, #-2]
          (Data & 0xFFFF);
      }
      InstancePtr->RecvBufferPtr += 2;
    7a28: e5803018  str r3, [r0, #24]
      break;
    7a2c: eaffffdc  b 79a4 <XQspiPs_GetReadData+0x28>

00007a30 <StubStatusHandler>:
{
  (void) CallBackRef;
  (void) StatusEvent;
  (void) ByteCount;

  Xil_AssertVoidAlways();
    7a30: e3080718  movw  r0, #34584  ; 0x8718
    7a34: e30014c2  movw  r1, #1218 ; 0x4c2
* @note   None.
*
******************************************************************************/
static void StubStatusHandler(void *CallBackRef, u32 StatusEvent,
        unsigned ByteCount)
{
    7a38: e92d4008  push  {r3, lr}
  (void) CallBackRef;
  (void) StatusEvent;
  (void) ByteCount;

  Xil_AssertVoidAlways();
    7a3c: e3400001  movt  r0, #1
    7a40: eb000592  bl  9090 <Xil_Assert>
    7a44: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7a48: e3403002  movt  r3, #2
    7a4c: e3a02001  mov r2, #1
    7a50: e5832000  str r2, [r3]
    7a54: e8bd8008  pop {r3, pc}

00007a58 <XQspiPs_Abort>:
* This function does a read/modify/write of the config register. The user of
* this function needs to take care of critical sections.
*
******************************************************************************/
void XQspiPs_Abort(XQspiPs *InstancePtr)
{
    7a58: e92d4038  push  {r3, r4, r5, lr}
    7a5c: e1a04000  mov r4, r0
  u32 ConfigReg;
  u32 IsLock;

  XQspiPs_Disable(InstancePtr);
    7a60: e5900004  ldr r0, [r0, #4]
    7a64: e3a01000  mov r1, #0
    7a68: e2800014  add r0, r0, #20
    7a6c: ebfff9cf  bl  61b0 <Xil_Out32>

  /*
   * De-assert slave select lines.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    7a70: e5940004  ldr r0, [r4, #4]
    7a74: ebfff9c7  bl  6198 <Xil_In32>
       XQSPIPS_CR_OFFSET);
  ConfigReg |= (XQSPIPS_CR_SSCTRL_MASK | XQSPIPS_CR_SSFORCE_MASK);
    7a78: e3801b11  orr r1, r0, #17408  ; 0x4400
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7a7c: e5940004  ldr r0, [r4, #4]
    7a80: ebfff9ca  bl  61b0 <Xil_Out32>
       XQSPIPS_CR_OFFSET, ConfigReg);

  /*
   * QSPI Software Reset
   */
  IsLock = XQspiPs_ReadReg(XPAR_XSLCR_0_BASEADDR, SLCR_LOCKSTA);
    7a84: e3a0000c  mov r0, #12
    7a88: e34f0800  movt  r0, #63488  ; 0xf800
    7a8c: ebfff9c1  bl  6198 <Xil_In32>
  if (IsLock) {
    7a90: e2505000  subs  r5, r0, #0
    7a94: 1a000014  bne 7aec <XQspiPs_Abort+0x94>
    XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, SLCR_UNLOCK,
        SLCR_UNLOCK_MASK);
  }
  XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, LQSPI_RST_CTRL,
    7a98: e3a00e23  mov r0, #560  ; 0x230
    7a9c: e3a01003  mov r1, #3
    7aa0: e34f0800  movt  r0, #63488  ; 0xf800
    7aa4: ebfff9c1  bl  61b0 <Xil_Out32>
      LQSPI_RST_CTRL_MASK);
  XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, LQSPI_RST_CTRL, 0x0);
    7aa8: e3a00e23  mov r0, #560  ; 0x230
    7aac: e1a01005  mov r1, r5
    7ab0: e34f0800  movt  r0, #63488  ; 0xf800
    7ab4: ebfff9bd  bl  61b0 <Xil_Out32>
  }

  /*
   * Set the RX and TX FIFO threshold to reset value (one)
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7ab8: e5940004  ldr r0, [r4, #4]
    7abc: e3a01001  mov r1, #1
    7ac0: e280002c  add r0, r0, #44 ; 0x2c
    7ac4: ebfff9b9  bl  61b0 <Xil_Out32>
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7ac8: e5940004  ldr r0, [r4, #4]
    7acc: e3a01001  mov r1, #1
    7ad0: e2800028  add r0, r0, #40 ; 0x28
    7ad4: ebfff9b5  bl  61b0 <Xil_Out32>
      XQSPIPS_TXWR_OFFSET, XQSPIPS_TXWR_RESET_VALUE);

  InstancePtr->RemainingBytes = 0;
    7ad8: e3a03000  mov r3, #0
    7adc: e5843020  str r3, [r4, #32]
  InstancePtr->RequestedBytes = 0;
    7ae0: e584301c  str r3, [r4, #28]
  InstancePtr->IsBusy = FALSE;
    7ae4: e5843024  str r3, [r4, #36] ; 0x24
    7ae8: e8bd8038  pop {r3, r4, r5, pc}
  /*
   * QSPI Software Reset
   */
  IsLock = XQspiPs_ReadReg(XPAR_XSLCR_0_BASEADDR, SLCR_LOCKSTA);
  if (IsLock) {
    XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, SLCR_UNLOCK,
    7aec: e3a00008  mov r0, #8
    7af0: e30d1f0d  movw  r1, #57101  ; 0xdf0d
    7af4: e34f0800  movt  r0, #63488  ; 0xf800
    7af8: ebfff9ac  bl  61b0 <Xil_Out32>
        SLCR_UNLOCK_MASK);
  }
  XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, LQSPI_RST_CTRL,
    7afc: e3a00e23  mov r0, #560  ; 0x230
    7b00: e34f0800  movt  r0, #63488  ; 0xf800
    7b04: e3a01003  mov r1, #3
    7b08: ebfff9a8  bl  61b0 <Xil_Out32>
      LQSPI_RST_CTRL_MASK);
  XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, LQSPI_RST_CTRL, 0x0);
    7b0c: e3a00e23  mov r0, #560  ; 0x230
    7b10: e34f0800  movt  r0, #63488  ; 0xf800
    7b14: e3a01000  mov r1, #0
    7b18: ebfff9a4  bl  61b0 <Xil_Out32>
  if (IsLock) {
    XQspiPs_WriteReg(XPAR_XSLCR_0_BASEADDR, SLCR_LOCK,
    7b1c: e3a00004  mov r0, #4
    7b20: e34f0800  movt  r0, #63488  ; 0xf800
    7b24: e307167b  movw  r1, #30331  ; 0x767b
    7b28: ebfff9a0  bl  61b0 <Xil_Out32>
    7b2c: eaffffe1  b 7ab8 <XQspiPs_Abort+0x60>

00007b30 <XQspiPs_Reset>:
*
* @note   None.
*
******************************************************************************/
void XQspiPs_Reset(XQspiPs *InstancePtr)
{
    7b30: e92d4038  push  {r3, r4, r5, lr}
  u32 ConfigReg;

  Xil_AssertVoid(InstancePtr != NULL);
    7b34: e2505000  subs  r5, r0, #0
    7b38: 0a000019  beq 7ba4 <XQspiPs_Reset+0x74>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7b3c: e5952010  ldr r2, [r5, #16]
    7b40: e3013111  movw  r3, #4369 ; 0x1111
    7b44: e3413111  movt  r3, #4369 ; 0x1111
******************************************************************************/
void XQspiPs_Reset(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertVoid(InstancePtr != NULL);
    7b48: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7b4c: e1520003  cmp r2, r3
******************************************************************************/
void XQspiPs_Reset(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertVoid(InstancePtr != NULL);
    7b50: e3404002  movt  r4, #2
    7b54: e3a03000  mov r3, #0
    7b58: e5843000  str r3, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7b5c: 0a000006  beq 7b7c <XQspiPs_Reset+0x4c>
    7b60: e3080718  movw  r0, #34584  ; 0x8718
    7b64: e3a01f43  mov r1, #268  ; 0x10c
    7b68: e3400001  movt  r0, #1
    7b6c: eb000547  bl  9090 <Xil_Assert>
    7b70: e3a03001  mov r3, #1
    7b74: e5843000  str r3, [r4]
    7b78: e8bd8038  pop {r3, r4, r5, pc}

  /*
   * Abort any transfer that is in progress
   */
  XQspiPs_Abort(InstancePtr);
    7b7c: ebffffb5  bl  7a58 <XQspiPs_Abort>

  /*
   * Write default value to configuration register.
   * Do not modify reserved bits.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    7b80: e5950004  ldr r0, [r5, #4]
    7b84: ebfff983  bl  6198 <Xil_In32>
       XQSPIPS_CR_OFFSET);
  ConfigReg |= XQSPIPS_CR_RESET_MASK_SET;
  ConfigReg &= ~XQSPIPS_CR_RESET_MASK_CLR;
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress, XQSPIPS_CR_OFFSET,
    7b88: e30414c1  movw  r1, #17601  ; 0x44c1
    7b8c: e3481008  movt  r1, #32776  ; 0x8008
   * Do not modify reserved bits.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
       XQSPIPS_CR_OFFSET);
  ConfigReg |= XQSPIPS_CR_RESET_MASK_SET;
  ConfigReg &= ~XQSPIPS_CR_RESET_MASK_CLR;
    7b90: e3c03002  bic r3, r0, #2
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress, XQSPIPS_CR_OFFSET,
    7b94: e5950004  ldr r0, [r5, #4]
    7b98: e1831001  orr r1, r3, r1
        ConfigReg);
}
    7b9c: e8bd4038  pop {r3, r4, r5, lr}
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
       XQSPIPS_CR_OFFSET);
  ConfigReg |= XQSPIPS_CR_RESET_MASK_SET;
  ConfigReg &= ~XQSPIPS_CR_RESET_MASK_CLR;
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress, XQSPIPS_CR_OFFSET,
    7ba0: eafff982  b 61b0 <Xil_Out32>
******************************************************************************/
void XQspiPs_Reset(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertVoid(InstancePtr != NULL);
    7ba4: e3080718  movw  r0, #34584  ; 0x8718
    7ba8: e300110b  movw  r1, #267  ; 0x10b
    7bac: e3400001  movt  r0, #1
    7bb0: eb000536  bl  9090 <Xil_Assert>
    7bb4: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7bb8: e3403002  movt  r3, #2
    7bbc: e3a02001  mov r2, #1
    7bc0: e5832000  str r2, [r3]
    7bc4: e8bd8038  pop {r3, r4, r5, pc}

00007bc8 <XQspiPs_CfgInitialize>:
* @note   None.
*
******************************************************************************/
int XQspiPs_CfgInitialize(XQspiPs *InstancePtr, XQspiPs_Config *ConfigPtr,
        u32 EffectiveAddr)
{
    7bc8: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  Xil_AssertNonvoid(InstancePtr != NULL);
    7bcc: e2505000  subs  r5, r0, #0
    7bd0: 0a00001c  beq 7c48 <XQspiPs_CfgInitialize+0x80>
    7bd4: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(ConfigPtr != NULL);
    7bd8: e3510000  cmp r1, #0
*
******************************************************************************/
int XQspiPs_CfgInitialize(XQspiPs *InstancePtr, XQspiPs_Config *ConfigPtr,
        u32 EffectiveAddr)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    7bdc: e3406002  movt  r6, #2
    7be0: e3a04000  mov r4, #0
    7be4: e1a07001  mov r7, r1
    7be8: e5864000  str r4, [r6]
  Xil_AssertNonvoid(ConfigPtr != NULL);
    7bec: 0a00001f  beq 7c70 <XQspiPs_CfgInitialize+0xa8>
   * If the device is busy, disallow the initialize and return a status
   * indicating it is already started. This allows the user to stop the
   * device and re-initialize, but prevents a user from inadvertently
   * initializing. This assumes the busy flag is cleared at startup.
   */
  if (InstancePtr->IsBusy == TRUE) {
    7bf0: e5953024  ldr r3, [r5, #36] ; 0x24
    7bf4: e3530001  cmp r3, #1
    7bf8: 1a000001  bne 7c04 <XQspiPs_CfgInitialize+0x3c>
    return XST_DEVICE_IS_STARTED;
    7bfc: e3a00005  mov r0, #5
   * initialization is done, but before the device is started.
   */
  XQspiPs_Reset(InstancePtr);

  return XST_SUCCESS;
}
    7c00: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
   * Set some default values.
   */
  InstancePtr->IsBusy = FALSE;

  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->StatusHandler = StubStatusHandler;
    7c04: e3071a30  movw  r1, #31280  ; 0x7a30
  }

  /*
   * Set some default values.
   */
  InstancePtr->IsBusy = FALSE;
    7c08: e5854024  str r4, [r5, #36] ; 0x24

  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->StatusHandler = StubStatusHandler;

  InstancePtr->SendBufferPtr = NULL;
    7c0c: e5854014  str r4, [r5, #20]
   * Set some default values.
   */
  InstancePtr->IsBusy = FALSE;

  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->StatusHandler = StubStatusHandler;
    7c10: e3401000  movt  r1, #0

  InstancePtr->SendBufferPtr = NULL;
  InstancePtr->RecvBufferPtr = NULL;
    7c14: e5854018  str r4, [r5, #24]
  InstancePtr->RequestedBytes = 0;
  InstancePtr->RemainingBytes = 0;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    7c18: e3013111  movw  r3, #4369 ; 0x1111
  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->StatusHandler = StubStatusHandler;

  InstancePtr->SendBufferPtr = NULL;
  InstancePtr->RecvBufferPtr = NULL;
  InstancePtr->RequestedBytes = 0;
    7c1c: e585401c  str r4, [r5, #28]
  InstancePtr->RemainingBytes = 0;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    7c20: e7df3813  bfi r3, r3, #16, #16
  InstancePtr->StatusHandler = StubStatusHandler;

  InstancePtr->SendBufferPtr = NULL;
  InstancePtr->RecvBufferPtr = NULL;
  InstancePtr->RequestedBytes = 0;
  InstancePtr->RemainingBytes = 0;
    7c24: e5854020  str r4, [r5, #32]
   * Set some default values.
   */
  InstancePtr->IsBusy = FALSE;

  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->StatusHandler = StubStatusHandler;
    7c28: e5851028  str r1, [r5, #40] ; 0x28

  InstancePtr->SendBufferPtr = NULL;
  InstancePtr->RecvBufferPtr = NULL;
  InstancePtr->RequestedBytes = 0;
  InstancePtr->RemainingBytes = 0;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
    7c2c: e5853010  str r3, [r5, #16]

  InstancePtr->Config.ConnectionMode = ConfigPtr->ConnectionMode;
    7c30: e5d7300c  ldrb  r3, [r7, #12]
  /*
   * Set some default values.
   */
  InstancePtr->IsBusy = FALSE;

  InstancePtr->Config.BaseAddress = EffectiveAddr;
    7c34: e5852004  str r2, [r5, #4]
  InstancePtr->RecvBufferPtr = NULL;
  InstancePtr->RequestedBytes = 0;
  InstancePtr->RemainingBytes = 0;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;

  InstancePtr->Config.ConnectionMode = ConfigPtr->ConnectionMode;
    7c38: e5c5300c  strb  r3, [r5, #12]
  /*
   * Reset the QSPI device to get it into its initial state. It is
   * expected that device configuration will take place after this
   * initialization is done, but before the device is started.
   */
  XQspiPs_Reset(InstancePtr);
    7c3c: ebffffbb  bl  7b30 <XQspiPs_Reset>

  return XST_SUCCESS;
    7c40: e1a00004  mov r0, r4
    7c44: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
*
******************************************************************************/
int XQspiPs_CfgInitialize(XQspiPs *InstancePtr, XQspiPs_Config *ConfigPtr,
        u32 EffectiveAddr)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    7c48: e3080718  movw  r0, #34584  ; 0x8718
    7c4c: e3a010d0  mov r1, #208  ; 0xd0
    7c50: e3400001  movt  r0, #1
    7c54: eb00050d  bl  9090 <Xil_Assert>
    7c58: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7c5c: e3403002  movt  r3, #2
    7c60: e3a02001  mov r2, #1
    7c64: e1a00005  mov r0, r5
    7c68: e5832000  str r2, [r3]
    7c6c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  Xil_AssertNonvoid(ConfigPtr != NULL);
    7c70: e3080718  movw  r0, #34584  ; 0x8718
    7c74: e3a010d1  mov r1, #209  ; 0xd1
    7c78: e3400001  movt  r0, #1
    7c7c: eb000503  bl  9090 <Xil_Assert>
    7c80: e3a03001  mov r3, #1
    7c84: e1a00007  mov r0, r7
    7c88: e5863000  str r3, [r6]
    7c8c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

00007c90 <XQspiPs_Transfer>:
* no two threads are transferring data on the QSPI bus at the same time.
*
******************************************************************************/
int XQspiPs_Transfer(XQspiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr,
      unsigned ByteCount)
{
    7c90: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
  CurrInst = &NewInst[0];

  /*
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7c94: e2504000  subs  r4, r0, #0
* no two threads are transferring data on the QSPI bus at the same time.
*
******************************************************************************/
int XQspiPs_Transfer(XQspiPs *InstancePtr, u8 *SendBufPtr, u8 *RecvBufPtr,
      unsigned ByteCount)
{
    7c98: e24dd008  sub sp, sp, #8
  CurrInst = &NewInst[0];

  /*
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7c9c: 0a0000ae  beq 7f5c <XQspiPs_Transfer+0x2cc>
    7ca0: e3028ae8  movw  r8, #10984  ; 0x2ae8
  Xil_AssertNonvoid(SendBufPtr != NULL);
    7ca4: e3510000  cmp r1, #0
  CurrInst = &NewInst[0];

  /*
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7ca8: e3408002  movt  r8, #2
    7cac: e3a05000  mov r5, #0
    7cb0: e1a07001  mov r7, r1
    7cb4: e5885000  str r5, [r8]
  Xil_AssertNonvoid(SendBufPtr != NULL);
    7cb8: 0a0000b1  beq 7f84 <XQspiPs_Transfer+0x2f4>
  Xil_AssertNonvoid(ByteCount > 0);
    7cbc: e3530000  cmp r3, #0
    7cc0: e1a06003  mov r6, r3
    7cc4: 0a000013  beq 7d18 <XQspiPs_Transfer+0x88>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7cc8: e5941010  ldr r1, [r4, #16]
    7ccc: e3013111  movw  r3, #4369 ; 0x1111
    7cd0: e3413111  movt  r3, #4369 ; 0x1111
    7cd4: e1510003  cmp r1, r3
    7cd8: 1a000005  bne 7cf4 <XQspiPs_Transfer+0x64>

  /*
   * Check whether there is another transfer in progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    7cdc: e5945024  ldr r5, [r4, #36] ; 0x24
    7ce0: e3550000  cmp r5, #0
    return XST_DEVICE_BUSY;
    7ce4: 13a00015  movne r0, #21
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Check whether there is another transfer in progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    7ce8: 0a000013  beq 7d3c <XQspiPs_Transfer+0xac>
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
}
    7cec: e28dd008  add sp, sp, #8
    7cf0: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(SendBufPtr != NULL);
  Xil_AssertNonvoid(ByteCount > 0);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    7cf4: e3080718  movw  r0, #34584  ; 0x8718
    7cf8: e30011b3  movw  r1, #435  ; 0x1b3
    7cfc: e3400001  movt  r0, #1
    7d00: eb0004e2  bl  9090 <Xil_Assert>
    7d04: e1a00005  mov r0, r5
    7d08: e3a03001  mov r3, #1
    7d0c: e5883000  str r3, [r8]
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
}
    7d10: e28dd008  add sp, sp, #8
    7d14: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  /*
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(SendBufPtr != NULL);
  Xil_AssertNonvoid(ByteCount > 0);
    7d18: e3080718  movw  r0, #34584  ; 0x8718
    7d1c: e30011b2  movw  r1, #434  ; 0x1b2
    7d20: e3400001  movt  r0, #1
    7d24: eb0004d9  bl  9090 <Xil_Assert>
    7d28: e1a00006  mov r0, r6
    7d2c: e3a03001  mov r3, #1
    7d30: e5883000  str r3, [r8]
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
}
    7d34: e28dd008  add sp, sp, #8
    7d38: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    7d3c: e30b832c  movw  r8, #45868  ; 0xb32c
  InstancePtr->IsBusy = TRUE;

  /*
   * Set up buffer pointers.
   */
  InstancePtr->SendBufferPtr = SendBufPtr;
    7d40: e5847014  str r7, [r4, #20]

  /*
   * Set the busy flag, which will be cleared in the ISR when the
   * transfer is entirely done.
   */
  InstancePtr->IsBusy = TRUE;
    7d44: e3a03001  mov r3, #1

  /*
   * Set up buffer pointers.
   */
  InstancePtr->SendBufferPtr = SendBufPtr;
  InstancePtr->RecvBufferPtr = RecvBufPtr;
    7d48: e5842018  str r2, [r4, #24]

  InstancePtr->RequestedBytes = ByteCount;
    7d4c: e584601c  str r6, [r4, #28]
    7d50: e3408001  movt  r8, #1
  InstancePtr->RemainingBytes = ByteCount;
    7d54: e5846020  str r6, [r4, #32]

  /*
   * Set the busy flag, which will be cleared in the ISR when the
   * transfer is entirely done.
   */
  InstancePtr->IsBusy = TRUE;
    7d58: e5843024  str r3, [r4, #36] ; 0x24

  /*
   * The first byte with every chip-select assertion is always
   * expected to be an instruction for flash interface mode
   */
  Instruction = *InstancePtr->SendBufferPtr;
    7d5c: e5d77000  ldrb  r7, [r7]
    7d60: ea000002  b 7d70 <XQspiPs_Transfer+0xe0>

  for (Index = 0 ; Index < ARRAY_SIZE(FlashInst); Index++) {
    7d64: e2855001  add r5, r5, #1
    7d68: e355001a  cmp r5, #26
    7d6c: 0a000003  beq 7d80 <XQspiPs_Transfer+0xf0>
    7d70: e0852085  add r2, r5, r5, lsl #1
    if (Instruction == FlashInst[Index].OpCode) {
    7d74: e7d82002  ldrb  r2, [r8, r2]
    7d78: e1520007  cmp r2, r7
    7d7c: 1afffff8  bne 7d64 <XQspiPs_Transfer+0xd4>
  }

  /*
   * Set the RX FIFO threshold
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7d80: e5940004  ldr r0, [r4, #4]
    7d84: e3a01020  mov r1, #32
    7d88: e280002c  add r0, r0, #44 ; 0x2c
    7d8c: ebfff907  bl  61b0 <Xil_Out32>

  /*
   * If the slave select is "Forced" or under manual control,
   * set the slave select now, before beginning the transfer.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    7d90: e1a00004  mov r0, r4
    7d94: eb0003c7  bl  8cb8 <XQspiPs_GetOptions>
    7d98: e3100010  tst r0, #16
    7d9c: 1a000080  bne 7fa4 <XQspiPs_Transfer+0x314>
  }

  /*
   * Enable the device.
   */
  XQspiPs_Enable(InstancePtr);
    7da0: e5940004  ldr r0, [r4, #4]
    7da4: e3a01001  mov r1, #1
    7da8: e2800014  add r0, r0, #20
    7dac: ebfff8ff  bl  61b0 <Xil_Out32>

  /*
   * Clear all the interrrupts.
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress, XQSPIPS_SR_OFFSET,
    7db0: e5940004  ldr r0, [r4, #4]
    7db4: e3a01041  mov r1, #65 ; 0x41
    7db8: e2800004  add r0, r0, #4
    7dbc: ebfff8fb  bl  61b0 <Xil_Out32>
      XQSPIPS_IXR_WR_TO_CLR_MASK);

  if (Index < ARRAY_SIZE(FlashInst)) {
    7dc0: e355001a  cmp r5, #26
    7dc4: 0a00004b  beq 7ef8 <XQspiPs_Transfer+0x268>
    CurrInst = &FlashInst[Index];
    7dc8: e1a03085  lsl r3, r5, #1
    7dcc: e0832005  add r2, r3, r5
    7dd0: e088e002  add lr, r8, r2
    /*
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
    7dd4: e7d82002  ldrb  r2, [r8, r2]
    7dd8: e3560003  cmp r6, #3
    7ddc: 03520001  cmpeq r2, #1
    7de0: 0a000095  beq 803c <XQspiPs_Transfer+0x3ac>
    7de4: e0835005  add r5, r3, r5
    7de8: e0885005  add r5, r8, r5

  /*
   * If the instruction size in not 4 bytes then the data received needs
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    7dec: e5d53001  ldrb  r3, [r5, #1]
    7df0: e3530004  cmp r3, #4
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7df4: 13a06000  movne r6, #0

  /*
   * If the instruction size in not 4 bytes then the data received needs
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    7df8: 0a00004b  beq 7f2c <XQspiPs_Transfer+0x29c>
    InstancePtr->ShiftReadData = 1;
    7dfc: e3a03001  mov r3, #1
    7e00: e5843030  str r3, [r4, #48] ; 0x30
  } else {
    InstancePtr->ShiftReadData = 0;
  }

  /* Get the complete command (flash inst + address/data) */
  Data = *((u32 *)InstancePtr->SendBufferPtr);
    7e04: e5942014  ldr r2, [r4, #20]
  InstancePtr->SendBufferPtr += CurrInst->InstSize;
    7e08: e5de3001  ldrb  r3, [lr, #1]
  InstancePtr->RemainingBytes -= CurrInst->InstSize;
    7e0c: e594c020  ldr ip, [r4, #32]
  } else {
    InstancePtr->ShiftReadData = 0;
  }

  /* Get the complete command (flash inst + address/data) */
  Data = *((u32 *)InstancePtr->SendBufferPtr);
    7e10: e5921000  ldr r1, [r2]
  InstancePtr->SendBufferPtr += CurrInst->InstSize;
    7e14: e0822003  add r2, r2, r3
    7e18: e5842014  str r2, [r4, #20]
  InstancePtr->RemainingBytes -= CurrInst->InstSize;
    7e1c: e5de2001  ldrb  r2, [lr, #1]
  if (InstancePtr->RemainingBytes < 0) {
    7e20: e05cc002  subs  ip, ip, r2
  }

  /* Get the complete command (flash inst + address/data) */
  Data = *((u32 *)InstancePtr->SendBufferPtr);
  InstancePtr->SendBufferPtr += CurrInst->InstSize;
  InstancePtr->RemainingBytes -= CurrInst->InstSize;
    7e24: 5584c020  strpl ip, [r4, #32]
  if (InstancePtr->RemainingBytes < 0) {
    InstancePtr->RemainingBytes = 0;
    7e28: 43a03000  movmi r3, #0
    7e2c: 45843020  strmi r3, [r4, #32]
  }

  /* Write the command to the FIFO */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7e30: e5943004  ldr r3, [r4, #4]
    7e34: e5de0002  ldrb  r0, [lr, #2]
    7e38: e0800003  add r0, r0, r3
    7e3c: ebfff8db  bl  61b0 <Xil_Out32>

  /*
   * If switching from TXD1/2/3 to TXD0, then start transfer and
   * check for FIFO empty
   */
  if(SwitchFlag == 1) {
    7e40: e3560001  cmp r6, #1
    7e44: 0a00005c  beq 7fbc <XQspiPs_Transfer+0x32c>

  /*
   * Fill the Tx FIFO with as many bytes as it takes (or as many as
   * we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    7e48: e5943020  ldr r3, [r4, #32]
    7e4c: e3530000  cmp r3, #0
    7e50: c5943014  ldrgt r3, [r4, #20]
    7e54: c3a05001  movgt r5, #1
    7e58: da000017  ble 7ebc <XQspiPs_Transfer+0x22c>
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7e5c: e5940004  ldr r0, [r4, #4]
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    }
    TransCount++;
    7e60: e2855001  add r5, r5, #1
   * Fill the Tx FIFO with as many bytes as it takes (or as many as
   * we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7e64: e5931000  ldr r1, [r3]
    7e68: e280001c  add r0, r0, #28
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    }
    TransCount++;
    7e6c: e6ef5075  uxtb  r5, r5
   * Fill the Tx FIFO with as many bytes as it takes (or as many as
   * we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7e70: ebfff8ce  bl  61b0 <Xil_Out32>
          XQSPIPS_TXD_00_OFFSET,
          *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    7e74: e5942020  ldr r2, [r4, #32]
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_TXD_00_OFFSET,
          *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    7e78: e5943014  ldr r3, [r4, #20]
    InstancePtr->RemainingBytes -= 4;
    7e7c: e2422004  sub r2, r2, #4
    7e80: e5842020  str r2, [r4, #32]
    if (InstancePtr->RemainingBytes < 0) {
    7e84: e3520000  cmp r2, #0
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_TXD_00_OFFSET,
          *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    7e88: e2833004  add r3, r3, #4
    7e8c: e5843014  str r3, [r4, #20]

  /*
   * Fill the Tx FIFO with as many bytes as it takes (or as many as
   * we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    7e90: c3a02001  movgt r2, #1
    7e94: d3a02000  movle r2, #0
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_TXD_00_OFFSET,
          *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
    7e98: ba000005  blt 7eb4 <XQspiPs_Transfer+0x224>

  /*
   * Fill the Tx FIFO with as many bytes as it takes (or as many as
   * we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    7e9c: e355003f  cmp r5, #63 ; 0x3f
    7ea0: 03a02000  moveq r2, #0
    7ea4: 12022001  andne r2, r2, #1
    7ea8: e3520000  cmp r2, #0
    7eac: 1affffea  bne 7e5c <XQspiPs_Transfer+0x1cc>
    7eb0: ea000001  b 7ebc <XQspiPs_Transfer+0x22c>
          XQSPIPS_TXD_00_OFFSET,
          *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    7eb4: e3a03000  mov r3, #0
    7eb8: e5843020  str r3, [r4, #32]

  /*
   * Enable QSPI interrupts (connecting to the interrupt controller and
   * enabling interrupts should have been done by the caller).
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7ebc: e5940004  ldr r0, [r4, #4]
    7ec0: e3a01055  mov r1, #85 ; 0x55
    7ec4: e2800008  add r0, r0, #8
    7ec8: ebfff8b8  bl  61b0 <Xil_Out32>
        XQSPIPS_IXR_TXUF_MASK);

  /*
   * If, in Manual Start mode, Start the transfer.
   */
  if (XQspiPs_IsManualStart(InstancePtr)) {
    7ecc: e1a00004  mov r0, r4
    7ed0: eb000378  bl  8cb8 <XQspiPs_GetOptions>
    7ed4: e2100020  ands  r0, r0, #32
    7ed8: 0affff83  beq 7cec <XQspiPs_Transfer+0x5c>
    ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    7edc: e5940004  ldr r0, [r4, #4]
    7ee0: ebfff8ac  bl  6198 <Xil_In32>
        XQSPIPS_CR_OFFSET);
    ConfigReg |= XQSPIPS_CR_MANSTRT_MASK;
    7ee4: e3801801  orr r1, r0, #65536  ; 0x10000
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7ee8: e5940004  ldr r0, [r4, #4]
    7eec: ebfff8af  bl  61b0 <Xil_Out32>
          XQSPIPS_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
    7ef0: e3a00000  mov r0, #0
    7ef4: eaffff7c  b 7cec <XQspiPs_Transfer+0x5c>
     * 4 bytes is not the actual size, but is indicative of
     * the TXD register used.
     * The remaining bytes of the instruction will be transmitted
     * through TXD0 below.
     */
    switch(ByteCount%4)
    7ef8: e2063003  and r3, r6, #3
    7efc: e3530002  cmp r3, #2
    7f00: 0a00003f  beq 8004 <XQspiPs_Transfer+0x374>
    7f04: e3530003  cmp r3, #3
    7f08: 0a00000a  beq 7f38 <XQspiPs_Transfer+0x2a8>
    7f0c: e3530001  cmp r3, #1
    7f10: 0a000033  beq 7fe4 <XQspiPs_Transfer+0x354>
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;

  CurrInst = &NewInst[0];
    7f14: e1a0e00d  mov lr, sp
          SwitchFlag = 1;
        }
        break;
      default:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_FOUR;
    7f18: e3a02004  mov r2, #4
        CurrInst->TxOffset = XQSPIPS_TXD_00_OFFSET;
    7f1c: e3a0301c  mov r3, #28
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      default:
        CurrInst->OpCode = Instruction;
    7f20: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_FOUR;
    7f24: e5cd2001  strb  r2, [sp, #1]
        CurrInst->TxOffset = XQSPIPS_TXD_00_OFFSET;
    7f28: e5cd3002  strb  r3, [sp, #2]
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    InstancePtr->ShiftReadData = 1;
  } else {
    InstancePtr->ShiftReadData = 0;
    7f2c: e3a06000  mov r6, #0
    7f30: e5846030  str r6, [r4, #48] ; 0x30
    7f34: eaffffb2  b 7e04 <XQspiPs_Transfer+0x174>
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7f38: e3560004  cmp r6, #4
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
    7f3c: e5cd3001  strb  r3, [sp, #1]
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
    7f40: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
        CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    7f44: e3e03077  mvn r3, #119  ; 0x77
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7f48: 93a06000  movls r6, #0
    7f4c: 83a06001  movhi r6, #1
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
        CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    7f50: e5cd3002  strb  r3, [sp, #2]
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7f54: e1a0e00d  mov lr, sp
    7f58: eaffffa7  b 7dfc <XQspiPs_Transfer+0x16c>
  CurrInst = &NewInst[0];

  /*
   * The RecvBufPtr argument can be null
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    7f5c: e3080718  movw  r0, #34584  ; 0x8718
    7f60: e3a01e1b  mov r1, #432  ; 0x1b0
    7f64: e3400001  movt  r0, #1
    7f68: eb000448  bl  9090 <Xil_Assert>
    7f6c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    7f70: e3403002  movt  r3, #2
    7f74: e3a02001  mov r2, #1
    7f78: e1a00004  mov r0, r4
    7f7c: e5832000  str r2, [r3]
    7f80: eaffff59  b 7cec <XQspiPs_Transfer+0x5c>
  Xil_AssertNonvoid(SendBufPtr != NULL);
    7f84: e3080718  movw  r0, #34584  ; 0x8718
    7f88: e30011b1  movw  r1, #433  ; 0x1b1
    7f8c: e3400001  movt  r0, #1
    7f90: eb00043e  bl  9090 <Xil_Assert>
    7f94: e3a03001  mov r3, #1
    7f98: e1a00007  mov r0, r7
    7f9c: e5883000  str r3, [r8]
    7fa0: eaffff51  b 7cec <XQspiPs_Transfer+0x5c>
  /*
   * If the slave select is "Forced" or under manual control,
   * set the slave select now, before beginning the transfer.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    7fa4: e5940004  ldr r0, [r4, #4]
    7fa8: ebfff87a  bl  6198 <Xil_In32>
         XQSPIPS_CR_OFFSET);
    ConfigReg &= ~XQSPIPS_CR_SSCTRL_MASK;
    7fac: e3c01b01  bic r1, r0, #1024 ; 0x400
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    7fb0: e5940004  ldr r0, [r4, #4]
    7fb4: ebfff87d  bl  61b0 <Xil_Out32>
    7fb8: eaffff78  b 7da0 <XQspiPs_Transfer+0x110>
  if(SwitchFlag == 1) {
    SwitchFlag = 0;
    /*
     * If, in Manual Start mode, start the transfer.
     */
    if (XQspiPs_IsManualStart(InstancePtr)) {
    7fbc: e1a00004  mov r0, r4
    7fc0: eb00033c  bl  8cb8 <XQspiPs_GetOptions>
    7fc4: e3100020  tst r0, #32
    7fc8: 1a000015  bne 8024 <XQspiPs_Transfer+0x394>
    }
    /*
     * Wait for the transfer to finish by polling Tx fifo status.
     */
    do {
      StatusReg = XQspiPs_ReadReg(
    7fcc: e5940004  ldr r0, [r4, #4]
    7fd0: e2800004  add r0, r0, #4
    7fd4: ebfff86f  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
          XQSPIPS_SR_OFFSET);
    } while ((StatusReg & XQSPIPS_IXR_TXOW_MASK) == 0);
    7fd8: e3100004  tst r0, #4
    7fdc: 0afffffa  beq 7fcc <XQspiPs_Transfer+0x33c>
    7fe0: eaffff98  b 7e48 <XQspiPs_Transfer+0x1b8>
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7fe4: e3560004  cmp r6, #4
     */
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
    7fe8: e5cd3001  strb  r3, [sp, #1]
     * through TXD0 below.
     */
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
    7fec: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
        CurrInst->TxOffset = XQSPIPS_TXD_01_OFFSET;
    7ff0: e3e0307f  mvn r3, #127  ; 0x7f
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    7ff4: 93a06000  movls r6, #0
    7ff8: 83a06001  movhi r6, #1
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
        CurrInst->TxOffset = XQSPIPS_TXD_01_OFFSET;
    7ffc: e5cd3002  strb  r3, [sp, #2]
    8000: eaffffd3  b 7f54 <XQspiPs_Transfer+0x2c4>
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8004: e3560004  cmp r6, #4
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
    8008: e5cd3001  strb  r3, [sp, #1]
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
    800c: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
        CurrInst->TxOffset = XQSPIPS_TXD_10_OFFSET;
    8010: e3e0307b  mvn r3, #123  ; 0x7b
  u32 Data;
  unsigned int Index;
  u8 TransCount = 0;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8014: 93a06000  movls r6, #0
    8018: 83a06001  movhi r6, #1
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
        CurrInst->TxOffset = XQSPIPS_TXD_10_OFFSET;
    801c: e5cd3002  strb  r3, [sp, #2]
    8020: eaffffcb  b 7f54 <XQspiPs_Transfer+0x2c4>
    SwitchFlag = 0;
    /*
     * If, in Manual Start mode, start the transfer.
     */
    if (XQspiPs_IsManualStart(InstancePtr)) {
      ConfigReg = XQspiPs_ReadReg(
    8024: e5940004  ldr r0, [r4, #4]
    8028: ebfff85a  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
           XQSPIPS_CR_OFFSET);
      ConfigReg |= XQSPIPS_CR_MANSTRT_MASK;
    802c: e3801801  orr r1, r0, #65536  ; 0x10000
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8030: e5940004  ldr r0, [r4, #4]
    8034: ebfff85d  bl  61b0 <Xil_Out32>
    8038: eaffffe3  b 7fcc <XQspiPs_Transfer+0x33c>
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
      (ByteCount == 3) ) {
      CurrInst->InstSize = 3;
    803c: e3a01003  mov r1, #3
      CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    8040: e3e02077  mvn r2, #119  ; 0x77
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
      (ByteCount == 3) ) {
      CurrInst->InstSize = 3;
    8044: e5ce1001  strb  r1, [lr, #1]
      CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    8048: e5ce2002  strb  r2, [lr, #2]
    804c: eaffff64  b 7de4 <XQspiPs_Transfer+0x154>

00008050 <XQspiPs_PolledTransfer>:
* no two threads are transferring data on the QSPI bus at the same time.
*
******************************************************************************/
int XQspiPs_PolledTransfer(XQspiPs *InstancePtr, u8 *SendBufPtr,
          u8 *RecvBufPtr, unsigned ByteCount)
{
    8050: e92d41f0  push  {r4, r5, r6, r7, r8, lr}

  CurrInst = &NewInst[0];
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    8054: e2504000  subs  r4, r0, #0
* no two threads are transferring data on the QSPI bus at the same time.
*
******************************************************************************/
int XQspiPs_PolledTransfer(XQspiPs *InstancePtr, u8 *SendBufPtr,
          u8 *RecvBufPtr, unsigned ByteCount)
{
    8058: e24dd008  sub sp, sp, #8

  CurrInst = &NewInst[0];
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    805c: 0a0000fb  beq 8450 <XQspiPs_PolledTransfer+0x400>
    8060: e3028ae8  movw  r8, #10984  ; 0x2ae8
  Xil_AssertNonvoid(SendBufPtr != NULL);
    8064: e3510000  cmp r1, #0

  CurrInst = &NewInst[0];
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    8068: e3408002  movt  r8, #2
    806c: e3a05000  mov r5, #0
    8070: e1a07001  mov r7, r1
    8074: e5885000  str r5, [r8]
  Xil_AssertNonvoid(SendBufPtr != NULL);
    8078: 0a000113  beq 84cc <XQspiPs_PolledTransfer+0x47c>
  Xil_AssertNonvoid(ByteCount > 0);
    807c: e3530000  cmp r3, #0
    8080: e1a06003  mov r6, r3
    8084: 0a000013  beq 80d8 <XQspiPs_PolledTransfer+0x88>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8088: e5941010  ldr r1, [r4, #16]
    808c: e3013111  movw  r3, #4369 ; 0x1111
    8090: e3413111  movt  r3, #4369 ; 0x1111
    8094: e1510003  cmp r1, r3
    8098: 1a000005  bne 80b4 <XQspiPs_PolledTransfer+0x64>

  /*
   * Check whether there is another transfer in progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    809c: e5945024  ldr r5, [r4, #36] ; 0x24
    80a0: e3550000  cmp r5, #0
    return XST_DEVICE_BUSY;
    80a4: 13a00015  movne r0, #21
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Check whether there is another transfer in progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    80a8: 0a000013  beq 80fc <XQspiPs_PolledTransfer+0xac>
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

  return XST_SUCCESS;
}
    80ac: e28dd008  add sp, sp, #8
    80b0: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(SendBufPtr != NULL);
  Xil_AssertNonvoid(ByteCount > 0);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    80b4: e3080718  movw  r0, #34584  ; 0x8718
    80b8: e30012d6  movw  r1, #726  ; 0x2d6
    80bc: e3400001  movt  r0, #1
    80c0: eb0003f2  bl  9090 <Xil_Assert>
    80c4: e1a00005  mov r0, r5
    80c8: e3a03001  mov r3, #1
    80cc: e5883000  str r3, [r8]
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

  return XST_SUCCESS;
}
    80d0: e28dd008  add sp, sp, #8
    80d4: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(SendBufPtr != NULL);
  Xil_AssertNonvoid(ByteCount > 0);
    80d8: e3080718  movw  r0, #34584  ; 0x8718
    80dc: e30012d5  movw  r1, #725  ; 0x2d5
    80e0: e3400001  movt  r0, #1
    80e4: eb0003e9  bl  9090 <Xil_Assert>
    80e8: e1a00006  mov r0, r6
    80ec: e3a03001  mov r3, #1
    80f0: e5883000  str r3, [r8]
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

  return XST_SUCCESS;
}
    80f4: e28dd008  add sp, sp, #8
    80f8: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    80fc: e30b832c  movw  r8, #45868  ; 0xb32c
  InstancePtr->IsBusy = TRUE;

  /*
   * Set up buffer pointers.
   */
  InstancePtr->SendBufferPtr = SendBufPtr;
    8100: e5847014  str r7, [r4, #20]

  /*
   * Set the busy flag, which will be cleared when the transfer is
   * entirely done.
   */
  InstancePtr->IsBusy = TRUE;
    8104: e3a03001  mov r3, #1

  /*
   * Set up buffer pointers.
   */
  InstancePtr->SendBufferPtr = SendBufPtr;
  InstancePtr->RecvBufferPtr = RecvBufPtr;
    8108: e5842018  str r2, [r4, #24]

  InstancePtr->RequestedBytes = ByteCount;
    810c: e584601c  str r6, [r4, #28]
    8110: e3408001  movt  r8, #1
  InstancePtr->RemainingBytes = ByteCount;
    8114: e5846020  str r6, [r4, #32]

  /*
   * Set the busy flag, which will be cleared when the transfer is
   * entirely done.
   */
  InstancePtr->IsBusy = TRUE;
    8118: e5843024  str r3, [r4, #36] ; 0x24

  /*
   * The first byte with every chip-select assertion is always
   * expected to be an instruction for flash interface mode
   */
  Instruction = *InstancePtr->SendBufferPtr;
    811c: e5d77000  ldrb  r7, [r7]
    8120: ea000002  b 8130 <XQspiPs_PolledTransfer+0xe0>

  for (Index = 0 ; Index < ARRAY_SIZE(FlashInst); Index++) {
    8124: e2855001  add r5, r5, #1
    8128: e355001a  cmp r5, #26
    812c: 0a000003  beq 8140 <XQspiPs_PolledTransfer+0xf0>
    8130: e0852085  add r2, r5, r5, lsl #1
    if (Instruction == FlashInst[Index].OpCode) {
    8134: e7d82002  ldrb  r2, [r8, r2]
    8138: e1520007  cmp r2, r7
    813c: 1afffff8  bne 8124 <XQspiPs_PolledTransfer+0xd4>
  }

  /*
   * Set the RX FIFO threshold
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8140: e5940004  ldr r0, [r4, #4]
    8144: e3a01020  mov r1, #32
    8148: e280002c  add r0, r0, #44 ; 0x2c
    814c: ebfff817  bl  61b0 <Xil_Out32>

  /*
   * If the slave select is "Forced" or under manual control,
   * set the slave select now, before beginning the transfer.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    8150: e1a00004  mov r0, r4
    8154: eb0002d7  bl  8cb8 <XQspiPs_GetOptions>
    8158: e3100010  tst r0, #16
    815c: 1a0000d4  bne 84b4 <XQspiPs_PolledTransfer+0x464>
  }

  /*
   * Enable the device.
   */
  XQspiPs_Enable(InstancePtr);
    8160: e5940004  ldr r0, [r4, #4]
    8164: e3a01001  mov r1, #1
    8168: e2800014  add r0, r0, #20
    816c: ebfff80f  bl  61b0 <Xil_Out32>

  if (Index < ARRAY_SIZE(FlashInst)) {
    8170: e355001a  cmp r5, #26
    8174: 0a0000a5  beq 8410 <XQspiPs_PolledTransfer+0x3c0>

    CurrInst = &FlashInst[Index];
    8178: e1a03085  lsl r3, r5, #1
    817c: e0831005  add r1, r3, r5
    8180: e0882001  add r2, r8, r1
    /*
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
    8184: e7d81001  ldrb  r1, [r8, r1]
    8188: e3560003  cmp r6, #3
    818c: 03510001  cmpeq r1, #1
    8190: 0a0000f4  beq 8568 <XQspiPs_PolledTransfer+0x518>
    8194: e0833005  add r3, r3, r5
    8198: e0883003  add r3, r8, r3

  /*
   * If the instruction size in not 4 bytes then the data received needs
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    819c: e5d33001  ldrb  r3, [r3, #1]
    81a0: e3530004  cmp r3, #4
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    81a4: 13a06000  movne r6, #0

  /*
   * If the instruction size in not 4 bytes then the data received needs
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    81a8: 0a0000a5  beq 8444 <XQspiPs_PolledTransfer+0x3f4>
    InstancePtr->ShiftReadData = 1;
    81ac: e3a03001  mov r3, #1
    81b0: e5843030  str r3, [r4, #48] ; 0x30
  } else {
    InstancePtr->ShiftReadData = 0;
  }
  TransCount = 0;
  /* Get the complete command (flash inst + address/data) */
  Data = *((u32 *)InstancePtr->SendBufferPtr);
    81b4: e5940014  ldr r0, [r4, #20]
  InstancePtr->SendBufferPtr += CurrInst->InstSize;
    81b8: e5d2c001  ldrb  ip, [r2, #1]
  InstancePtr->RemainingBytes -= CurrInst->InstSize;
    81bc: e5943020  ldr r3, [r4, #32]
  } else {
    InstancePtr->ShiftReadData = 0;
  }
  TransCount = 0;
  /* Get the complete command (flash inst + address/data) */
  Data = *((u32 *)InstancePtr->SendBufferPtr);
    81c0: e5901000  ldr r1, [r0]
  InstancePtr->SendBufferPtr += CurrInst->InstSize;
    81c4: e080000c  add r0, r0, ip
    81c8: e5840014  str r0, [r4, #20]
  InstancePtr->RemainingBytes -= CurrInst->InstSize;
    81cc: e5d20001  ldrb  r0, [r2, #1]
  if (InstancePtr->RemainingBytes < 0) {
    81d0: e0533000  subs  r3, r3, r0
    InstancePtr->RemainingBytes = 0;
    81d4: 43a03000  movmi r3, #0
    81d8: e5843020  str r3, [r4, #32]
  }

  /* Write the command to the FIFO */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    81dc: e5943004  ldr r3, [r4, #4]
    81e0: e5d20002  ldrb  r0, [r2, #2]
    81e4: e0800003  add r0, r0, r3
    81e8: ebfff7f0  bl  61b0 <Xil_Out32>

  /*
   * If switching from TXD1/2/3 to TXD0, then start transfer and
   * check for FIFO empty
   */
  if(SwitchFlag == 1) {
    81ec: e3560001  cmp r6, #1
    81f0: 0a0000bd  beq 84ec <XQspiPs_PolledTransfer+0x49c>
  /*
   * Check if manual start is selected and store it in a
   * local varibale for reference. This is to avoid reading
   * the config register everytime.
   */
  IsManualStart = XQspiPs_IsManualStart(InstancePtr);
    81f4: e1a00004  mov r0, r4
    81f8: eb0002ae  bl  8cb8 <XQspiPs_GetOptions>

  /*
   * Fill the DTR/FIFO with as many bytes as it will take (or as
   * many as we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    81fc: e5943020  ldr r3, [r4, #32]
    8200: e3530000  cmp r3, #0
  }

  /* Write the command to the FIFO */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          CurrInst->TxOffset, Data);
  ++TransCount;
    8204: d3a05001  movle r5, #1
  /*
   * Check if manual start is selected and store it in a
   * local varibale for reference. This is to avoid reading
   * the config register everytime.
   */
  IsManualStart = XQspiPs_IsManualStart(InstancePtr);
    8208: e2008020  and r8, r0, #32

  /*
   * Fill the DTR/FIFO with as many bytes as it will take (or as
   * many as we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    820c: da000017  ble 8270 <XQspiPs_PolledTransfer+0x220>
    8210: e5942014  ldr r2, [r4, #20]
    8214: e3a05001  mov r5, #1
    8218: ea000003  b 822c <XQspiPs_PolledTransfer+0x1dc>
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    }
    ++TransCount;
    821c: e6ef5071  uxtb  r5, r1

  /*
   * Fill the DTR/FIFO with as many bytes as it will take (or as
   * many as we have to send).
   */
  while ((InstancePtr->RemainingBytes > 0) &&
    8220: 0a000012  beq 8270 <XQspiPs_PolledTransfer+0x220>
    8224: e355003f  cmp r5, #63 ; 0x3f
    8228: 0a000010  beq 8270 <XQspiPs_PolledTransfer+0x220>
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    822c: e5940004  ldr r0, [r4, #4]
    8230: e5921000  ldr r1, [r2]
    8234: e280001c  add r0, r0, #28
    8238: ebfff7dc  bl  61b0 <Xil_Out32>
         XQSPIPS_TXD_00_OFFSET,
         *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    823c: e5943020  ldr r3, [r4, #32]
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
         XQSPIPS_TXD_00_OFFSET,
         *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    8240: e5942014  ldr r2, [r4, #20]
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    }
    ++TransCount;
    8244: e2851001  add r1, r5, #1
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
         XQSPIPS_TXD_00_OFFSET,
         *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    8248: e2433004  sub r3, r3, #4
    824c: e5843020  str r3, [r4, #32]
    if (InstancePtr->RemainingBytes < 0) {
    8250: e3530000  cmp r3, #0
  while ((InstancePtr->RemainingBytes > 0) &&
    (TransCount < XQSPIPS_FIFO_DEPTH)) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
         XQSPIPS_TXD_00_OFFSET,
         *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    8254: e2822004  add r2, r2, #4
    8258: e5842014  str r2, [r4, #20]
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
    825c: aaffffee  bge 821c <XQspiPs_PolledTransfer+0x1cc>
      InstancePtr->RemainingBytes = 0;
    8260: e3a02000  mov r2, #0
    }
    ++TransCount;
    8264: e6ef5071  uxtb  r5, r1
    8268: e1a03002  mov r3, r2
         XQSPIPS_TXD_00_OFFSET,
         *((u32 *)InstancePtr->SendBufferPtr));
    InstancePtr->SendBufferPtr += 4;
    InstancePtr->RemainingBytes -= 4;
    if (InstancePtr->RemainingBytes < 0) {
      InstancePtr->RemainingBytes = 0;
    826c: e5842020  str r2, [r4, #32]
    }
    ++TransCount;
  }

  while((InstancePtr->RemainingBytes > 0) ||
    8270: e3530000  cmp r3, #0
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
      if (InstancePtr->RemainingBytes < 0) {
        InstancePtr->RemainingBytes = 0;
    8274: e3a07000  mov r7, #0
      InstancePtr->RemainingBytes = 0;
    }
    ++TransCount;
  }

  while((InstancePtr->RemainingBytes > 0) ||
    8278: da00004a  ble 83a8 <XQspiPs_PolledTransfer+0x358>

    /*
     * Fill the TX FIFO with RX threshold no. of entries (or as
     * many as we have to send, in case that's less).
     */
    while ((InstancePtr->RemainingBytes > 0) &&
    827c: e355001f  cmp r5, #31
    8280: 8a000017  bhi 82e4 <XQspiPs_PolledTransfer+0x294>
    8284: e5943014  ldr r3, [r4, #20]
      (TransCount < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8288: e5940004  ldr r0, [r4, #4]
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
      if (InstancePtr->RemainingBytes < 0) {
        InstancePtr->RemainingBytes = 0;
      }
      ++TransCount;
    828c: e2855001  add r5, r5, #1
     * Fill the TX FIFO with RX threshold no. of entries (or as
     * many as we have to send, in case that's less).
     */
    while ((InstancePtr->RemainingBytes > 0) &&
      (TransCount < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8290: e5931000  ldr r1, [r3]
    8294: e280001c  add r0, r0, #28
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
      if (InstancePtr->RemainingBytes < 0) {
        InstancePtr->RemainingBytes = 0;
      }
      ++TransCount;
    8298: e6ef5075  uxtb  r5, r5
     * Fill the TX FIFO with RX threshold no. of entries (or as
     * many as we have to send, in case that's less).
     */
    while ((InstancePtr->RemainingBytes > 0) &&
      (TransCount < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    829c: ebfff7c3  bl  61b0 <Xil_Out32>
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
    82a0: e5942020  ldr r2, [r4, #32]
    while ((InstancePtr->RemainingBytes > 0) &&
      (TransCount < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
    82a4: e5943014  ldr r3, [r4, #20]
      InstancePtr->RemainingBytes -= 4;
    82a8: e2422004  sub r2, r2, #4
    82ac: e5842020  str r2, [r4, #32]
      if (InstancePtr->RemainingBytes < 0) {
    82b0: e3520000  cmp r2, #0
    while ((InstancePtr->RemainingBytes > 0) &&
      (TransCount < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
    82b4: e2833004  add r3, r3, #4
    82b8: e5843014  str r3, [r4, #20]

    /*
     * Fill the TX FIFO with RX threshold no. of entries (or as
     * many as we have to send, in case that's less).
     */
    while ((InstancePtr->RemainingBytes > 0) &&
    82bc: c3a02001  movgt r2, #1
    82c0: d3a02000  movle r2, #0
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
      if (InstancePtr->RemainingBytes < 0) {
    82c4: ba000005  blt 82e0 <XQspiPs_PolledTransfer+0x290>

    /*
     * Fill the TX FIFO with RX threshold no. of entries (or as
     * many as we have to send, in case that's less).
     */
    while ((InstancePtr->RemainingBytes > 0) &&
    82c8: e355001f  cmp r5, #31
    82cc: 83a02000  movhi r2, #0
    82d0: 92022001  andls r2, r2, #1
    82d4: e3520000  cmp r2, #0
    82d8: 1affffea  bne 8288 <XQspiPs_PolledTransfer+0x238>
    82dc: ea000000  b 82e4 <XQspiPs_PolledTransfer+0x294>
           XQSPIPS_TXD_00_OFFSET,
           *((u32 *)InstancePtr->SendBufferPtr));
      InstancePtr->SendBufferPtr += 4;
      InstancePtr->RemainingBytes -= 4;
      if (InstancePtr->RemainingBytes < 0) {
        InstancePtr->RemainingBytes = 0;
    82e0: e5847020  str r7, [r4, #32]
    }

    /*
     * If, in Manual Start mode, start the transfer.
     */
    if (IsManualStart == TRUE) {
    82e4: e3580000  cmp r8, #0
    82e8: 1a000042  bne 83f8 <XQspiPs_PolledTransfer+0x3a8>
     * small transfers (<32 words) and
     * when the last chunk in a large data transfer is < 32 words.
     */

    do {
      StatusReg = XQspiPs_ReadReg(
    82ec: e5940004  ldr r0, [r4, #4]
    82f0: e2800004  add r0, r0, #4
    82f4: ebfff7a7  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
          XQSPIPS_SR_OFFSET);
    } while ( ((StatusReg & XQSPIPS_IXR_TXOW_MASK) == 0) &&
      ((StatusReg & XQSPIPS_IXR_RXNEMPTY_MASK) == 0) );
    82f8: e3100014  tst r0, #20
    82fc: 0afffffa  beq 82ec <XQspiPs_PolledTransfer+0x29c>
    8300: e594301c  ldr r3, [r4, #28]
    8304: e3a06000  mov r6, #0
     * count obtained while filling tx fifo. Always get
     * the received data, but only fill the receive
     * buffer if it points to something (the upper layer
     * software may not care to receive data).
     */
    while ((InstancePtr->RequestedBytes > 0) &&
    8308: e3560020  cmp r6, #32
    830c: 13530000  cmpne r3, #0
      (RxCount < XQSPIPS_RXFIFO_THRESHOLD_OPT )) {
      u32 Data;

      RxCount++;
    8310: e2866001  add r6, r6, #1
     * count obtained while filling tx fifo. Always get
     * the received data, but only fill the receive
     * buffer if it points to something (the upper layer
     * software may not care to receive data).
     */
    while ((InstancePtr->RequestedBytes > 0) &&
    8314: c3a05001  movgt r5, #1
    8318: d3a05000  movle r5, #0
    831c: da00001e  ble 839c <XQspiPs_PolledTransfer+0x34c>
      (RxCount < XQSPIPS_RXFIFO_THRESHOLD_OPT )) {
      u32 Data;

      RxCount++;

      if (InstancePtr->RecvBufferPtr != NULL) {
    8320: e5945018  ldr r5, [r4, #24]
        if (InstancePtr->RequestedBytes < 4) {
          Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8324: e5940004  ldr r0, [r4, #4]
      (RxCount < XQSPIPS_RXFIFO_THRESHOLD_OPT )) {
      u32 Data;

      RxCount++;

      if (InstancePtr->RecvBufferPtr != NULL) {
    8328: e3550000  cmp r5, #0
        if (InstancePtr->RequestedBytes < 4) {
          Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    832c: e2800020  add r0, r0, #32
      (RxCount < XQSPIPS_RXFIFO_THRESHOLD_OPT )) {
      u32 Data;

      RxCount++;

      if (InstancePtr->RecvBufferPtr != NULL) {
    8330: 0a000015  beq 838c <XQspiPs_PolledTransfer+0x33c>
        if (InstancePtr->RequestedBytes < 4) {
    8334: e3530003  cmp r3, #3
    8338: ca000006  bgt 8358 <XQspiPs_PolledTransfer+0x308>
          Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    833c: ebfff795  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(InstancePtr, Data,
    8340: e5d4201c  ldrb  r2, [r4, #28]

      RxCount++;

      if (InstancePtr->RecvBufferPtr != NULL) {
        if (InstancePtr->RequestedBytes < 4) {
          Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8344: e1a01000  mov r1, r0
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(InstancePtr, Data,
    8348: e1a00004  mov r0, r4
    834c: ebfffd8a  bl  797c <XQspiPs_GetReadData>
    8350: e594301c  ldr r3, [r4, #28]
    8354: eaffffeb  b 8308 <XQspiPs_PolledTransfer+0x2b8>
            InstancePtr->RequestedBytes);
        } else {
          (*(u32 *)InstancePtr->RecvBufferPtr) =
            XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8358: ebfff78e  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
          InstancePtr->RecvBufferPtr += 4;
          InstancePtr->RequestedBytes -= 4;
    835c: e594301c  ldr r3, [r4, #28]
            InstancePtr->RequestedBytes);
        } else {
          (*(u32 *)InstancePtr->RecvBufferPtr) =
            XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          InstancePtr->RecvBufferPtr += 4;
    8360: e5942018  ldr r2, [r4, #24]
          InstancePtr->RequestedBytes -= 4;
          if (InstancePtr->RequestedBytes < 0) {
    8364: e2533004  subs  r3, r3, #4
            InstancePtr->RequestedBytes);
        } else {
          (*(u32 *)InstancePtr->RecvBufferPtr) =
            XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          InstancePtr->RecvBufferPtr += 4;
    8368: e2822004  add r2, r2, #4
          Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(InstancePtr, Data,
            InstancePtr->RequestedBytes);
        } else {
          (*(u32 *)InstancePtr->RecvBufferPtr) =
    836c: e5850000  str r0, [r5]
            XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          InstancePtr->RecvBufferPtr += 4;
    8370: e5842018  str r2, [r4, #24]
          InstancePtr->RequestedBytes -= 4;
          if (InstancePtr->RequestedBytes < 0) {
    8374: 4a000001  bmi 8380 <XQspiPs_PolledTransfer+0x330>
          }
        }
      } else {
        Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
        InstancePtr->RequestedBytes -= 4;
    8378: e584301c  str r3, [r4, #28]
    837c: eaffffe1  b 8308 <XQspiPs_PolledTransfer+0x2b8>
            XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          InstancePtr->RecvBufferPtr += 4;
          InstancePtr->RequestedBytes -= 4;
          if (InstancePtr->RequestedBytes < 0) {
            InstancePtr->RequestedBytes = 0;
    8380: e584701c  str r7, [r4, #28]
    8384: e3a03000  mov r3, #0
    8388: eaffffde  b 8308 <XQspiPs_PolledTransfer+0x2b8>
          }
        }
      } else {
        Data = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    838c: ebfff781  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
        InstancePtr->RequestedBytes -= 4;
    8390: e594301c  ldr r3, [r4, #28]
    8394: e2433004  sub r3, r3, #4
    8398: eafffff6  b 8378 <XQspiPs_PolledTransfer+0x328>
    839c: e5943020  ldr r3, [r4, #32]
      InstancePtr->RemainingBytes = 0;
    }
    ++TransCount;
  }

  while((InstancePtr->RemainingBytes > 0) ||
    83a0: e3530000  cmp r3, #0
    83a4: caffffb4  bgt 827c <XQspiPs_PolledTransfer+0x22c>
    83a8: e594301c  ldr r3, [r4, #28]
    83ac: e3530000  cmp r3, #0
    83b0: caffffcb  bgt 82e4 <XQspiPs_PolledTransfer+0x294>

  /*
   * If the Slave select lines are being manually controlled, disable
   * them because the transfer is complete.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    83b4: e1a00004  mov r0, r4
    83b8: eb00023e  bl  8cb8 <XQspiPs_GetOptions>
    83bc: e3100010  tst r0, #16
    83c0: 1a000035  bne 849c <XQspiPs_PolledTransfer+0x44c>
  InstancePtr->IsBusy = FALSE;

  /*
   * Disable the device.
   */
  XQspiPs_Disable(InstancePtr);
    83c4: e5940004  ldr r0, [r4, #4]
  }

  /*
   * Clear the busy flag.
   */
  InstancePtr->IsBusy = FALSE;
    83c8: e3a05000  mov r5, #0

  /*
   * Disable the device.
   */
  XQspiPs_Disable(InstancePtr);
    83cc: e1a01005  mov r1, r5
  }

  /*
   * Clear the busy flag.
   */
  InstancePtr->IsBusy = FALSE;
    83d0: e5845024  str r5, [r4, #36] ; 0x24

  /*
   * Disable the device.
   */
  XQspiPs_Disable(InstancePtr);
    83d4: e2800014  add r0, r0, #20
    83d8: ebfff774  bl  61b0 <Xil_Out32>

  /*
   * Reset the RX FIFO threshold to one
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    83dc: e5940004  ldr r0, [r4, #4]
    83e0: e3a01001  mov r1, #1
    83e4: e280002c  add r0, r0, #44 ; 0x2c
    83e8: ebfff770  bl  61b0 <Xil_Out32>
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

  return XST_SUCCESS;
    83ec: e1a00005  mov r0, r5
}
    83f0: e28dd008  add sp, sp, #8
    83f4: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

    /*
     * If, in Manual Start mode, start the transfer.
     */
    if (IsManualStart == TRUE) {
      ConfigReg = XQspiPs_ReadReg(
    83f8: e5940004  ldr r0, [r4, #4]
    83fc: ebfff765  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
           XQSPIPS_CR_OFFSET);
      ConfigReg |= XQSPIPS_CR_MANSTRT_MASK;
    8400: e3801801  orr r1, r0, #65536  ; 0x10000
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8404: e5940004  ldr r0, [r4, #4]
    8408: ebfff768  bl  61b0 <Xil_Out32>
    840c: eaffffb6  b 82ec <XQspiPs_PolledTransfer+0x29c>
     * The InstSize mentioned in case of instructions greater than 4 bytes
     * is not the actual size, but is indicative of the TXD register used.
     * The remaining bytes of the instruction will be transmitted
     * through TXD0 below.
     */
    switch(ByteCount%4)
    8410: e2063003  and r3, r6, #3
    8414: e3530002  cmp r3, #2
    8418: 0a000042  beq 8528 <XQspiPs_PolledTransfer+0x4d8>
    841c: e3530003  cmp r3, #3
    8420: 0a000014  beq 8478 <XQspiPs_PolledTransfer+0x428>
    8424: e3530001  cmp r3, #1
    8428: 0a000046  beq 8548 <XQspiPs_PolledTransfer+0x4f8>
          SwitchFlag = 1;
        }
        break;
      default:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_FOUR;
    842c: e3a02004  mov r2, #4
    8430: e5cd2001  strb  r2, [sp, #1]
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
  u8 IsManualStart = FALSE;
  u32 RxCount = 0;

  CurrInst = &NewInst[0];
    8434: e1a0200d  mov r2, sp
        }
        break;
      default:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_FOUR;
        CurrInst->TxOffset = XQSPIPS_TXD_00_OFFSET;
    8438: e3a0301c  mov r3, #28
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      default:
        CurrInst->OpCode = Instruction;
    843c: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_FOUR;
        CurrInst->TxOffset = XQSPIPS_TXD_00_OFFSET;
    8440: e5cd3002  strb  r3, [sp, #2]
   * to be shifted
   */
  if( CurrInst->InstSize != 4 ) {
    InstancePtr->ShiftReadData = 1;
  } else {
    InstancePtr->ShiftReadData = 0;
    8444: e3a06000  mov r6, #0
    8448: e5846030  str r6, [r4, #48] ; 0x30
    844c: eaffff58  b 81b4 <XQspiPs_PolledTransfer+0x164>

  CurrInst = &NewInst[0];
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
    8450: e3080718  movw  r0, #34584  ; 0x8718
    8454: e30012d3  movw  r1, #723  ; 0x2d3
    8458: e3400001  movt  r0, #1
    845c: eb00030b  bl  9090 <Xil_Assert>
    8460: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8464: e3403002  movt  r3, #2
    8468: e3a02001  mov r2, #1
    846c: e1a00004  mov r0, r4
    8470: e5832000  str r2, [r3]
    8474: eaffff0c  b 80ac <XQspiPs_PolledTransfer+0x5c>
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8478: e3560004  cmp r6, #4
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
    847c: e5cd3001  strb  r3, [sp, #1]
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
    8480: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
        CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    8484: e3e03077  mvn r3, #119  ; 0x77
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8488: 93a06000  movls r6, #0
    848c: 83a06001  movhi r6, #1
        }
        break;
      case XQSPIPS_SIZE_THREE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_THREE;
        CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    8490: e5cd3002  strb  r3, [sp, #2]
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8494: e1a0200d  mov r2, sp
    8498: eaffff43  b 81ac <XQspiPs_PolledTransfer+0x15c>
  /*
   * If the Slave select lines are being manually controlled, disable
   * them because the transfer is complete.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    849c: e5940004  ldr r0, [r4, #4]
    84a0: ebfff73c  bl  6198 <Xil_In32>
         XQSPIPS_CR_OFFSET);
    ConfigReg |= XQSPIPS_CR_SSCTRL_MASK;
    84a4: e3801b01  orr r1, r0, #1024 ; 0x400
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    84a8: e5940004  ldr r0, [r4, #4]
    84ac: ebfff73f  bl  61b0 <Xil_Out32>
    84b0: eaffffc3  b 83c4 <XQspiPs_PolledTransfer+0x374>
  /*
   * If the slave select is "Forced" or under manual control,
   * set the slave select now, before beginning the transfer.
   */
  if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    84b4: e5940004  ldr r0, [r4, #4]
    84b8: ebfff736  bl  6198 <Xil_In32>
         XQSPIPS_CR_OFFSET);
    ConfigReg &= ~XQSPIPS_CR_SSCTRL_MASK;
    84bc: e3c01b01  bic r1, r0, #1024 ; 0x400
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    84c0: e5940004  ldr r0, [r4, #4]
    84c4: ebfff739  bl  61b0 <Xil_Out32>
    84c8: eaffff24  b 8160 <XQspiPs_PolledTransfer+0x110>
  CurrInst = &NewInst[0];
  /*
   * The RecvBufPtr argument can be NULL.
   */
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(SendBufPtr != NULL);
    84cc: e3080718  movw  r0, #34584  ; 0x8718
    84d0: e3a01fb5  mov r1, #724  ; 0x2d4
    84d4: e3400001  movt  r0, #1
    84d8: eb0002ec  bl  9090 <Xil_Assert>
    84dc: e3a03001  mov r3, #1
    84e0: e1a00007  mov r0, r7
    84e4: e5883000  str r3, [r8]
    84e8: eafffeef  b 80ac <XQspiPs_PolledTransfer+0x5c>
  if(SwitchFlag == 1) {
    SwitchFlag = 0;
    /*
     * If, in Manual Start mode, start the transfer.
     */
    if (XQspiPs_IsManualStart(InstancePtr)) {
    84ec: e1a00004  mov r0, r4
    84f0: eb0001f0  bl  8cb8 <XQspiPs_GetOptions>
    84f4: e3100020  tst r0, #32
    84f8: 0a000004  beq 8510 <XQspiPs_PolledTransfer+0x4c0>
      ConfigReg = XQspiPs_ReadReg(
    84fc: e5940004  ldr r0, [r4, #4]
    8500: ebfff724  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
           XQSPIPS_CR_OFFSET);
      ConfigReg |= XQSPIPS_CR_MANSTRT_MASK;
    8504: e3801801  orr r1, r0, #65536  ; 0x10000
      XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8508: e5940004  ldr r0, [r4, #4]
    850c: ebfff727  bl  61b0 <Xil_Out32>
    }
    /*
     * Wait for the transfer to finish by polling Tx fifo status.
     */
    do {
      StatusReg = XQspiPs_ReadReg(
    8510: e5940004  ldr r0, [r4, #4]
    8514: e2800004  add r0, r0, #4
    8518: ebfff71e  bl  6198 <Xil_In32>
          InstancePtr->Config.BaseAddress,
          XQSPIPS_SR_OFFSET);
    } while ((StatusReg & XQSPIPS_IXR_TXOW_MASK) == 0);
    851c: e3100004  tst r0, #4
    8520: 0afffffa  beq 8510 <XQspiPs_PolledTransfer+0x4c0>
    8524: eaffff32  b 81f4 <XQspiPs_PolledTransfer+0x1a4>
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8528: e3560004  cmp r6, #4
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
    852c: e5cd3001  strb  r3, [sp, #1]
        if(ByteCount > 4) {
          SwitchFlag = 1;
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
    8530: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
        CurrInst->TxOffset = XQSPIPS_TXD_10_OFFSET;
    8534: e3e0307b  mvn r3, #123  ; 0x7b
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8538: 93a06000  movls r6, #0
    853c: 83a06001  movhi r6, #1
        }
        break;
      case XQSPIPS_SIZE_TWO:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_TWO;
        CurrInst->TxOffset = XQSPIPS_TXD_10_OFFSET;
    8540: e5cd3002  strb  r3, [sp, #2]
    8544: eaffffd2  b 8494 <XQspiPs_PolledTransfer+0x444>
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8548: e3560004  cmp r6, #4
     */
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
    854c: e5cd3001  strb  r3, [sp, #1]
     * through TXD0 below.
     */
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
    8550: e5cd7000  strb  r7, [sp]
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
        CurrInst->TxOffset = XQSPIPS_TXD_01_OFFSET;
    8554: e3e0307f  mvn r3, #127  ; 0x7f
  u32 Data;
  u8 TransCount;
  unsigned int Index;
  XQspiPsInstFormat *CurrInst;
  XQspiPsInstFormat NewInst[2];
  u8 SwitchFlag  = 0;
    8558: 93a06000  movls r6, #0
    855c: 83a06001  movhi r6, #1
    switch(ByteCount%4)
    {
      case XQSPIPS_SIZE_ONE:
        CurrInst->OpCode = Instruction;
        CurrInst->InstSize = XQSPIPS_SIZE_ONE;
        CurrInst->TxOffset = XQSPIPS_TXD_01_OFFSET;
    8560: e5cd3002  strb  r3, [sp, #2]
    8564: eaffffca  b 8494 <XQspiPs_PolledTransfer+0x444>
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
      (ByteCount == 3) ) {
      CurrInst->InstSize = 3;
    8568: e3a00003  mov r0, #3
      CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    856c: e3e01077  mvn r1, #119  ; 0x77
     * Check for WRSR instruction which has different size for
     * Spansion (3 bytes) and Micron (2 bytes)
     */
    if( (CurrInst->OpCode == XQSPIPS_FLASH_OPCODE_WRSR) &&
      (ByteCount == 3) ) {
      CurrInst->InstSize = 3;
    8570: e5c20001  strb  r0, [r2, #1]
      CurrInst->TxOffset = XQSPIPS_TXD_11_OFFSET;
    8574: e5c21002  strb  r1, [r2, #2]
    8578: eaffff05  b 8194 <XQspiPs_PolledTransfer+0x144>

0000857c <XQspiPs_LqspiRead>:
*
*
******************************************************************************/
int XQspiPs_LqspiRead(XQspiPs *InstancePtr, u8 *RecvBufPtr,
      u32 Address, unsigned ByteCount)
{
    857c: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
  Xil_AssertNonvoid(InstancePtr != NULL);
    8580: e2506000  subs  r6, r0, #0
    8584: 0a000030  beq 864c <XQspiPs_LqspiRead+0xd0>
    8588: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertNonvoid(RecvBufPtr != NULL);
    858c: e3510000  cmp r1, #0
*
******************************************************************************/
int XQspiPs_LqspiRead(XQspiPs *InstancePtr, u8 *RecvBufPtr,
      u32 Address, unsigned ByteCount)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    8590: e3404002  movt  r4, #2
    8594: e3a05000  mov r5, #0
    8598: e1a08001  mov r8, r1
    859c: e5845000  str r5, [r4]
  Xil_AssertNonvoid(RecvBufPtr != NULL);
    85a0: 0a000033  beq 8674 <XQspiPs_LqspiRead+0xf8>
  Xil_AssertNonvoid(ByteCount > 0);
    85a4: e3530000  cmp r3, #0
    85a8: e1a07003  mov r7, r3
    85ac: 0a000018  beq 8614 <XQspiPs_LqspiRead+0x98>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    85b0: e5963010  ldr r3, [r6, #16]
    85b4: e301c111  movw  ip, #4369 ; 0x1111
    85b8: e341c111  movt  ip, #4369 ; 0x1111
    85bc: e153000c  cmp r3, ip
    85c0: 0a000007  beq 85e4 <XQspiPs_LqspiRead+0x68>
    85c4: e3080718  movw  r0, #34584  ; 0x8718
    85c8: e300142f  movw  r1, #1071 ; 0x42f
    85cc: e3400001  movt  r0, #1
    85d0: eb0002ae  bl  9090 <Xil_Assert>
    85d4: e3a03001  mov r3, #1
    85d8: e1a00005  mov r0, r5
    85dc: e5843000  str r3, [r4]
    85e0: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
#define XPAR_PS7_QSPI_LINEAR_0_S_AXI_BASEADDR 0xFC000000
#endif
  /*
   * Enable the controller
   */
  XQspiPs_Enable(InstancePtr);
    85e4: e5960004  ldr r0, [r6, #4]
    85e8: e3a01001  mov r1, #1
    85ec: e1a09002  mov r9, r2
    85f0: e2800014  add r0, r0, #20
    85f4: ebfff6ed  bl  61b0 <Xil_Out32>

  if (XQspiPs_GetLqspiConfigReg(InstancePtr) &
    85f8: e5960004  ldr r0, [r6, #4]
    85fc: e28000a0  add r0, r0, #160  ; 0xa0
    8600: ebfff6e4  bl  6198 <Xil_In32>
    8604: e3500000  cmp r0, #0
    8608: ba000009  blt 8634 <XQspiPs_LqspiRead+0xb8>
          (const void*)(XPAR_PS7_QSPI_LINEAR_0_S_AXI_BASEADDR +
           Address),
          (size_t)ByteCount);
    return XST_SUCCESS;
  } else {
    return XST_FAILURE;
    860c: e3a00001  mov r0, #1
    8610: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
int XQspiPs_LqspiRead(XQspiPs *InstancePtr, u8 *RecvBufPtr,
      u32 Address, unsigned ByteCount)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(RecvBufPtr != NULL);
  Xil_AssertNonvoid(ByteCount > 0);
    8614: e3080718  movw  r0, #34584  ; 0x8718
    8618: e300142e  movw  r1, #1070 ; 0x42e
    861c: e3400001  movt  r0, #1
    8620: eb00029a  bl  9090 <Xil_Assert>
    8624: e3a03001  mov r3, #1
    8628: e1a00007  mov r0, r7
    862c: e5843000  str r3, [r4]
    8630: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
   */
  XQspiPs_Enable(InstancePtr);

  if (XQspiPs_GetLqspiConfigReg(InstancePtr) &
    XQSPIPS_LQSPI_CR_LINEAR_MASK) {
    memcpy((void*)RecvBufPtr,
    8634: e1a00008  mov r0, r8
    8638: e289133f  add r1, r9, #-67108864  ; 0xfc000000
    863c: e1a02007  mov r2, r7
    8640: eb00048e  bl  9880 <memcpy>
          (const void*)(XPAR_PS7_QSPI_LINEAR_0_S_AXI_BASEADDR +
           Address),
          (size_t)ByteCount);
    return XST_SUCCESS;
    8644: e1a00005  mov r0, r5
  /*
   * Disable the controller
   */
  XQspiPs_Disable(InstancePtr);

}
    8648: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
*
******************************************************************************/
int XQspiPs_LqspiRead(XQspiPs *InstancePtr, u8 *RecvBufPtr,
      u32 Address, unsigned ByteCount)
{
  Xil_AssertNonvoid(InstancePtr != NULL);
    864c: e3080718  movw  r0, #34584  ; 0x8718
    8650: e300142c  movw  r1, #1068 ; 0x42c
    8654: e3400001  movt  r0, #1
    8658: eb00028c  bl  9090 <Xil_Assert>
    865c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8660: e3403002  movt  r3, #2
    8664: e3a02001  mov r2, #1
    8668: e1a00006  mov r0, r6
    866c: e5832000  str r2, [r3]
    8670: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
  Xil_AssertNonvoid(RecvBufPtr != NULL);
    8674: e3080718  movw  r0, #34584  ; 0x8718
    8678: e300142d  movw  r1, #1069 ; 0x42d
    867c: e3400001  movt  r0, #1
    8680: eb000282  bl  9090 <Xil_Assert>
    8684: e3a03001  mov r3, #1
    8688: e1a00008  mov r0, r8
    868c: e5843000  str r3, [r4]
    8690: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

00008694 <XQspiPs_SetSlaveSelect>:
* This function only sets the slave which will be selected when a transfer
* occurs. The slave is not selected when the QSPI is idle.
*
******************************************************************************/
int XQspiPs_SetSlaveSelect(XQspiPs *InstancePtr)
{
    8694: e92d4070  push  {r4, r5, r6, lr}
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8698: e2506000  subs  r6, r0, #0
    869c: 0a00001c  beq 8714 <XQspiPs_SetSlaveSelect+0x80>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    86a0: e5962010  ldr r2, [r6, #16]
    86a4: e3013111  movw  r3, #4369 ; 0x1111
    86a8: e3413111  movt  r3, #4369 ; 0x1111
******************************************************************************/
int XQspiPs_SetSlaveSelect(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    86ac: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    86b0: e1520003  cmp r2, r3
******************************************************************************/
int XQspiPs_SetSlaveSelect(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    86b4: e3405002  movt  r5, #2
    86b8: e3a04000  mov r4, #0
    86bc: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    86c0: 1a000004  bne 86d8 <XQspiPs_SetSlaveSelect+0x44>

  /*
   * Do not allow the slave select to change while a transfer is in
   * progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    86c4: e5964024  ldr r4, [r6, #36] ; 0x24
    86c8: e3540000  cmp r4, #0
    86cc: 0a000009  beq 86f8 <XQspiPs_SetSlaveSelect+0x64>
    return XST_DEVICE_BUSY;
    86d0: e3a00015  mov r0, #21
  ConfigReg &= ~XQSPIPS_CR_SSCTRL_MASK;
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
        XQSPIPS_CR_OFFSET, ConfigReg);

  return XST_SUCCESS;
}
    86d4: e8bd8070  pop {r4, r5, r6, pc}
int XQspiPs_SetSlaveSelect(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    86d8: e3080718  movw  r0, #34584  ; 0x8718
    86dc: e3001465  movw  r1, #1125 ; 0x465
    86e0: e3400001  movt  r0, #1
    86e4: eb000269  bl  9090 <Xil_Assert>
    86e8: e3a03001  mov r3, #1
    86ec: e1a00004  mov r0, r4
    86f0: e5853000  str r3, [r5]
    86f4: e8bd8070  pop {r4, r5, r6, pc}
  }

  /*
   * Select the slave
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    86f8: e5960004  ldr r0, [r6, #4]
    86fc: ebfff6a5  bl  6198 <Xil_In32>
              XQSPIPS_CR_OFFSET);
  ConfigReg &= ~XQSPIPS_CR_SSCTRL_MASK;
    8700: e3c01b01  bic r1, r0, #1024 ; 0x400
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8704: e5960004  ldr r0, [r6, #4]
    8708: ebfff6a8  bl  61b0 <Xil_Out32>
        XQSPIPS_CR_OFFSET, ConfigReg);

  return XST_SUCCESS;
    870c: e1a00004  mov r0, r4
    8710: e8bd8070  pop {r4, r5, r6, pc}
******************************************************************************/
int XQspiPs_SetSlaveSelect(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8714: e3080718  movw  r0, #34584  ; 0x8718
    8718: e3001464  movw  r1, #1124 ; 0x464
    871c: e3400001  movt  r0, #1
    8720: eb00025a  bl  9090 <Xil_Assert>
    8724: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8728: e3403002  movt  r3, #2
    872c: e3a02001  mov r2, #1
    8730: e1a00006  mov r0, r6
    8734: e5832000  str r2, [r3]
    8738: e8bd8070  pop {r4, r5, r6, pc}

0000873c <XQspiPs_SetStatusHandler>:
*
******************************************************************************/
void XQspiPs_SetStatusHandler(XQspiPs *InstancePtr, void *CallBackRef,
        XQspiPs_StatusHandler FuncPtr)
{
  Xil_AssertVoid(InstancePtr != NULL);
    873c: e3500000  cmp r0, #0
* quickly and queue potentially time-consuming work to a task-level thread.
*
******************************************************************************/
void XQspiPs_SetStatusHandler(XQspiPs *InstancePtr, void *CallBackRef,
        XQspiPs_StatusHandler FuncPtr)
{
    8740: e92d4010  push  {r4, lr}
  Xil_AssertVoid(InstancePtr != NULL);
    8744: 0a000014  beq 879c <XQspiPs_SetStatusHandler+0x60>
    8748: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(FuncPtr != NULL);
    874c: e3520000  cmp r2, #0
*
******************************************************************************/
void XQspiPs_SetStatusHandler(XQspiPs *InstancePtr, void *CallBackRef,
        XQspiPs_StatusHandler FuncPtr)
{
  Xil_AssertVoid(InstancePtr != NULL);
    8750: e3404002  movt  r4, #2
    8754: e3a03000  mov r3, #0
    8758: e5843000  str r3, [r4]
  Xil_AssertVoid(FuncPtr != NULL);
    875c: 0a000017  beq 87c0 <XQspiPs_SetStatusHandler+0x84>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8760: e590c010  ldr ip, [r0, #16]
    8764: e3013111  movw  r3, #4369 ; 0x1111
    8768: e3413111  movt  r3, #4369 ; 0x1111
    876c: e15c0003  cmp ip, r3
    8770: 0a000006  beq 8790 <XQspiPs_SetStatusHandler+0x54>
    8774: e3080718  movw  r0, #34584  ; 0x8718
    8778: e30014a5  movw  r1, #1189 ; 0x4a5
    877c: e3400001  movt  r0, #1
    8780: eb000242  bl  9090 <Xil_Assert>
    8784: e3a03001  mov r3, #1
    8788: e5843000  str r3, [r4]
    878c: e8bd8010  pop {r4, pc}

  InstancePtr->StatusHandler = FuncPtr;
    8790: e5802028  str r2, [r0, #40] ; 0x28
  InstancePtr->StatusRef = CallBackRef;
    8794: e580102c  str r1, [r0, #44] ; 0x2c
    8798: e8bd8010  pop {r4, pc}
*
******************************************************************************/
void XQspiPs_SetStatusHandler(XQspiPs *InstancePtr, void *CallBackRef,
        XQspiPs_StatusHandler FuncPtr)
{
  Xil_AssertVoid(InstancePtr != NULL);
    879c: e3080718  movw  r0, #34584  ; 0x8718
    87a0: e30014a3  movw  r1, #1187 ; 0x4a3
    87a4: e3400001  movt  r0, #1
    87a8: eb000238  bl  9090 <Xil_Assert>
    87ac: e3023ae8  movw  r3, #10984  ; 0x2ae8
    87b0: e3403002  movt  r3, #2
    87b4: e3a02001  mov r2, #1
    87b8: e5832000  str r2, [r3]
    87bc: e8bd8010  pop {r4, pc}
  Xil_AssertVoid(FuncPtr != NULL);
    87c0: e3080718  movw  r0, #34584  ; 0x8718
    87c4: e30014a4  movw  r1, #1188 ; 0x4a4
    87c8: e3400001  movt  r0, #1
    87cc: eb00022f  bl  9090 <Xil_Assert>
    87d0: e3a03001  mov r3, #1
    87d4: e5843000  str r3, [r4]
    87d8: e8bd8010  pop {r4, pc}

000087dc <XQspiPs_InterruptHandler>:
* The slave select register is being set to deselect the slave when a transfer
* is complete.
*
******************************************************************************/
void XQspiPs_InterruptHandler(void *InstancePtr)
{
    87dc: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
  u32 Data;
  u32 TransCount;
  u32 Count = 0;
  unsigned BytesDone; /* Number of bytes done so far. */

  Xil_AssertVoid(InstancePtr != NULL);
    87e0: e2504000  subs  r4, r0, #0
    87e4: 0a0000c6  beq 8b04 <XQspiPs_InterruptHandler+0x328>
  Xil_AssertVoid(QspiPtr->IsReady == XIL_COMPONENT_IS_READY);
    87e8: e5942010  ldr r2, [r4, #16]
    87ec: e3013111  movw  r3, #4369 ; 0x1111
    87f0: e3413111  movt  r3, #4369 ; 0x1111
  u32 Data;
  u32 TransCount;
  u32 Count = 0;
  unsigned BytesDone; /* Number of bytes done so far. */

  Xil_AssertVoid(InstancePtr != NULL);
    87f4: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertVoid(QspiPtr->IsReady == XIL_COMPONENT_IS_READY);
    87f8: e1520003  cmp r2, r3
  u32 Data;
  u32 TransCount;
  u32 Count = 0;
  unsigned BytesDone; /* Number of bytes done so far. */

  Xil_AssertVoid(InstancePtr != NULL);
    87fc: e3405002  movt  r5, #2
    8800: e3a03000  mov r3, #0
    8804: e5853000  str r3, [r5]
  Xil_AssertVoid(QspiPtr->IsReady == XIL_COMPONENT_IS_READY);
    8808: 0a000006  beq 8828 <XQspiPs_InterruptHandler+0x4c>
    880c: e3080718  movw  r0, #34584  ; 0x8718
    8810: e30014f3  movw  r1, #1267 ; 0x4f3
    8814: e3400001  movt  r0, #1
    8818: eb00021c  bl  9090 <Xil_Assert>
    881c: e3a03001  mov r3, #1
    8820: e5853000  str r3, [r5]
    8824: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
   * interrupt to be generated. If we clear at the end of the ISR,
   * we may miss newly generated interrupts. This occurs because we
   * transmit from within the ISR, which could potentially cause another
   * TX_EMPTY interrupt.
   */
  IntrStatus = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    8828: e5940004  ldr r0, [r4, #4]
    882c: e2800004  add r0, r0, #4
    8830: ebfff658  bl  6198 <Xil_In32>
    8834: e1a06000  mov r6, r0
              XQSPIPS_SR_OFFSET);
  XQspiPs_WriteReg(QspiPtr->Config.BaseAddress, XQSPIPS_SR_OFFSET,
    8838: e5940004  ldr r0, [r4, #4]
    883c: e2061041  and r1, r6, #65 ; 0x41
    8840: e2800004  add r0, r0, #4
    8844: ebfff659  bl  61b0 <Xil_Out32>
        (IntrStatus & XQSPIPS_IXR_WR_TO_CLR_MASK));
  XQspiPs_WriteReg(QspiPtr->Config.BaseAddress, XQSPIPS_IDR_OFFSET,
    8848: e5940004  ldr r0, [r4, #4]
    884c: e3a01055  mov r1, #85 ; 0x55
    8850: e280000c  add r0, r0, #12
    8854: ebfff655  bl  61b0 <Xil_Out32>
      XQSPIPS_IXR_TXOW_MASK | XQSPIPS_IXR_RXNEMPTY_MASK |
      XQSPIPS_IXR_RXOVR_MASK | XQSPIPS_IXR_TXUF_MASK);

  if ((IntrStatus & XQSPIPS_IXR_TXOW_MASK) ||
    8858: e3160014  tst r6, #20
    885c: 0a000043  beq 8970 <XQspiPs_InterruptHandler+0x194>
     * in which case, read all the data from RX FIFO.
     * Always get the received data, but only fill the
     * receive buffer if it is not null (it can be null when
     * the device does not care to receive data).
     */
    TransCount = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8860: e5943020  ldr r3, [r4, #32]
    8864: e594801c  ldr r8, [r4, #28]
    8868: e0638008  rsb r8, r3, r8
    if (TransCount % 4) {
    886c: e3180003  tst r8, #3
      TransCount = TransCount/4 + 1;
    8870: 11a08128  lsrne r8, r8, #2
    8874: 12888001  addne r8, r8, #1
     * Always get the received data, but only fill the
     * receive buffer if it is not null (it can be null when
     * the device does not care to receive data).
     */
    TransCount = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    if (TransCount % 4) {
    8878: 1a000001  bne 8884 <XQspiPs_InterruptHandler+0xa8>
      TransCount = TransCount/4 + 1;
    } else {
      TransCount = TransCount/4;
    }

    while ((Count < TransCount) &&
    887c: e1b08128  lsrs  r8, r8, #2
    8880: 0a000056  beq 89e0 <XQspiPs_InterruptHandler+0x204>
* The slave select register is being set to deselect the slave when a transfer
* is complete.
*
******************************************************************************/
void XQspiPs_InterruptHandler(void *InstancePtr)
{
    8884: e3a05000  mov r5, #0
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
          QspiPtr->RequestedBytes -= 4;
          if (QspiPtr->RequestedBytes < 0) {
            QspiPtr->RequestedBytes = 0;
    8888: e1a09005  mov r9, r5
    888c: ea00000c  b 88c4 <XQspiPs_InterruptHandler+0xe8>
    while ((Count < TransCount) &&
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {

      if (QspiPtr->RecvBufferPtr != NULL) {
        if (QspiPtr->RequestedBytes < 4) {
          Data = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    8890: ebfff640  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(QspiPtr, Data,
    8894: e5d4201c  ldrb  r2, [r4, #28]
    while ((Count < TransCount) &&
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {

      if (QspiPtr->RecvBufferPtr != NULL) {
        if (QspiPtr->RequestedBytes < 4) {
          Data = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    8898: e1a01000  mov r1, r0
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(QspiPtr, Data,
    889c: e1a00004  mov r0, r4
    88a0: ebfffc35  bl  797c <XQspiPs_GetReadData>
        if (QspiPtr->RequestedBytes < 0) {
          QspiPtr->RequestedBytes = 0;
        }

      }
      Count++;
    88a4: e2855001  add r5, r5, #1
      TransCount = TransCount/4 + 1;
    } else {
      TransCount = TransCount/4;
    }

    while ((Count < TransCount) &&
    88a8: e1580005  cmp r8, r5
    88ac: 83a03001  movhi r3, #1
    88b0: 93a03000  movls r3, #0
    88b4: e355001f  cmp r5, #31
    88b8: 83a03000  movhi r3, #0
    88bc: e3530000  cmp r3, #0
    88c0: 0a000045  beq 89dc <XQspiPs_InterruptHandler+0x200>
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {

      if (QspiPtr->RecvBufferPtr != NULL) {
    88c4: e5947018  ldr r7, [r4, #24]
    88c8: e3570000  cmp r7, #0
    88cc: 0a00006a  beq 8a7c <XQspiPs_InterruptHandler+0x2a0>
        if (QspiPtr->RequestedBytes < 4) {
    88d0: e594301c  ldr r3, [r4, #28]
          Data = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    88d4: e5940004  ldr r0, [r4, #4]

    while ((Count < TransCount) &&
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {

      if (QspiPtr->RecvBufferPtr != NULL) {
        if (QspiPtr->RequestedBytes < 4) {
    88d8: e3530003  cmp r3, #3
          Data = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    88dc: e2800020  add r0, r0, #32

    while ((Count < TransCount) &&
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {

      if (QspiPtr->RecvBufferPtr != NULL) {
        if (QspiPtr->RequestedBytes < 4) {
    88e0: daffffea  ble 8890 <XQspiPs_InterruptHandler+0xb4>
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(QspiPtr, Data,
            QspiPtr->RequestedBytes);
        } else {
          (*(u32 *)QspiPtr->RecvBufferPtr) =
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    88e4: ebfff62b  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
          QspiPtr->RequestedBytes -= 4;
    88e8: e594301c  ldr r3, [r4, #28]
            QspiPtr->RequestedBytes);
        } else {
          (*(u32 *)QspiPtr->RecvBufferPtr) =
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
    88ec: e5942018  ldr r2, [r4, #24]
          QspiPtr->RequestedBytes -= 4;
    88f0: e2433004  sub r3, r3, #4
          if (QspiPtr->RequestedBytes < 0) {
    88f4: e3530000  cmp r3, #0
            QspiPtr->RequestedBytes);
        } else {
          (*(u32 *)QspiPtr->RecvBufferPtr) =
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
    88f8: e2822004  add r2, r2, #4
          Data = XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          XQspiPs_GetReadData(QspiPtr, Data,
            QspiPtr->RequestedBytes);
        } else {
          (*(u32 *)QspiPtr->RecvBufferPtr) =
    88fc: e5870000  str r0, [r7]
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
          QspiPtr->RequestedBytes -= 4;
    8900: e584301c  str r3, [r4, #28]
            QspiPtr->RequestedBytes);
        } else {
          (*(u32 *)QspiPtr->RecvBufferPtr) =
            XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
            XQSPIPS_RXD_OFFSET);
          QspiPtr->RecvBufferPtr += 4;
    8904: e5842018  str r2, [r4, #24]
          QspiPtr->RequestedBytes -= 4;
          if (QspiPtr->RequestedBytes < 0) {
    8908: aaffffe5  bge 88a4 <XQspiPs_InterruptHandler+0xc8>
            QspiPtr->RequestedBytes = 0;
    890c: e584901c  str r9, [r4, #28]
    8910: eaffffe3  b 88a4 <XQspiPs_InterruptHandler+0xc8>
       * No more data to send.  Disable the interrupt
       * and inform the upper layer software that the
       * transfer is done. The interrupt will be re-enabled
       * when another transfer is initiated.
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8914: e5940004  ldr r0, [r4, #4]
    8918: e3a01055  mov r1, #85 ; 0x55
    891c: e280000c  add r0, r0, #12
    8920: ebfff622  bl  61b0 <Xil_Out32>

      /*
       * If the Slave select is being manually controlled,
       * disable it because the transfer is complete.
       */
      if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    8924: e1a00004  mov r0, r4
    8928: eb0000e2  bl  8cb8 <XQspiPs_GetOptions>
    892c: e3100010  tst r0, #16
    8930: 1a000088  bne 8b58 <XQspiPs_InterruptHandler+0x37c>
      QspiPtr->IsBusy = FALSE;

      /*
       * Disable the device.
       */
      XQspiPs_Disable(QspiPtr);
    8934: e5940004  ldr r0, [r4, #4]
      }

      /*
       * Clear the busy flag.
       */
      QspiPtr->IsBusy = FALSE;
    8938: e3a03000  mov r3, #0

      /*
       * Disable the device.
       */
      XQspiPs_Disable(QspiPtr);
    893c: e1a01003  mov r1, r3
      }

      /*
       * Clear the busy flag.
       */
      QspiPtr->IsBusy = FALSE;
    8940: e5843024  str r3, [r4, #36] ; 0x24

      /*
       * Disable the device.
       */
      XQspiPs_Disable(QspiPtr);
    8944: e2800014  add r0, r0, #20
    8948: ebfff618  bl  61b0 <Xil_Out32>

      /*
       * Reset the RX FIFO threshold to one
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    894c: e5940004  ldr r0, [r4, #4]
    8950: e3a01001  mov r1, #1
    8954: e280002c  add r0, r0, #44 ; 0x2c
    8958: ebfff614  bl  61b0 <Xil_Out32>
        XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

      QspiPtr->StatusHandler(QspiPtr->StatusRef,
    895c: e5943028  ldr r3, [r4, #40] ; 0x28
    8960: e594002c  ldr r0, [r4, #44] ; 0x2c
    8964: e3a01d12  mov r1, #1152 ; 0x480
    8968: e594201c  ldr r2, [r4, #28]
    896c: e12fff33  blx r3
  }

  /*
   * Check for overflow and underflow errors.
   */
  if (IntrStatus & XQSPIPS_IXR_RXOVR_MASK) {
    8970: e3160001  tst r6, #1
    8974: 1a000049  bne 8aa0 <XQspiPs_InterruptHandler+0x2c4>

    QspiPtr->StatusHandler(QspiPtr->StatusRef,
      XST_SPI_RECEIVE_OVERRUN, BytesDone);
  }

  if (IntrStatus & XQSPIPS_IXR_TXUF_MASK) {
    8978: e3160040  tst r6, #64 ; 0x40
    897c: 08bd87f0  popeq {r4, r5, r6, r7, r8, r9, sl, pc}
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8980: e594301c  ldr r3, [r4, #28]

    QspiPtr->IsBusy = FALSE;
    8984: e3a02000  mov r2, #0
    QspiPtr->StatusHandler(QspiPtr->StatusRef,
      XST_SPI_RECEIVE_OVERRUN, BytesDone);
  }

  if (IntrStatus & XQSPIPS_IXR_TXUF_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8988: e5945020  ldr r5, [r4, #32]
    QspiPtr->IsBusy = FALSE;
    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    898c: e1a00004  mov r0, r4
  }

  if (IntrStatus & XQSPIPS_IXR_TXUF_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;

    QspiPtr->IsBusy = FALSE;
    8990: e5842024  str r2, [r4, #36] ; 0x24
    QspiPtr->StatusHandler(QspiPtr->StatusRef,
      XST_SPI_RECEIVE_OVERRUN, BytesDone);
  }

  if (IntrStatus & XQSPIPS_IXR_TXUF_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8994: e0655003  rsb r5, r5, r3
    QspiPtr->IsBusy = FALSE;
    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    8998: eb0000c6  bl  8cb8 <XQspiPs_GetOptions>
    899c: e3100010  tst r0, #16
    89a0: 1a000060  bne 8b28 <XQspiPs_InterruptHandler+0x34c>
    }

    /*
     * Disable the device.
     */
    XQspiPs_Disable(QspiPtr);
    89a4: e5940004  ldr r0, [r4, #4]
    89a8: e3a01000  mov r1, #0
    89ac: e2800014  add r0, r0, #20
    89b0: ebfff5fe  bl  61b0 <Xil_Out32>

    /*
     * Reset the RX FIFO threshold to one
     */
    XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    89b4: e5940004  ldr r0, [r4, #4]
    89b8: e3a01001  mov r1, #1
    89bc: e280002c  add r0, r0, #44 ; 0x2c
    89c0: ebfff5fa  bl  61b0 <Xil_Out32>
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

    QspiPtr->StatusHandler(QspiPtr->StatusRef,
    89c4: e1a02005  mov r2, r5
    89c8: e5943028  ldr r3, [r4, #40] ; 0x28
    89cc: e3001481  movw  r1, #1153 ; 0x481
    89d0: e594002c  ldr r0, [r4, #44] ; 0x2c
              XST_SPI_TRANSMIT_UNDERRUN, BytesDone);
  }
}
    89d4: e8bd47f0  pop {r4, r5, r6, r7, r8, r9, sl, lr}
     * Reset the RX FIFO threshold to one
     */
    XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

    QspiPtr->StatusHandler(QspiPtr->StatusRef,
    89d8: e12fff13  bx  r3
    89dc: e5943020  ldr r3, [r4, #32]
     * Interrupt asserted as TX_OW got asserted
     * See if there is more data to send.
     * Fill TX FIFO with RX threshold no. of entries or
     * remaining entries (in case that is less than threshold)
     */
    while ((QspiPtr->RemainingBytes > 0) &&
    89e0: e3530000  cmp r3, #0
    89e4: da000061  ble 8b70 <XQspiPs_InterruptHandler+0x394>
    89e8: e5943014  ldr r3, [r4, #20]
    89ec: e3a05020  mov r5, #32
    89f0: ea000002  b 8a00 <XQspiPs_InterruptHandler+0x224>
    89f4: 0a00000f  beq 8a38 <XQspiPs_InterruptHandler+0x25c>
    89f8: e2555001  subs  r5, r5, #1
    89fc: 0a000010  beq 8a44 <XQspiPs_InterruptHandler+0x268>
      (Count < XQSPIPS_RXFIFO_THRESHOLD_OPT)) {
      /*
       * Send more data.
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8a00: e5940004  ldr r0, [r4, #4]
    8a04: e5931000  ldr r1, [r3]
    8a08: e280001c  add r0, r0, #28
    8a0c: ebfff5e7  bl  61b0 <Xil_Out32>
        XQSPIPS_TXD_00_OFFSET,
        *((u32 *)QspiPtr->SendBufferPtr));
      QspiPtr->SendBufferPtr += 4;
      QspiPtr->RemainingBytes -= 4;
    8a10: e5942020  ldr r2, [r4, #32]
       * Send more data.
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
        XQSPIPS_TXD_00_OFFSET,
        *((u32 *)QspiPtr->SendBufferPtr));
      QspiPtr->SendBufferPtr += 4;
    8a14: e5943014  ldr r3, [r4, #20]
      QspiPtr->RemainingBytes -= 4;
    8a18: e2422004  sub r2, r2, #4
    8a1c: e5842020  str r2, [r4, #32]
      if (QspiPtr->RemainingBytes < 0) {
    8a20: e3520000  cmp r2, #0
       * Send more data.
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
        XQSPIPS_TXD_00_OFFSET,
        *((u32 *)QspiPtr->SendBufferPtr));
      QspiPtr->SendBufferPtr += 4;
    8a24: e2833004  add r3, r3, #4
    8a28: e5843014  str r3, [r4, #20]
      QspiPtr->RemainingBytes -= 4;
      if (QspiPtr->RemainingBytes < 0) {
    8a2c: aafffff0  bge 89f4 <XQspiPs_InterruptHandler+0x218>
        QspiPtr->RemainingBytes = 0;
    8a30: e3a03000  mov r3, #0
    8a34: e5843020  str r3, [r4, #32]
      }

      Count++;
    }

    if ((QspiPtr->RemainingBytes == 0) &&
    8a38: e594301c  ldr r3, [r4, #28]
    8a3c: e3530000  cmp r3, #0
    8a40: 0affffb3  beq 8914 <XQspiPs_InterruptHandler+0x138>
            QspiPtr->RequestedBytes);
    } else {
      /*
       * Enable the TXOW interrupt.
       */
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8a44: e5940004  ldr r0, [r4, #4]
    8a48: e3a01055  mov r1, #85 ; 0x55
    8a4c: e2800008  add r0, r0, #8
    8a50: ebfff5d6  bl  61b0 <Xil_Out32>
           XQSPIPS_IXR_RXOVR_MASK |
           XQSPIPS_IXR_TXUF_MASK);
      /*
       * If, in Manual Start mode, start the transfer.
       */
      if (XQspiPs_IsManualStart(QspiPtr)) {
    8a54: e1a00004  mov r0, r4
    8a58: eb000096  bl  8cb8 <XQspiPs_GetOptions>
    8a5c: e3100020  tst r0, #32
    8a60: 0affffc2  beq 8970 <XQspiPs_InterruptHandler+0x194>
        ConfigReg = XQspiPs_ReadReg(
    8a64: e5940004  ldr r0, [r4, #4]
    8a68: ebfff5ca  bl  6198 <Xil_In32>
          QspiPtr->Config.BaseAddress,
           XQSPIPS_CR_OFFSET);
        ConfigReg |= XQSPIPS_CR_MANSTRT_MASK;
    8a6c: e3801801  orr r1, r0, #65536  ; 0x10000
        XQspiPs_WriteReg(
    8a70: e5940004  ldr r0, [r4, #4]
    8a74: ebfff5cd  bl  61b0 <Xil_Out32>
    8a78: eaffffbc  b 8970 <XQspiPs_InterruptHandler+0x194>
          if (QspiPtr->RequestedBytes < 0) {
            QspiPtr->RequestedBytes = 0;
          }
        }
      } else {
        XQspiPs_ReadReg(QspiPtr->Config.BaseAddress,
    8a7c: e5940004  ldr r0, [r4, #4]
    8a80: e2800020  add r0, r0, #32
    8a84: ebfff5c3  bl  6198 <Xil_In32>
            XQSPIPS_RXD_OFFSET);
        QspiPtr->RequestedBytes -= 4;
    8a88: e594301c  ldr r3, [r4, #28]
    8a8c: e2433004  sub r3, r3, #4
    8a90: e584301c  str r3, [r4, #28]
        if (QspiPtr->RequestedBytes < 0) {
    8a94: e3530000  cmp r3, #0
    8a98: aaffff81  bge 88a4 <XQspiPs_InterruptHandler+0xc8>
    8a9c: eaffff9a  b 890c <XQspiPs_InterruptHandler+0x130>

  /*
   * Check for overflow and underflow errors.
   */
  if (IntrStatus & XQSPIPS_IXR_RXOVR_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8aa0: e594301c  ldr r3, [r4, #28]
    QspiPtr->IsBusy = FALSE;
    8aa4: e3a02000  mov r2, #0

  /*
   * Check for overflow and underflow errors.
   */
  if (IntrStatus & XQSPIPS_IXR_RXOVR_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8aa8: e5945020  ldr r5, [r4, #32]

    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    8aac: e1a00004  mov r0, r4
  /*
   * Check for overflow and underflow errors.
   */
  if (IntrStatus & XQSPIPS_IXR_RXOVR_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    QspiPtr->IsBusy = FALSE;
    8ab0: e5842024  str r2, [r4, #36] ; 0x24

  /*
   * Check for overflow and underflow errors.
   */
  if (IntrStatus & XQSPIPS_IXR_RXOVR_MASK) {
    BytesDone = QspiPtr->RequestedBytes - QspiPtr->RemainingBytes;
    8ab4: e0655003  rsb r5, r5, r3

    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
    8ab8: eb00007e  bl  8cb8 <XQspiPs_GetOptions>
    8abc: e3100010  tst r0, #16
    8ac0: 1a00001e  bne 8b40 <XQspiPs_InterruptHandler+0x364>
    }

    /*
     * Disable the device.
     */
    XQspiPs_Disable(QspiPtr);
    8ac4: e5940004  ldr r0, [r4, #4]
    8ac8: e3a01000  mov r1, #0
    8acc: e2800014  add r0, r0, #20
    8ad0: ebfff5b6  bl  61b0 <Xil_Out32>

    /*
     * Reset the RX FIFO threshold to one
     */
    XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8ad4: e5940004  ldr r0, [r4, #4]
    8ad8: e3a01001  mov r1, #1
    8adc: e280002c  add r0, r0, #44 ; 0x2c
    8ae0: ebfff5b2  bl  61b0 <Xil_Out32>
      XQSPIPS_RXWR_OFFSET, XQSPIPS_RXWR_RESET_VALUE);

    QspiPtr->StatusHandler(QspiPtr->StatusRef,
    8ae4: e1a02005  mov r2, r5
    8ae8: e5943028  ldr r3, [r4, #40] ; 0x28
    8aec: e3001482  movw  r1, #1154 ; 0x482
    8af0: e594002c  ldr r0, [r4, #44] ; 0x2c
    8af4: e12fff33  blx r3
      XST_SPI_RECEIVE_OVERRUN, BytesDone);
  }

  if (IntrStatus & XQSPIPS_IXR_TXUF_MASK) {
    8af8: e3160040  tst r6, #64 ; 0x40
    8afc: 08bd87f0  popeq {r4, r5, r6, r7, r8, r9, sl, pc}
    8b00: eaffff9e  b 8980 <XQspiPs_InterruptHandler+0x1a4>
  u32 Data;
  u32 TransCount;
  u32 Count = 0;
  unsigned BytesDone; /* Number of bytes done so far. */

  Xil_AssertVoid(InstancePtr != NULL);
    8b04: e3080718  movw  r0, #34584  ; 0x8718
    8b08: e30014f2  movw  r1, #1266 ; 0x4f2
    8b0c: e3400001  movt  r0, #1
    8b10: eb00015e  bl  9090 <Xil_Assert>
    8b14: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8b18: e3403002  movt  r3, #2
    8b1c: e3a02001  mov r2, #1
    8b20: e5832000  str r2, [r3]
    8b24: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
      ConfigReg = XQspiPs_ReadReg(
    8b28: e5940004  ldr r0, [r4, #4]
    8b2c: ebfff599  bl  6198 <Xil_In32>
          QspiPtr->Config.BaseAddress,
          XQSPIPS_CR_OFFSET);
      ConfigReg |= XQSPIPS_CR_SSCTRL_MASK;
    8b30: e3801b01  orr r1, r0, #1024 ; 0x400
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8b34: e5940004  ldr r0, [r4, #4]
    8b38: ebfff59c  bl  61b0 <Xil_Out32>
    8b3c: eaffff98  b 89a4 <XQspiPs_InterruptHandler+0x1c8>
    /*
     * If the Slave select lines is being manually controlled,
     * disable it because the transfer is complete.
     */
    if (XQspiPs_IsManualChipSelect(InstancePtr)) {
      ConfigReg = XQspiPs_ReadReg(
    8b40: e5940004  ldr r0, [r4, #4]
    8b44: ebfff593  bl  6198 <Xil_In32>
          QspiPtr->Config.BaseAddress,
          XQSPIPS_CR_OFFSET);
      ConfigReg |= XQSPIPS_CR_SSCTRL_MASK;
    8b48: e3801b01  orr r1, r0, #1024 ; 0x400
      XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8b4c: e5940004  ldr r0, [r4, #4]
    8b50: ebfff596  bl  61b0 <Xil_Out32>
    8b54: eaffffda  b 8ac4 <XQspiPs_InterruptHandler+0x2e8>
      /*
       * If the Slave select is being manually controlled,
       * disable it because the transfer is complete.
       */
      if (XQspiPs_IsManualChipSelect(InstancePtr)) {
        ConfigReg = XQspiPs_ReadReg(
    8b58: e5940004  ldr r0, [r4, #4]
    8b5c: ebfff58d  bl  6198 <Xil_In32>
            QspiPtr->Config.BaseAddress,
            XQSPIPS_CR_OFFSET);
        ConfigReg |= XQSPIPS_CR_SSCTRL_MASK;
    8b60: e3801b01  orr r1, r0, #1024 ; 0x400
        XQspiPs_WriteReg(QspiPtr->Config.BaseAddress,
    8b64: e5940004  ldr r0, [r4, #4]
    8b68: ebfff590  bl  61b0 <Xil_Out32>
    8b6c: eaffff70  b 8934 <XQspiPs_InterruptHandler+0x158>
      }

      Count++;
    }

    if ((QspiPtr->RemainingBytes == 0) &&
    8b70: 0affffb0  beq 8a38 <XQspiPs_InterruptHandler+0x25c>
    8b74: eaffffb2  b 8a44 <XQspiPs_InterruptHandler+0x268>

00008b78 <XQspiPs_LookupConfig>:
{
  XQspiPs_Config *CfgPtr = NULL;
  int Index;

  for (Index = 0; Index < XPAR_XQSPIPS_NUM_INSTANCES; Index++) {
    if (XQspiPs_ConfigTable[Index].DeviceId == DeviceId) {
    8b78: e30b337c  movw  r3, #45948  ; 0xb37c
    8b7c: e3403001  movt  r3, #1
    8b80: e1d320b0  ldrh  r2, [r3]
      CfgPtr = &XQspiPs_ConfigTable[Index];
      break;
    }
  }
  return CfgPtr;
}
    8b84: e1520000  cmp r2, r0
    8b88: 01a00003  moveq r0, r3
    8b8c: 13a00000  movne r0, #0
    8b90: e12fff1e  bx  lr

00008b94 <XQspiPs_SetOptions>:
* @note
* This function is not thread-safe.
*
******************************************************************************/
int XQspiPs_SetOptions(XQspiPs *InstancePtr, u32 Options)
{
    8b94: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  u32 ConfigReg;
  unsigned int Index;
  u32 QspiOptions;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8b98: e2506000  subs  r6, r0, #0
    8b9c: 0a000032  beq 8c6c <XQspiPs_SetOptions+0xd8>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8ba0: e5962010  ldr r2, [r6, #16]
    8ba4: e3013111  movw  r3, #4369 ; 0x1111
    8ba8: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 ConfigReg;
  unsigned int Index;
  u32 QspiOptions;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8bac: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8bb0: e1520003  cmp r2, r3
{
  u32 ConfigReg;
  unsigned int Index;
  u32 QspiOptions;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8bb4: e3405002  movt  r5, #2
    8bb8: e3a04000  mov r4, #0
    8bbc: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8bc0: 1a000004  bne 8bd8 <XQspiPs_SetOptions+0x44>

  /*
   * Do not allow to modify the Control Register while a transfer is in
   * progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    8bc4: e5963024  ldr r3, [r6, #36] ; 0x24
    8bc8: e3530000  cmp r3, #0
    8bcc: 0a000009  beq 8bf8 <XQspiPs_SetOptions+0x64>
    return XST_DEVICE_BUSY;
    8bd0: e3a00015  mov r0, #21
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_LQSPI_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
}
    8bd4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  u32 ConfigReg;
  unsigned int Index;
  u32 QspiOptions;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8bd8: e3080724  movw  r0, #34596  ; 0x8724
    8bdc: e3a0107f  mov r1, #127  ; 0x7f
    8be0: e3400001  movt  r0, #1
    8be4: eb000129  bl  9090 <Xil_Assert>
    8be8: e3a03001  mov r3, #1
    8bec: e1a00004  mov r0, r4
    8bf0: e5853000  str r3, [r5]
    8bf4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  }

  QspiOptions = Options & XQSPIPS_LQSPI_MODE_OPTION;
  Options &= ~XQSPIPS_LQSPI_MODE_OPTION;

  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8bf8: e5960004  ldr r0, [r6, #4]
    8bfc: e1a07001  mov r7, r1
  if (InstancePtr->IsBusy) {
    return XST_DEVICE_BUSY;
  }

  QspiOptions = Options & XQSPIPS_LQSPI_MODE_OPTION;
  Options &= ~XQSPIPS_LQSPI_MODE_OPTION;
    8c00: e3c14080  bic r4, r1, #128  ; 0x80

  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8c04: ebfff563  bl  6198 <Xil_In32>
    8c08: e3083450  movw  r3, #33872  ; 0x8450
    8c0c: e3403001  movt  r3, #1
    8c10: e1a01000  mov r1, r0
    8c14: e2830028  add r0, r3, #40 ; 0x28
  /*
   * Loop through the options table, turning the option on or off
   * depending on whether the bit is set in the incoming options flag.
   */
  for (Index = 0; Index < XQSPIPS_NUM_OPTIONS; Index++) {
    if (Options & OptionsTable[Index].Option) {
    8c18: e5932000  ldr r2, [r3]
    8c1c: e2833008  add r3, r3, #8
    8c20: e1140002  tst r4, r2
      /* Turn it on */
      ConfigReg |= OptionsTable[Index].Mask;
    8c24: e5132004  ldr r2, [r3, #-4]
    8c28: 11811002  orrne r1, r1, r2
    } else {
      /* Turn it off */
      ConfigReg &= ~(OptionsTable[Index].Mask);
    8c2c: 01c11002  biceq r1, r1, r2

  /*
   * Loop through the options table, turning the option on or off
   * depending on whether the bit is set in the incoming options flag.
   */
  for (Index = 0; Index < XQSPIPS_NUM_OPTIONS; Index++) {
    8c30: e1530000  cmp r3, r0
    8c34: 1afffff7  bne 8c18 <XQspiPs_SetOptions+0x84>

  /*
   * Now write the control register. Leave it to the upper layers
   * to restart the device.
   */
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress, XQSPIPS_CR_OFFSET,
    8c38: e5960004  ldr r0, [r6, #4]
    8c3c: ebfff55b  bl  61b0 <Xil_Out32>
       ConfigReg);

  /*
   * Check for the LQSPI configuration options.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8c40: e5960004  ldr r0, [r6, #4]
    8c44: e28000a0  add r0, r0, #160  ; 0xa0
    8c48: ebfff552  bl  6198 <Xil_In32>
              XQSPIPS_LQSPI_CR_OFFSET);


  if (QspiOptions & XQSPIPS_LQSPI_MODE_OPTION) {
    8c4c: e2174080  ands  r4, r7, #128  ; 0x80
    8c50: 1a00000f  bne 8c94 <XQspiPs_SetOptions+0x100>
          XQSPIPS_LQSPI_CR_OFFSET,
          XQSPIPS_LQSPI_CR_RST_STATE);
    XQspiPs_SetSlaveSelect(InstancePtr);
  } else {
    ConfigReg &= ~XQSPIPS_LQSPI_CR_LINEAR_MASK;
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8c54: e5963004  ldr r3, [r6, #4]
    8c58: e3c01102  bic r1, r0, #-2147483648  ; 0x80000000
    8c5c: e28300a0  add r0, r3, #160  ; 0xa0
    8c60: ebfff552  bl  61b0 <Xil_Out32>
          XQSPIPS_LQSPI_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
    8c64: e1a00004  mov r0, r4
    8c68: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
{
  u32 ConfigReg;
  unsigned int Index;
  u32 QspiOptions;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8c6c: e3080724  movw  r0, #34596  ; 0x8724
    8c70: e3a0107e  mov r1, #126  ; 0x7e
    8c74: e3400001  movt  r0, #1
    8c78: eb000104  bl  9090 <Xil_Assert>
    8c7c: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8c80: e3403002  movt  r3, #2
    8c84: e3a02001  mov r2, #1
    8c88: e1a00006  mov r0, r6
    8c8c: e5832000  str r2, [r3]
    8c90: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
              XQSPIPS_LQSPI_CR_OFFSET);


  if (QspiOptions & XQSPIPS_LQSPI_MODE_OPTION) {
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8c94: e5960004  ldr r0, [r6, #4]
    8c98: e300116b  movw  r1, #363  ; 0x16b
    8c9c: e3481000  movt  r1, #32768  ; 0x8000
    8ca0: e28000a0  add r0, r0, #160  ; 0xa0
    8ca4: ebfff541  bl  61b0 <Xil_Out32>
          XQSPIPS_LQSPI_CR_OFFSET,
          XQSPIPS_LQSPI_CR_RST_STATE);
    XQspiPs_SetSlaveSelect(InstancePtr);
    8ca8: e1a00006  mov r0, r6
    8cac: ebfffe78  bl  8694 <XQspiPs_SetSlaveSelect>
    ConfigReg &= ~XQSPIPS_LQSPI_CR_LINEAR_MASK;
    XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
          XQSPIPS_LQSPI_CR_OFFSET, ConfigReg);
  }

  return XST_SUCCESS;
    8cb0: e3a00000  mov r0, #0
    8cb4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

00008cb8 <XQspiPs_GetOptions>:
*
* @note   None.
*
******************************************************************************/
u32 XQspiPs_GetOptions(XQspiPs *InstancePtr)
{
    8cb8: e92d4070  push  {r4, r5, r6, lr}
  u32 OptionsFlag = 0;
  u32 ConfigReg;
  unsigned int Index;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8cbc: e2506000  subs  r6, r0, #0
    8cc0: 0a000023  beq 8d54 <XQspiPs_GetOptions+0x9c>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8cc4: e5962010  ldr r2, [r6, #16]
    8cc8: e3013111  movw  r3, #4369 ; 0x1111
    8ccc: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 OptionsFlag = 0;
  u32 ConfigReg;
  unsigned int Index;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8cd0: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8cd4: e1520003  cmp r2, r3
{
  u32 OptionsFlag = 0;
  u32 ConfigReg;
  unsigned int Index;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8cd8: e3405002  movt  r5, #2
    8cdc: e3a04000  mov r4, #0
    8ce0: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8ce4: 0a000007  beq 8d08 <XQspiPs_GetOptions+0x50>
    8ce8: e3080724  movw  r0, #34596  ; 0x8724
    8cec: e3a010d1  mov r1, #209  ; 0xd1
    8cf0: e3400001  movt  r0, #1
    8cf4: eb0000e5  bl  9090 <Xil_Assert>
    8cf8: e3a03001  mov r3, #1
    8cfc: e1a00004  mov r0, r4
    8d00: e5853000  str r3, [r5]
    8d04: e8bd8070  pop {r4, r5, r6, pc}

  /*
   * Get the current options from QSPI configuration register.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8d08: e5960004  ldr r0, [r6, #4]
    8d0c: ebfff521  bl  6198 <Xil_In32>
    8d10: e3083450  movw  r3, #33872  ; 0x8450
    8d14: e3403001  movt  r3, #1
    8d18: e2831028  add r1, r3, #40 ; 0x28

  /*
   * Loop through the options table to grab options
   */
  for (Index = 0; Index < XQSPIPS_NUM_OPTIONS; Index++) {
    if (ConfigReg & OptionsTable[Index].Mask) {
    8d1c: e5932004  ldr r2, [r3, #4]
    8d20: e2833008  add r3, r3, #8
    8d24: e1100002  tst r0, r2
      OptionsFlag |= OptionsTable[Index].Option;
    8d28: 15132008  ldrne r2, [r3, #-8]
    8d2c: 11844002  orrne r4, r4, r2
              XQSPIPS_CR_OFFSET);

  /*
   * Loop through the options table to grab options
   */
  for (Index = 0; Index < XQSPIPS_NUM_OPTIONS; Index++) {
    8d30: e1530001  cmp r3, r1
    8d34: 1afffff8  bne 8d1c <XQspiPs_GetOptions+0x64>
  }

  /*
   * Check for the LQSPI configuration options.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8d38: e5960004  ldr r0, [r6, #4]
    8d3c: e28000a0  add r0, r0, #160  ; 0xa0
    8d40: ebfff514  bl  6198 <Xil_In32>
              XQSPIPS_LQSPI_CR_OFFSET);

  if ((ConfigReg & XQSPIPS_LQSPI_CR_LINEAR_MASK) != 0) {
    8d44: e3500000  cmp r0, #0
    OptionsFlag |= XQSPIPS_LQSPI_MODE_OPTION;
    8d48: b3840080  orrlt r0, r4, #128  ; 0x80
    8d4c: a1a00004  movge r0, r4
  }

  return OptionsFlag;
}
    8d50: e8bd8070  pop {r4, r5, r6, pc}
{
  u32 OptionsFlag = 0;
  u32 ConfigReg;
  unsigned int Index;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8d54: e3080724  movw  r0, #34596  ; 0x8724
    8d58: e3a010d0  mov r1, #208  ; 0xd0
    8d5c: e3400001  movt  r0, #1
    8d60: eb0000ca  bl  9090 <Xil_Assert>
    8d64: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8d68: e3403002  movt  r3, #2
    8d6c: e3a02001  mov r2, #1
    8d70: e1a00006  mov r0, r6
    8d74: e5832000  str r2, [r3]
    8d78: e8bd8070  pop {r4, r5, r6, pc}

00008d7c <XQspiPs_SetClkPrescaler>:
* @note
* This function is not thread-safe.
*
******************************************************************************/
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
    8d7c: e92d4070  push  {r4, r5, r6, lr}
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8d80: e2506000  subs  r6, r0, #0
* @note
* This function is not thread-safe.
*
******************************************************************************/
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
    8d84: e24dd008  sub sp, sp, #8
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8d88: 0a000026  beq 8e28 <XQspiPs_SetClkPrescaler+0xac>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8d8c: e5962010  ldr r2, [r6, #16]
    8d90: e3013111  movw  r3, #4369 ; 0x1111
    8d94: e3413111  movt  r3, #4369 ; 0x1111
******************************************************************************/
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8d98: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8d9c: e1520003  cmp r2, r3
******************************************************************************/
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8da0: e3405002  movt  r5, #2
    8da4: e3a04000  mov r4, #0
    8da8: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8dac: 1a000007  bne 8dd0 <XQspiPs_SetClkPrescaler+0x54>
  Xil_AssertNonvoid(Prescaler <= XQSPIPS_CR_PRESC_MAXIMUM);
    8db0: e3510007  cmp r1, #7
    8db4: 8a00000e  bhi 8df4 <XQspiPs_SetClkPrescaler+0x78>

  /*
   * Do not allow the slave select to change while a transfer is in
   * progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    8db8: e5964024  ldr r4, [r6, #36] ; 0x24
    8dbc: e3540000  cmp r4, #0
    return XST_DEVICE_BUSY;
    8dc0: 13a00015  movne r0, #21

  /*
   * Do not allow the slave select to change while a transfer is in
   * progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    8dc4: 0a00000d  beq 8e00 <XQspiPs_SetClkPrescaler+0x84>
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
        XQSPIPS_CR_OFFSET,
        ConfigReg);

  return XST_SUCCESS;
}
    8dc8: e28dd008  add sp, sp, #8
    8dcc: e8bd8070  pop {r4, r5, r6, pc}
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8dd0: e3080724  movw  r0, #34596  ; 0x8724
    8dd4: e3001109  movw  r1, #265  ; 0x109
  Xil_AssertNonvoid(Prescaler <= XQSPIPS_CR_PRESC_MAXIMUM);
    8dd8: e3400001  movt  r0, #1
    8ddc: eb0000ab  bl  9090 <Xil_Assert>
    8de0: e1a00004  mov r0, r4
    8de4: e3a03001  mov r3, #1
    8de8: e5853000  str r3, [r5]
  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
        XQSPIPS_CR_OFFSET,
        ConfigReg);

  return XST_SUCCESS;
}
    8dec: e28dd008  add sp, sp, #8
    8df0: e8bd8070  pop {r4, r5, r6, pc}
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
  Xil_AssertNonvoid(Prescaler <= XQSPIPS_CR_PRESC_MAXIMUM);
    8df4: e3080724  movw  r0, #34596  ; 0x8724
    8df8: e300110a  movw  r1, #266  ; 0x10a
    8dfc: eafffff5  b 8dd8 <XQspiPs_SetClkPrescaler+0x5c>
  /*
   * Read the configuration register, mask out the interesting bits, and set
   * them with the shifted value passed into the function. Write the
   * results back to the configuration register.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8e00: e5960004  ldr r0, [r6, #4]
    8e04: e58d1004  str r1, [sp, #4]
    8e08: ebfff4e2  bl  6198 <Xil_In32>

  ConfigReg &= ~XQSPIPS_CR_PRESC_MASK;
  ConfigReg |= (u32) (Prescaler & XQSPIPS_CR_PRESC_MAXIMUM) <<
          XQSPIPS_CR_PRESC_SHIFT;

  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8e0c: e59d1004  ldr r1, [sp, #4]
   * results back to the configuration register.
   */
  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
              XQSPIPS_CR_OFFSET);

  ConfigReg &= ~XQSPIPS_CR_PRESC_MASK;
    8e10: e3c03038  bic r3, r0, #56 ; 0x38
  ConfigReg |= (u32) (Prescaler & XQSPIPS_CR_PRESC_MAXIMUM) <<
          XQSPIPS_CR_PRESC_SHIFT;

  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8e14: e5960004  ldr r0, [r6, #4]
    8e18: e1831181  orr r1, r3, r1, lsl #3
    8e1c: ebfff4e3  bl  61b0 <Xil_Out32>
        XQSPIPS_CR_OFFSET,
        ConfigReg);

  return XST_SUCCESS;
    8e20: e1a00004  mov r0, r4
    8e24: eaffffe7  b 8dc8 <XQspiPs_SetClkPrescaler+0x4c>
******************************************************************************/
int XQspiPs_SetClkPrescaler(XQspiPs *InstancePtr, u8 Prescaler)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8e28: e3080724  movw  r0, #34596  ; 0x8724
    8e2c: e3a01f42  mov r1, #264  ; 0x108
    8e30: e3400001  movt  r0, #1
    8e34: eb000095  bl  9090 <Xil_Assert>
    8e38: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8e3c: e3403002  movt  r3, #2
    8e40: e3a02001  mov r2, #1
    8e44: e1a00006  mov r0, r6
    8e48: e5832000  str r2, [r3]
    8e4c: eaffffdd  b 8dc8 <XQspiPs_SetClkPrescaler+0x4c>

00008e50 <XQspiPs_GetClkPrescaler>:
* @note   None.
*
*
******************************************************************************/
u8 XQspiPs_GetClkPrescaler(XQspiPs *InstancePtr)
{
    8e50: e92d4070  push  {r4, r5, r6, lr}
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8e54: e2506000  subs  r6, r0, #0
    8e58: 0a000014  beq 8eb0 <XQspiPs_GetClkPrescaler+0x60>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8e5c: e5962010  ldr r2, [r6, #16]
    8e60: e3013111  movw  r3, #4369 ; 0x1111
    8e64: e3413111  movt  r3, #4369 ; 0x1111
******************************************************************************/
u8 XQspiPs_GetClkPrescaler(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8e68: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8e6c: e1520003  cmp r2, r3
******************************************************************************/
u8 XQspiPs_GetClkPrescaler(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8e70: e3405002  movt  r5, #2
    8e74: e3a04000  mov r4, #0
    8e78: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8e7c: 0a000007  beq 8ea0 <XQspiPs_GetClkPrescaler+0x50>
    8e80: e3080724  movw  r0, #34596  ; 0x8724
    8e84: e3001139  movw  r1, #313  ; 0x139
    8e88: e3400001  movt  r0, #1
    8e8c: eb00007f  bl  9090 <Xil_Assert>
    8e90: e3a03001  mov r3, #1
    8e94: e1a00004  mov r0, r4
    8e98: e5853000  str r3, [r5]
              XQSPIPS_CR_OFFSET);

  ConfigReg &= XQSPIPS_CR_PRESC_MASK;

  return (u8)(ConfigReg >> XQSPIPS_CR_PRESC_SHIFT);
}
    8e9c: e8bd8070  pop {r4, r5, r6, pc}
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  ConfigReg = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8ea0: e5960004  ldr r0, [r6, #4]
    8ea4: ebfff4bb  bl  6198 <Xil_In32>
              XQSPIPS_CR_OFFSET);

  ConfigReg &= XQSPIPS_CR_PRESC_MASK;

  return (u8)(ConfigReg >> XQSPIPS_CR_PRESC_SHIFT);
    8ea8: e7e201d0  ubfx  r0, r0, #3, #3
    8eac: e8bd8070  pop {r4, r5, r6, pc}
******************************************************************************/
u8 XQspiPs_GetClkPrescaler(XQspiPs *InstancePtr)
{
  u32 ConfigReg;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8eb0: e3080724  movw  r0, #34596  ; 0x8724
    8eb4: e3a01f4e  mov r1, #312  ; 0x138
    8eb8: e3400001  movt  r0, #1
    8ebc: eb000073  bl  9090 <Xil_Assert>
    8ec0: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8ec4: e3403002  movt  r3, #2
    8ec8: e3a02001  mov r2, #1
    8ecc: e1a00006  mov r0, r6
    8ed0: e5832000  str r2, [r3]
    8ed4: e8bd8070  pop {r4, r5, r6, pc}

00008ed8 <XQspiPs_SetDelays>:
* @note   None.
*
******************************************************************************/
int XQspiPs_SetDelays(XQspiPs *InstancePtr, u8 DelayNss, u8 DelayBtwn,
       u8 DelayAfter, u8 DelayInit)
{
    8ed8: e92d4070  push  {r4, r5, r6, lr}
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8edc: e2506000  subs  r6, r0, #0
* @note   None.
*
******************************************************************************/
int XQspiPs_SetDelays(XQspiPs *InstancePtr, u8 DelayNss, u8 DelayBtwn,
       u8 DelayAfter, u8 DelayInit)
{
    8ee0: e5dde010  ldrb  lr, [sp, #16]
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8ee4: 0a00001d  beq 8f60 <XQspiPs_SetDelays+0x88>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8ee8: e5960010  ldr r0, [r6, #16]
    8eec: e301c111  movw  ip, #4369 ; 0x1111
    8ef0: e341c111  movt  ip, #4369 ; 0x1111
int XQspiPs_SetDelays(XQspiPs *InstancePtr, u8 DelayNss, u8 DelayBtwn,
       u8 DelayAfter, u8 DelayInit)
{
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8ef4: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8ef8: e150000c  cmp r0, ip
int XQspiPs_SetDelays(XQspiPs *InstancePtr, u8 DelayNss, u8 DelayBtwn,
       u8 DelayAfter, u8 DelayInit)
{
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8efc: e3405002  movt  r5, #2
    8f00: e3a04000  mov r4, #0
    8f04: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8f08: 1a000004  bne 8f20 <XQspiPs_SetDelays+0x48>

  /*
   * Do not allow the delays to change while a transfer is in
   * progress. Not thread-safe.
   */
  if (InstancePtr->IsBusy) {
    8f0c: e5964024  ldr r4, [r6, #36] ; 0x24
    8f10: e3540000  cmp r4, #0
    8f14: 0a000009  beq 8f40 <XQspiPs_SetDelays+0x68>
    return XST_DEVICE_BUSY;
    8f18: e3a00015  mov r0, #21

  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
        XQSPIPS_DR_OFFSET, DelayRegister);

  return XST_SUCCESS;
}
    8f1c: e8bd8070  pop {r4, r5, r6, pc}
       u8 DelayAfter, u8 DelayInit)
{
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8f20: e3080724  movw  r0, #34596  ; 0x8724
    8f24: e3a01f5a  mov r1, #360  ; 0x168
    8f28: e3400001  movt  r0, #1
    8f2c: eb000057  bl  9090 <Xil_Assert>
    8f30: e3a03001  mov r3, #1
    8f34: e1a00004  mov r0, r4
    8f38: e5853000  str r3, [r5]
    8f3c: e8bd8070  pop {r4, r5, r6, pc}
    8f40: e18ee403  orr lr, lr, r3, lsl #8
  DelayRegister = (u32) DelayNss << XQSPIPS_DR_NSS_SHIFT;
  DelayRegister |= (u32) DelayBtwn << XQSPIPS_DR_BTWN_SHIFT;
  DelayRegister |= (u32) DelayAfter << XQSPIPS_DR_AFTER_SHIFT;
  DelayRegister |= (u32) DelayInit;

  XQspiPs_WriteReg(InstancePtr->Config.BaseAddress,
    8f44: e5960004  ldr r0, [r6, #4]
    8f48: e18e2802  orr r2, lr, r2, lsl #16
    8f4c: e1821c01  orr r1, r2, r1, lsl #24
    8f50: e2800018  add r0, r0, #24
    8f54: ebfff495  bl  61b0 <Xil_Out32>
        XQSPIPS_DR_OFFSET, DelayRegister);

  return XST_SUCCESS;
    8f58: e1a00004  mov r0, r4
    8f5c: e8bd8070  pop {r4, r5, r6, pc}
int XQspiPs_SetDelays(XQspiPs *InstancePtr, u8 DelayNss, u8 DelayBtwn,
       u8 DelayAfter, u8 DelayInit)
{
  u32 DelayRegister;

  Xil_AssertNonvoid(InstancePtr != NULL);
    8f60: e3080724  movw  r0, #34596  ; 0x8724
    8f64: e3001167  movw  r1, #359  ; 0x167
    8f68: e3400001  movt  r0, #1
    8f6c: eb000047  bl  9090 <Xil_Assert>
    8f70: e3023ae8  movw  r3, #10984  ; 0x2ae8
    8f74: e3403002  movt  r3, #2
    8f78: e3a02001  mov r2, #1
    8f7c: e1a00006  mov r0, r6
    8f80: e5832000  str r2, [r3]
    8f84: e8bd8070  pop {r4, r5, r6, pc}

00008f88 <XQspiPs_GetDelays>:
void XQspiPs_GetDelays(XQspiPs *InstancePtr, u8 *DelayNss, u8 *DelayBtwn,
       u8 *DelayAfter, u8 *DelayInit)
{
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
    8f88: e3500000  cmp r0, #0
* @note   None.
*
******************************************************************************/
void XQspiPs_GetDelays(XQspiPs *InstancePtr, u8 *DelayNss, u8 *DelayBtwn,
       u8 *DelayAfter, u8 *DelayInit)
{
    8f8c: e92d4010  push  {r4, lr}
    8f90: e24dd010  sub sp, sp, #16
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
    8f94: 0a000021  beq 9020 <XQspiPs_GetDelays+0x98>
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8f98: e590e010  ldr lr, [r0, #16]
    8f9c: e301c111  movw  ip, #4369 ; 0x1111
    8fa0: e341c111  movt  ip, #4369 ; 0x1111
void XQspiPs_GetDelays(XQspiPs *InstancePtr, u8 *DelayNss, u8 *DelayBtwn,
       u8 *DelayAfter, u8 *DelayInit)
{
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
    8fa4: e3024ae8  movw  r4, #10984  ; 0x2ae8
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8fa8: e15e000c  cmp lr, ip
void XQspiPs_GetDelays(XQspiPs *InstancePtr, u8 *DelayNss, u8 *DelayBtwn,
       u8 *DelayAfter, u8 *DelayInit)
{
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
    8fac: e3404002  movt  r4, #2
    8fb0: e3a0c000  mov ip, #0
    8fb4: e584c000  str ip, [r4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
    8fb8: 0a000007  beq 8fdc <XQspiPs_GetDelays+0x54>
    8fbc: e3080724  movw  r0, #34596  ; 0x8724
    8fc0: e300119a  movw  r1, #410  ; 0x19a
    8fc4: e3400001  movt  r0, #1
    8fc8: eb000030  bl  9090 <Xil_Assert>
    8fcc: e3a03001  mov r3, #1
    8fd0: e5843000  str r3, [r4]
  *DelayBtwn = (u8)((DelayRegister & XQSPIPS_DR_BTWN_MASK) >>
        XQSPIPS_DR_BTWN_SHIFT);

  *DelayNss = (u8)((DelayRegister & XQSPIPS_DR_NSS_MASK) >>
        XQSPIPS_DR_NSS_SHIFT);
}
    8fd4: e28dd010  add sp, sp, #16
    8fd8: e8bd8010  pop {r4, pc}
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  DelayRegister = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
    8fdc: e5900004  ldr r0, [r0, #4]
    8fe0: e98d000e  stmib sp, {r1, r2, r3}
    8fe4: e2800018  add r0, r0, #24
    8fe8: ebfff46a  bl  6198 <Xil_In32>
           XQSPIPS_DR_OFFSET);

  *DelayInit = (u8)(DelayRegister & XQSPIPS_DR_INIT_MASK);
    8fec: e59d3018  ldr r3, [sp, #24]

  *DelayAfter = (u8)((DelayRegister & XQSPIPS_DR_AFTER_MASK) >>
         XQSPIPS_DR_AFTER_SHIFT);

  *DelayBtwn = (u8)((DelayRegister & XQSPIPS_DR_BTWN_MASK) >>
    8ff0: e59d2008  ldr r2, [sp, #8]
        XQSPIPS_DR_BTWN_SHIFT);

  *DelayNss = (u8)((DelayRegister & XQSPIPS_DR_NSS_MASK) >>
    8ff4: e59d1004  ldr r1, [sp, #4]
  Xil_AssertVoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  DelayRegister = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_DR_OFFSET);

  *DelayInit = (u8)(DelayRegister & XQSPIPS_DR_INIT_MASK);
    8ff8: e5c30000  strb  r0, [r3]
         XQSPIPS_DR_AFTER_SHIFT);

  *DelayBtwn = (u8)((DelayRegister & XQSPIPS_DR_BTWN_MASK) >>
        XQSPIPS_DR_BTWN_SHIFT);

  *DelayNss = (u8)((DelayRegister & XQSPIPS_DR_NSS_MASK) >>
    8ffc: e1a0cc20  lsr ip, r0, #24
  DelayRegister = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_DR_OFFSET);

  *DelayInit = (u8)(DelayRegister & XQSPIPS_DR_INIT_MASK);

  *DelayAfter = (u8)((DelayRegister & XQSPIPS_DR_AFTER_MASK) >>
    9000: e59d300c  ldr r3, [sp, #12]
    9004: e7e7e450  ubfx  lr, r0, #8, #8
         XQSPIPS_DR_AFTER_SHIFT);

  *DelayBtwn = (u8)((DelayRegister & XQSPIPS_DR_BTWN_MASK) >>
    9008: e7e70850  ubfx  r0, r0, #16, #8
  DelayRegister = XQspiPs_ReadReg(InstancePtr->Config.BaseAddress,
           XQSPIPS_DR_OFFSET);

  *DelayInit = (u8)(DelayRegister & XQSPIPS_DR_INIT_MASK);

  *DelayAfter = (u8)((DelayRegister & XQSPIPS_DR_AFTER_MASK) >>
    900c: e5c3e000  strb  lr, [r3]
         XQSPIPS_DR_AFTER_SHIFT);

  *DelayBtwn = (u8)((DelayRegister & XQSPIPS_DR_BTWN_MASK) >>
    9010: e5c20000  strb  r0, [r2]
        XQSPIPS_DR_BTWN_SHIFT);

  *DelayNss = (u8)((DelayRegister & XQSPIPS_DR_NSS_MASK) >>
    9014: e5c1c000  strb  ip, [r1]
        XQSPIPS_DR_NSS_SHIFT);
}
    9018: e28dd010  add sp, sp, #16
    901c: e8bd8010  pop {r4, pc}
void XQspiPs_GetDelays(XQspiPs *InstancePtr, u8 *DelayNss, u8 *DelayBtwn,
       u8 *DelayAfter, u8 *DelayInit)
{
  u32 DelayRegister;

  Xil_AssertVoid(InstancePtr != NULL);
    9020: e3080724  movw  r0, #34596  ; 0x8724
    9024: e3001199  movw  r1, #409  ; 0x199
    9028: e3400001  movt  r0, #1
    902c: eb000017  bl  9090 <Xil_Assert>
    9030: e3023ae8  movw  r3, #10984  ; 0x2ae8
    9034: e3403002  movt  r3, #2
    9038: e3a02001  mov r2, #1
    903c: e5832000  str r2, [r3]
    9040: eaffffe3  b 8fd4 <XQspiPs_GetDelays+0x4c>

00009044 <__cpu_init>:
  .global __cpu_init
  .align 2
__cpu_init:

/* Clear cp15 regs with unknown reset values */
  mov r0, #0x0
    9044: e3a00000  mov r0, #0
  mcr p15, 0, r0, c5, c0, 0 /* DFSR */
    9048: ee050f10  mcr 15, 0, r0, cr5, cr0, {0}
  mcr p15, 0, r0, c5, c0, 1 /* IFSR */
    904c: ee050f30  mcr 15, 0, r0, cr5, cr0, {1}
  mcr p15, 0, r0, c6, c0, 0 /* DFAR */
    9050: ee060f10  mcr 15, 0, r0, cr6, cr0, {0}
  mcr p15, 0, r0, c6, c0, 2 /* IFAR */
    9054: ee060f50  mcr 15, 0, r0, cr6, cr0, {2}
  mcr p15, 0, r0, c9, c13, 2  /* PMXEVCNTR */
    9058: ee090f5d  mcr 15, 0, r0, cr9, cr13, {2}
  mcr p15, 0, r0, c13, c0, 2  /* TPIDRURW */
    905c: ee0d0f50  mcr 15, 0, r0, cr13, cr0, {2}
  mcr p15, 0, r0, c13, c0, 3  /* TPIDRURO */
    9060: ee0d0f70  mcr 15, 0, r0, cr13, cr0, {3}

/* Reset and start Cycle Counter */
  mov r2, #0x80000000   /* clear overflow */
    9064: e3a02102  mov r2, #-2147483648  ; 0x80000000
  mcr p15, 0, r2, c9, c12, 3
    9068: ee092f7c  mcr 15, 0, r2, cr9, cr12, {3}
  mov r2, #0xd    /* D, C, E */
    906c: e3a0200d  mov r2, #13
  mcr p15, 0, r2, c9, c12, 0
    9070: ee092f1c  mcr 15, 0, r2, cr9, cr12, {0}
  mov r2, #0x80000000   /* enable cycle counter */
    9074: e3a02102  mov r2, #-2147483648  ; 0x80000000
  mcr p15, 0, r2, c9, c12, 1
    9078: ee092f3c  mcr 15, 0, r2, cr9, cr12, {1}

  bx  lr
    907c: e12fff1e  bx  lr

00009080 <outbyte>:

#ifdef __cplusplus
}
#endif 

void outbyte(char c) {
    9080: e1a01000  mov r1, r0
   XUartPs_SendByte(STDOUT_BASEADDRESS, c);
    9084: e3a00a01  mov r0, #4096 ; 0x1000
    9088: e34e0000  movt  r0, #57344  ; 0xe000
    908c: ea00000c  b 90c4 <XUartPs_SendByte>

00009090 <Xil_Assert>:
*
* @note     None.
*
******************************************************************************/
void Xil_Assert(const char8 *File, s32 Line)
{
    9090: e92d4008  push  {r3, lr}
  s32 Xil_AssertWait = 1;
  /* if the callback has been set then invoke it */
  if (Xil_AssertCallbackRoutine != 0) {
    9094: e3013520  movw  r3, #5408 ; 0x1520
    9098: e3403002  movt  r3, #2
    909c: e5933000  ldr r3, [r3]
    90a0: e3530000  cmp r3, #0
    90a4: 0a000000  beq 90ac <Xil_Assert+0x1c>
    (*Xil_AssertCallbackRoutine)(File, Line);
    90a8: e12fff33  blx r3
    90ac: eafffffe  b 90ac <Xil_Assert+0x1c>

000090b0 <Xil_AssertSetCallback>:
* @note     This function has no effect if NDEBUG is set
*
******************************************************************************/
void Xil_AssertSetCallback(Xil_AssertCallback Routine)
{
  Xil_AssertCallbackRoutine = Routine;
    90b0: e3013520  movw  r3, #5408 ; 0x1520
    90b4: e3403002  movt  r3, #2
    90b8: e5830000  str r0, [r3]
    90bc: e12fff1e  bx  lr

000090c0 <XNullHandler>:
*
* @note     None.
*
******************************************************************************/
void XNullHandler(void *NullParameter)
{
    90c0: e12fff1e  bx  lr

000090c4 <XUartPs_SendByte>:
*
* @note   None.
*
*****************************************************************************/
void XUartPs_SendByte(u32 BaseAddress, u8 Data)
{
    90c4: e92d4070  push  {r4, r5, r6, lr}
    90c8: e280402c  add r4, r0, #44 ; 0x2c
    90cc: e1a05000  mov r5, r0
    90d0: e1a06001  mov r6, r1
  /*
   * Wait until there is space in TX FIFO
   */
  while (XUartPs_IsTransmitFull(BaseAddress)) {
    90d4: e1a00004  mov r0, r4
    90d8: ebfff42e  bl  6198 <Xil_In32>
    90dc: e3100010  tst r0, #16
    90e0: 1afffffb  bne 90d4 <XUartPs_SendByte+0x10>
  }

  /*
   * Write the byte into the TX FIFO
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_FIFO_OFFSET, (u32)Data);
    90e4: e2850030  add r0, r5, #48 ; 0x30
    90e8: e1a01006  mov r1, r6
}
    90ec: e8bd4070  pop {r4, r5, r6, lr}
  }

  /*
   * Write the byte into the TX FIFO
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_FIFO_OFFSET, (u32)Data);
    90f0: eafff42e  b 61b0 <Xil_Out32>

000090f4 <XUartPs_RecvByte>:
*
* @note   None.
*
*****************************************************************************/
u8 XUartPs_RecvByte(u32 BaseAddress)
{
    90f4: e92d4038  push  {r3, r4, r5, lr}
    90f8: e280402c  add r4, r0, #44 ; 0x2c
    90fc: e1a05000  mov r5, r0
  u32 RecievedByte;
  /*
   * Wait until there is data
   */
  while (!XUartPs_IsReceiveData(BaseAddress)) {
    9100: e1a00004  mov r0, r4
    9104: ebfff423  bl  6198 <Xil_In32>
    9108: e3100002  tst r0, #2
    910c: 1afffffb  bne 9100 <XUartPs_RecvByte+0xc>
    ;
  }
  RecievedByte = XUartPs_ReadReg(BaseAddress, XUARTPS_FIFO_OFFSET);
    9110: e2850030  add r0, r5, #48 ; 0x30
    9114: ebfff41f  bl  6198 <Xil_In32>
  /*
   * Return the byte received
   */
  return (u8)RecievedByte;
}
    9118: e6ef0070  uxtb  r0, r0
    911c: e8bd8038  pop {r3, r4, r5, pc}

00009120 <XUartPs_ResetHw>:
*
* @note   None.
*
*****************************************************************************/
void XUartPs_ResetHw(u32 BaseAddress)
{
    9120: e92d4010  push  {r4, lr}

  /*
   * Disable interrupts
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_IDR_OFFSET, XUARTPS_IXR_MASK);
    9124: e3011fff  movw  r1, #8191 ; 0x1fff
*
* @note   None.
*
*****************************************************************************/
void XUartPs_ResetHw(u32 BaseAddress)
{
    9128: e1a04000  mov r4, r0

  /*
   * Disable interrupts
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_IDR_OFFSET, XUARTPS_IXR_MASK);
    912c: e280000c  add r0, r0, #12
    9130: ebfff41e  bl  61b0 <Xil_Out32>

  /*
   * Disable receive and transmit
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_CR_OFFSET,
    9134: e1a00004  mov r0, r4
    9138: e3a01028  mov r1, #40 ; 0x28
    913c: ebfff41b  bl  61b0 <Xil_Out32>

  /*
   * Software reset of receive and transmit
   * This clears the FIFO.
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_CR_OFFSET,
    9140: e1a00004  mov r0, r4
    9144: e3a01003  mov r1, #3
    9148: ebfff418  bl  61b0 <Xil_Out32>
        ((u32)XUARTPS_CR_TXRST | (u32)XUARTPS_CR_RXRST));

  /*
   * Clear status flags - SW reset wont clear sticky flags.
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_ISR_OFFSET, XUARTPS_IXR_MASK);
    914c: e2840014  add r0, r4, #20
    9150: e3011fff  movw  r1, #8191 ; 0x1fff
    9154: ebfff415  bl  61b0 <Xil_Out32>

  /*
   * Mode register reset value : All zeroes
   * Normal mode, even parity, 1 stop bit
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_MR_OFFSET,
    9158: e2840004  add r0, r4, #4
    915c: e3a01000  mov r1, #0
    9160: ebfff412  bl  61b0 <Xil_Out32>
        XUARTPS_MR_CHMODE_NORM);

  /*
   * Rx and TX trigger register reset values
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_RXWM_OFFSET,
    9164: e2840020  add r0, r4, #32
    9168: e3a01020  mov r1, #32
    916c: ebfff40f  bl  61b0 <Xil_Out32>
        XUARTPS_RXWM_RESET_VAL);
  XUartPs_WriteReg(BaseAddress, XUARTPS_TXWM_OFFSET,
    9170: e2840044  add r0, r4, #68 ; 0x44
    9174: e3a01020  mov r1, #32
    9178: ebfff40c  bl  61b0 <Xil_Out32>
        XUARTPS_TXWM_RESET_VAL);

  /*
   * Rx timeout disabled by default
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_RXTOUT_OFFSET,
    917c: e284001c  add r0, r4, #28
    9180: e3a01000  mov r1, #0
    9184: ebfff409  bl  61b0 <Xil_Out32>
        XUARTPS_RXTOUT_DISABLE);

  /*
   * Baud rate generator and dividor reset values
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_BAUDGEN_OFFSET,
    9188: e2840018  add r0, r4, #24
    918c: e300128b  movw  r1, #651  ; 0x28b
    9190: ebfff406  bl  61b0 <Xil_Out32>
        XUARTPS_BAUDGEN_RESET_VAL);
  XUartPs_WriteReg(BaseAddress, XUARTPS_BAUDDIV_OFFSET,
    9194: e2840034  add r0, r4, #52 ; 0x34
    9198: e3a0100f  mov r1, #15
    919c: ebfff403  bl  61b0 <Xil_Out32>

  /*
   * Control register reset value -
   * RX and TX are disable by default
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_CR_OFFSET,
    91a0: e1a00004  mov r0, r4
    91a4: e3a01f4a  mov r1, #296  ; 0x128
        ((u32)XUARTPS_CR_RX_DIS | (u32)XUARTPS_CR_TX_DIS |
            (u32)XUARTPS_CR_STOPBRK));

}
    91a8: e8bd4010  pop {r4, lr}

  /*
   * Control register reset value -
   * RX and TX are disable by default
   */
  XUartPs_WriteReg(BaseAddress, XUARTPS_CR_OFFSET,
    91ac: eafff3ff  b 61b0 <Xil_Out32>

000091b0 <__aeabi_uidiv>:
    91b0: e2512001  subs  r2, r1, #1
    91b4: 012fff1e  bxeq  lr
    91b8: 3a000074  bcc 9390 <__aeabi_uidiv+0x1e0>
    91bc: e1500001  cmp r0, r1
    91c0: 9a00006b  bls 9374 <__aeabi_uidiv+0x1c4>
    91c4: e1110002  tst r1, r2
    91c8: 0a00006c  beq 9380 <__aeabi_uidiv+0x1d0>
    91cc: e16f3f10  clz r3, r0
    91d0: e16f2f11  clz r2, r1
    91d4: e0423003  sub r3, r2, r3
    91d8: e273301f  rsbs  r3, r3, #31
    91dc: 10833083  addne r3, r3, r3, lsl #1
    91e0: e3a02000  mov r2, #0
    91e4: 108ff103  addne pc, pc, r3, lsl #2
    91e8: e320f000  nop {0}
    91ec: e1500f81  cmp r0, r1, lsl #31
    91f0: e0a22002  adc r2, r2, r2
    91f4: 20400f81  subcs r0, r0, r1, lsl #31
    91f8: e1500f01  cmp r0, r1, lsl #30
    91fc: e0a22002  adc r2, r2, r2
    9200: 20400f01  subcs r0, r0, r1, lsl #30
    9204: e1500e81  cmp r0, r1, lsl #29
    9208: e0a22002  adc r2, r2, r2
    920c: 20400e81  subcs r0, r0, r1, lsl #29
    9210: e1500e01  cmp r0, r1, lsl #28
    9214: e0a22002  adc r2, r2, r2
    9218: 20400e01  subcs r0, r0, r1, lsl #28
    921c: e1500d81  cmp r0, r1, lsl #27
    9220: e0a22002  adc r2, r2, r2
    9224: 20400d81  subcs r0, r0, r1, lsl #27
    9228: e1500d01  cmp r0, r1, lsl #26
    922c: e0a22002  adc r2, r2, r2
    9230: 20400d01  subcs r0, r0, r1, lsl #26
    9234: e1500c81  cmp r0, r1, lsl #25
    9238: e0a22002  adc r2, r2, r2
    923c: 20400c81  subcs r0, r0, r1, lsl #25
    9240: e1500c01  cmp r0, r1, lsl #24
    9244: e0a22002  adc r2, r2, r2
    9248: 20400c01  subcs r0, r0, r1, lsl #24
    924c: e1500b81  cmp r0, r1, lsl #23
    9250: e0a22002  adc r2, r2, r2
    9254: 20400b81  subcs r0, r0, r1, lsl #23
    9258: e1500b01  cmp r0, r1, lsl #22
    925c: e0a22002  adc r2, r2, r2
    9260: 20400b01  subcs r0, r0, r1, lsl #22
    9264: e1500a81  cmp r0, r1, lsl #21
    9268: e0a22002  adc r2, r2, r2
    926c: 20400a81  subcs r0, r0, r1, lsl #21
    9270: e1500a01  cmp r0, r1, lsl #20
    9274: e0a22002  adc r2, r2, r2
    9278: 20400a01  subcs r0, r0, r1, lsl #20
    927c: e1500981  cmp r0, r1, lsl #19
    9280: e0a22002  adc r2, r2, r2
    9284: 20400981  subcs r0, r0, r1, lsl #19
    9288: e1500901  cmp r0, r1, lsl #18
    928c: e0a22002  adc r2, r2, r2
    9290: 20400901  subcs r0, r0, r1, lsl #18
    9294: e1500881  cmp r0, r1, lsl #17
    9298: e0a22002  adc r2, r2, r2
    929c: 20400881  subcs r0, r0, r1, lsl #17
    92a0: e1500801  cmp r0, r1, lsl #16
    92a4: e0a22002  adc r2, r2, r2
    92a8: 20400801  subcs r0, r0, r1, lsl #16
    92ac: e1500781  cmp r0, r1, lsl #15
    92b0: e0a22002  adc r2, r2, r2
    92b4: 20400781  subcs r0, r0, r1, lsl #15
    92b8: e1500701  cmp r0, r1, lsl #14
    92bc: e0a22002  adc r2, r2, r2
    92c0: 20400701  subcs r0, r0, r1, lsl #14
    92c4: e1500681  cmp r0, r1, lsl #13
    92c8: e0a22002  adc r2, r2, r2
    92cc: 20400681  subcs r0, r0, r1, lsl #13
    92d0: e1500601  cmp r0, r1, lsl #12
    92d4: e0a22002  adc r2, r2, r2
    92d8: 20400601  subcs r0, r0, r1, lsl #12
    92dc: e1500581  cmp r0, r1, lsl #11
    92e0: e0a22002  adc r2, r2, r2
    92e4: 20400581  subcs r0, r0, r1, lsl #11
    92e8: e1500501  cmp r0, r1, lsl #10
    92ec: e0a22002  adc r2, r2, r2
    92f0: 20400501  subcs r0, r0, r1, lsl #10
    92f4: e1500481  cmp r0, r1, lsl #9
    92f8: e0a22002  adc r2, r2, r2
    92fc: 20400481  subcs r0, r0, r1, lsl #9
    9300: e1500401  cmp r0, r1, lsl #8
    9304: e0a22002  adc r2, r2, r2
    9308: 20400401  subcs r0, r0, r1, lsl #8
    930c: e1500381  cmp r0, r1, lsl #7
    9310: e0a22002  adc r2, r2, r2
    9314: 20400381  subcs r0, r0, r1, lsl #7
    9318: e1500301  cmp r0, r1, lsl #6
    931c: e0a22002  adc r2, r2, r2
    9320: 20400301  subcs r0, r0, r1, lsl #6
    9324: e1500281  cmp r0, r1, lsl #5
    9328: e0a22002  adc r2, r2, r2
    932c: 20400281  subcs r0, r0, r1, lsl #5
    9330: e1500201  cmp r0, r1, lsl #4
    9334: e0a22002  adc r2, r2, r2
    9338: 20400201  subcs r0, r0, r1, lsl #4
    933c: e1500181  cmp r0, r1, lsl #3
    9340: e0a22002  adc r2, r2, r2
    9344: 20400181  subcs r0, r0, r1, lsl #3
    9348: e1500101  cmp r0, r1, lsl #2
    934c: e0a22002  adc r2, r2, r2
    9350: 20400101  subcs r0, r0, r1, lsl #2
    9354: e1500081  cmp r0, r1, lsl #1
    9358: e0a22002  adc r2, r2, r2
    935c: 20400081  subcs r0, r0, r1, lsl #1
    9360: e1500001  cmp r0, r1
    9364: e0a22002  adc r2, r2, r2
    9368: 20400001  subcs r0, r0, r1
    936c: e1a00002  mov r0, r2
    9370: e12fff1e  bx  lr
    9374: 03a00001  moveq r0, #1
    9378: 13a00000  movne r0, #0
    937c: e12fff1e  bx  lr
    9380: e16f2f11  clz r2, r1
    9384: e262201f  rsb r2, r2, #31
    9388: e1a00230  lsr r0, r0, r2
    938c: e12fff1e  bx  lr
    9390: e3500000  cmp r0, #0
    9394: 13e00000  mvnne r0, #0
    9398: ea000007  b 93bc <__aeabi_idiv0>

0000939c <__aeabi_uidivmod>:
    939c: e3510000  cmp r1, #0
    93a0: 0afffffa  beq 9390 <__aeabi_uidiv+0x1e0>
    93a4: e92d4003  push  {r0, r1, lr}
    93a8: ebffff80  bl  91b0 <__aeabi_uidiv>
    93ac: e8bd4006  pop {r1, r2, lr}
    93b0: e0030092  mul r3, r2, r0
    93b4: e0411003  sub r1, r1, r3
    93b8: e12fff1e  bx  lr

000093bc <__aeabi_idiv0>:
    93bc: e12fff1e  bx  lr

000093c0 <__aeabi_drsub>:
    93c0: e2211102  eor r1, r1, #-2147483648  ; 0x80000000
    93c4: ea000000  b 93cc <__adddf3>

000093c8 <__aeabi_dsub>:
    93c8: e2233102  eor r3, r3, #-2147483648  ; 0x80000000

000093cc <__adddf3>:
    93cc: e92d4030  push  {r4, r5, lr}
    93d0: e1a04081  lsl r4, r1, #1
    93d4: e1a05083  lsl r5, r3, #1
    93d8: e1340005  teq r4, r5
    93dc: 01300002  teqeq r0, r2
    93e0: 1194c000  orrsne  ip, r4, r0
    93e4: 1195c002  orrsne  ip, r5, r2
    93e8: 11f0cac4  mvnsne  ip, r4, asr #21
    93ec: 11f0cac5  mvnsne  ip, r5, asr #21
    93f0: 0a000079  beq 95dc <__adddf3+0x210>
    93f4: e1a04aa4  lsr r4, r4, #21
    93f8: e0745aa5  rsbs  r5, r4, r5, lsr #21
    93fc: b2655000  rsblt r5, r5, #0
    9400: da000006  ble 9420 <__adddf3+0x54>
    9404: e0844005  add r4, r4, r5
    9408: e0202002  eor r2, r0, r2
    940c: e0213003  eor r3, r1, r3
    9410: e0220000  eor r0, r2, r0
    9414: e0231001  eor r1, r3, r1
    9418: e0202002  eor r2, r0, r2
    941c: e0213003  eor r3, r1, r3
    9420: e3550036  cmp r5, #54 ; 0x36
    9424: 88bd8030  pophi {r4, r5, pc}
    9428: e3110102  tst r1, #-2147483648  ; 0x80000000
    942c: e1a01601  lsl r1, r1, #12
    9430: e3a0c601  mov ip, #1048576  ; 0x100000
    9434: e18c1621  orr r1, ip, r1, lsr #12
    9438: 0a000001  beq 9444 <__adddf3+0x78>
    943c: e2700000  rsbs  r0, r0, #0
    9440: e2e11000  rsc r1, r1, #0
    9444: e3130102  tst r3, #-2147483648  ; 0x80000000
    9448: e1a03603  lsl r3, r3, #12
    944c: e18c3623  orr r3, ip, r3, lsr #12
    9450: 0a000001  beq 945c <__adddf3+0x90>
    9454: e2722000  rsbs  r2, r2, #0
    9458: e2e33000  rsc r3, r3, #0
    945c: e1340005  teq r4, r5
    9460: 0a000057  beq 95c4 <__adddf3+0x1f8>
    9464: e2444001  sub r4, r4, #1
    9468: e275e020  rsbs  lr, r5, #32
    946c: ba000005  blt 9488 <__adddf3+0xbc>
    9470: e1a0ce12  lsl ip, r2, lr
    9474: e0900532  adds  r0, r0, r2, lsr r5
    9478: e2a11000  adc r1, r1, #0
    947c: e0900e13  adds  r0, r0, r3, lsl lr
    9480: e0b11553  adcs  r1, r1, r3, asr r5
    9484: ea000006  b 94a4 <__adddf3+0xd8>
    9488: e2455020  sub r5, r5, #32
    948c: e28ee020  add lr, lr, #32
    9490: e3520001  cmp r2, #1
    9494: e1a0ce13  lsl ip, r3, lr
    9498: 238cc002  orrcs ip, ip, #2
    949c: e0900553  adds  r0, r0, r3, asr r5
    94a0: e0b11fc3  adcs  r1, r1, r3, asr #31
    94a4: e2015102  and r5, r1, #-2147483648  ; 0x80000000
    94a8: 5a000002  bpl 94b8 <__adddf3+0xec>
    94ac: e27cc000  rsbs  ip, ip, #0
    94b0: e2f00000  rscs  r0, r0, #0
    94b4: e2e11000  rsc r1, r1, #0
    94b8: e3510601  cmp r1, #1048576  ; 0x100000
    94bc: 3a00000e  bcc 94fc <__adddf3+0x130>
    94c0: e3510602  cmp r1, #2097152  ; 0x200000
    94c4: 3a000006  bcc 94e4 <__adddf3+0x118>
    94c8: e1b010a1  lsrs  r1, r1, #1
    94cc: e1b00060  rrxs  r0, r0
    94d0: e1a0c06c  rrx ip, ip
    94d4: e2844001  add r4, r4, #1
    94d8: e1a02a84  lsl r2, r4, #21
    94dc: e3720501  cmn r2, #4194304  ; 0x400000
    94e0: 2a000055  bcs 963c <__adddf3+0x270>
    94e4: e35c0102  cmp ip, #-2147483648  ; 0x80000000
    94e8: 01b0c0a0  lsrseq  ip, r0, #1
    94ec: e2b00000  adcs  r0, r0, #0
    94f0: e0a11a04  adc r1, r1, r4, lsl #20
    94f4: e1811005  orr r1, r1, r5
    94f8: e8bd8030  pop {r4, r5, pc}
    94fc: e1b0c08c  lsls  ip, ip, #1
    9500: e0b00000  adcs  r0, r0, r0
    9504: e0a11001  adc r1, r1, r1
    9508: e3110601  tst r1, #1048576  ; 0x100000
    950c: e2444001  sub r4, r4, #1
    9510: 1afffff3  bne 94e4 <__adddf3+0x118>
    9514: e3310000  teq r1, #0
    9518: 01a01000  moveq r1, r0
    951c: 03a00000  moveq r0, #0
    9520: e16f3f11  clz r3, r1
    9524: 02833020  addeq r3, r3, #32
    9528: e243300b  sub r3, r3, #11
    952c: e2532020  subs  r2, r3, #32
    9530: aa000007  bge 9554 <__adddf3+0x188>
    9534: e292200c  adds  r2, r2, #12
    9538: da000004  ble 9550 <__adddf3+0x184>
    953c: e282c014  add ip, r2, #20
    9540: e262200c  rsb r2, r2, #12
    9544: e1a00c11  lsl r0, r1, ip
    9548: e1a01231  lsr r1, r1, r2
    954c: ea000004  b 9564 <__adddf3+0x198>
    9550: e2822014  add r2, r2, #20
    9554: d262c020  rsble ip, r2, #32
    9558: e1a01211  lsl r1, r1, r2
    955c: d1811c30  orrle r1, r1, r0, lsr ip
    9560: d1a00210  lslle r0, r0, r2
    9564: e0544003  subs  r4, r4, r3
    9568: a0811a04  addge r1, r1, r4, lsl #20
    956c: a1811005  orrge r1, r1, r5
    9570: a8bd8030  popge {r4, r5, pc}
    9574: e1e04004  mvn r4, r4
    9578: e254401f  subs  r4, r4, #31
    957c: aa00000d  bge 95b8 <__adddf3+0x1ec>
    9580: e294400c  adds  r4, r4, #12
    9584: ca000005  bgt 95a0 <__adddf3+0x1d4>
    9588: e2844014  add r4, r4, #20
    958c: e2642020  rsb r2, r4, #32
    9590: e1a00430  lsr r0, r0, r4
    9594: e1800211  orr r0, r0, r1, lsl r2
    9598: e1851431  orr r1, r5, r1, lsr r4
    959c: e8bd8030  pop {r4, r5, pc}
    95a0: e264400c  rsb r4, r4, #12
    95a4: e2642020  rsb r2, r4, #32
    95a8: e1a00230  lsr r0, r0, r2
    95ac: e1800411  orr r0, r0, r1, lsl r4
    95b0: e1a01005  mov r1, r5
    95b4: e8bd8030  pop {r4, r5, pc}
    95b8: e1a00431  lsr r0, r1, r4
    95bc: e1a01005  mov r1, r5
    95c0: e8bd8030  pop {r4, r5, pc}
    95c4: e3340000  teq r4, #0
    95c8: e2233601  eor r3, r3, #1048576  ; 0x100000
    95cc: 02211601  eoreq r1, r1, #1048576  ; 0x100000
    95d0: 02844001  addeq r4, r4, #1
    95d4: 12455001  subne r5, r5, #1
    95d8: eaffffa1  b 9464 <__adddf3+0x98>
    95dc: e1f0cac4  mvns  ip, r4, asr #21
    95e0: 11f0cac5  mvnsne  ip, r5, asr #21
    95e4: 0a000018  beq 964c <__adddf3+0x280>
    95e8: e1340005  teq r4, r5
    95ec: 01300002  teqeq r0, r2
    95f0: 0a000003  beq 9604 <__adddf3+0x238>
    95f4: e194c000  orrs  ip, r4, r0
    95f8: 01a01003  moveq r1, r3
    95fc: 01a00002  moveq r0, r2
    9600: e8bd8030  pop {r4, r5, pc}
    9604: e1310003  teq r1, r3
    9608: 13a01000  movne r1, #0
    960c: 13a00000  movne r0, #0
    9610: 18bd8030  popne {r4, r5, pc}
    9614: e1b0caa4  lsrs  ip, r4, #21
    9618: 1a000003  bne 962c <__adddf3+0x260>
    961c: e1b00080  lsls  r0, r0, #1
    9620: e0b11001  adcs  r1, r1, r1
    9624: 23811102  orrcs r1, r1, #-2147483648  ; 0x80000000
    9628: e8bd8030  pop {r4, r5, pc}
    962c: e2944501  adds  r4, r4, #4194304  ; 0x400000
    9630: 32811601  addcc r1, r1, #1048576  ; 0x100000
    9634: 38bd8030  popcc {r4, r5, pc}
    9638: e2015102  and r5, r1, #-2147483648  ; 0x80000000
    963c: e385147f  orr r1, r5, #2130706432 ; 0x7f000000
    9640: e381160f  orr r1, r1, #15728640 ; 0xf00000
    9644: e3a00000  mov r0, #0
    9648: e8bd8030  pop {r4, r5, pc}
    964c: e1f0cac4  mvns  ip, r4, asr #21
    9650: 11a01003  movne r1, r3
    9654: 11a00002  movne r0, r2
    9658: 01f0cac5  mvnseq  ip, r5, asr #21
    965c: 11a03001  movne r3, r1
    9660: 11a02000  movne r2, r0
    9664: e1904601  orrs  r4, r0, r1, lsl #12
    9668: 01925603  orrseq  r5, r2, r3, lsl #12
    966c: 01310003  teqeq r1, r3
    9670: 13811702  orrne r1, r1, #524288 ; 0x80000
    9674: e8bd8030  pop {r4, r5, pc}

00009678 <__aeabi_ui2d>:
    9678: e3300000  teq r0, #0
    967c: 03a01000  moveq r1, #0
    9680: 012fff1e  bxeq  lr
    9684: e92d4030  push  {r4, r5, lr}
    9688: e3a04b01  mov r4, #1024 ; 0x400
    968c: e2844032  add r4, r4, #50 ; 0x32
    9690: e3a05000  mov r5, #0
    9694: e3a01000  mov r1, #0
    9698: eaffff9d  b 9514 <__adddf3+0x148>

0000969c <__aeabi_i2d>:
    969c: e3300000  teq r0, #0
    96a0: 03a01000  moveq r1, #0
    96a4: 012fff1e  bxeq  lr
    96a8: e92d4030  push  {r4, r5, lr}
    96ac: e3a04b01  mov r4, #1024 ; 0x400
    96b0: e2844032  add r4, r4, #50 ; 0x32
    96b4: e2105102  ands  r5, r0, #-2147483648  ; 0x80000000
    96b8: 42600000  rsbmi r0, r0, #0
    96bc: e3a01000  mov r1, #0
    96c0: eaffff93  b 9514 <__adddf3+0x148>

000096c4 <__aeabi_f2d>:
    96c4: e1b02080  lsls  r2, r0, #1
    96c8: e1a011c2  asr r1, r2, #3
    96cc: e1a01061  rrx r1, r1
    96d0: e1a00e02  lsl r0, r2, #28
    96d4: 121234ff  andsne  r3, r2, #-16777216  ; 0xff000000
    96d8: 133304ff  teqne r3, #-16777216  ; 0xff000000
    96dc: 1221130e  eorne r1, r1, #939524096  ; 0x38000000
    96e0: 112fff1e  bxne  lr
    96e4: e3320000  teq r2, #0
    96e8: 133304ff  teqne r3, #-16777216  ; 0xff000000
    96ec: 012fff1e  bxeq  lr
    96f0: e92d4030  push  {r4, r5, lr}
    96f4: e3a04d0e  mov r4, #896  ; 0x380
    96f8: e2015102  and r5, r1, #-2147483648  ; 0x80000000
    96fc: e3c11102  bic r1, r1, #-2147483648  ; 0x80000000
    9700: eaffff83  b 9514 <__adddf3+0x148>

00009704 <__aeabi_ul2d>:
    9704: e1902001  orrs  r2, r0, r1
    9708: 012fff1e  bxeq  lr
    970c: e92d4030  push  {r4, r5, lr}
    9710: e3a05000  mov r5, #0
    9714: ea000006  b 9734 <__aeabi_l2d+0x1c>

00009718 <__aeabi_l2d>:
    9718: e1902001  orrs  r2, r0, r1
    971c: 012fff1e  bxeq  lr
    9720: e92d4030  push  {r4, r5, lr}
    9724: e2115102  ands  r5, r1, #-2147483648  ; 0x80000000
    9728: 5a000001  bpl 9734 <__aeabi_l2d+0x1c>
    972c: e2700000  rsbs  r0, r0, #0
    9730: e2e11000  rsc r1, r1, #0
    9734: e3a04b01  mov r4, #1024 ; 0x400
    9738: e2844032  add r4, r4, #50 ; 0x32
    973c: e1b0cb21  lsrs  ip, r1, #22
    9740: 0affff5c  beq 94b8 <__adddf3+0xec>
    9744: e3a02003  mov r2, #3
    9748: e1b0c1ac  lsrs  ip, ip, #3
    974c: 12822003  addne r2, r2, #3
    9750: e1b0c1ac  lsrs  ip, ip, #3
    9754: 12822003  addne r2, r2, #3
    9758: e08221ac  add r2, r2, ip, lsr #3
    975c: e2623020  rsb r3, r2, #32
    9760: e1a0c310  lsl ip, r0, r3
    9764: e1a00230  lsr r0, r0, r2
    9768: e1800311  orr r0, r0, r1, lsl r3
    976c: e1a01231  lsr r1, r1, r2
    9770: e0844002  add r4, r4, r2
    9774: eaffff4f  b 94b8 <__adddf3+0xec>

00009778 <exit>:
    9778: e92d4008  push  {r3, lr}
    977c: e3a01000  mov r1, #0
    9780: e1a04000  mov r4, r0
    9784: eb000a19  bl  bff0 <__call_exitprocs>
    9788: e308357c  movw  r3, #34172  ; 0x857c
    978c: e3403001  movt  r3, #1
    9790: e5930000  ldr r0, [r3]
    9794: e590303c  ldr r3, [r0, #60] ; 0x3c
    9798: e3530000  cmp r3, #0
    979c: 0a000000  beq 97a4 <exit+0x2c>
    97a0: e12fff33  blx r3
    97a4: e1a00004  mov r0, r4
    97a8: eb002336  bl  12488 <_exit>

000097ac <__libc_fini_array>:
    97ac: e92d4038  push  {r3, r4, r5, lr}
    97b0: e3003014  movw  r3, #20
    97b4: e3005010  movw  r5, #16
    97b8: e3403002  movt  r3, #2
    97bc: e3405002  movt  r5, #2
    97c0: e0653003  rsb r3, r5, r3
    97c4: e1b04143  asrs  r4, r3, #2
    97c8: 10835005  addne r5, r3, r5
    97cc: 0a000004  beq 97e4 <__libc_fini_array+0x38>
    97d0: e2444001  sub r4, r4, #1
    97d4: e5353004  ldr r3, [r5, #-4]!
    97d8: e12fff33  blx r3
    97dc: e3540000  cmp r4, #0
    97e0: 1afffffa  bne 97d0 <__libc_fini_array+0x24>
    97e4: e8bd4038  pop {r3, r4, r5, lr}
    97e8: ea003765  b 17584 <_fini>

000097ec <__libc_init_array>:
    97ec: e92d4070  push  {r4, r5, r6, lr}
    97f0: e3006008  movw  r6, #8
    97f4: e3005008  movw  r5, #8
    97f8: e3406002  movt  r6, #2
    97fc: e3405002  movt  r5, #2
    9800: e0656006  rsb r6, r5, r6
    9804: e1b06146  asrs  r6, r6, #2
    9808: 13a04000  movne r4, #0
    980c: 0a000004  beq 9824 <__libc_init_array+0x38>
    9810: e2844001  add r4, r4, #1
    9814: e4953004  ldr r3, [r5], #4
    9818: e12fff33  blx r3
    981c: e1560004  cmp r6, r4
    9820: 1afffffa  bne 9810 <__libc_init_array+0x24>
    9824: e3006010  movw  r6, #16
    9828: e3005008  movw  r5, #8
    982c: e3406002  movt  r6, #2
    9830: e3405002  movt  r5, #2
    9834: e0656006  rsb r6, r5, r6
    9838: eb00374b  bl  1756c <_init>
    983c: e1b06146  asrs  r6, r6, #2
    9840: 0a000006  beq 9860 <__libc_init_array+0x74>
    9844: e3a04000  mov r4, #0
    9848: e2844001  add r4, r4, #1
    984c: e4953004  ldr r3, [r5], #4
    9850: e12fff33  blx r3
    9854: e1560004  cmp r6, r4
    9858: 1afffffa  bne 9848 <__libc_init_array+0x5c>
    985c: e8bd8070  pop {r4, r5, r6, pc}
    9860: e8bd8070  pop {r4, r5, r6, pc}
  ...

00009880 <memcpy>:
    9880: e1a0c000  mov ip, r0
    9884: e3520040  cmp r2, #64 ; 0x40
    9888: aa000019  bge 98f4 <memcpy+0x74>
    988c: e2023038  and r3, r2, #56 ; 0x38
    9890: e2633034  rsb r3, r3, #52 ; 0x34
    9894: e08ff003  add pc, pc, r3
    9898: f421070d  vld1.8  {d0}, [r1]!
    989c: f40c070d  vst1.8  {d0}, [ip]!
    98a0: f421070d  vld1.8  {d0}, [r1]!
    98a4: f40c070d  vst1.8  {d0}, [ip]!
    98a8: f421070d  vld1.8  {d0}, [r1]!
    98ac: f40c070d  vst1.8  {d0}, [ip]!
    98b0: f421070d  vld1.8  {d0}, [r1]!
    98b4: f40c070d  vst1.8  {d0}, [ip]!
    98b8: f421070d  vld1.8  {d0}, [r1]!
    98bc: f40c070d  vst1.8  {d0}, [ip]!
    98c0: f421070d  vld1.8  {d0}, [r1]!
    98c4: f40c070d  vst1.8  {d0}, [ip]!
    98c8: f421070d  vld1.8  {d0}, [r1]!
    98cc: f40c070d  vst1.8  {d0}, [ip]!
    98d0: e3120004  tst r2, #4
    98d4: 14913004  ldrne r3, [r1], #4
    98d8: 148c3004  strne r3, [ip], #4
    98dc: e1b02f82  lsls  r2, r2, #31
    98e0: 20d130b2  ldrhcs  r3, [r1], #2
    98e4: 15d11000  ldrbne  r1, [r1]
    98e8: 20cc30b2  strhcs  r3, [ip], #2
    98ec: 15cc1000  strbne  r1, [ip]
    98f0: e12fff1e  bx  lr
    98f4: e52da004  push  {sl}    ; (str sl, [sp, #-4]!)
    98f8: e201a007  and sl, r1, #7
    98fc: e20c3007  and r3, ip, #7
    9900: e153000a  cmp r3, sl
    9904: 1a0000f1  bne 9cd0 <memcpy+0x450>
    9908: eeb00a40  vmov.f32  s0, s0
    990c: e1b0ae8c  lsls  sl, ip, #29
    9910: 0a000008  beq 9938 <memcpy+0xb8>
    9914: e27aa000  rsbs  sl, sl, #0
    9918: e0422eaa  sub r2, r2, sl, lsr #29
    991c: 44913004  ldrmi r3, [r1], #4
    9920: 448c3004  strmi r3, [ip], #4
    9924: e1b0a10a  lsls  sl, sl, #2
    9928: 20d130b2  ldrhcs  r3, [r1], #2
    992c: 14d1a001  ldrbne  sl, [r1], #1
    9930: 20cc30b2  strhcs  r3, [ip], #2
    9934: 14cca001  strbne  sl, [ip], #1
    9938: e252a040  subs  sl, r2, #64 ; 0x40
    993c: ba000017  blt 99a0 <memcpy+0x120>
    9940: e35a0c02  cmp sl, #512  ; 0x200
    9944: aa000032  bge 9a14 <memcpy+0x194>
    9948: ed910b00  vldr  d0, [r1]
    994c: e25aa040  subs  sl, sl, #64 ; 0x40
    9950: ed911b02  vldr  d1, [r1, #8]
    9954: ed8c0b00  vstr  d0, [ip]
    9958: ed910b04  vldr  d0, [r1, #16]
    995c: ed8c1b02  vstr  d1, [ip, #8]
    9960: ed911b06  vldr  d1, [r1, #24]
    9964: ed8c0b04  vstr  d0, [ip, #16]
    9968: ed910b08  vldr  d0, [r1, #32]
    996c: ed8c1b06  vstr  d1, [ip, #24]
    9970: ed911b0a  vldr  d1, [r1, #40] ; 0x28
    9974: ed8c0b08  vstr  d0, [ip, #32]
    9978: ed910b0c  vldr  d0, [r1, #48] ; 0x30
    997c: ed8c1b0a  vstr  d1, [ip, #40] ; 0x28
    9980: ed911b0e  vldr  d1, [r1, #56] ; 0x38
    9984: ed8c0b0c  vstr  d0, [ip, #48] ; 0x30
    9988: e2811040  add r1, r1, #64 ; 0x40
    998c: ed8c1b0e  vstr  d1, [ip, #56] ; 0x38
    9990: e28cc040  add ip, ip, #64 ; 0x40
    9994: aaffffeb  bge 9948 <memcpy+0xc8>
    9998: e31a003f  tst sl, #63 ; 0x3f
    999c: 0a00001a  beq 9a0c <memcpy+0x18c>
    99a0: e20a3038  and r3, sl, #56 ; 0x38
    99a4: e08cc003  add ip, ip, r3
    99a8: e0811003  add r1, r1, r3
    99ac: e2633034  rsb r3, r3, #52 ; 0x34
    99b0: e08ff003  add pc, pc, r3
    99b4: ed110b0e  vldr  d0, [r1, #-56]  ; 0xffffffc8
    99b8: ed0c0b0e  vstr  d0, [ip, #-56]  ; 0xffffffc8
    99bc: ed110b0c  vldr  d0, [r1, #-48]  ; 0xffffffd0
    99c0: ed0c0b0c  vstr  d0, [ip, #-48]  ; 0xffffffd0
    99c4: ed110b0a  vldr  d0, [r1, #-40]  ; 0xffffffd8
    99c8: ed0c0b0a  vstr  d0, [ip, #-40]  ; 0xffffffd8
    99cc: ed110b08  vldr  d0, [r1, #-32]  ; 0xffffffe0
    99d0: ed0c0b08  vstr  d0, [ip, #-32]  ; 0xffffffe0
    99d4: ed110b06  vldr  d0, [r1, #-24]  ; 0xffffffe8
    99d8: ed0c0b06  vstr  d0, [ip, #-24]  ; 0xffffffe8
    99dc: ed110b04  vldr  d0, [r1, #-16]
    99e0: ed0c0b04  vstr  d0, [ip, #-16]
    99e4: ed110b02  vldr  d0, [r1, #-8]
    99e8: ed0c0b02  vstr  d0, [ip, #-8]
    99ec: e31a0004  tst sl, #4
    99f0: 14913004  ldrne r3, [r1], #4
    99f4: 148c3004  strne r3, [ip], #4
    99f8: e1b0af8a  lsls  sl, sl, #31
    99fc: 20d130b2  ldrhcs  r3, [r1], #2
    9a00: 15d1a000  ldrbne  sl, [r1]
    9a04: 20cc30b2  strhcs  r3, [ip], #2
    9a08: 15cca000  strbne  sl, [ip]
    9a0c: e49da004  pop {sl}    ; (ldr sl, [sp], #4)
    9a10: e12fff1e  bx  lr
    9a14: ed913b00  vldr  d3, [r1]
    9a18: ed914b10  vldr  d4, [r1, #64] ; 0x40
    9a1c: ed915b20  vldr  d5, [r1, #128]  ; 0x80
    9a20: ed916b30  vldr  d6, [r1, #192]  ; 0xc0
    9a24: ed917b40  vldr  d7, [r1, #256]  ; 0x100
    9a28: ed910b02  vldr  d0, [r1, #8]
    9a2c: ed911b04  vldr  d1, [r1, #16]
    9a30: ed912b06  vldr  d2, [r1, #24]
    9a34: e2811020  add r1, r1, #32
    9a38: e25aad0a  subs  sl, sl, #640  ; 0x280
    9a3c: ba000055  blt 9b98 <memcpy+0x318>
    9a40: ed8c3b00  vstr  d3, [ip]
    9a44: ed913b00  vldr  d3, [r1]
    9a48: ed8c0b02  vstr  d0, [ip, #8]
    9a4c: ed910b02  vldr  d0, [r1, #8]
    9a50: ed8c1b04  vstr  d1, [ip, #16]
    9a54: ed911b04  vldr  d1, [r1, #16]
    9a58: ed8c2b06  vstr  d2, [ip, #24]
    9a5c: ed912b06  vldr  d2, [r1, #24]
    9a60: ed8c3b08  vstr  d3, [ip, #32]
    9a64: ed913b48  vldr  d3, [r1, #288]  ; 0x120
    9a68: ed8c0b0a  vstr  d0, [ip, #40] ; 0x28
    9a6c: ed910b0a  vldr  d0, [r1, #40] ; 0x28
    9a70: ed8c1b0c  vstr  d1, [ip, #48] ; 0x30
    9a74: ed911b0c  vldr  d1, [r1, #48] ; 0x30
    9a78: ed8c2b0e  vstr  d2, [ip, #56] ; 0x38
    9a7c: ed912b0e  vldr  d2, [r1, #56] ; 0x38
    9a80: ed8c4b10  vstr  d4, [ip, #64] ; 0x40
    9a84: ed914b10  vldr  d4, [r1, #64] ; 0x40
    9a88: ed8c0b12  vstr  d0, [ip, #72] ; 0x48
    9a8c: ed910b12  vldr  d0, [r1, #72] ; 0x48
    9a90: ed8c1b14  vstr  d1, [ip, #80] ; 0x50
    9a94: ed911b14  vldr  d1, [r1, #80] ; 0x50
    9a98: ed8c2b16  vstr  d2, [ip, #88] ; 0x58
    9a9c: ed912b16  vldr  d2, [r1, #88] ; 0x58
    9aa0: ed8c4b18  vstr  d4, [ip, #96] ; 0x60
    9aa4: ed914b58  vldr  d4, [r1, #352]  ; 0x160
    9aa8: ed8c0b1a  vstr  d0, [ip, #104]  ; 0x68
    9aac: ed910b1a  vldr  d0, [r1, #104]  ; 0x68
    9ab0: ed8c1b1c  vstr  d1, [ip, #112]  ; 0x70
    9ab4: ed911b1c  vldr  d1, [r1, #112]  ; 0x70
    9ab8: ed8c2b1e  vstr  d2, [ip, #120]  ; 0x78
    9abc: ed912b1e  vldr  d2, [r1, #120]  ; 0x78
    9ac0: ed8c5b20  vstr  d5, [ip, #128]  ; 0x80
    9ac4: ed915b20  vldr  d5, [r1, #128]  ; 0x80
    9ac8: ed8c0b22  vstr  d0, [ip, #136]  ; 0x88
    9acc: ed910b22  vldr  d0, [r1, #136]  ; 0x88
    9ad0: ed8c1b24  vstr  d1, [ip, #144]  ; 0x90
    9ad4: ed911b24  vldr  d1, [r1, #144]  ; 0x90
    9ad8: ed8c2b26  vstr  d2, [ip, #152]  ; 0x98
    9adc: ed912b26  vldr  d2, [r1, #152]  ; 0x98
    9ae0: ed8c5b28  vstr  d5, [ip, #160]  ; 0xa0
    9ae4: ed915b68  vldr  d5, [r1, #416]  ; 0x1a0
    9ae8: ed8c0b2a  vstr  d0, [ip, #168]  ; 0xa8
    9aec: ed910b2a  vldr  d0, [r1, #168]  ; 0xa8
    9af0: ed8c1b2c  vstr  d1, [ip, #176]  ; 0xb0
    9af4: ed911b2c  vldr  d1, [r1, #176]  ; 0xb0
    9af8: ed8c2b2e  vstr  d2, [ip, #184]  ; 0xb8
    9afc: ed912b2e  vldr  d2, [r1, #184]  ; 0xb8
    9b00: e28cc0c0  add ip, ip, #192  ; 0xc0
    9b04: e28110c0  add r1, r1, #192  ; 0xc0
    9b08: ed8c6b00  vstr  d6, [ip]
    9b0c: ed916b00  vldr  d6, [r1]
    9b10: ed8c0b02  vstr  d0, [ip, #8]
    9b14: ed910b02  vldr  d0, [r1, #8]
    9b18: ed8c1b04  vstr  d1, [ip, #16]
    9b1c: ed911b04  vldr  d1, [r1, #16]
    9b20: ed8c2b06  vstr  d2, [ip, #24]
    9b24: ed912b06  vldr  d2, [r1, #24]
    9b28: ed8c6b08  vstr  d6, [ip, #32]
    9b2c: ed916b48  vldr  d6, [r1, #288]  ; 0x120
    9b30: ed8c0b0a  vstr  d0, [ip, #40] ; 0x28
    9b34: ed910b0a  vldr  d0, [r1, #40] ; 0x28
    9b38: ed8c1b0c  vstr  d1, [ip, #48] ; 0x30
    9b3c: ed911b0c  vldr  d1, [r1, #48] ; 0x30
    9b40: ed8c2b0e  vstr  d2, [ip, #56] ; 0x38
    9b44: ed912b0e  vldr  d2, [r1, #56] ; 0x38
    9b48: ed8c7b10  vstr  d7, [ip, #64] ; 0x40
    9b4c: ed917b10  vldr  d7, [r1, #64] ; 0x40
    9b50: ed8c0b12  vstr  d0, [ip, #72] ; 0x48
    9b54: ed910b12  vldr  d0, [r1, #72] ; 0x48
    9b58: ed8c1b14  vstr  d1, [ip, #80] ; 0x50
    9b5c: ed911b14  vldr  d1, [r1, #80] ; 0x50
    9b60: ed8c2b16  vstr  d2, [ip, #88] ; 0x58
    9b64: ed912b16  vldr  d2, [r1, #88] ; 0x58
    9b68: ed8c7b18  vstr  d7, [ip, #96] ; 0x60
    9b6c: ed917b58  vldr  d7, [r1, #352]  ; 0x160
    9b70: ed8c0b1a  vstr  d0, [ip, #104]  ; 0x68
    9b74: ed910b1a  vldr  d0, [r1, #104]  ; 0x68
    9b78: ed8c1b1c  vstr  d1, [ip, #112]  ; 0x70
    9b7c: ed911b1c  vldr  d1, [r1, #112]  ; 0x70
    9b80: ed8c2b1e  vstr  d2, [ip, #120]  ; 0x78
    9b84: ed912b1e  vldr  d2, [r1, #120]  ; 0x78
    9b88: e28cc080  add ip, ip, #128  ; 0x80
    9b8c: e2811080  add r1, r1, #128  ; 0x80
    9b90: e25aad05  subs  sl, sl, #320  ; 0x140
    9b94: aaffffa9  bge 9a40 <memcpy+0x1c0>
    9b98: ed8c3b00  vstr  d3, [ip]
    9b9c: ed913b00  vldr  d3, [r1]
    9ba0: ed8c0b02  vstr  d0, [ip, #8]
    9ba4: ed910b02  vldr  d0, [r1, #8]
    9ba8: ed8c1b04  vstr  d1, [ip, #16]
    9bac: ed911b04  vldr  d1, [r1, #16]
    9bb0: ed8c2b06  vstr  d2, [ip, #24]
    9bb4: ed912b06  vldr  d2, [r1, #24]
    9bb8: ed8c3b08  vstr  d3, [ip, #32]
    9bbc: ed8c0b0a  vstr  d0, [ip, #40] ; 0x28
    9bc0: ed910b0a  vldr  d0, [r1, #40] ; 0x28
    9bc4: ed8c1b0c  vstr  d1, [ip, #48] ; 0x30
    9bc8: ed911b0c  vldr  d1, [r1, #48] ; 0x30
    9bcc: ed8c2b0e  vstr  d2, [ip, #56] ; 0x38
    9bd0: ed912b0e  vldr  d2, [r1, #56] ; 0x38
    9bd4: ed8c4b10  vstr  d4, [ip, #64] ; 0x40
    9bd8: ed914b10  vldr  d4, [r1, #64] ; 0x40
    9bdc: ed8c0b12  vstr  d0, [ip, #72] ; 0x48
    9be0: ed910b12  vldr  d0, [r1, #72] ; 0x48
    9be4: ed8c1b14  vstr  d1, [ip, #80] ; 0x50
    9be8: ed911b14  vldr  d1, [r1, #80] ; 0x50
    9bec: ed8c2b16  vstr  d2, [ip, #88] ; 0x58
    9bf0: ed912b16  vldr  d2, [r1, #88] ; 0x58
    9bf4: ed8c4b18  vstr  d4, [ip, #96] ; 0x60
    9bf8: ed8c0b1a  vstr  d0, [ip, #104]  ; 0x68
    9bfc: ed910b1a  vldr  d0, [r1, #104]  ; 0x68
    9c00: ed8c1b1c  vstr  d1, [ip, #112]  ; 0x70
    9c04: ed911b1c  vldr  d1, [r1, #112]  ; 0x70
    9c08: ed8c2b1e  vstr  d2, [ip, #120]  ; 0x78
    9c0c: ed912b1e  vldr  d2, [r1, #120]  ; 0x78
    9c10: ed8c5b20  vstr  d5, [ip, #128]  ; 0x80
    9c14: ed915b20  vldr  d5, [r1, #128]  ; 0x80
    9c18: ed8c0b22  vstr  d0, [ip, #136]  ; 0x88
    9c1c: ed910b22  vldr  d0, [r1, #136]  ; 0x88
    9c20: ed8c1b24  vstr  d1, [ip, #144]  ; 0x90
    9c24: ed911b24  vldr  d1, [r1, #144]  ; 0x90
    9c28: ed8c2b26  vstr  d2, [ip, #152]  ; 0x98
    9c2c: ed912b26  vldr  d2, [r1, #152]  ; 0x98
    9c30: ed8c5b28  vstr  d5, [ip, #160]  ; 0xa0
    9c34: ed8c0b2a  vstr  d0, [ip, #168]  ; 0xa8
    9c38: ed910b2a  vldr  d0, [r1, #168]  ; 0xa8
    9c3c: ed8c1b2c  vstr  d1, [ip, #176]  ; 0xb0
    9c40: ed911b2c  vldr  d1, [r1, #176]  ; 0xb0
    9c44: ed8c2b2e  vstr  d2, [ip, #184]  ; 0xb8
    9c48: ed912b2e  vldr  d2, [r1, #184]  ; 0xb8
    9c4c: e28110c0  add r1, r1, #192  ; 0xc0
    9c50: e28cc0c0  add ip, ip, #192  ; 0xc0
    9c54: ed8c6b00  vstr  d6, [ip]
    9c58: ed916b00  vldr  d6, [r1]
    9c5c: ed8c0b02  vstr  d0, [ip, #8]
    9c60: ed910b02  vldr  d0, [r1, #8]
    9c64: ed8c1b04  vstr  d1, [ip, #16]
    9c68: ed911b04  vldr  d1, [r1, #16]
    9c6c: ed8c2b06  vstr  d2, [ip, #24]
    9c70: ed912b06  vldr  d2, [r1, #24]
    9c74: ed8c6b08  vstr  d6, [ip, #32]
    9c78: ed8c0b0a  vstr  d0, [ip, #40] ; 0x28
    9c7c: ed910b0a  vldr  d0, [r1, #40] ; 0x28
    9c80: ed8c1b0c  vstr  d1, [ip, #48] ; 0x30
    9c84: ed911b0c  vldr  d1, [r1, #48] ; 0x30
    9c88: ed8c2b0e  vstr  d2, [ip, #56] ; 0x38
    9c8c: ed912b0e  vldr  d2, [r1, #56] ; 0x38
    9c90: ed8c7b10  vstr  d7, [ip, #64] ; 0x40
    9c94: ed917b10  vldr  d7, [r1, #64] ; 0x40
    9c98: ed8c0b12  vstr  d0, [ip, #72] ; 0x48
    9c9c: ed910b12  vldr  d0, [r1, #72] ; 0x48
    9ca0: ed8c1b14  vstr  d1, [ip, #80] ; 0x50
    9ca4: ed911b14  vldr  d1, [r1, #80] ; 0x50
    9ca8: ed8c2b16  vstr  d2, [ip, #88] ; 0x58
    9cac: ed912b16  vldr  d2, [r1, #88] ; 0x58
    9cb0: ed8c7b18  vstr  d7, [ip, #96] ; 0x60
    9cb4: e2811060  add r1, r1, #96 ; 0x60
    9cb8: ed8c0b1a  vstr  d0, [ip, #104]  ; 0x68
    9cbc: ed8c1b1c  vstr  d1, [ip, #112]  ; 0x70
    9cc0: ed8c2b1e  vstr  d2, [ip, #120]  ; 0x78
    9cc4: e28cc080  add ip, ip, #128  ; 0x80
    9cc8: e28aad05  add sl, sl, #320  ; 0x140
    9ccc: eaffff1d  b 9948 <memcpy+0xc8>
    9cd0: f5d1f000  pld [r1]
    9cd4: f5d1f040  pld [r1, #64] ; 0x40
    9cd8: e1b0ae8c  lsls  sl, ip, #29
    9cdc: f5d1f080  pld [r1, #128]  ; 0x80
    9ce0: 0a000008  beq 9d08 <memcpy+0x488>
    9ce4: e27aa000  rsbs  sl, sl, #0
    9ce8: e0422eaa  sub r2, r2, sl, lsr #29
    9cec: 44913004  ldrmi r3, [r1], #4
    9cf0: 448c3004  strmi r3, [ip], #4
    9cf4: e1b0a10a  lsls  sl, sl, #2
    9cf8: 14d13001  ldrbne  r3, [r1], #1
    9cfc: 20d1a0b2  ldrhcs  sl, [r1], #2
    9d00: 14cc3001  strbne  r3, [ip], #1
    9d04: 20cca0b2  strhcs  sl, [ip], #2
    9d08: f5d1f0c0  pld [r1, #192]  ; 0xc0
    9d0c: e2522040  subs  r2, r2, #64 ; 0x40
    9d10: 449da004  popmi {sl}    ; (ldrmi sl, [sp], #4)
    9d14: 4afffedc  bmi 988c <memcpy+0xc>
    9d18: f5d1f100  pld [r1, #256]  ; 0x100
    9d1c: f421020d  vld1.8  {d0-d3}, [r1]!
    9d20: f421420d  vld1.8  {d4-d7}, [r1]!
    9d24: e2522040  subs  r2, r2, #64 ; 0x40
    9d28: 4a000006  bmi 9d48 <memcpy+0x4c8>
    9d2c: f5d1f100  pld [r1, #256]  ; 0x100
    9d30: f40c021d  vst1.8  {d0-d3}, [ip :64]!
    9d34: f421020d  vld1.8  {d0-d3}, [r1]!
    9d38: f40c421d  vst1.8  {d4-d7}, [ip :64]!
    9d3c: f421420d  vld1.8  {d4-d7}, [r1]!
    9d40: e2522040  subs  r2, r2, #64 ; 0x40
    9d44: 5afffff8  bpl 9d2c <memcpy+0x4ac>
    9d48: f40c021d  vst1.8  {d0-d3}, [ip :64]!
    9d4c: f40c421d  vst1.8  {d4-d7}, [ip :64]!
    9d50: e212203f  ands  r2, r2, #63 ; 0x3f
    9d54: e49da004  pop {sl}    ; (ldr sl, [sp], #4)
    9d58: 1afffecb  bne 988c <memcpy+0xc>
    9d5c: e12fff1e  bx  lr
    9d60: e320f000  nop {0}
    9d64: e320f000  nop {0}
    9d68: e320f000  nop {0}
    9d6c: e320f000  nop {0}
    9d70: e320f000  nop {0}
    9d74: e320f000  nop {0}
    9d78: e320f000  nop {0}
    9d7c: e320f000  nop {0}

00009d80 <_printf_r>:
    9d80: e92d000e  push  {r1, r2, r3}
    9d84: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
    9d88: e24dd008  sub sp, sp, #8
    9d8c: e28dc010  add ip, sp, #16
    9d90: e5901008  ldr r1, [r0, #8]
    9d94: e59d200c  ldr r2, [sp, #12]
    9d98: e1a0300c  mov r3, ip
    9d9c: e58dc004  str ip, [sp, #4]
    9da0: eb000056  bl  9f00 <_vfprintf_r>
    9da4: e28dd008  add sp, sp, #8
    9da8: e49de004  pop {lr}    ; (ldr lr, [sp], #4)
    9dac: e28dd00c  add sp, sp, #12
    9db0: e12fff1e  bx  lr

00009db4 <printf>:
    9db4: e92d000f  push  {r0, r1, r2, r3}
    9db8: e30b1390  movw  r1, #45968  ; 0xb390
    9dbc: e3401001  movt  r1, #1
    9dc0: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
    9dc4: e24dd00c  sub sp, sp, #12
    9dc8: e5910000  ldr r0, [r1]
    9dcc: e28dc014  add ip, sp, #20
    9dd0: e59d2010  ldr r2, [sp, #16]
    9dd4: e1a0300c  mov r3, ip
    9dd8: e58dc004  str ip, [sp, #4]
    9ddc: e5901008  ldr r1, [r0, #8]
    9de0: eb000046  bl  9f00 <_vfprintf_r>
    9de4: e28dd00c  add sp, sp, #12
    9de8: e49de004  pop {lr}    ; (ldr lr, [sp], #4)
    9dec: e28dd010  add sp, sp, #16
    9df0: e12fff1e  bx  lr
  ...

00009e00 <strlen>:
    9e00: f890 f000   pld [r0]
    9e04: e96d 4502   strd  r4, r5, [sp, #-8]!
    9e08: f020 0107   bic.w r1, r0, #7
    9e0c: f06f 0c00   mvn.w ip, #0
    9e10: f010 0407   ands.w  r4, r0, #7
    9e14: f891 f020   pld [r1, #32]
    9e18: f040 8049   bne.w 9eae <strlen+0xae>
    9e1c: f04f 0400   mov.w r4, #0
    9e20: f06f 0007   mvn.w r0, #7
    9e24: e9d1 2300   ldrd  r2, r3, [r1]
    9e28: f891 f040   pld [r1, #64] ; 0x40
    9e2c: f100 0008   add.w r0, r0, #8
    9e30: fa82 f24c   uadd8 r2, r2, ip
    9e34: faa4 f28c   sel r2, r4, ip
    9e38: fa83 f34c   uadd8 r3, r3, ip
    9e3c: faa2 f38c   sel r3, r2, ip
    9e40: bb4b        cbnz  r3, 9e96 <strlen+0x96>
    9e42: e9d1 2302   ldrd  r2, r3, [r1, #8]
    9e46: fa82 f24c   uadd8 r2, r2, ip
    9e4a: f100 0008   add.w r0, r0, #8
    9e4e: faa4 f28c   sel r2, r4, ip
    9e52: fa83 f34c   uadd8 r3, r3, ip
    9e56: faa2 f38c   sel r3, r2, ip
    9e5a: b9e3        cbnz  r3, 9e96 <strlen+0x96>
    9e5c: e9d1 2304   ldrd  r2, r3, [r1, #16]
    9e60: fa82 f24c   uadd8 r2, r2, ip
    9e64: f100 0008   add.w r0, r0, #8
    9e68: faa4 f28c   sel r2, r4, ip
    9e6c: fa83 f34c   uadd8 r3, r3, ip
    9e70: faa2 f38c   sel r3, r2, ip
    9e74: b97b        cbnz  r3, 9e96 <strlen+0x96>
    9e76: e9d1 2306   ldrd  r2, r3, [r1, #24]
    9e7a: f101 0120   add.w r1, r1, #32
    9e7e: fa82 f24c   uadd8 r2, r2, ip
    9e82: f100 0008   add.w r0, r0, #8
    9e86: faa4 f28c   sel r2, r4, ip
    9e8a: fa83 f34c   uadd8 r3, r3, ip
    9e8e: faa2 f38c   sel r3, r2, ip
    9e92: 2b00        cmp r3, #0
    9e94: d0c6        beq.n 9e24 <strlen+0x24>
    9e96: 2a00        cmp r2, #0
    9e98: bf04        itt eq
    9e9a: 3004        addeq r0, #4
    9e9c: 461a        moveq r2, r3
    9e9e: ba12        rev r2, r2
    9ea0: fab2 f282   clz r2, r2
    9ea4: e8fd 4502   ldrd  r4, r5, [sp], #8
    9ea8: eb00 00d2   add.w r0, r0, r2, lsr #3
    9eac: 4770        bx  lr
    9eae: e9d1 2300   ldrd  r2, r3, [r1]
    9eb2: f004 0503   and.w r5, r4, #3
    9eb6: f1c4 0000   rsb r0, r4, #0
    9eba: ea4f 05c5   mov.w r5, r5, lsl #3
    9ebe: f014 0f04   tst.w r4, #4
    9ec2: f891 f040   pld [r1, #64] ; 0x40
    9ec6: fa0c f505   lsl.w r5, ip, r5
    9eca: ea62 0205   orn r2, r2, r5
    9ece: bf1c        itt ne
    9ed0: ea63 0305   ornne r3, r3, r5
    9ed4: 4662        movne r2, ip
    9ed6: f04f 0400   mov.w r4, #0
    9eda: e7a9        b.n 9e30 <strlen+0x30>
    9edc: f3af 8000   nop.w
    9ee0: f3af 8000   nop.w
    9ee4: f3af 8000   nop.w
    9ee8: f3af 8000   nop.w
    9eec: f3af 8000   nop.w
    9ef0: f3af 8000   nop.w
    9ef4: f3af 8000   nop.w
    9ef8: f3af 8000   nop.w
    9efc: f3af 8000   nop.w

00009f00 <_vfprintf_r>:
    9f00: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    9f04: e1a04003  mov r4, r3
    9f08: ed2d8b04  vpush {d8-d9}
    9f0c: e1a0b001  mov fp, r1
    9f10: e1a05000  mov r5, r0
    9f14: e24ddf43  sub sp, sp, #268  ; 0x10c
    9f18: e58d2024  str r2, [sp, #36] ; 0x24
    9f1c: e58d0028  str r0, [sp, #40] ; 0x28
    9f20: eb001065  bl  e0bc <_localeconv_r>
    9f24: e58d4034  str r4, [sp, #52] ; 0x34
    9f28: e5903000  ldr r3, [r0]
    9f2c: e1a00003  mov r0, r3
    9f30: e58d3054  str r3, [sp, #84] ; 0x54
    9f34: faffffb1  blx 9e00 <strlen>
    9f38: e3550000  cmp r5, #0
    9f3c: e58d0058  str r0, [sp, #88] ; 0x58
    9f40: 0a000002  beq 9f50 <_vfprintf_r+0x50>
    9f44: e5953038  ldr r3, [r5, #56] ; 0x38
    9f48: e3530000  cmp r3, #0
    9f4c: 0a0000d0  beq a294 <_vfprintf_r+0x394>
    9f50: e1db30bc  ldrh  r3, [fp, #12]
    9f54: e6ff2073  uxth  r2, r3
    9f58: e3120a02  tst r2, #8192 ; 0x2000
    9f5c: 1a000005  bne 9f78 <_vfprintf_r+0x78>
    9f60: e3832a02  orr r2, r3, #8192 ; 0x2000
    9f64: e59b3064  ldr r3, [fp, #100]  ; 0x64
    9f68: e1cb20bc  strh  r2, [fp, #12]
    9f6c: e6ff2072  uxth  r2, r2
    9f70: e3c33a02  bic r3, r3, #8192 ; 0x2000
    9f74: e58b3064  str r3, [fp, #100]  ; 0x64
    9f78: e3120008  tst r2, #8
    9f7c: 0a000099  beq a1e8 <_vfprintf_r+0x2e8>
    9f80: e59b3010  ldr r3, [fp, #16]
    9f84: e3530000  cmp r3, #0
    9f88: 0a000096  beq a1e8 <_vfprintf_r+0x2e8>
    9f8c: e202201a  and r2, r2, #26
    9f90: e352000a  cmp r2, #10
    9f94: 0a0000b3  beq a268 <_vfprintf_r+0x368>
    9f98: ed9f8bee  vldr  d8, [pc, #952]  ; a358 <_vfprintf_r+0x458>
    9f9c: e28d80c8  add r8, sp, #200  ; 0xc8
    9fa0: e3081580  movw  r1, #34176  ; 0x8580
    9fa4: e3060667  movw  r0, #26215  ; 0x6667
    9fa8: e1a09008  mov r9, r8
    9fac: e3a03000  mov r3, #0
    9fb0: e3401001  movt  r1, #1
    9fb4: e3460666  movt  r0, #26214  ; 0x6666
    9fb8: e58d304c  str r3, [sp, #76] ; 0x4c
    9fbc: e58d305c  str r3, [sp, #92] ; 0x5c
    9fc0: e58d3068  str r3, [sp, #104]  ; 0x68
    9fc4: e58d302c  str r3, [sp, #44] ; 0x2c
    9fc8: e58d1050  str r1, [sp, #80] ; 0x50
    9fcc: e58d006c  str r0, [sp, #108]  ; 0x6c
    9fd0: e58d309c  str r3, [sp, #156]  ; 0x9c
    9fd4: e58d3098  str r3, [sp, #152]  ; 0x98
    9fd8: e58d8094  str r8, [sp, #148]  ; 0x94
    9fdc: e59d4024  ldr r4, [sp, #36] ; 0x24
    9fe0: e5d43000  ldrb  r3, [r4]
    9fe4: e3530025  cmp r3, #37 ; 0x25
    9fe8: 13530000  cmpne r3, #0
    9fec: 0a0000ab  beq a2a0 <_vfprintf_r+0x3a0>
    9ff0: e5f43001  ldrb  r3, [r4, #1]!
    9ff4: e3530025  cmp r3, #37 ; 0x25
    9ff8: 13530000  cmpne r3, #0
    9ffc: 1afffffb  bne 9ff0 <_vfprintf_r+0xf0>
    a000: e59d2024  ldr r2, [sp, #36] ; 0x24
    a004: e0545002  subs  r5, r4, r2
    a008: 0a00000d  beq a044 <_vfprintf_r+0x144>
    a00c: e59d3098  ldr r3, [sp, #152]  ; 0x98
    a010: e5892000  str r2, [r9]
    a014: e2833001  add r3, r3, #1
    a018: e59d209c  ldr r2, [sp, #156]  ; 0x9c
    a01c: e3530007  cmp r3, #7
    a020: e5895004  str r5, [r9, #4]
    a024: e58d3098  str r3, [sp, #152]  ; 0x98
    a028: d2899008  addle r9, r9, #8
    a02c: e0823005  add r3, r2, r5
    a030: e58d309c  str r3, [sp, #156]  ; 0x9c
    a034: ca000075  bgt a210 <_vfprintf_r+0x310>
    a038: e59d302c  ldr r3, [sp, #44] ; 0x2c
    a03c: e0833005  add r3, r3, r5
    a040: e58d302c  str r3, [sp, #44] ; 0x2c
    a044: e5d43000  ldrb  r3, [r4]
    a048: e3530000  cmp r3, #0
    a04c: 0a000077  beq a230 <_vfprintf_r+0x330>
    a050: e5d46001  ldrb  r6, [r4, #1]
    a054: e3a03000  mov r3, #0
    a058: e2841001  add r1, r4, #1
    a05c: e1a02003  mov r2, r3
    a060: e5cd3077  strb  r3, [sp, #119]  ; 0x77
    a064: e58d3030  str r3, [sp, #48] ; 0x30
    a068: e58d301c  str r3, [sp, #28]
    a06c: e3e07000  mvn r7, #0
    a070: e2813001  add r3, r1, #1
    a074: e2461020  sub r1, r6, #32
    a078: e3510058  cmp r1, #88 ; 0x58
    a07c: 979ff101  ldrls pc, [pc, r1, lsl #2]
    a080: ea000266  b aa20 <_vfprintf_r+0xb20>
    a084: 0000a610  .word 0x0000a610
    a088: 0000aa20  .word 0x0000aa20
    a08c: 0000aa20  .word 0x0000aa20
    a090: 0000a624  .word 0x0000a624
    a094: 0000aa20  .word 0x0000aa20
    a098: 0000aa20  .word 0x0000aa20
    a09c: 0000aa20  .word 0x0000aa20
    a0a0: 0000aa20  .word 0x0000aa20
    a0a4: 0000aa20  .word 0x0000aa20
    a0a8: 0000aa20  .word 0x0000aa20
    a0ac: 0000a63c  .word 0x0000a63c
    a0b0: 0000a664  .word 0x0000a664
    a0b4: 0000aa20  .word 0x0000aa20
    a0b8: 0000a4e8  .word 0x0000a4e8
    a0bc: 0000a8cc  .word 0x0000a8cc
    a0c0: 0000aa20  .word 0x0000aa20
    a0c4: 0000a674  .word 0x0000a674
    a0c8: 0000a68c  .word 0x0000a68c
    a0cc: 0000a68c  .word 0x0000a68c
    a0d0: 0000a68c  .word 0x0000a68c
    a0d4: 0000a68c  .word 0x0000a68c
    a0d8: 0000a68c  .word 0x0000a68c
    a0dc: 0000a68c  .word 0x0000a68c
    a0e0: 0000a68c  .word 0x0000a68c
    a0e4: 0000a68c  .word 0x0000a68c
    a0e8: 0000a68c  .word 0x0000a68c
    a0ec: 0000aa20  .word 0x0000aa20
    a0f0: 0000aa20  .word 0x0000aa20
    a0f4: 0000aa20  .word 0x0000aa20
    a0f8: 0000aa20  .word 0x0000aa20
    a0fc: 0000aa20  .word 0x0000aa20
    a100: 0000aa20  .word 0x0000aa20
    a104: 0000aa20  .word 0x0000aa20
    a108: 0000aa20  .word 0x0000aa20
    a10c: 0000aa20  .word 0x0000aa20
    a110: 0000aa20  .word 0x0000aa20
    a114: 0000a714  .word 0x0000a714
    a118: 0000a770  .word 0x0000a770
    a11c: 0000aa20  .word 0x0000aa20
    a120: 0000a770  .word 0x0000a770
    a124: 0000aa20  .word 0x0000aa20
    a128: 0000aa20  .word 0x0000aa20
    a12c: 0000aa20  .word 0x0000aa20
    a130: 0000aa20  .word 0x0000aa20
    a134: 0000a7f8  .word 0x0000a7f8
    a138: 0000aa20  .word 0x0000aa20
    a13c: 0000aa20  .word 0x0000aa20
    a140: 0000a910  .word 0x0000a910
    a144: 0000aa20  .word 0x0000aa20
    a148: 0000aa20  .word 0x0000aa20
    a14c: 0000aa20  .word 0x0000aa20
    a150: 0000aa20  .word 0x0000aa20
    a154: 0000aa20  .word 0x0000aa20
    a158: 0000a9dc  .word 0x0000a9dc
    a15c: 0000aa20  .word 0x0000aa20
    a160: 0000aa20  .word 0x0000aa20
    a164: 0000a954  .word 0x0000a954
    a168: 0000aa20  .word 0x0000aa20
    a16c: 0000aa20  .word 0x0000aa20
    a170: 0000aa20  .word 0x0000aa20
    a174: 0000aa20  .word 0x0000aa20
    a178: 0000aa20  .word 0x0000aa20
    a17c: 0000aa20  .word 0x0000aa20
    a180: 0000aa20  .word 0x0000aa20
    a184: 0000aa20  .word 0x0000aa20
    a188: 0000aa20  .word 0x0000aa20
    a18c: 0000aa20  .word 0x0000aa20
    a190: 0000a998  .word 0x0000a998
    a194: 0000a810  .word 0x0000a810
    a198: 0000a770  .word 0x0000a770
    a19c: 0000a770  .word 0x0000a770
    a1a0: 0000a770  .word 0x0000a770
    a1a4: 0000a850  .word 0x0000a850
    a1a8: 0000a810  .word 0x0000a810
    a1ac: 0000aa20  .word 0x0000aa20
    a1b0: 0000aa20  .word 0x0000aa20
    a1b4: 0000a868  .word 0x0000a868
    a1b8: 0000aa20  .word 0x0000aa20
    a1bc: 0000a894  .word 0x0000a894
    a1c0: 0000a500  .word 0x0000a500
    a1c4: 0000a6b4  .word 0x0000a6b4
    a1c8: 0000a6fc  .word 0x0000a6fc
    a1cc: 0000aa20  .word 0x0000aa20
    a1d0: 0000a530  .word 0x0000a530
    a1d4: 0000aa20  .word 0x0000aa20
    a1d8: 0000a2a8  .word 0x0000a2a8
    a1dc: 0000aa20  .word 0x0000aa20
    a1e0: 0000aa20  .word 0x0000aa20
    a1e4: 0000a5a4  .word 0x0000a5a4
    a1e8: e59d0028  ldr r0, [sp, #40] ; 0x28
    a1ec: e1a0100b  mov r1, fp
    a1f0: eb000728  bl  be98 <__swsetup_r>
    a1f4: e3500000  cmp r0, #0
    a1f8: 01db20bc  ldrheq  r2, [fp, #12]
    a1fc: 0affff62  beq 9f8c <_vfprintf_r+0x8c>
    a200: e3e00000  mvn r0, #0
    a204: e28ddf43  add sp, sp, #268  ; 0x10c
    a208: ecbd8b04  vpop  {d8-d9}
    a20c: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a210: e59d0028  ldr r0, [sp, #40] ; 0x28
    a214: e1a0100b  mov r1, fp
    a218: e28d2094  add r2, sp, #148  ; 0x94
    a21c: eb0016c8  bl  fd44 <__sprint_r>
    a220: e3500000  cmp r0, #0
    a224: 1a000008  bne a24c <_vfprintf_r+0x34c>
    a228: e1a09008  mov r9, r8
    a22c: eaffff81  b a038 <_vfprintf_r+0x138>
    a230: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    a234: e3530000  cmp r3, #0
    a238: 0a000003  beq a24c <_vfprintf_r+0x34c>
    a23c: e59d0028  ldr r0, [sp, #40] ; 0x28
    a240: e1a0100b  mov r1, fp
    a244: e28d2094  add r2, sp, #148  ; 0x94
    a248: eb0016bd  bl  fd44 <__sprint_r>
    a24c: e1db30bc  ldrh  r3, [fp, #12]
    a250: e3130040  tst r3, #64 ; 0x40
    a254: 1affffe9  bne a200 <_vfprintf_r+0x300>
    a258: e59d002c  ldr r0, [sp, #44] ; 0x2c
    a25c: e28ddf43  add sp, sp, #268  ; 0x10c
    a260: ecbd8b04  vpop  {d8-d9}
    a264: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a268: e1db30fe  ldrsh r3, [fp, #14]
    a26c: e3530000  cmp r3, #0
    a270: baffff48  blt 9f98 <_vfprintf_r+0x98>
    a274: e59d0028  ldr r0, [sp, #40] ; 0x28
    a278: e1a0100b  mov r1, fp
    a27c: e59d2024  ldr r2, [sp, #36] ; 0x24
    a280: e1a03004  mov r3, r4
    a284: eb0006d9  bl  bdf0 <__sbprintf>
    a288: e28ddf43  add sp, sp, #268  ; 0x10c
    a28c: ecbd8b04  vpop  {d8-d9}
    a290: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    a294: e59d0028  ldr r0, [sp, #40] ; 0x28
    a298: eb000e1e  bl  db18 <__sinit>
    a29c: eaffff2b  b 9f50 <_vfprintf_r+0x50>
    a2a0: e59d4024  ldr r4, [sp, #36] ; 0x24
    a2a4: eaffff66  b a044 <_vfprintf_r+0x144>
    a2a8: e58d3024  str r3, [sp, #36] ; 0x24
    a2ac: e59d301c  ldr r3, [sp, #28]
    a2b0: e3130020  tst r3, #32
    a2b4: 0a0001cf  beq a9f8 <_vfprintf_r+0xaf8>
    a2b8: e59d3034  ldr r3, [sp, #52] ; 0x34
    a2bc: e3a02001  mov r2, #1
    a2c0: e2833007  add r3, r3, #7
    a2c4: e3c33007  bic r3, r3, #7
    a2c8: e2831008  add r1, r3, #8
    a2cc: e58d1034  str r1, [sp, #52] ; 0x34
    a2d0: e1c340d0  ldrd  r4, [r3]
    a2d4: e3a03000  mov r3, #0
    a2d8: e58d7044  str r7, [sp, #68] ; 0x44
    a2dc: e1a0a003  mov sl, r3
    a2e0: e5cd3077  strb  r3, [sp, #119]  ; 0x77
    a2e4: e3570000  cmp r7, #0
    a2e8: a59d301c  ldrge r3, [sp, #28]
    a2ec: a3c33080  bicge r3, r3, #128  ; 0x80
    a2f0: a58d301c  strge r3, [sp, #28]
    a2f4: e1943005  orrs  r3, r4, r5
    a2f8: 13a03001  movne r3, #1
    a2fc: 03a03000  moveq r3, #0
    a300: e3570000  cmp r7, #0
    a304: 13833001  orrne r3, r3, #1
    a308: e3530000  cmp r3, #0
    a30c: 0a0002cc  beq ae44 <_vfprintf_r+0xf44>
    a310: e3520001  cmp r2, #1
    a314: 0a0003a1  beq b1a0 <_vfprintf_r+0x12a0>
    a318: e3520002  cmp r2, #2
    a31c: e1a02008  mov r2, r8
    a320: 1a00000f  bne a364 <_vfprintf_r+0x464>
    a324: e59d105c  ldr r1, [sp, #92] ; 0x5c
    a328: e204300f  and r3, r4, #15
    a32c: e1a04224  lsr r4, r4, #4
    a330: e1844e05  orr r4, r4, r5, lsl #28
    a334: e1a05225  lsr r5, r5, #4
    a338: e7d13003  ldrb  r3, [r1, r3]
    a33c: e1940005  orrs  r0, r4, r5
    a340: e5623001  strb  r3, [r2, #-1]!
    a344: 1afffff7  bne a328 <_vfprintf_r+0x428>
    a348: e1a03002  mov r3, r2
    a34c: e58d2040  str r2, [sp, #64] ; 0x40
    a350: e0635008  rsb r5, r3, r8
    a354: ea000019  b a3c0 <_vfprintf_r+0x4c0>
  ...
    a360: 00018590  .word 0x00018590
    a364: e2043007  and r3, r4, #7
    a368: e1a041a4  lsr r4, r4, #3
    a36c: e1844e85  orr r4, r4, r5, lsl #29
    a370: e1a051a5  lsr r5, r5, #3
    a374: e1941005  orrs  r1, r4, r5
    a378: e2833030  add r3, r3, #48 ; 0x30
    a37c: e5623001  strb  r3, [r2, #-1]!
    a380: 1afffff7  bne a364 <_vfprintf_r+0x464>
    a384: e59d101c  ldr r1, [sp, #28]
    a388: e58d2040  str r2, [sp, #64] ; 0x40
    a38c: e3110001  tst r1, #1
    a390: 01a03002  moveq r3, r2
    a394: 00635008  rsbeq r5, r3, r8
    a398: 0a000008  beq a3c0 <_vfprintf_r+0x4c0>
    a39c: e3530030  cmp r3, #48 ; 0x30
    a3a0: e59d3040  ldr r3, [sp, #64] ; 0x40
    a3a4: 0affffe9  beq a350 <_vfprintf_r+0x450>
    a3a8: e2433001  sub r3, r3, #1
    a3ac: e58d3040  str r3, [sp, #64] ; 0x40
    a3b0: e1a01003  mov r1, r3
    a3b4: e0615008  rsb r5, r1, r8
    a3b8: e3a03030  mov r3, #48 ; 0x30
    a3bc: e5423001  strb  r3, [r2, #-1]
    a3c0: e1550007  cmp r5, r7
    a3c4: e3a03000  mov r3, #0
    a3c8: e58d3048  str r3, [sp, #72] ; 0x48
    a3cc: a1a03005  movge r3, r5
    a3d0: b1a03007  movlt r3, r7
    a3d4: e58d3020  str r3, [sp, #32]
    a3d8: e35a0000  cmp sl, #0
    a3dc: 0a000002  beq a3ec <_vfprintf_r+0x4ec>
    a3e0: e59d3020  ldr r3, [sp, #32]
    a3e4: e2833001  add r3, r3, #1
    a3e8: e58d3020  str r3, [sp, #32]
    a3ec: e59d301c  ldr r3, [sp, #28]
    a3f0: e2133002  ands  r3, r3, #2
    a3f4: e58d3038  str r3, [sp, #56] ; 0x38
    a3f8: 159d3020  ldrne r3, [sp, #32]
    a3fc: 12833002  addne r3, r3, #2
    a400: 158d3020  strne r3, [sp, #32]
    a404: e59d301c  ldr r3, [sp, #28]
    a408: e2133084  ands  r3, r3, #132  ; 0x84
    a40c: e58d303c  str r3, [sp, #60] ; 0x3c
    a410: 1a00019a  bne aa80 <_vfprintf_r+0xb80>
    a414: e59d3030  ldr r3, [sp, #48] ; 0x30
    a418: e59d2020  ldr r2, [sp, #32]
    a41c: e0624003  rsb r4, r2, r3
    a420: e3540000  cmp r4, #0
    a424: da000195  ble aa80 <_vfprintf_r+0xb80>
    a428: e3540010  cmp r4, #16
    a42c: da00058f  ble ba70 <_vfprintf_r+0x1b70>
    a430: e308a580  movw  sl, #34176  ; 0x8580
    a434: e58d6060  str r6, [sp, #96] ; 0x60
    a438: e58d5064  str r5, [sp, #100]  ; 0x64
    a43c: e340a001  movt  sl, #1
    a440: e59d109c  ldr r1, [sp, #156]  ; 0x9c
    a444: e3a07010  mov r7, #16
    a448: e59d2098  ldr r2, [sp, #152]  ; 0x98
    a44c: e59d5028  ldr r5, [sp, #40] ; 0x28
    a450: e59d6050  ldr r6, [sp, #80] ; 0x50
    a454: ea000002  b a464 <_vfprintf_r+0x564>
    a458: e2444010  sub r4, r4, #16
    a45c: e3540010  cmp r4, #16
    a460: da000013  ble a4b4 <_vfprintf_r+0x5b4>
    a464: e2822001  add r2, r2, #1
    a468: e2811010  add r1, r1, #16
    a46c: e3520007  cmp r2, #7
    a470: e88900c0  stm r9, {r6, r7}
    a474: e58d2098  str r2, [sp, #152]  ; 0x98
    a478: d2899008  addle r9, r9, #8
    a47c: e58d109c  str r1, [sp, #156]  ; 0x9c
    a480: dafffff4  ble a458 <_vfprintf_r+0x558>
    a484: e1a00005  mov r0, r5
    a488: e1a0100b  mov r1, fp
    a48c: e28d2094  add r2, sp, #148  ; 0x94
    a490: e1a09008  mov r9, r8
    a494: eb00162a  bl  fd44 <__sprint_r>
    a498: e3500000  cmp r0, #0
    a49c: 1affff6a  bne a24c <_vfprintf_r+0x34c>
    a4a0: e2444010  sub r4, r4, #16
    a4a4: e59d109c  ldr r1, [sp, #156]  ; 0x9c
    a4a8: e3540010  cmp r4, #16
    a4ac: e59d2098  ldr r2, [sp, #152]  ; 0x98
    a4b0: caffffeb  bgt a464 <_vfprintf_r+0x564>
    a4b4: e59d6060  ldr r6, [sp, #96] ; 0x60
    a4b8: e59d5064  ldr r5, [sp, #100]  ; 0x64
    a4bc: e2822001  add r2, r2, #1
    a4c0: e0843001  add r3, r4, r1
    a4c4: e3520007  cmp r2, #7
    a4c8: e58d2098  str r2, [sp, #152]  ; 0x98
    a4cc: e58d309c  str r3, [sp, #156]  ; 0x9c
    a4d0: e589a000  str sl, [r9]
    a4d4: e5894004  str r4, [r9, #4]
    a4d8: ca000160  bgt aa60 <_vfprintf_r+0xb60>
    a4dc: e2899008  add r9, r9, #8
    a4e0: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    a4e4: ea000166  b aa84 <_vfprintf_r+0xb84>
    a4e8: e1a01003  mov r1, r3
    a4ec: e59d001c  ldr r0, [sp, #28]
    a4f0: e5d36000  ldrb  r6, [r3]
    a4f4: e3800004  orr r0, r0, #4
    a4f8: e58d001c  str r0, [sp, #28]
    a4fc: eafffedb  b a070 <_vfprintf_r+0x170>
    a500: e58d3024  str r3, [sp, #36] ; 0x24
    a504: e59d301c  ldr r3, [sp, #28]
    a508: e2135020  ands  r5, r3, #32
    a50c: 0a000106  beq a92c <_vfprintf_r+0xa2c>
    a510: e59d3034  ldr r3, [sp, #52] ; 0x34
    a514: e3a02000  mov r2, #0
    a518: e2833007  add r3, r3, #7
    a51c: e3c33007  bic r3, r3, #7
    a520: e2831008  add r1, r3, #8
    a524: e58d1034  str r1, [sp, #52] ; 0x34
    a528: e1c340d0  ldrd  r4, [r3]
    a52c: eaffff68  b a2d4 <_vfprintf_r+0x3d4>
    a530: e58d3024  str r3, [sp, #36] ; 0x24
    a534: e3a04000  mov r4, #0
    a538: e59d3034  ldr r3, [sp, #52] ; 0x34
    a53c: e1a05007  mov r5, r7
    a540: e5cd4077  strb  r4, [sp, #119]  ; 0x77
    a544: e2837004  add r7, r3, #4
    a548: e5932000  ldr r2, [r3]
    a54c: e1520004  cmp r2, r4
    a550: e58d2040  str r2, [sp, #64] ; 0x40
    a554: 0a000563  beq bae8 <_vfprintf_r+0x1be8>
    a558: e3550000  cmp r5, #0
    a55c: e59d0040  ldr r0, [sp, #64] ; 0x40
    a560: ba000539  blt ba4c <_vfprintf_r+0x1b4c>
    a564: e1a01004  mov r1, r4
    a568: e1a02005  mov r2, r5
    a56c: fa00111b  blx e9e0 <memchr>
    a570: e3500000  cmp r0, #0
    a574: 0a00059a  beq bbe4 <_vfprintf_r+0x1ce4>
    a578: e59d3040  ldr r3, [sp, #64] ; 0x40
    a57c: e58d4044  str r4, [sp, #68] ; 0x44
    a580: e0633000  rsb r3, r3, r0
    a584: e58d7034  str r7, [sp, #52] ; 0x34
    a588: e1530005  cmp r3, r5
    a58c: e58d4048  str r4, [sp, #72] ; 0x48
    a590: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    a594: b1a05003  movlt r5, r3
    a598: e1c53fc5  bic r3, r5, r5, asr #31
    a59c: e58d3020  str r3, [sp, #32]
    a5a0: eaffff8c  b a3d8 <_vfprintf_r+0x4d8>
    a5a4: e58d3024  str r3, [sp, #36] ; 0x24
    a5a8: e308374c  movw  r3, #34636  ; 0x874c
    a5ac: e3403001  movt  r3, #1
    a5b0: e58d305c  str r3, [sp, #92] ; 0x5c
    a5b4: e59d301c  ldr r3, [sp, #28]
    a5b8: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a5bc: e3130020  tst r3, #32
    a5c0: 0a0000eb  beq a974 <_vfprintf_r+0xa74>
    a5c4: e59d3034  ldr r3, [sp, #52] ; 0x34
    a5c8: e2833007  add r3, r3, #7
    a5cc: e3c33007  bic r3, r3, #7
    a5d0: e2832008  add r2, r3, #8
    a5d4: e58d2034  str r2, [sp, #52] ; 0x34
    a5d8: e1c340d0  ldrd  r4, [r3]
    a5dc: e59d301c  ldr r3, [sp, #28]
    a5e0: e3130001  tst r3, #1
    a5e4: 0a0002b3  beq b0b8 <_vfprintf_r+0x11b8>
    a5e8: e1943005  orrs  r3, r4, r5
    a5ec: 0a0002b1  beq b0b8 <_vfprintf_r+0x11b8>
    a5f0: e59d301c  ldr r3, [sp, #28]
    a5f4: e3a02002  mov r2, #2
    a5f8: e5cd6079  strb  r6, [sp, #121]  ; 0x79
    a5fc: e3833002  orr r3, r3, #2
    a600: e58d301c  str r3, [sp, #28]
    a604: e3a03030  mov r3, #48 ; 0x30
    a608: e5cd3078  strb  r3, [sp, #120]  ; 0x78
    a60c: eaffff30  b a2d4 <_vfprintf_r+0x3d4>
    a610: e3520000  cmp r2, #0
    a614: e5d36000  ldrb  r6, [r3]
    a618: e1a01003  mov r1, r3
    a61c: 03a02020  moveq r2, #32
    a620: eafffe92  b a070 <_vfprintf_r+0x170>
    a624: e59d101c  ldr r1, [sp, #28]
    a628: e3811001  orr r1, r1, #1
    a62c: e58d101c  str r1, [sp, #28]
    a630: e1a01003  mov r1, r3
    a634: e5d36000  ldrb  r6, [r3]
    a638: eafffe8c  b a070 <_vfprintf_r+0x170>
    a63c: e59d1034  ldr r1, [sp, #52] ; 0x34
    a640: e2811004  add r1, r1, #4
    a644: e5110004  ldr r0, [r1, #-4]
    a648: e3500000  cmp r0, #0
    a64c: e58d0030  str r0, [sp, #48] ; 0x30
    a650: ba0004b5  blt b92c <_vfprintf_r+0x1a2c>
    a654: e58d1034  str r1, [sp, #52] ; 0x34
    a658: e1a01003  mov r1, r3
    a65c: e5d36000  ldrb  r6, [r3]
    a660: eafffe82  b a070 <_vfprintf_r+0x170>
    a664: e5d36000  ldrb  r6, [r3]
    a668: e1a01003  mov r1, r3
    a66c: e3a0202b  mov r2, #43 ; 0x2b
    a670: eafffe7e  b a070 <_vfprintf_r+0x170>
    a674: e59d101c  ldr r1, [sp, #28]
    a678: e3811080  orr r1, r1, #128  ; 0x80
    a67c: e58d101c  str r1, [sp, #28]
    a680: e1a01003  mov r1, r3
    a684: e5d36000  ldrb  r6, [r3]
    a688: eafffe78  b a070 <_vfprintf_r+0x170>
    a68c: e2460030  sub r0, r6, #48 ; 0x30
    a690: e3a01000  mov r1, #0
    a694: e0811101  add r1, r1, r1, lsl #2
    a698: e4d36001  ldrb  r6, [r3], #1
    a69c: e0801081  add r1, r0, r1, lsl #1
    a6a0: e2460030  sub r0, r6, #48 ; 0x30
    a6a4: e3500009  cmp r0, #9
    a6a8: 9afffff9  bls a694 <_vfprintf_r+0x794>
    a6ac: e58d1030  str r1, [sp, #48] ; 0x30
    a6b0: eafffe6f  b a074 <_vfprintf_r+0x174>
    a6b4: e59d2034  ldr r2, [sp, #52] ; 0x34
    a6b8: e3a06078  mov r6, #120  ; 0x78
    a6bc: e59d101c  ldr r1, [sp, #28]
    a6c0: e3a05000  mov r5, #0
    a6c4: e58d3024  str r3, [sp, #36] ; 0x24
    a6c8: e308374c  movw  r3, #34636  ; 0x874c
    a6cc: e5924000  ldr r4, [r2]
    a6d0: e3403001  movt  r3, #1
    a6d4: e2822004  add r2, r2, #4
    a6d8: e3811002  orr r1, r1, #2
    a6dc: e58d2034  str r2, [sp, #52] ; 0x34
    a6e0: e3a02002  mov r2, #2
    a6e4: e58d305c  str r3, [sp, #92] ; 0x5c
    a6e8: e3a03030  mov r3, #48 ; 0x30
    a6ec: e58d101c  str r1, [sp, #28]
    a6f0: e5cd6079  strb  r6, [sp, #121]  ; 0x79
    a6f4: e5cd3078  strb  r3, [sp, #120]  ; 0x78
    a6f8: eafffef5  b a2d4 <_vfprintf_r+0x3d4>
    a6fc: e59d101c  ldr r1, [sp, #28]
    a700: e3811020  orr r1, r1, #32
    a704: e58d101c  str r1, [sp, #28]
    a708: e1a01003  mov r1, r3
    a70c: e5d36000  ldrb  r6, [r3]
    a710: eafffe56  b a070 <_vfprintf_r+0x170>
    a714: e58d3024  str r3, [sp, #36] ; 0x24
    a718: e59d301c  ldr r3, [sp, #28]
    a71c: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a720: e3833010  orr r3, r3, #16
    a724: e58d301c  str r3, [sp, #28]
    a728: e59d301c  ldr r3, [sp, #28]
    a72c: e3130020  tst r3, #32
    a730: 0a00003b  beq a824 <_vfprintf_r+0x924>
    a734: e59d3034  ldr r3, [sp, #52] ; 0x34
    a738: e2833007  add r3, r3, #7
    a73c: e3c33007  bic r3, r3, #7
    a740: e2832008  add r2, r3, #8
    a744: e58d2034  str r2, [sp, #52] ; 0x34
    a748: e1c320d0  ldrd  r2, [r3]
    a74c: e1a04002  mov r4, r2
    a750: e1a05003  mov r5, r3
    a754: e3520000  cmp r2, #0
    a758: e2d33000  sbcs  r3, r3, #0
    a75c: ba00036c  blt b514 <_vfprintf_r+0x1614>
    a760: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    a764: e3a02001  mov r2, #1
    a768: e58d7044  str r7, [sp, #68] ; 0x44
    a76c: eafffedc  b a2e4 <_vfprintf_r+0x3e4>
    a770: e58d3024  str r3, [sp, #36] ; 0x24
    a774: e59d3034  ldr r3, [sp, #52] ; 0x34
    a778: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a77c: e2833007  add r3, r3, #7
    a780: e3c33007  bic r3, r3, #7
    a784: e2832008  add r2, r3, #8
    a788: e58d2034  str r2, [sp, #52] ; 0x34
    a78c: ed938b00  vldr  d8, [r3]
    a790: ec510b18  vmov  r0, r1, d8
    a794: eb001429  bl  f840 <__fpclassifyd>
    a798: e3500001  cmp r0, #1
    a79c: 1a000363  bne b530 <_vfprintf_r+0x1630>
    a7a0: eeb58bc0  vcmpe.f64 d8, #0.0
    a7a4: e59dc01c  ldr ip, [sp, #28]
    a7a8: e308373c  movw  r3, #34620  ; 0x873c
    a7ac: e3a01003  mov r1, #3
    a7b0: e3082740  movw  r2, #34624  ; 0x8740
    a7b4: e3403001  movt  r3, #1
    a7b8: e3a00000  mov r0, #0
    a7bc: e3402001  movt  r2, #1
    a7c0: eef1fa10  vmrs  APSR_nzcv, fpscr
    a7c4: 43a0a02d  movmi sl, #45 ; 0x2d
    a7c8: 55dda077  ldrbpl  sl, [sp, #119]  ; 0x77
    a7cc: e3ccc080  bic ip, ip, #128  ; 0x80
    a7d0: 45cda077  strbmi  sl, [sp, #119]  ; 0x77
    a7d4: e3560047  cmp r6, #71 ; 0x47
    a7d8: e58d1020  str r1, [sp, #32]
    a7dc: e1a05001  mov r5, r1
    a7e0: d1a02003  movle r2, r3
    a7e4: e58d0044  str r0, [sp, #68] ; 0x44
    a7e8: e58dc01c  str ip, [sp, #28]
    a7ec: e58d2040  str r2, [sp, #64] ; 0x40
    a7f0: e58d0048  str r0, [sp, #72] ; 0x48
    a7f4: eafffef7  b a3d8 <_vfprintf_r+0x4d8>
    a7f8: e59d101c  ldr r1, [sp, #28]
    a7fc: e3811008  orr r1, r1, #8
    a800: e58d101c  str r1, [sp, #28]
    a804: e1a01003  mov r1, r3
    a808: e5d36000  ldrb  r6, [r3]
    a80c: eafffe17  b a070 <_vfprintf_r+0x170>
    a810: e58d3024  str r3, [sp, #36] ; 0x24
    a814: e59d301c  ldr r3, [sp, #28]
    a818: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a81c: e3130020  tst r3, #32
    a820: 1affffc3  bne a734 <_vfprintf_r+0x834>
    a824: e59d301c  ldr r3, [sp, #28]
    a828: e3130010  tst r3, #16
    a82c: 0a0003ac  beq b6e4 <_vfprintf_r+0x17e4>
    a830: e59d3034  ldr r3, [sp, #52] ; 0x34
    a834: e5934000  ldr r4, [r3]
    a838: e2833004  add r3, r3, #4
    a83c: e58d3034  str r3, [sp, #52] ; 0x34
    a840: e1a05fc4  asr r5, r4, #31
    a844: e1a02004  mov r2, r4
    a848: e1a03005  mov r3, r5
    a84c: eaffffc0  b a754 <_vfprintf_r+0x854>
    a850: e59d101c  ldr r1, [sp, #28]
    a854: e3811040  orr r1, r1, #64 ; 0x40
    a858: e58d101c  str r1, [sp, #28]
    a85c: e1a01003  mov r1, r3
    a860: e5d36000  ldrb  r6, [r3]
    a864: eafffe01  b a070 <_vfprintf_r+0x170>
    a868: e5d36000  ldrb  r6, [r3]
    a86c: e59d101c  ldr r1, [sp, #28]
    a870: e356006c  cmp r6, #108  ; 0x6c
    a874: 03811020  orreq r1, r1, #32
    a878: 13811010  orrne r1, r1, #16
    a87c: 058d101c  streq r1, [sp, #28]
    a880: 02831001  addeq r1, r3, #1
    a884: 158d101c  strne r1, [sp, #28]
    a888: 11a01003  movne r1, r3
    a88c: 05d36001  ldrbeq  r6, [r3, #1]
    a890: eafffdf6  b a070 <_vfprintf_r+0x170>
    a894: e58d3024  str r3, [sp, #36] ; 0x24
    a898: e59d301c  ldr r3, [sp, #28]
    a89c: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a8a0: e3130020  tst r3, #32
    a8a4: 0a00039a  beq b714 <_vfprintf_r+0x1814>
    a8a8: e59d102c  ldr r1, [sp, #44] ; 0x2c
    a8ac: e59d2034  ldr r2, [sp, #52] ; 0x34
    a8b0: ee801b90  vdup.32 d16, r1
    a8b4: e2822004  add r2, r2, #4
    a8b8: e5123004  ldr r3, [r2, #-4]
    a8bc: f2e000b0  vshr.s64  d16, d16, #32
    a8c0: e58d2034  str r2, [sp, #52] ; 0x34
    a8c4: edc30b00  vstr  d16, [r3]
    a8c8: eafffdc3  b 9fdc <_vfprintf_r+0xdc>
    a8cc: e5d36000  ldrb  r6, [r3]
    a8d0: e2831001  add r1, r3, #1
    a8d4: e356002a  cmp r6, #42 ; 0x2a
    a8d8: 0a000529  beq bd84 <_vfprintf_r+0x1e84>
    a8dc: e2460030  sub r0, r6, #48 ; 0x30
    a8e0: e1a03001  mov r3, r1
    a8e4: e3500009  cmp r0, #9
    a8e8: e3a07000  mov r7, #0
    a8ec: 8afffde0  bhi a074 <_vfprintf_r+0x174>
    a8f0: e0877107  add r7, r7, r7, lsl #2
    a8f4: e4d36001  ldrb  r6, [r3], #1
    a8f8: e0807087  add r7, r0, r7, lsl #1
    a8fc: e2460030  sub r0, r6, #48 ; 0x30
    a900: e3500009  cmp r0, #9
    a904: 9afffff9  bls a8f0 <_vfprintf_r+0x9f0>
    a908: e1877fc7  orr r7, r7, r7, asr #31
    a90c: eafffdd8  b a074 <_vfprintf_r+0x174>
    a910: e58d3024  str r3, [sp, #36] ; 0x24
    a914: e59d301c  ldr r3, [sp, #28]
    a918: e3833010  orr r3, r3, #16
    a91c: e58d301c  str r3, [sp, #28]
    a920: e59d301c  ldr r3, [sp, #28]
    a924: e2135020  ands  r5, r3, #32
    a928: 1afffef8  bne a510 <_vfprintf_r+0x610>
    a92c: e59d301c  ldr r3, [sp, #28]
    a930: e2133010  ands  r3, r3, #16
    a934: 0a000354  beq b68c <_vfprintf_r+0x178c>
    a938: e59d3034  ldr r3, [sp, #52] ; 0x34
    a93c: e1a02005  mov r2, r5
    a940: e3a05000  mov r5, #0
    a944: e2833004  add r3, r3, #4
    a948: e5134004  ldr r4, [r3, #-4]
    a94c: e58d3034  str r3, [sp, #52] ; 0x34
    a950: eafffe5f  b a2d4 <_vfprintf_r+0x3d4>
    a954: e58d3024  str r3, [sp, #36] ; 0x24
    a958: e30836e8  movw  r3, #34536  ; 0x86e8
    a95c: e3403001  movt  r3, #1
    a960: e58d305c  str r3, [sp, #92] ; 0x5c
    a964: e59d301c  ldr r3, [sp, #28]
    a968: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    a96c: e3130020  tst r3, #32
    a970: 1affff13  bne a5c4 <_vfprintf_r+0x6c4>
    a974: e59d301c  ldr r3, [sp, #28]
    a978: e3130010  tst r3, #16
    a97c: 0a00034c  beq b6b4 <_vfprintf_r+0x17b4>
    a980: e59d3034  ldr r3, [sp, #52] ; 0x34
    a984: e3a05000  mov r5, #0
    a988: e2833004  add r3, r3, #4
    a98c: e5134004  ldr r4, [r3, #-4]
    a990: e58d3034  str r3, [sp, #52] ; 0x34
    a994: eaffff10  b a5dc <_vfprintf_r+0x6dc>
    a998: e59d0034  ldr r0, [sp, #52] ; 0x34
    a99c: e3a01001  mov r1, #1
    a9a0: e58d3024  str r3, [sp, #36] ; 0x24
    a9a4: e3a03000  mov r3, #0
    a9a8: e1a0a003  mov sl, r3
    a9ac: e2800004  add r0, r0, #4
    a9b0: e5102004  ldr r2, [r0, #-4]
    a9b4: e1a05001  mov r5, r1
    a9b8: e5cd3077  strb  r3, [sp, #119]  ; 0x77
    a9bc: e58d3044  str r3, [sp, #68] ; 0x44
    a9c0: e58d3048  str r3, [sp, #72] ; 0x48
    a9c4: e28d30a0  add r3, sp, #160  ; 0xa0
    a9c8: e58d1020  str r1, [sp, #32]
    a9cc: e58d0034  str r0, [sp, #52] ; 0x34
    a9d0: e5cd20a0  strb  r2, [sp, #160]  ; 0xa0
    a9d4: e58d3040  str r3, [sp, #64] ; 0x40
    a9d8: eafffe83  b a3ec <_vfprintf_r+0x4ec>
    a9dc: e58d3024  str r3, [sp, #36] ; 0x24
    a9e0: e59d301c  ldr r3, [sp, #28]
    a9e4: e3833010  orr r3, r3, #16
    a9e8: e58d301c  str r3, [sp, #28]
    a9ec: e59d301c  ldr r3, [sp, #28]
    a9f0: e3130020  tst r3, #32
    a9f4: 1afffe2f  bne a2b8 <_vfprintf_r+0x3b8>
    a9f8: e59d301c  ldr r3, [sp, #28]
    a9fc: e3130010  tst r3, #16
    aa00: 0a000357  beq b764 <_vfprintf_r+0x1864>
    aa04: e59d3034  ldr r3, [sp, #52] ; 0x34
    aa08: e5934000  ldr r4, [r3]
    aa0c: e3a02001  mov r2, #1
    aa10: e2833004  add r3, r3, #4
    aa14: e3a05000  mov r5, #0
    aa18: e58d3034  str r3, [sp, #52] ; 0x34
    aa1c: eafffe2c  b a2d4 <_vfprintf_r+0x3d4>
    aa20: e3560000  cmp r6, #0
    aa24: e58d3024  str r3, [sp, #36] ; 0x24
    aa28: e5cd2077  strb  r2, [sp, #119]  ; 0x77
    aa2c: 0afffdff  beq a230 <_vfprintf_r+0x330>
    aa30: e3a03000  mov r3, #0
    aa34: e3a02001  mov r2, #1
    aa38: e1a0a003  mov sl, r3
    aa3c: e5cd3077  strb  r3, [sp, #119]  ; 0x77
    aa40: e58d3044  str r3, [sp, #68] ; 0x44
    aa44: e1a05002  mov r5, r2
    aa48: e58d3048  str r3, [sp, #72] ; 0x48
    aa4c: e28d30a0  add r3, sp, #160  ; 0xa0
    aa50: e58d2020  str r2, [sp, #32]
    aa54: e5cd60a0  strb  r6, [sp, #160]  ; 0xa0
    aa58: e58d3040  str r3, [sp, #64] ; 0x40
    aa5c: eafffe62  b a3ec <_vfprintf_r+0x4ec>
    aa60: e59d0028  ldr r0, [sp, #40] ; 0x28
    aa64: e1a0100b  mov r1, fp
    aa68: e28d2094  add r2, sp, #148  ; 0x94
    aa6c: eb0014b4  bl  fd44 <__sprint_r>
    aa70: e3500000  cmp r0, #0
    aa74: 1afffdf4  bne a24c <_vfprintf_r+0x34c>
    aa78: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    aa7c: e1a09008  mov r9, r8
    aa80: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    aa84: e35a0000  cmp sl, #0
    aa88: 0a00000b  beq aabc <_vfprintf_r+0xbbc>
    aa8c: e59d2098  ldr r2, [sp, #152]  ; 0x98
    aa90: e2833001  add r3, r3, #1
    aa94: e28d1077  add r1, sp, #119  ; 0x77
    aa98: e58d309c  str r3, [sp, #156]  ; 0x9c
    aa9c: e2822001  add r2, r2, #1
    aaa0: e5891000  str r1, [r9]
    aaa4: e3520007  cmp r2, #7
    aaa8: e58d2098  str r2, [sp, #152]  ; 0x98
    aaac: e3a02001  mov r2, #1
    aab0: e5892004  str r2, [r9, #4]
    aab4: d2899008  addle r9, r9, #8
    aab8: ca00016c  bgt b070 <_vfprintf_r+0x1170>
    aabc: e59d2038  ldr r2, [sp, #56] ; 0x38
    aac0: e3520000  cmp r2, #0
    aac4: 0a00000b  beq aaf8 <_vfprintf_r+0xbf8>
    aac8: e59d2098  ldr r2, [sp, #152]  ; 0x98
    aacc: e2833002  add r3, r3, #2
    aad0: e28d1078  add r1, sp, #120  ; 0x78
    aad4: e58d309c  str r3, [sp, #156]  ; 0x9c
    aad8: e2822001  add r2, r2, #1
    aadc: e5891000  str r1, [r9]
    aae0: e3520007  cmp r2, #7
    aae4: e58d2098  str r2, [sp, #152]  ; 0x98
    aae8: e3a02002  mov r2, #2
    aaec: e5892004  str r2, [r9, #4]
    aaf0: d2899008  addle r9, r9, #8
    aaf4: ca000166  bgt b094 <_vfprintf_r+0x1194>
    aaf8: e59d203c  ldr r2, [sp, #60] ; 0x3c
    aafc: e3520080  cmp r2, #128  ; 0x80
    ab00: 0a0000dd  beq ae7c <_vfprintf_r+0xf7c>
    ab04: e59d2044  ldr r2, [sp, #68] ; 0x44
    ab08: e0657002  rsb r7, r5, r2
    ab0c: e3570000  cmp r7, #0
    ab10: da000033  ble abe4 <_vfprintf_r+0xce4>
    ab14: e3570010  cmp r7, #16
    ab18: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ab1c: e51f47c4  ldr r4, [pc, #-1988]  ; a360 <_vfprintf_r+0x460>
    ab20: da00001f  ble aba4 <_vfprintf_r+0xca4>
    ab24: e58d5038  str r5, [sp, #56] ; 0x38
    ab28: e3a0a010  mov sl, #16
    ab2c: e1a05004  mov r5, r4
    ab30: e1a01003  mov r1, r3
    ab34: e59d4028  ldr r4, [sp, #40] ; 0x28
    ab38: ea000002  b ab48 <_vfprintf_r+0xc48>
    ab3c: e2477010  sub r7, r7, #16
    ab40: e3570010  cmp r7, #16
    ab44: da000013  ble ab98 <_vfprintf_r+0xc98>
    ab48: e2822001  add r2, r2, #1
    ab4c: e2811010  add r1, r1, #16
    ab50: e3520007  cmp r2, #7
    ab54: e8890420  stm r9, {r5, sl}
    ab58: e58d2098  str r2, [sp, #152]  ; 0x98
    ab5c: d2899008  addle r9, r9, #8
    ab60: e58d109c  str r1, [sp, #156]  ; 0x9c
    ab64: dafffff4  ble ab3c <_vfprintf_r+0xc3c>
    ab68: e1a00004  mov r0, r4
    ab6c: e1a0100b  mov r1, fp
    ab70: e28d2094  add r2, sp, #148  ; 0x94
    ab74: e1a09008  mov r9, r8
    ab78: eb001471  bl  fd44 <__sprint_r>
    ab7c: e3500000  cmp r0, #0
    ab80: 1afffdb1  bne a24c <_vfprintf_r+0x34c>
    ab84: e2477010  sub r7, r7, #16
    ab88: e59d109c  ldr r1, [sp, #156]  ; 0x9c
    ab8c: e3570010  cmp r7, #16
    ab90: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ab94: caffffeb  bgt ab48 <_vfprintf_r+0xc48>
    ab98: e1a04005  mov r4, r5
    ab9c: e59d5038  ldr r5, [sp, #56] ; 0x38
    aba0: e1a03001  mov r3, r1
    aba4: e2822001  add r2, r2, #1
    aba8: e0833007  add r3, r3, r7
    abac: e3520007  cmp r2, #7
    abb0: e8890090  stm r9, {r4, r7}
    abb4: e58d2098  str r2, [sp, #152]  ; 0x98
    abb8: d2899008  addle r9, r9, #8
    abbc: e58d309c  str r3, [sp, #156]  ; 0x9c
    abc0: da000007  ble abe4 <_vfprintf_r+0xce4>
    abc4: e59d0028  ldr r0, [sp, #40] ; 0x28
    abc8: e1a0100b  mov r1, fp
    abcc: e28d2094  add r2, sp, #148  ; 0x94
    abd0: eb00145b  bl  fd44 <__sprint_r>
    abd4: e3500000  cmp r0, #0
    abd8: 1afffd9b  bne a24c <_vfprintf_r+0x34c>
    abdc: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    abe0: e1a09008  mov r9, r8
    abe4: e59d201c  ldr r2, [sp, #28]
    abe8: e3120c01  tst r2, #256  ; 0x100
    abec: 1a00004f  bne ad30 <_vfprintf_r+0xe30>
    abf0: e59d2098  ldr r2, [sp, #152]  ; 0x98
    abf4: e0833005  add r3, r3, r5
    abf8: e59d1040  ldr r1, [sp, #64] ; 0x40
    abfc: e2822001  add r2, r2, #1
    ac00: e58d309c  str r3, [sp, #156]  ; 0x9c
    ac04: e3520007  cmp r2, #7
    ac08: e5895004  str r5, [r9, #4]
    ac0c: e5891000  str r1, [r9]
    ac10: e58d2098  str r2, [sp, #152]  ; 0x98
    ac14: ca000105  bgt b030 <_vfprintf_r+0x1130>
    ac18: e2899008  add r9, r9, #8
    ac1c: e59d201c  ldr r2, [sp, #28]
    ac20: e3120004  tst r2, #4
    ac24: 0a000034  beq acfc <_vfprintf_r+0xdfc>
    ac28: e59d2030  ldr r2, [sp, #48] ; 0x30
    ac2c: e59d1020  ldr r1, [sp, #32]
    ac30: e0614002  rsb r4, r1, r2
    ac34: e3540000  cmp r4, #0
    ac38: da00002f  ble acfc <_vfprintf_r+0xdfc>
    ac3c: e3540010  cmp r4, #16
    ac40: da0003a4  ble bad8 <_vfprintf_r+0x1bd8>
    ac44: e308a580  movw  sl, #34176  ; 0x8580
    ac48: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ac4c: e340a001  movt  sl, #1
    ac50: e3a05010  mov r5, #16
    ac54: e59d6028  ldr r6, [sp, #40] ; 0x28
    ac58: e59d7050  ldr r7, [sp, #80] ; 0x50
    ac5c: ea000002  b ac6c <_vfprintf_r+0xd6c>
    ac60: e2444010  sub r4, r4, #16
    ac64: e3540010  cmp r4, #16
    ac68: da000014  ble acc0 <_vfprintf_r+0xdc0>
    ac6c: e2822001  add r2, r2, #1
    ac70: e2833010  add r3, r3, #16
    ac74: e3520007  cmp r2, #7
    ac78: e5897000  str r7, [r9]
    ac7c: e5895004  str r5, [r9, #4]
    ac80: d2899008  addle r9, r9, #8
    ac84: e58d2098  str r2, [sp, #152]  ; 0x98
    ac88: e58d309c  str r3, [sp, #156]  ; 0x9c
    ac8c: dafffff3  ble ac60 <_vfprintf_r+0xd60>
    ac90: e1a00006  mov r0, r6
    ac94: e1a0100b  mov r1, fp
    ac98: e28d2094  add r2, sp, #148  ; 0x94
    ac9c: e1a09008  mov r9, r8
    aca0: eb001427  bl  fd44 <__sprint_r>
    aca4: e3500000  cmp r0, #0
    aca8: 1afffd67  bne a24c <_vfprintf_r+0x34c>
    acac: e2444010  sub r4, r4, #16
    acb0: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    acb4: e3540010  cmp r4, #16
    acb8: e59d2098  ldr r2, [sp, #152]  ; 0x98
    acbc: caffffea  bgt ac6c <_vfprintf_r+0xd6c>
    acc0: e2822001  add r2, r2, #1
    acc4: e0833004  add r3, r3, r4
    acc8: e3520007  cmp r2, #7
    accc: e58d2098  str r2, [sp, #152]  ; 0x98
    acd0: e58d309c  str r3, [sp, #156]  ; 0x9c
    acd4: e589a000  str sl, [r9]
    acd8: e5894004  str r4, [r9, #4]
    acdc: da000006  ble acfc <_vfprintf_r+0xdfc>
    ace0: e59d0028  ldr r0, [sp, #40] ; 0x28
    ace4: e1a0100b  mov r1, fp
    ace8: e28d2094  add r2, sp, #148  ; 0x94
    acec: eb001414  bl  fd44 <__sprint_r>
    acf0: e3500000  cmp r0, #0
    acf4: 1afffd54  bne a24c <_vfprintf_r+0x34c>
    acf8: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    acfc: e59d202c  ldr r2, [sp, #44] ; 0x2c
    ad00: e59d1020  ldr r1, [sp, #32]
    ad04: e59d0030  ldr r0, [sp, #48] ; 0x30
    ad08: e1510000  cmp r1, r0
    ad0c: a0822001  addge r2, r2, r1
    ad10: b0822000  addlt r2, r2, r0
    ad14: e3530000  cmp r3, #0
    ad18: e58d202c  str r2, [sp, #44] ; 0x2c
    ad1c: 1a0000cc  bne b054 <_vfprintf_r+0x1154>
    ad20: e3a03000  mov r3, #0
    ad24: e1a09008  mov r9, r8
    ad28: e58d3098  str r3, [sp, #152]  ; 0x98
    ad2c: eafffcaa  b 9fdc <_vfprintf_r+0xdc>
    ad30: e3560065  cmp r6, #101  ; 0x65
    ad34: da00008a  ble af64 <_vfprintf_r+0x1064>
    ad38: eeb58b40  vcmp.f64  d8, #0.0
    ad3c: eef1fa10  vmrs  APSR_nzcv, fpscr
    ad40: 1a0000de  bne b0c0 <_vfprintf_r+0x11c0>
    ad44: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ad48: e3081768  movw  r1, #34664  ; 0x8768
    ad4c: e2833001  add r3, r3, #1
    ad50: e3401001  movt  r1, #1
    ad54: e2822001  add r2, r2, #1
    ad58: e5891000  str r1, [r9]
    ad5c: e3520007  cmp r2, #7
    ad60: e58d2098  str r2, [sp, #152]  ; 0x98
    ad64: e58d309c  str r3, [sp, #156]  ; 0x9c
    ad68: e3a02001  mov r2, #1
    ad6c: e5892004  str r2, [r9, #4]
    ad70: d2899008  addle r9, r9, #8
    ad74: ca000284  bgt b78c <_vfprintf_r+0x188c>
    ad78: e59d207c  ldr r2, [sp, #124]  ; 0x7c
    ad7c: e59d104c  ldr r1, [sp, #76] ; 0x4c
    ad80: e1520001  cmp r2, r1
    ad84: ba000002  blt ad94 <_vfprintf_r+0xe94>
    ad88: e59d201c  ldr r2, [sp, #28]
    ad8c: e3120001  tst r2, #1
    ad90: 0affffa1  beq ac1c <_vfprintf_r+0xd1c>
    ad94: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ad98: e59d1058  ldr r1, [sp, #88] ; 0x58
    ad9c: e2822001  add r2, r2, #1
    ada0: e59d0054  ldr r0, [sp, #84] ; 0x54
    ada4: e3520007  cmp r2, #7
    ada8: e0833001  add r3, r3, r1
    adac: e5891004  str r1, [r9, #4]
    adb0: e5890000  str r0, [r9]
    adb4: d2899008  addle r9, r9, #8
    adb8: e58d309c  str r3, [sp, #156]  ; 0x9c
    adbc: e58d2098  str r2, [sp, #152]  ; 0x98
    adc0: ca0002df  bgt b944 <_vfprintf_r+0x1a44>
    adc4: e59d204c  ldr r2, [sp, #76] ; 0x4c
    adc8: e2425001  sub r5, r2, #1
    adcc: e3550000  cmp r5, #0
    add0: daffff91  ble ac1c <_vfprintf_r+0xd1c>
    add4: e3550010  cmp r5, #16
    add8: e59d2098  ldr r2, [sp, #152]  ; 0x98
    addc: e51f4a84  ldr r4, [pc, #-2692]  ; a360 <_vfprintf_r+0x460>
    ade0: c3a06010  movgt r6, #16
    ade4: c59d7028  ldrgt r7, [sp, #40] ; 0x28
    ade8: ca000003  bgt adfc <_vfprintf_r+0xefc>
    adec: ea000113  b b240 <_vfprintf_r+0x1340>
    adf0: e2455010  sub r5, r5, #16
    adf4: e3550010  cmp r5, #16
    adf8: da000110  ble b240 <_vfprintf_r+0x1340>
    adfc: e2822001  add r2, r2, #1
    ae00: e2833010  add r3, r3, #16
    ae04: e3520007  cmp r2, #7
    ae08: e8890050  stm r9, {r4, r6}
    ae0c: e58d2098  str r2, [sp, #152]  ; 0x98
    ae10: d2899008  addle r9, r9, #8
    ae14: e58d309c  str r3, [sp, #156]  ; 0x9c
    ae18: dafffff4  ble adf0 <_vfprintf_r+0xef0>
    ae1c: e1a00007  mov r0, r7
    ae20: e1a0100b  mov r1, fp
    ae24: e28d2094  add r2, sp, #148  ; 0x94
    ae28: e1a09008  mov r9, r8
    ae2c: eb0013c4  bl  fd44 <__sprint_r>
    ae30: e3500000  cmp r0, #0
    ae34: 1afffd04  bne a24c <_vfprintf_r+0x34c>
    ae38: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    ae3c: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ae40: eaffffea  b adf0 <_vfprintf_r+0xef0>
    ae44: e3520000  cmp r2, #0
    ae48: 158d8040  strne r8, [sp, #64] ; 0x40
    ae4c: 11a05003  movne r5, r3
    ae50: 1afffd5a  bne a3c0 <_vfprintf_r+0x4c0>
    ae54: e59d301c  ldr r3, [sp, #28]
    ae58: e3130001  tst r3, #1
    ae5c: 058d8040  streq r8, [sp, #64] ; 0x40
    ae60: 128d2f42  addne r2, sp, #264  ; 0x108
    ae64: 13a03030  movne r3, #48 ; 0x30
    ae68: 01a05002  moveq r5, r2
    ae6c: 15623041  strbne  r3, [r2, #-65]! ; 0xffffffbf
    ae70: 10625008  rsbne r5, r2, r8
    ae74: 158d2040  strne r2, [sp, #64] ; 0x40
    ae78: eafffd50  b a3c0 <_vfprintf_r+0x4c0>
    ae7c: e59d2030  ldr r2, [sp, #48] ; 0x30
    ae80: e59d1020  ldr r1, [sp, #32]
    ae84: e0617002  rsb r7, r1, r2
    ae88: e3570000  cmp r7, #0
    ae8c: daffff1c  ble ab04 <_vfprintf_r+0xc04>
    ae90: e3570010  cmp r7, #16
    ae94: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ae98: e51f4b40  ldr r4, [pc, #-2880]  ; a360 <_vfprintf_r+0x460>
    ae9c: da00001f  ble af20 <_vfprintf_r+0x1020>
    aea0: e58d5038  str r5, [sp, #56] ; 0x38
    aea4: e3a0a010  mov sl, #16
    aea8: e1a05004  mov r5, r4
    aeac: e1a01003  mov r1, r3
    aeb0: e59d4028  ldr r4, [sp, #40] ; 0x28
    aeb4: ea000002  b aec4 <_vfprintf_r+0xfc4>
    aeb8: e2477010  sub r7, r7, #16
    aebc: e3570010  cmp r7, #16
    aec0: da000013  ble af14 <_vfprintf_r+0x1014>
    aec4: e2822001  add r2, r2, #1
    aec8: e2811010  add r1, r1, #16
    aecc: e3520007  cmp r2, #7
    aed0: e8890420  stm r9, {r5, sl}
    aed4: e58d2098  str r2, [sp, #152]  ; 0x98
    aed8: d2899008  addle r9, r9, #8
    aedc: e58d109c  str r1, [sp, #156]  ; 0x9c
    aee0: dafffff4  ble aeb8 <_vfprintf_r+0xfb8>
    aee4: e1a00004  mov r0, r4
    aee8: e1a0100b  mov r1, fp
    aeec: e28d2094  add r2, sp, #148  ; 0x94
    aef0: e1a09008  mov r9, r8
    aef4: eb001392  bl  fd44 <__sprint_r>
    aef8: e3500000  cmp r0, #0
    aefc: 1afffcd2  bne a24c <_vfprintf_r+0x34c>
    af00: e2477010  sub r7, r7, #16
    af04: e59d109c  ldr r1, [sp, #156]  ; 0x9c
    af08: e3570010  cmp r7, #16
    af0c: e59d2098  ldr r2, [sp, #152]  ; 0x98
    af10: caffffeb  bgt aec4 <_vfprintf_r+0xfc4>
    af14: e1a04005  mov r4, r5
    af18: e59d5038  ldr r5, [sp, #56] ; 0x38
    af1c: e1a03001  mov r3, r1
    af20: e2822001  add r2, r2, #1
    af24: e0833007  add r3, r3, r7
    af28: e3520007  cmp r2, #7
    af2c: e8890090  stm r9, {r4, r7}
    af30: e58d2098  str r2, [sp, #152]  ; 0x98
    af34: d2899008  addle r9, r9, #8
    af38: e58d309c  str r3, [sp, #156]  ; 0x9c
    af3c: dafffef0  ble ab04 <_vfprintf_r+0xc04>
    af40: e59d0028  ldr r0, [sp, #40] ; 0x28
    af44: e1a0100b  mov r1, fp
    af48: e28d2094  add r2, sp, #148  ; 0x94
    af4c: eb00137c  bl  fd44 <__sprint_r>
    af50: e3500000  cmp r0, #0
    af54: 1afffcbc  bne a24c <_vfprintf_r+0x34c>
    af58: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    af5c: e1a09008  mov r9, r8
    af60: eafffee7  b ab04 <_vfprintf_r+0xc04>
    af64: e59d204c  ldr r2, [sp, #76] ; 0x4c
    af68: e3520001  cmp r2, #1
    af6c: da00011d  ble b3e8 <_vfprintf_r+0x14e8>
    af70: e59d1040  ldr r1, [sp, #64] ; 0x40
    af74: e2833001  add r3, r3, #1
    af78: e59d2098  ldr r2, [sp, #152]  ; 0x98
    af7c: e58d309c  str r3, [sp, #156]  ; 0x9c
    af80: e5891000  str r1, [r9]
    af84: e3a01001  mov r1, #1
    af88: e0822001  add r2, r2, r1
    af8c: e58d2098  str r2, [sp, #152]  ; 0x98
    af90: e3520007  cmp r2, #7
    af94: e5891004  str r1, [r9, #4]
    af98: d2899008  addle r9, r9, #8
    af9c: ca000129  bgt b448 <_vfprintf_r+0x1548>
    afa0: e2822001  add r2, r2, #1
    afa4: e59d1058  ldr r1, [sp, #88] ; 0x58
    afa8: e59d0054  ldr r0, [sp, #84] ; 0x54
    afac: e3520007  cmp r2, #7
    afb0: e0833001  add r3, r3, r1
    afb4: e58d2098  str r2, [sp, #152]  ; 0x98
    afb8: e58d309c  str r3, [sp, #156]  ; 0x9c
    afbc: e8890003  stm r9, {r0, r1}
    afc0: d2899008  addle r9, r9, #8
    afc4: ca000129  bgt b470 <_vfprintf_r+0x1570>
    afc8: eeb58b40  vcmp.f64  d8, #0.0
    afcc: eef1fa10  vmrs  APSR_nzcv, fpscr
    afd0: 0a00007b  beq b1c4 <_vfprintf_r+0x12c4>
    afd4: e59d1040  ldr r1, [sp, #64] ; 0x40
    afd8: e2822001  add r2, r2, #1
    afdc: e3520007  cmp r2, #7
    afe0: e58d2098  str r2, [sp, #152]  ; 0x98
    afe4: e2810001  add r0, r1, #1
    afe8: e59d104c  ldr r1, [sp, #76] ; 0x4c
    afec: e5890000  str r0, [r9]
    aff0: e2411001  sub r1, r1, #1
    aff4: e0833001  add r3, r3, r1
    aff8: e58d309c  str r3, [sp, #156]  ; 0x9c
    affc: e5891004  str r1, [r9, #4]
    b000: ca000106  bgt b420 <_vfprintf_r+0x1520>
    b004: e2899008  add r9, r9, #8
    b008: e2822001  add r2, r2, #1
    b00c: e59d1068  ldr r1, [sp, #104]  ; 0x68
    b010: e3520007  cmp r2, #7
    b014: e58d2098  str r2, [sp, #152]  ; 0x98
    b018: e0833001  add r3, r3, r1
    b01c: e28d2084  add r2, sp, #132  ; 0x84
    b020: e58d309c  str r3, [sp, #156]  ; 0x9c
    b024: e5891004  str r1, [r9, #4]
    b028: e5892000  str r2, [r9]
    b02c: dafffef9  ble ac18 <_vfprintf_r+0xd18>
    b030: e59d0028  ldr r0, [sp, #40] ; 0x28
    b034: e1a0100b  mov r1, fp
    b038: e28d2094  add r2, sp, #148  ; 0x94
    b03c: eb001340  bl  fd44 <__sprint_r>
    b040: e3500000  cmp r0, #0
    b044: 1afffc80  bne a24c <_vfprintf_r+0x34c>
    b048: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b04c: e1a09008  mov r9, r8
    b050: eafffef1  b ac1c <_vfprintf_r+0xd1c>
    b054: e59d0028  ldr r0, [sp, #40] ; 0x28
    b058: e1a0100b  mov r1, fp
    b05c: e28d2094  add r2, sp, #148  ; 0x94
    b060: eb001337  bl  fd44 <__sprint_r>
    b064: e3500000  cmp r0, #0
    b068: 0affff2c  beq ad20 <_vfprintf_r+0xe20>
    b06c: eafffc76  b a24c <_vfprintf_r+0x34c>
    b070: e59d0028  ldr r0, [sp, #40] ; 0x28
    b074: e1a0100b  mov r1, fp
    b078: e28d2094  add r2, sp, #148  ; 0x94
    b07c: eb001330  bl  fd44 <__sprint_r>
    b080: e3500000  cmp r0, #0
    b084: 1afffc70  bne a24c <_vfprintf_r+0x34c>
    b088: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b08c: e1a09008  mov r9, r8
    b090: eafffe89  b aabc <_vfprintf_r+0xbbc>
    b094: e59d0028  ldr r0, [sp, #40] ; 0x28
    b098: e1a0100b  mov r1, fp
    b09c: e28d2094  add r2, sp, #148  ; 0x94
    b0a0: eb001327  bl  fd44 <__sprint_r>
    b0a4: e3500000  cmp r0, #0
    b0a8: 1afffc67  bne a24c <_vfprintf_r+0x34c>
    b0ac: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b0b0: e1a09008  mov r9, r8
    b0b4: eafffe8f  b aaf8 <_vfprintf_r+0xbf8>
    b0b8: e3a02002  mov r2, #2
    b0bc: eafffc84  b a2d4 <_vfprintf_r+0x3d4>
    b0c0: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    b0c4: e3550000  cmp r5, #0
    b0c8: da0001b8  ble b7b0 <_vfprintf_r+0x18b0>
    b0cc: e59d204c  ldr r2, [sp, #76] ; 0x4c
    b0d0: e59d1048  ldr r1, [sp, #72] ; 0x48
    b0d4: e59d0040  ldr r0, [sp, #64] ; 0x40
    b0d8: e1520001  cmp r2, r1
    b0dc: e0807002  add r7, r0, r2
    b0e0: b1a05002  movlt r5, r2
    b0e4: a1a05001  movge r5, r1
    b0e8: e3550000  cmp r5, #0
    b0ec: da000009  ble b118 <_vfprintf_r+0x1218>
    b0f0: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b0f4: e0833005  add r3, r3, r5
    b0f8: e5890000  str r0, [r9]
    b0fc: e2822001  add r2, r2, #1
    b100: e5895004  str r5, [r9, #4]
    b104: e3520007  cmp r2, #7
    b108: e58d309c  str r3, [sp, #156]  ; 0x9c
    b10c: e58d2098  str r2, [sp, #152]  ; 0x98
    b110: d2899008  addle r9, r9, #8
    b114: ca00025a  bgt ba84 <_vfprintf_r+0x1b84>
    b118: e59d2048  ldr r2, [sp, #72] ; 0x48
    b11c: e3550000  cmp r5, #0
    b120: a0652002  rsbge r2, r5, r2
    b124: e3520000  cmp r2, #0
    b128: e1a05002  mov r5, r2
    b12c: da00005b  ble b2a0 <_vfprintf_r+0x13a0>
    b130: e3550010  cmp r5, #16
    b134: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b138: e51f4de0  ldr r4, [pc, #-3552]  ; a360 <_vfprintf_r+0x460>
    b13c: c3a06010  movgt r6, #16
    b140: c59da028  ldrgt sl, [sp, #40] ; 0x28
    b144: ca000003  bgt b158 <_vfprintf_r+0x1258>
    b148: ea000044  b b260 <_vfprintf_r+0x1360>
    b14c: e2455010  sub r5, r5, #16
    b150: e3550010  cmp r5, #16
    b154: da000041  ble b260 <_vfprintf_r+0x1360>
    b158: e2822001  add r2, r2, #1
    b15c: e2833010  add r3, r3, #16
    b160: e3520007  cmp r2, #7
    b164: e8890050  stm r9, {r4, r6}
    b168: e58d2098  str r2, [sp, #152]  ; 0x98
    b16c: d2899008  addle r9, r9, #8
    b170: e58d309c  str r3, [sp, #156]  ; 0x9c
    b174: dafffff4  ble b14c <_vfprintf_r+0x124c>
    b178: e1a0000a  mov r0, sl
    b17c: e1a0100b  mov r1, fp
    b180: e28d2094  add r2, sp, #148  ; 0x94
    b184: e1a09008  mov r9, r8
    b188: eb0012ed  bl  fd44 <__sprint_r>
    b18c: e3500000  cmp r0, #0
    b190: 1afffc2d  bne a24c <_vfprintf_r+0x34c>
    b194: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b198: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b19c: eaffffea  b b14c <_vfprintf_r+0x124c>
    b1a0: e3550000  cmp r5, #0
    b1a4: 03540009  cmpeq r4, #9
    b1a8: 8a0000c2  bhi b4b8 <_vfprintf_r+0x15b8>
    b1ac: e28d3f42  add r3, sp, #264  ; 0x108
    b1b0: e2844030  add r4, r4, #48 ; 0x30
    b1b4: e5634041  strb  r4, [r3, #-65]! ; 0xffffffbf
    b1b8: e0635008  rsb r5, r3, r8
    b1bc: e58d3040  str r3, [sp, #64] ; 0x40
    b1c0: eafffc7e  b a3c0 <_vfprintf_r+0x4c0>
    b1c4: e59d104c  ldr r1, [sp, #76] ; 0x4c
    b1c8: e2415001  sub r5, r1, #1
    b1cc: e3550000  cmp r5, #0
    b1d0: daffff8c  ble b008 <_vfprintf_r+0x1108>
    b1d4: e3550010  cmp r5, #16
    b1d8: e51f4e80  ldr r4, [pc, #-3712]  ; a360 <_vfprintf_r+0x460>
    b1dc: c3a06010  movgt r6, #16
    b1e0: c59d7028  ldrgt r7, [sp, #40] ; 0x28
    b1e4: ca000003  bgt b1f8 <_vfprintf_r+0x12f8>
    b1e8: ea0000aa  b b498 <_vfprintf_r+0x1598>
    b1ec: e2455010  sub r5, r5, #16
    b1f0: e3550010  cmp r5, #16
    b1f4: da0000a7  ble b498 <_vfprintf_r+0x1598>
    b1f8: e2822001  add r2, r2, #1
    b1fc: e2833010  add r3, r3, #16
    b200: e3520007  cmp r2, #7
    b204: e8890050  stm r9, {r4, r6}
    b208: e58d2098  str r2, [sp, #152]  ; 0x98
    b20c: d2899008  addle r9, r9, #8
    b210: e58d309c  str r3, [sp, #156]  ; 0x9c
    b214: dafffff4  ble b1ec <_vfprintf_r+0x12ec>
    b218: e1a00007  mov r0, r7
    b21c: e1a0100b  mov r1, fp
    b220: e28d2094  add r2, sp, #148  ; 0x94
    b224: e1a09008  mov r9, r8
    b228: eb0012c5  bl  fd44 <__sprint_r>
    b22c: e3500000  cmp r0, #0
    b230: 1afffc05  bne a24c <_vfprintf_r+0x34c>
    b234: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b238: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b23c: eaffffea  b b1ec <_vfprintf_r+0x12ec>
    b240: e2822001  add r2, r2, #1
    b244: e0833005  add r3, r3, r5
    b248: e3520007  cmp r2, #7
    b24c: e58d2098  str r2, [sp, #152]  ; 0x98
    b250: e58d309c  str r3, [sp, #156]  ; 0x9c
    b254: e8890030  stm r9, {r4, r5}
    b258: dafffe6e  ble ac18 <_vfprintf_r+0xd18>
    b25c: eaffff73  b b030 <_vfprintf_r+0x1130>
    b260: e2822001  add r2, r2, #1
    b264: e0833005  add r3, r3, r5
    b268: e3520007  cmp r2, #7
    b26c: e8890030  stm r9, {r4, r5}
    b270: e58d2098  str r2, [sp, #152]  ; 0x98
    b274: d2899008  addle r9, r9, #8
    b278: e58d309c  str r3, [sp, #156]  ; 0x9c
    b27c: da000007  ble b2a0 <_vfprintf_r+0x13a0>
    b280: e59d0028  ldr r0, [sp, #40] ; 0x28
    b284: e1a0100b  mov r1, fp
    b288: e28d2094  add r2, sp, #148  ; 0x94
    b28c: eb0012ac  bl  fd44 <__sprint_r>
    b290: e3500000  cmp r0, #0
    b294: 1afffbec  bne a24c <_vfprintf_r+0x34c>
    b298: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b29c: e1a09008  mov r9, r8
    b2a0: e59d2040  ldr r2, [sp, #64] ; 0x40
    b2a4: e59d1048  ldr r1, [sp, #72] ; 0x48
    b2a8: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    b2ac: e0826001  add r6, r2, r1
    b2b0: e59d204c  ldr r2, [sp, #76] ; 0x4c
    b2b4: e1550002  cmp r5, r2
    b2b8: ba000034  blt b390 <_vfprintf_r+0x1490>
    b2bc: e59d201c  ldr r2, [sp, #28]
    b2c0: e3120001  tst r2, #1
    b2c4: 1a000031  bne b390 <_vfprintf_r+0x1490>
    b2c8: e59d204c  ldr r2, [sp, #76] ; 0x4c
    b2cc: e0667007  rsb r7, r6, r7
    b2d0: e0655002  rsb r5, r5, r2
    b2d4: e1550007  cmp r5, r7
    b2d8: b1a04005  movlt r4, r5
    b2dc: a1a04007  movge r4, r7
    b2e0: e3540000  cmp r4, #0
    b2e4: da000009  ble b310 <_vfprintf_r+0x1410>
    b2e8: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b2ec: e0833004  add r3, r3, r4
    b2f0: e5896000  str r6, [r9]
    b2f4: e2822001  add r2, r2, #1
    b2f8: e5894004  str r4, [r9, #4]
    b2fc: e3520007  cmp r2, #7
    b300: e58d309c  str r3, [sp, #156]  ; 0x9c
    b304: e58d2098  str r2, [sp, #152]  ; 0x98
    b308: d2899008  addle r9, r9, #8
    b30c: ca0001e5  bgt baa8 <_vfprintf_r+0x1ba8>
    b310: e3540000  cmp r4, #0
    b314: a0645005  rsbge r5, r4, r5
    b318: e3550000  cmp r5, #0
    b31c: dafffe3e  ble ac1c <_vfprintf_r+0xd1c>
    b320: e3550010  cmp r5, #16
    b324: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b328: e51f4fd0  ldr r4, [pc, #-4048]  ; a360 <_vfprintf_r+0x460>
    b32c: c3a06010  movgt r6, #16
    b330: c59d7028  ldrgt r7, [sp, #40] ; 0x28
    b334: ca000003  bgt b348 <_vfprintf_r+0x1448>
    b338: eaffffc0  b b240 <_vfprintf_r+0x1340>
    b33c: e2455010  sub r5, r5, #16
    b340: e3550010  cmp r5, #16
    b344: daffffbd  ble b240 <_vfprintf_r+0x1340>
    b348: e2822001  add r2, r2, #1
    b34c: e2833010  add r3, r3, #16
    b350: e3520007  cmp r2, #7
    b354: e8890050  stm r9, {r4, r6}
    b358: e58d2098  str r2, [sp, #152]  ; 0x98
    b35c: d2899008  addle r9, r9, #8
    b360: e58d309c  str r3, [sp, #156]  ; 0x9c
    b364: dafffff4  ble b33c <_vfprintf_r+0x143c>
    b368: e1a00007  mov r0, r7
    b36c: e1a0100b  mov r1, fp
    b370: e28d2094  add r2, sp, #148  ; 0x94
    b374: e1a09008  mov r9, r8
    b378: eb001271  bl  fd44 <__sprint_r>
    b37c: e3500000  cmp r0, #0
    b380: 1afffbb1  bne a24c <_vfprintf_r+0x34c>
    b384: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b388: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b38c: eaffffea  b b33c <_vfprintf_r+0x143c>
    b390: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b394: e59d1058  ldr r1, [sp, #88] ; 0x58
    b398: e2822001  add r2, r2, #1
    b39c: e59d0054  ldr r0, [sp, #84] ; 0x54
    b3a0: e3520007  cmp r2, #7
    b3a4: e0833001  add r3, r3, r1
    b3a8: e5891004  str r1, [r9, #4]
    b3ac: e5890000  str r0, [r9]
    b3b0: d2899008  addle r9, r9, #8
    b3b4: e58d309c  str r3, [sp, #156]  ; 0x9c
    b3b8: e58d2098  str r2, [sp, #152]  ; 0x98
    b3bc: daffffc1  ble b2c8 <_vfprintf_r+0x13c8>
    b3c0: e59d0028  ldr r0, [sp, #40] ; 0x28
    b3c4: e1a0100b  mov r1, fp
    b3c8: e28d2094  add r2, sp, #148  ; 0x94
    b3cc: eb00125c  bl  fd44 <__sprint_r>
    b3d0: e3500000  cmp r0, #0
    b3d4: 1afffb9c  bne a24c <_vfprintf_r+0x34c>
    b3d8: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    b3dc: e1a09008  mov r9, r8
    b3e0: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b3e4: eaffffb7  b b2c8 <_vfprintf_r+0x13c8>
    b3e8: e59d201c  ldr r2, [sp, #28]
    b3ec: e3120001  tst r2, #1
    b3f0: 1afffede  bne af70 <_vfprintf_r+0x1070>
    b3f4: e59d1040  ldr r1, [sp, #64] ; 0x40
    b3f8: e2833001  add r3, r3, #1
    b3fc: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b400: e58d309c  str r3, [sp, #156]  ; 0x9c
    b404: e5891000  str r1, [r9]
    b408: e3a01001  mov r1, #1
    b40c: e0822001  add r2, r2, r1
    b410: e58d2098  str r2, [sp, #152]  ; 0x98
    b414: e3520007  cmp r2, #7
    b418: e5891004  str r1, [r9, #4]
    b41c: dafffef8  ble b004 <_vfprintf_r+0x1104>
    b420: e59d0028  ldr r0, [sp, #40] ; 0x28
    b424: e1a0100b  mov r1, fp
    b428: e28d2094  add r2, sp, #148  ; 0x94
    b42c: eb001244  bl  fd44 <__sprint_r>
    b430: e3500000  cmp r0, #0
    b434: 1afffb84  bne a24c <_vfprintf_r+0x34c>
    b438: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b43c: e1a09008  mov r9, r8
    b440: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b444: eafffeef  b b008 <_vfprintf_r+0x1108>
    b448: e59d0028  ldr r0, [sp, #40] ; 0x28
    b44c: e1a0100b  mov r1, fp
    b450: e28d2094  add r2, sp, #148  ; 0x94
    b454: eb00123a  bl  fd44 <__sprint_r>
    b458: e3500000  cmp r0, #0
    b45c: 1afffb7a  bne a24c <_vfprintf_r+0x34c>
    b460: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b464: e1a09008  mov r9, r8
    b468: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b46c: eafffecb  b afa0 <_vfprintf_r+0x10a0>
    b470: e59d0028  ldr r0, [sp, #40] ; 0x28
    b474: e1a0100b  mov r1, fp
    b478: e28d2094  add r2, sp, #148  ; 0x94
    b47c: eb001230  bl  fd44 <__sprint_r>
    b480: e3500000  cmp r0, #0
    b484: 1afffb70  bne a24c <_vfprintf_r+0x34c>
    b488: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b48c: e1a09008  mov r9, r8
    b490: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b494: eafffecb  b afc8 <_vfprintf_r+0x10c8>
    b498: e2822001  add r2, r2, #1
    b49c: e0833005  add r3, r3, r5
    b4a0: e3520007  cmp r2, #7
    b4a4: e58d2098  str r2, [sp, #152]  ; 0x98
    b4a8: e58d309c  str r3, [sp, #156]  ; 0x9c
    b4ac: e8890030  stm r9, {r4, r5}
    b4b0: dafffed3  ble b004 <_vfprintf_r+0x1104>
    b4b4: eaffffd9  b b420 <_vfprintf_r+0x1520>
    b4b8: e58d6020  str r6, [sp, #32]
    b4bc: e1a06008  mov r6, r8
    b4c0: e1a00004  mov r0, r4
    b4c4: e1a01005  mov r1, r5
    b4c8: e3a0200a  mov r2, #10
    b4cc: e3a03000  mov r3, #0
    b4d0: eb001d05  bl  128ec <__aeabi_uldivmod>
    b4d4: e1a00004  mov r0, r4
    b4d8: e1a01005  mov r1, r5
    b4dc: e3a03000  mov r3, #0
    b4e0: e2822030  add r2, r2, #48 ; 0x30
    b4e4: e5662001  strb  r2, [r6, #-1]!
    b4e8: e3a0200a  mov r2, #10
    b4ec: eb001cfe  bl  128ec <__aeabi_uldivmod>
    b4f0: e1a04000  mov r4, r0
    b4f4: e1a05001  mov r5, r1
    b4f8: e1943005  orrs  r3, r4, r5
    b4fc: 1affffef  bne b4c0 <_vfprintf_r+0x15c0>
    b500: e1a03006  mov r3, r6
    b504: e59d6020  ldr r6, [sp, #32]
    b508: e58d3040  str r3, [sp, #64] ; 0x40
    b50c: e0635008  rsb r5, r3, r8
    b510: eafffbaa  b a3c0 <_vfprintf_r+0x4c0>
    b514: e2744000  rsbs  r4, r4, #0
    b518: e3a0a02d  mov sl, #45 ; 0x2d
    b51c: e2e55000  rsc r5, r5, #0
    b520: e5cda077  strb  sl, [sp, #119]  ; 0x77
    b524: e58d7044  str r7, [sp, #68] ; 0x44
    b528: e3a02001  mov r2, #1
    b52c: eafffb6c  b a2e4 <_vfprintf_r+0x3e4>
    b530: ec510b18  vmov  r0, r1, d8
    b534: eb0010c1  bl  f840 <__fpclassifyd>
    b538: e3500000  cmp r0, #0
    b53c: 0a0000db  beq b8b0 <_vfprintf_r+0x19b0>
    b540: e3770001  cmn r7, #1
    b544: e3c65020  bic r5, r6, #32
    b548: 03a07006  moveq r7, #6
    b54c: 0a000105  beq b968 <_vfprintf_r+0x1a68>
    b550: e3550047  cmp r5, #71 ; 0x47
    b554: 03570000  cmpeq r7, #0
    b558: 1a000102  bne b968 <_vfprintf_r+0x1a68>
    b55c: ee183a90  vmov  r3, s17
    b560: e3a05047  mov r5, #71 ; 0x47
    b564: e3a07001  mov r7, #1
    b568: e3530000  cmp r3, #0
    b56c: e59d301c  ldr r3, [sp, #28]
    b570: e3833c01  orr r3, r3, #256  ; 0x100
    b574: e58d3038  str r3, [sp, #56] ; 0x38
    b578: ba0001df  blt bcfc <_vfprintf_r+0x1dfc>
    b57c: eeb09b48  vmov.f64  d9, d8
    b580: e3a0a000  mov sl, #0
    b584: e3a02002  mov r2, #2
    b588: e28d307c  add r3, sp, #124  ; 0x7c
    b58c: e58d2000  str r2, [sp]
    b590: e28d2080  add r2, sp, #128  ; 0x80
    b594: e58d3008  str r3, [sp, #8]
    b598: e28d308c  add r3, sp, #140  ; 0x8c
    b59c: e58d200c  str r2, [sp, #12]
    b5a0: e58d3010  str r3, [sp, #16]
    b5a4: e58d7004  str r7, [sp, #4]
    b5a8: e59d0028  ldr r0, [sp, #40] ; 0x28
    b5ac: ec532b19  vmov  r2, r3, d9
    b5b0: eb00035f  bl  c334 <_dtoa_r>
    b5b4: e3550047  cmp r5, #71 ; 0x47
    b5b8: e58d0040  str r0, [sp, #64] ; 0x40
    b5bc: 1a0001fe  bne bdbc <_vfprintf_r+0x1ebc>
    b5c0: e59d301c  ldr r3, [sp, #28]
    b5c4: e3130001  tst r3, #1
    b5c8: 0a0001d6  beq bd28 <_vfprintf_r+0x1e28>
    b5cc: e59d3040  ldr r3, [sp, #64] ; 0x40
    b5d0: e0834007  add r4, r3, r7
    b5d4: eeb59b40  vcmp.f64  d9, #0.0
    b5d8: eef1fa10  vmrs  APSR_nzcv, fpscr
    b5dc: 01a03004  moveq r3, r4
    b5e0: 0a000009  beq b60c <_vfprintf_r+0x170c>
    b5e4: e59d308c  ldr r3, [sp, #140]  ; 0x8c
    b5e8: e1540003  cmp r4, r3
    b5ec: 9a000006  bls b60c <_vfprintf_r+0x170c>
    b5f0: e3a01030  mov r1, #48 ; 0x30
    b5f4: e2832001  add r2, r3, #1
    b5f8: e58d208c  str r2, [sp, #140]  ; 0x8c
    b5fc: e5c31000  strb  r1, [r3]
    b600: e59d308c  ldr r3, [sp, #140]  ; 0x8c
    b604: e1540003  cmp r4, r3
    b608: 8afffff9  bhi b5f4 <_vfprintf_r+0x16f4>
    b60c: e59d2040  ldr r2, [sp, #64] ; 0x40
    b610: e3550047  cmp r5, #71 ; 0x47
    b614: e0623003  rsb r3, r2, r3
    b618: e58d304c  str r3, [sp, #76] ; 0x4c
    b61c: e59d307c  ldr r3, [sp, #124]  ; 0x7c
    b620: 1a000160  bne bba8 <_vfprintf_r+0x1ca8>
    b624: e3730003  cmn r3, #3
    b628: a1570003  cmpge r7, r3
    b62c: b2466002  sublt r6, r6, #2
    b630: ba000172  blt bc00 <_vfprintf_r+0x1d00>
    b634: e3a06067  mov r6, #103  ; 0x67
    b638: e58d3048  str r3, [sp, #72] ; 0x48
    b63c: e59d304c  ldr r3, [sp, #76] ; 0x4c
    b640: e59d2048  ldr r2, [sp, #72] ; 0x48
    b644: e1530002  cmp r3, r2
    b648: ca0001ae  bgt bd08 <_vfprintf_r+0x1e08>
    b64c: e59d301c  ldr r3, [sp, #28]
    b650: e3130001  tst r3, #1
    b654: 159d3048  ldrne r3, [sp, #72] ; 0x48
    b658: 01a05002  moveq r5, r2
    b65c: 01a03005  moveq r3, r5
    b660: 12835001  addne r5, r3, #1
    b664: 01c33fc3  biceq r3, r3, r3, asr #31
    b668: 11c53fc5  bicne r3, r5, r5, asr #31
    b66c: e35a0000  cmp sl, #0
    b670: 1a000144  bne bb88 <_vfprintf_r+0x1c88>
    b674: e58d3020  str r3, [sp, #32]
    b678: e59d3038  ldr r3, [sp, #56] ; 0x38
    b67c: e58da044  str sl, [sp, #68] ; 0x44
    b680: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    b684: e58d301c  str r3, [sp, #28]
    b688: eafffb52  b a3d8 <_vfprintf_r+0x4d8>
    b68c: e59d201c  ldr r2, [sp, #28]
    b690: e2122040  ands  r2, r2, #64 ; 0x40
    b694: 0a00007f  beq b898 <_vfprintf_r+0x1998>
    b698: e1a02003  mov r2, r3
    b69c: e59d3034  ldr r3, [sp, #52] ; 0x34
    b6a0: e3a05000  mov r5, #0
    b6a4: e2833004  add r3, r3, #4
    b6a8: e15340b4  ldrh  r4, [r3, #-4]
    b6ac: e58d3034  str r3, [sp, #52] ; 0x34
    b6b0: eafffb07  b a2d4 <_vfprintf_r+0x3d4>
    b6b4: e59d301c  ldr r3, [sp, #28]
    b6b8: e3130040  tst r3, #64 ; 0x40
    b6bc: e59d3034  ldr r3, [sp, #52] ; 0x34
    b6c0: 13a05000  movne r5, #0
    b6c4: 03a05000  moveq r5, #0
    b6c8: 05934000  ldreq r4, [r3]
    b6cc: 02833004  addeq r3, r3, #4
    b6d0: 11d340b0  ldrhne  r4, [r3]
    b6d4: 12833004  addne r3, r3, #4
    b6d8: 058d3034  streq r3, [sp, #52] ; 0x34
    b6dc: 158d3034  strne r3, [sp, #52] ; 0x34
    b6e0: eafffbbd  b a5dc <_vfprintf_r+0x6dc>
    b6e4: e59d301c  ldr r3, [sp, #28]
    b6e8: e3130040  tst r3, #64 ; 0x40
    b6ec: e59d3034  ldr r3, [sp, #52] ; 0x34
    b6f0: 0afffc4f  beq a834 <_vfprintf_r+0x934>
    b6f4: e1d340b0  ldrh  r4, [r3]
    b6f8: e2833004  add r3, r3, #4
    b6fc: e58d3034  str r3, [sp, #52] ; 0x34
    b700: e6bf4074  sxth  r4, r4
    b704: e1a05fc4  asr r5, r4, #31
    b708: e1a02004  mov r2, r4
    b70c: e1a03005  mov r3, r5
    b710: eafffc0f  b a754 <_vfprintf_r+0x854>
    b714: e59d301c  ldr r3, [sp, #28]
    b718: e3130010  tst r3, #16
    b71c: 1a000009  bne b748 <_vfprintf_r+0x1848>
    b720: e59d301c  ldr r3, [sp, #28]
    b724: e3130040  tst r3, #64 ; 0x40
    b728: 0a000006  beq b748 <_vfprintf_r+0x1848>
    b72c: e59d2034  ldr r2, [sp, #52] ; 0x34
    b730: e2822004  add r2, r2, #4
    b734: e5123004  ldr r3, [r2, #-4]
    b738: e58d2034  str r2, [sp, #52] ; 0x34
    b73c: e1dd22bc  ldrh  r2, [sp, #44] ; 0x2c
    b740: e1c320b0  strh  r2, [r3]
    b744: eafffa24  b 9fdc <_vfprintf_r+0xdc>
    b748: e59d2034  ldr r2, [sp, #52] ; 0x34
    b74c: e2822004  add r2, r2, #4
    b750: e5123004  ldr r3, [r2, #-4]
    b754: e58d2034  str r2, [sp, #52] ; 0x34
    b758: e59d202c  ldr r2, [sp, #44] ; 0x2c
    b75c: e5832000  str r2, [r3]
    b760: eafffa1d  b 9fdc <_vfprintf_r+0xdc>
    b764: e59d301c  ldr r3, [sp, #28]
    b768: e3130040  tst r3, #64 ; 0x40
    b76c: e59d3034  ldr r3, [sp, #52] ; 0x34
    b770: 0afffca4  beq aa08 <_vfprintf_r+0xb08>
    b774: e1d340b0  ldrh  r4, [r3]
    b778: e3a05000  mov r5, #0
    b77c: e2833004  add r3, r3, #4
    b780: e3a02001  mov r2, #1
    b784: e58d3034  str r3, [sp, #52] ; 0x34
    b788: eafffad1  b a2d4 <_vfprintf_r+0x3d4>
    b78c: e59d0028  ldr r0, [sp, #40] ; 0x28
    b790: e1a0100b  mov r1, fp
    b794: e28d2094  add r2, sp, #148  ; 0x94
    b798: eb001169  bl  fd44 <__sprint_r>
    b79c: e3500000  cmp r0, #0
    b7a0: 1afffaa9  bne a24c <_vfprintf_r+0x34c>
    b7a4: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b7a8: e1a09008  mov r9, r8
    b7ac: eafffd71  b ad78 <_vfprintf_r+0xe78>
    b7b0: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b7b4: e3081768  movw  r1, #34664  ; 0x8768
    b7b8: e2833001  add r3, r3, #1
    b7bc: e3401001  movt  r1, #1
    b7c0: e2822001  add r2, r2, #1
    b7c4: e5891000  str r1, [r9]
    b7c8: e3520007  cmp r2, #7
    b7cc: e58d2098  str r2, [sp, #152]  ; 0x98
    b7d0: e58d309c  str r3, [sp, #156]  ; 0x9c
    b7d4: e3a02001  mov r2, #1
    b7d8: e5892004  str r2, [r9, #4]
    b7dc: d2899008  addle r9, r9, #8
    b7e0: ca000047  bgt b904 <_vfprintf_r+0x1a04>
    b7e4: e59d204c  ldr r2, [sp, #76] ; 0x4c
    b7e8: e1952002  orrs  r2, r5, r2
    b7ec: 0a000040  beq b8f4 <_vfprintf_r+0x19f4>
    b7f0: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b7f4: e59d1058  ldr r1, [sp, #88] ; 0x58
    b7f8: e2822001  add r2, r2, #1
    b7fc: e59d0054  ldr r0, [sp, #84] ; 0x54
    b800: e3520007  cmp r2, #7
    b804: e0833001  add r3, r3, r1
    b808: e5891004  str r1, [r9, #4]
    b80c: e5890000  str r0, [r9]
    b810: d2899008  addle r9, r9, #8
    b814: e58d309c  str r3, [sp, #156]  ; 0x9c
    b818: e58d2098  str r2, [sp, #152]  ; 0x98
    b81c: ca00012b  bgt bcd0 <_vfprintf_r+0x1dd0>
    b820: e2655000  rsb r5, r5, #0
    b824: e3550000  cmp r5, #0
    b828: da00007c  ble ba20 <_vfprintf_r+0x1b20>
    b82c: e3550010  cmp r5, #16
    b830: e59f458c  ldr r4, [pc, #1420] ; bdc4 <_vfprintf_r+0x1ec4>
    b834: c3a06010  movgt r6, #16
    b838: c59d7028  ldrgt r7, [sp, #40] ; 0x28
    b83c: ca000003  bgt b850 <_vfprintf_r+0x1950>
    b840: ea000065  b b9dc <_vfprintf_r+0x1adc>
    b844: e2455010  sub r5, r5, #16
    b848: e3550010  cmp r5, #16
    b84c: da000062  ble b9dc <_vfprintf_r+0x1adc>
    b850: e2822001  add r2, r2, #1
    b854: e2833010  add r3, r3, #16
    b858: e3520007  cmp r2, #7
    b85c: e8890050  stm r9, {r4, r6}
    b860: e58d2098  str r2, [sp, #152]  ; 0x98
    b864: d2899008  addle r9, r9, #8
    b868: e58d309c  str r3, [sp, #156]  ; 0x9c
    b86c: dafffff4  ble b844 <_vfprintf_r+0x1944>
    b870: e1a00007  mov r0, r7
    b874: e1a0100b  mov r1, fp
    b878: e28d2094  add r2, sp, #148  ; 0x94
    b87c: e1a09008  mov r9, r8
    b880: eb00112f  bl  fd44 <__sprint_r>
    b884: e3500000  cmp r0, #0
    b888: 1afffa6f  bne a24c <_vfprintf_r+0x34c>
    b88c: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b890: e59d2098  ldr r2, [sp, #152]  ; 0x98
    b894: eaffffea  b b844 <_vfprintf_r+0x1944>
    b898: e59d3034  ldr r3, [sp, #52] ; 0x34
    b89c: e3a05000  mov r5, #0
    b8a0: e2833004  add r3, r3, #4
    b8a4: e5134004  ldr r4, [r3, #-4]
    b8a8: e58d3034  str r3, [sp, #52] ; 0x34
    b8ac: eafffa88  b a2d4 <_vfprintf_r+0x3d4>
    b8b0: e59dc01c  ldr ip, [sp, #28]
    b8b4: e3083744  movw  r3, #34628  ; 0x8744
    b8b8: e3560047  cmp r6, #71 ; 0x47
    b8bc: e3a01003  mov r1, #3
    b8c0: e3082748  movw  r2, #34632  ; 0x8748
    b8c4: e3403001  movt  r3, #1
    b8c8: e3402001  movt  r2, #1
    b8cc: e3ccc080  bic ip, ip, #128  ; 0x80
    b8d0: d1a02003  movle r2, r3
    b8d4: e58d0044  str r0, [sp, #68] ; 0x44
    b8d8: e58d1020  str r1, [sp, #32]
    b8dc: e1a05001  mov r5, r1
    b8e0: e58dc01c  str ip, [sp, #28]
    b8e4: e58d0048  str r0, [sp, #72] ; 0x48
    b8e8: e58d2040  str r2, [sp, #64] ; 0x40
    b8ec: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    b8f0: eafffab8  b a3d8 <_vfprintf_r+0x4d8>
    b8f4: e59d201c  ldr r2, [sp, #28]
    b8f8: e3120001  tst r2, #1
    b8fc: 0afffcc6  beq ac1c <_vfprintf_r+0xd1c>
    b900: eaffffba  b b7f0 <_vfprintf_r+0x18f0>
    b904: e59d0028  ldr r0, [sp, #40] ; 0x28
    b908: e1a0100b  mov r1, fp
    b90c: e28d2094  add r2, sp, #148  ; 0x94
    b910: eb00110b  bl  fd44 <__sprint_r>
    b914: e3500000  cmp r0, #0
    b918: 1afffa4b  bne a24c <_vfprintf_r+0x34c>
    b91c: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    b920: e1a09008  mov r9, r8
    b924: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b928: eaffffad  b b7e4 <_vfprintf_r+0x18e4>
    b92c: e59d0030  ldr r0, [sp, #48] ; 0x30
    b930: e58d1034  str r1, [sp, #52] ; 0x34
    b934: e1a01003  mov r1, r3
    b938: e2600000  rsb r0, r0, #0
    b93c: e58d0030  str r0, [sp, #48] ; 0x30
    b940: eafffae9  b a4ec <_vfprintf_r+0x5ec>
    b944: e59d0028  ldr r0, [sp, #40] ; 0x28
    b948: e1a0100b  mov r1, fp
    b94c: e28d2094  add r2, sp, #148  ; 0x94
    b950: eb0010fb  bl  fd44 <__sprint_r>
    b954: e3500000  cmp r0, #0
    b958: 1afffa3b  bne a24c <_vfprintf_r+0x34c>
    b95c: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    b960: e1a09008  mov r9, r8
    b964: eafffd16  b adc4 <_vfprintf_r+0xec4>
    b968: ee183a90  vmov  r3, s17
    b96c: e3530000  cmp r3, #0
    b970: e59d301c  ldr r3, [sp, #28]
    b974: aeb09b48  vmovge.f64  d9, d8
    b978: e3833c01  orr r3, r3, #256  ; 0x100
    b97c: a3a0a000  movge sl, #0
    b980: e58d3038  str r3, [sp, #56] ; 0x38
    b984: ba0000dc  blt bcfc <_vfprintf_r+0x1dfc>
    b988: e3550046  cmp r5, #70 ; 0x46
    b98c: 0a000061  beq bb18 <_vfprintf_r+0x1c18>
    b990: e3550045  cmp r5, #69 ; 0x45
    b994: 1afffefa  bne b584 <_vfprintf_r+0x1684>
    b998: e3a02002  mov r2, #2
    b99c: e28d307c  add r3, sp, #124  ; 0x7c
    b9a0: e58d2000  str r2, [sp]
    b9a4: e2874001  add r4, r7, #1
    b9a8: e28d2080  add r2, sp, #128  ; 0x80
    b9ac: e58d3008  str r3, [sp, #8]
    b9b0: e58d200c  str r2, [sp, #12]
    b9b4: e28d308c  add r3, sp, #140  ; 0x8c
    b9b8: e58d4004  str r4, [sp, #4]
    b9bc: e58d3010  str r3, [sp, #16]
    b9c0: e59d0028  ldr r0, [sp, #40] ; 0x28
    b9c4: ec532b19  vmov  r2, r3, d9
    b9c8: eb000259  bl  c334 <_dtoa_r>
    b9cc: e58d0040  str r0, [sp, #64] ; 0x40
    b9d0: e59d3040  ldr r3, [sp, #64] ; 0x40
    b9d4: e0834004  add r4, r3, r4
    b9d8: eafffefd  b b5d4 <_vfprintf_r+0x16d4>
    b9dc: e2822001  add r2, r2, #1
    b9e0: e0833005  add r3, r3, r5
    b9e4: e3520007  cmp r2, #7
    b9e8: e8890030  stm r9, {r4, r5}
    b9ec: e58d2098  str r2, [sp, #152]  ; 0x98
    b9f0: d2899008  addle r9, r9, #8
    b9f4: e58d309c  str r3, [sp, #156]  ; 0x9c
    b9f8: da000008  ble ba20 <_vfprintf_r+0x1b20>
    b9fc: e59d0028  ldr r0, [sp, #40] ; 0x28
    ba00: e1a0100b  mov r1, fp
    ba04: e28d2094  add r2, sp, #148  ; 0x94
    ba08: eb0010cd  bl  fd44 <__sprint_r>
    ba0c: e3500000  cmp r0, #0
    ba10: 1afffa0d  bne a24c <_vfprintf_r+0x34c>
    ba14: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    ba18: e1a09008  mov r9, r8
    ba1c: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ba20: e2822001  add r2, r2, #1
    ba24: e59d104c  ldr r1, [sp, #76] ; 0x4c
    ba28: e3520007  cmp r2, #7
    ba2c: e58d2098  str r2, [sp, #152]  ; 0x98
    ba30: e59d2040  ldr r2, [sp, #64] ; 0x40
    ba34: e0833001  add r3, r3, r1
    ba38: e5891004  str r1, [r9, #4]
    ba3c: e58d309c  str r3, [sp, #156]  ; 0x9c
    ba40: e5892000  str r2, [r9]
    ba44: dafffc73  ble ac18 <_vfprintf_r+0xd18>
    ba48: eafffd78  b b030 <_vfprintf_r+0x1130>
    ba4c: e58d4044  str r4, [sp, #68] ; 0x44
    ba50: fafff8ea  blx 9e00 <strlen>
    ba54: e58d7034  str r7, [sp, #52] ; 0x34
    ba58: e58d4048  str r4, [sp, #72] ; 0x48
    ba5c: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    ba60: e1c03fc0  bic r3, r0, r0, asr #31
    ba64: e1a05000  mov r5, r0
    ba68: e58d3020  str r3, [sp, #32]
    ba6c: eafffa59  b a3d8 <_vfprintf_r+0x4d8>
    ba70: e308a580  movw  sl, #34176  ; 0x8580
    ba74: e59d109c  ldr r1, [sp, #156]  ; 0x9c
    ba78: e340a001  movt  sl, #1
    ba7c: e59d2098  ldr r2, [sp, #152]  ; 0x98
    ba80: eafffa8d  b a4bc <_vfprintf_r+0x5bc>
    ba84: e59d0028  ldr r0, [sp, #40] ; 0x28
    ba88: e1a0100b  mov r1, fp
    ba8c: e28d2094  add r2, sp, #148  ; 0x94
    ba90: eb0010ab  bl  fd44 <__sprint_r>
    ba94: e3500000  cmp r0, #0
    ba98: 1afff9eb  bne a24c <_vfprintf_r+0x34c>
    ba9c: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    baa0: e1a09008  mov r9, r8
    baa4: eafffd9b  b b118 <_vfprintf_r+0x1218>
    baa8: e59d0028  ldr r0, [sp, #40] ; 0x28
    baac: e1a0100b  mov r1, fp
    bab0: e28d2094  add r2, sp, #148  ; 0x94
    bab4: eb0010a2  bl  fd44 <__sprint_r>
    bab8: e3500000  cmp r0, #0
    babc: 1afff9e2  bne a24c <_vfprintf_r+0x34c>
    bac0: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    bac4: e1a09008  mov r9, r8
    bac8: e59d204c  ldr r2, [sp, #76] ; 0x4c
    bacc: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    bad0: e0655002  rsb r5, r5, r2
    bad4: eafffe0d  b b310 <_vfprintf_r+0x1410>
    bad8: e308a580  movw  sl, #34176  ; 0x8580
    badc: e59d2098  ldr r2, [sp, #152]  ; 0x98
    bae0: e340a001  movt  sl, #1
    bae4: eafffc75  b acc0 <_vfprintf_r+0xdc0>
    bae8: e3550006  cmp r5, #6
    baec: e3083760  movw  r3, #34656  ; 0x8760
    baf0: e1a0a002  mov sl, r2
    baf4: e58d2044  str r2, [sp, #68] ; 0x44
    baf8: 23a05006  movcs r5, #6
    bafc: e58d2048  str r2, [sp, #72] ; 0x48
    bb00: e3403001  movt  r3, #1
    bb04: e1c52fc5  bic r2, r5, r5, asr #31
    bb08: e58d7034  str r7, [sp, #52] ; 0x34
    bb0c: e58d2020  str r2, [sp, #32]
    bb10: e58d3040  str r3, [sp, #64] ; 0x40
    bb14: eafffa2f  b a3d8 <_vfprintf_r+0x4d8>
    bb18: e3a02003  mov r2, #3
    bb1c: e28d307c  add r3, sp, #124  ; 0x7c
    bb20: e58d2000  str r2, [sp]
    bb24: e28d2080  add r2, sp, #128  ; 0x80
    bb28: e58d3008  str r3, [sp, #8]
    bb2c: e28d308c  add r3, sp, #140  ; 0x8c
    bb30: e58d200c  str r2, [sp, #12]
    bb34: e58d3010  str r3, [sp, #16]
    bb38: e58d7004  str r7, [sp, #4]
    bb3c: ec532b19  vmov  r2, r3, d9
    bb40: e59d0028  ldr r0, [sp, #40] ; 0x28
    bb44: eb0001fa  bl  c334 <_dtoa_r>
    bb48: eeb59b40  vcmp.f64  d9, #0.0
    bb4c: eef1fa10  vmrs  APSR_nzcv, fpscr
    bb50: 13a02001  movne r2, #1
    bb54: 03a02000  moveq r2, #0
    bb58: e5d01000  ldrb  r1, [r0]
    bb5c: e0803007  add r3, r0, r7
    bb60: e58d0040  str r0, [sp, #64] ; 0x40
    bb64: e3510030  cmp r1, #48 ; 0x30
    bb68: 13a02000  movne r2, #0
    bb6c: 02022001  andeq r2, r2, #1
    bb70: e3520000  cmp r2, #0
    bb74: 12674001  rsbne r4, r7, #1
    bb78: 158d407c  strne r4, [sp, #124]  ; 0x7c
    bb7c: 059d407c  ldreq r4, [sp, #124]  ; 0x7c
    bb80: e0834004  add r4, r3, r4
    bb84: eafffe92  b b5d4 <_vfprintf_r+0x16d4>
    bb88: e58d3020  str r3, [sp, #32]
    bb8c: e3a0a02d  mov sl, #45 ; 0x2d
    bb90: e59d3038  ldr r3, [sp, #56] ; 0x38
    bb94: e5cda077  strb  sl, [sp, #119]  ; 0x77
    bb98: e58d301c  str r3, [sp, #28]
    bb9c: e3a03000  mov r3, #0
    bba0: e58d3044  str r3, [sp, #68] ; 0x44
    bba4: eafffa0d  b a3e0 <_vfprintf_r+0x4e0>
    bba8: e3560065  cmp r6, #101  ; 0x65
    bbac: da000013  ble bc00 <_vfprintf_r+0x1d00>
    bbb0: e3560066  cmp r6, #102  ; 0x66
    bbb4: e58d3048  str r3, [sp, #72] ; 0x48
    bbb8: 1afffe9f  bne b63c <_vfprintf_r+0x173c>
    bbbc: e3530000  cmp r3, #0
    bbc0: da000065  ble bd5c <_vfprintf_r+0x1e5c>
    bbc4: e3570000  cmp r7, #0
    bbc8: 1a000058  bne bd30 <_vfprintf_r+0x1e30>
    bbcc: e59d301c  ldr r3, [sp, #28]
    bbd0: e3130001  tst r3, #1
    bbd4: 1a000055  bne bd30 <_vfprintf_r+0x1e30>
    bbd8: e59d5048  ldr r5, [sp, #72] ; 0x48
    bbdc: e1c53fc5  bic r3, r5, r5, asr #31
    bbe0: eafffea1  b b66c <_vfprintf_r+0x176c>
    bbe4: e1c53fc5  bic r3, r5, r5, asr #31
    bbe8: e58d0044  str r0, [sp, #68] ; 0x44
    bbec: e58d7034  str r7, [sp, #52] ; 0x34
    bbf0: e58d0048  str r0, [sp, #72] ; 0x48
    bbf4: e5dda077  ldrb  sl, [sp, #119]  ; 0x77
    bbf8: e58d3020  str r3, [sp, #32]
    bbfc: eafff9f5  b a3d8 <_vfprintf_r+0x4d8>
    bc00: e2433001  sub r3, r3, #1
    bc04: e58d307c  str r3, [sp, #124]  ; 0x7c
    bc08: e3530000  cmp r3, #0
    bc0c: e5cd6084  strb  r6, [sp, #132]  ; 0x84
    bc10: b2633000  rsblt r3, r3, #0
    bc14: b3a0202d  movlt r2, #45 ; 0x2d
    bc18: a3a0202b  movge r2, #43 ; 0x2b
    bc1c: e3530009  cmp r3, #9
    bc20: e5cd2085  strb  r2, [sp, #133]  ; 0x85
    bc24: da000046  ble bd44 <_vfprintf_r+0x1e44>
    bc28: e28de093  add lr, sp, #147  ; 0x93
    bc2c: e59d406c  ldr r4, [sp, #108]  ; 0x6c
    bc30: e1a0c00e  mov ip, lr
    bc34: e0c10493  smull r0, r1, r3, r4
    bc38: e1a02fc3  asr r2, r3, #31
    bc3c: e0621141  rsb r1, r2, r1, asr #2
    bc40: e3510009  cmp r1, #9
    bc44: e0812101  add r2, r1, r1, lsl #2
    bc48: e0432082  sub r2, r3, r2, lsl #1
    bc4c: e1a03001  mov r3, r1
    bc50: e2822030  add r2, r2, #48 ; 0x30
    bc54: e56c2001  strb  r2, [ip, #-1]!
    bc58: cafffff5  bgt bc34 <_vfprintf_r+0x1d34>
    bc5c: e2813030  add r3, r1, #48 ; 0x30
    bc60: e1a0200c  mov r2, ip
    bc64: e6ef3073  uxtb  r3, r3
    bc68: e5623001  strb  r3, [r2, #-1]!
    bc6c: e15e0002  cmp lr, r2
    bc70: 9a00004f  bls bdb4 <_vfprintf_r+0x1eb4>
    bc74: e1a0200c  mov r2, ip
    bc78: e28d1086  add r1, sp, #134  ; 0x86
    bc7c: ea000000  b bc84 <_vfprintf_r+0x1d84>
    bc80: e4d23001  ldrb  r3, [r2], #1
    bc84: e152000e  cmp r2, lr
    bc88: e4c13001  strb  r3, [r1], #1
    bc8c: 1afffffb  bne bc80 <_vfprintf_r+0x1d80>
    bc90: e28d3094  add r3, sp, #148  ; 0x94
    bc94: e28d2086  add r2, sp, #134  ; 0x86
    bc98: e06c3003  rsb r3, ip, r3
    bc9c: e0823003  add r3, r2, r3
    bca0: e59d104c  ldr r1, [sp, #76] ; 0x4c
    bca4: e28d2084  add r2, sp, #132  ; 0x84
    bca8: e0623003  rsb r3, r2, r3
    bcac: e58d3068  str r3, [sp, #104]  ; 0x68
    bcb0: e3510001  cmp r1, #1
    bcb4: e0815003  add r5, r1, r3
    bcb8: da000039  ble bda4 <_vfprintf_r+0x1ea4>
    bcbc: e2855001  add r5, r5, #1
    bcc0: e3a03000  mov r3, #0
    bcc4: e58d3048  str r3, [sp, #72] ; 0x48
    bcc8: e1c53fc5  bic r3, r5, r5, asr #31
    bccc: eafffe66  b b66c <_vfprintf_r+0x176c>
    bcd0: e59d0028  ldr r0, [sp, #40] ; 0x28
    bcd4: e1a0100b  mov r1, fp
    bcd8: e28d2094  add r2, sp, #148  ; 0x94
    bcdc: eb001018  bl  fd44 <__sprint_r>
    bce0: e3500000  cmp r0, #0
    bce4: 1afff958  bne a24c <_vfprintf_r+0x34c>
    bce8: e59d507c  ldr r5, [sp, #124]  ; 0x7c
    bcec: e1a09008  mov r9, r8
    bcf0: e59d309c  ldr r3, [sp, #156]  ; 0x9c
    bcf4: e59d2098  ldr r2, [sp, #152]  ; 0x98
    bcf8: eafffec8  b b820 <_vfprintf_r+0x1920>
    bcfc: eeb19b48  vneg.f64  d9, d8
    bd00: e3a0a02d  mov sl, #45 ; 0x2d
    bd04: eaffff1f  b b988 <_vfprintf_r+0x1a88>
    bd08: e59d3048  ldr r3, [sp, #72] ; 0x48
    bd0c: e3530000  cmp r3, #0
    bd10: d2635002  rsble r5, r3, #2
    bd14: e59d304c  ldr r3, [sp, #76] ; 0x4c
    bd18: c3a05001  movgt r5, #1
    bd1c: e0855003  add r5, r5, r3
    bd20: e1c53fc5  bic r3, r5, r5, asr #31
    bd24: eafffe50  b b66c <_vfprintf_r+0x176c>
    bd28: e59d308c  ldr r3, [sp, #140]  ; 0x8c
    bd2c: eafffe36  b b60c <_vfprintf_r+0x170c>
    bd30: e59d3048  ldr r3, [sp, #72] ; 0x48
    bd34: e2875001  add r5, r7, #1
    bd38: e0835005  add r5, r3, r5
    bd3c: e1c53fc5  bic r3, r5, r5, asr #31
    bd40: eafffe49  b b66c <_vfprintf_r+0x176c>
    bd44: e2833030  add r3, r3, #48 ; 0x30
    bd48: e5cd3087  strb  r3, [sp, #135]  ; 0x87
    bd4c: e3a03030  mov r3, #48 ; 0x30
    bd50: e5cd3086  strb  r3, [sp, #134]  ; 0x86
    bd54: e28d3088  add r3, sp, #136  ; 0x88
    bd58: eaffffd0  b bca0 <_vfprintf_r+0x1da0>
    bd5c: e3570000  cmp r7, #0
    bd60: 1a000004  bne bd78 <_vfprintf_r+0x1e78>
    bd64: e59d301c  ldr r3, [sp, #28]
    bd68: e3130001  tst r3, #1
    bd6c: 03a03001  moveq r3, #1
    bd70: 01a05003  moveq r5, r3
    bd74: 0afffe3c  beq b66c <_vfprintf_r+0x176c>
    bd78: e2875002  add r5, r7, #2
    bd7c: e1c53fc5  bic r3, r5, r5, asr #31
    bd80: eafffe39  b b66c <_vfprintf_r+0x176c>
    bd84: e59d0034  ldr r0, [sp, #52] ; 0x34
    bd88: e5d36001  ldrb  r6, [r3, #1]
    bd8c: e2800004  add r0, r0, #4
    bd90: e5107004  ldr r7, [r0, #-4]
    bd94: e58d0034  str r0, [sp, #52] ; 0x34
    bd98: e3570000  cmp r7, #0
    bd9c: aafff8b3  bge a070 <_vfprintf_r+0x170>
    bda0: eafff8b1  b a06c <_vfprintf_r+0x16c>
    bda4: e59d301c  ldr r3, [sp, #28]
    bda8: e2133001  ands  r3, r3, #1
    bdac: 0affffc4  beq bcc4 <_vfprintf_r+0x1dc4>
    bdb0: eaffffc1  b bcbc <_vfprintf_r+0x1dbc>
    bdb4: e28d3086  add r3, sp, #134  ; 0x86
    bdb8: eaffffb8  b bca0 <_vfprintf_r+0x1da0>
    bdbc: e1a04007  mov r4, r7
    bdc0: eaffff02  b b9d0 <_vfprintf_r+0x1ad0>
    bdc4: 00018590  .word 0x00018590

0000bdc8 <vfprintf>:
    bdc8: e30bc390  movw  ip, #45968  ; 0xb390
    bdcc: e1a03002  mov r3, r2
    bdd0: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
    bdd4: e340c001  movt  ip, #1
    bdd8: e1a0e001  mov lr, r1
    bddc: e1a01000  mov r1, r0
    bde0: e1a0200e  mov r2, lr
    bde4: e59c0000  ldr r0, [ip]
    bde8: e49de004  pop {lr}    ; (ldr lr, [sp], #4)
    bdec: eafff843  b 9f00 <_vfprintf_r>

0000bdf0 <__sbprintf>:
    bdf0: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
    bdf4: e1a04001  mov r4, r1
    bdf8: e24dde46  sub sp, sp, #1120 ; 0x460
    bdfc: e1d470be  ldrh  r7, [r4, #14]
    be00: e24dd008  sub sp, sp, #8
    be04: e5949064  ldr r9, [r4, #100]  ; 0x64
    be08: e594a01c  ldr sl, [r4, #28]
    be0c: e28d6068  add r6, sp, #104  ; 0x68
    be10: e5948024  ldr r8, [r4, #36] ; 0x24
    be14: e1a0100d  mov r1, sp
    be18: e1d4c0bc  ldrh  ip, [r4, #12]
    be1c: e3a0eb01  mov lr, #1024 ; 0x400
    be20: e1cd70be  strh  r7, [sp, #14]
    be24: e3a07000  mov r7, #0
    be28: e3ccc002  bic ip, ip, #2
    be2c: e58d9064  str r9, [sp, #100]  ; 0x64
    be30: e58d6000  str r6, [sp]
    be34: e1a09000  mov r9, r0
    be38: e58d6010  str r6, [sp, #16]
    be3c: e1cdc0bc  strh  ip, [sp, #12]
    be40: e58da01c  str sl, [sp, #28]
    be44: e58d8024  str r8, [sp, #36] ; 0x24
    be48: e58de008  str lr, [sp, #8]
    be4c: e58de014  str lr, [sp, #20]
    be50: e58d7018  str r7, [sp, #24]
    be54: ebfff829  bl  9f00 <_vfprintf_r>
    be58: e2506000  subs  r6, r0, #0
    be5c: ba000004  blt be74 <__sbprintf+0x84>
    be60: e1a00009  mov r0, r9
    be64: e1a0100d  mov r1, sp
    be68: eb000659  bl  d7d4 <_fflush_r>
    be6c: e1500007  cmp r0, r7
    be70: 13e06000  mvnne r6, #0
    be74: e1dd30bc  ldrh  r3, [sp, #12]
    be78: e1a00006  mov r0, r6
    be7c: e3130040  tst r3, #64 ; 0x40
    be80: 11d430bc  ldrhne  r3, [r4, #12]
    be84: 13833040  orrne r3, r3, #64 ; 0x40
    be88: 11c430bc  strhne  r3, [r4, #12]
    be8c: e28dde46  add sp, sp, #1120 ; 0x460
    be90: e28dd008  add sp, sp, #8
    be94: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}

0000be98 <__swsetup_r>:
    be98: e92d4038  push  {r3, r4, r5, lr}
    be9c: e30b3390  movw  r3, #45968  ; 0xb390
    bea0: e3403001  movt  r3, #1
    bea4: e1a05000  mov r5, r0
    bea8: e5930000  ldr r0, [r3]
    beac: e1a04001  mov r4, r1
    beb0: e3500000  cmp r0, #0
    beb4: 0a000002  beq bec4 <__swsetup_r+0x2c>
    beb8: e5903038  ldr r3, [r0, #56] ; 0x38
    bebc: e3530000  cmp r3, #0
    bec0: 0a000030  beq bf88 <__swsetup_r+0xf0>
    bec4: e1d4c0bc  ldrh  ip, [r4, #12]
    bec8: e6ff307c  uxth  r3, ip
    becc: e3130008  tst r3, #8
    bed0: 0a00000b  beq bf04 <__swsetup_r+0x6c>
    bed4: e5942010  ldr r2, [r4, #16]
    bed8: e3520000  cmp r2, #0
    bedc: 0a000012  beq bf2c <__swsetup_r+0x94>
    bee0: e2131001  ands  r1, r3, #1
    bee4: 1a000019  bne bf50 <__swsetup_r+0xb8>
    bee8: e3130002  tst r3, #2
    beec: 05941014  ldreq r1, [r4, #20]
    bef0: e3520000  cmp r2, #0
    bef4: e5841008  str r1, [r4, #8]
    bef8: 0a00001b  beq bf6c <__swsetup_r+0xd4>
    befc: e3a00000  mov r0, #0
    bf00: e8bd8038  pop {r3, r4, r5, pc}
    bf04: e3130010  tst r3, #16
    bf08: 0a000032  beq bfd8 <__swsetup_r+0x140>
    bf0c: e3130004  tst r3, #4
    bf10: 1a00001e  bne bf90 <__swsetup_r+0xf8>
    bf14: e5942010  ldr r2, [r4, #16]
    bf18: e38c3008  orr r3, ip, #8
    bf1c: e3520000  cmp r2, #0
    bf20: e1c430bc  strh  r3, [r4, #12]
    bf24: e6ff3073  uxth  r3, r3
    bf28: 1affffec  bne bee0 <__swsetup_r+0x48>
    bf2c: e2031d0a  and r1, r3, #640  ; 0x280
    bf30: e3510c02  cmp r1, #512  ; 0x200
    bf34: 0affffe9  beq bee0 <__swsetup_r+0x48>
    bf38: e1a00005  mov r0, r5
    bf3c: e1a01004  mov r1, r4
    bf40: eb000869  bl  e0ec <__smakebuf_r>
    bf44: e1d430bc  ldrh  r3, [r4, #12]
    bf48: e5942010  ldr r2, [r4, #16]
    bf4c: eaffffe3  b bee0 <__swsetup_r+0x48>
    bf50: e5943014  ldr r3, [r4, #20]
    bf54: e3520000  cmp r2, #0
    bf58: e3a01000  mov r1, #0
    bf5c: e5841008  str r1, [r4, #8]
    bf60: e2633000  rsb r3, r3, #0
    bf64: e5843018  str r3, [r4, #24]
    bf68: 1affffe3  bne befc <__swsetup_r+0x64>
    bf6c: e1d430bc  ldrh  r3, [r4, #12]
    bf70: e3130080  tst r3, #128  ; 0x80
    bf74: 0affffe0  beq befc <__swsetup_r+0x64>
    bf78: e3833040  orr r3, r3, #64 ; 0x40
    bf7c: e3e00000  mvn r0, #0
    bf80: e1c430bc  strh  r3, [r4, #12]
    bf84: e8bd8038  pop {r3, r4, r5, pc}
    bf88: eb0006e2  bl  db18 <__sinit>
    bf8c: eaffffcc  b bec4 <__swsetup_r+0x2c>
    bf90: e5941030  ldr r1, [r4, #48] ; 0x30
    bf94: e3510000  cmp r1, #0
    bf98: 0a000007  beq bfbc <__swsetup_r+0x124>
    bf9c: e2843040  add r3, r4, #64 ; 0x40
    bfa0: e1510003  cmp r1, r3
    bfa4: 0a000002  beq bfb4 <__swsetup_r+0x11c>
    bfa8: e1a00005  mov r0, r5
    bfac: eb00072c  bl  dc64 <_free_r>
    bfb0: e1d4c0bc  ldrh  ip, [r4, #12]
    bfb4: e3a03000  mov r3, #0
    bfb8: e5843030  str r3, [r4, #48] ; 0x30
    bfbc: e5942010  ldr r2, [r4, #16]
    bfc0: e3ccc024  bic ip, ip, #36 ; 0x24
    bfc4: e3a03000  mov r3, #0
    bfc8: e5843004  str r3, [r4, #4]
    bfcc: e6ffc07c  uxth  ip, ip
    bfd0: e5842000  str r2, [r4]
    bfd4: eaffffcf  b bf18 <__swsetup_r+0x80>
    bfd8: e38cc040  orr ip, ip, #64 ; 0x40
    bfdc: e3a03009  mov r3, #9
    bfe0: e3e00000  mvn r0, #0
    bfe4: e5853000  str r3, [r5]
    bfe8: e1c4c0bc  strh  ip, [r4, #12]
    bfec: e8bd8038  pop {r3, r4, r5, pc}

0000bff0 <__call_exitprocs>:
    bff0: e308357c  movw  r3, #34172  ; 0x857c
    bff4: e3002000  movw  r2, #0
    bff8: e3403001  movt  r3, #1
    bffc: e3402000  movt  r2, #0
    c000: e5933000  ldr r3, [r3]
    c004: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c008: e24dd014  sub sp, sp, #20
    c00c: e1a0a000  mov sl, r0
    c010: e1a06001  mov r6, r1
    c014: e58d3008  str r3, [sp, #8]
    c018: e2833f52  add r3, r3, #328  ; 0x148
    c01c: e58d2004  str r2, [sp, #4]
    c020: e58d300c  str r3, [sp, #12]
    c024: e59d3008  ldr r3, [sp, #8]
    c028: e5937148  ldr r7, [r3, #328]  ; 0x148
    c02c: e3570000  cmp r7, #0
    c030: 0a000039  beq c11c <__call_exitprocs+0x12c>
    c034: e59db00c  ldr fp, [sp, #12]
    c038: e1a0900b  mov r9, fp
    c03c: e5974004  ldr r4, [r7, #4]
    c040: e2545001  subs  r5, r4, #1
    c044: 52844001  addpl r4, r4, #1
    c048: 53a08000  movpl r8, #0
    c04c: 50874104  addpl r4, r7, r4, lsl #2
    c050: 5a000007  bpl c074 <__call_exitprocs+0x84>
    c054: ea000021  b c0e0 <__call_exitprocs+0xf0>
    c058: e5943100  ldr r3, [r4, #256]  ; 0x100
    c05c: e1530006  cmp r3, r6
    c060: 0a000005  beq c07c <__call_exitprocs+0x8c>
    c064: e2455001  sub r5, r5, #1
    c068: e2444004  sub r4, r4, #4
    c06c: e3750001  cmn r5, #1
    c070: 0a00001a  beq c0e0 <__call_exitprocs+0xf0>
    c074: e3560000  cmp r6, #0
    c078: 1afffff6  bne c058 <__call_exitprocs+0x68>
    c07c: e5973004  ldr r3, [r7, #4]
    c080: e5942000  ldr r2, [r4]
    c084: e2433001  sub r3, r3, #1
    c088: e1530005  cmp r3, r5
    c08c: 05875004  streq r5, [r7, #4]
    c090: 15848000  strne r8, [r4]
    c094: e3520000  cmp r2, #0
    c098: 0afffff1  beq c064 <__call_exitprocs+0x74>
    c09c: e5973188  ldr r3, [r7, #392]  ; 0x188
    c0a0: e3a01001  mov r1, #1
    c0a4: e1a01511  lsl r1, r1, r5
    c0a8: e597b004  ldr fp, [r7, #4]
    c0ac: e1110003  tst r1, r3
    c0b0: 1a00001b  bne c124 <__call_exitprocs+0x134>
    c0b4: e12fff32  blx r2
    c0b8: e5973004  ldr r3, [r7, #4]
    c0bc: e153000b  cmp r3, fp
    c0c0: 1affffd7  bne c024 <__call_exitprocs+0x34>
    c0c4: e5993000  ldr r3, [r9]
    c0c8: e1530007  cmp r3, r7
    c0cc: 1affffd4  bne c024 <__call_exitprocs+0x34>
    c0d0: e2455001  sub r5, r5, #1
    c0d4: e2444004  sub r4, r4, #4
    c0d8: e3750001  cmn r5, #1
    c0dc: 1affffe4  bne c074 <__call_exitprocs+0x84>
    c0e0: e59d3004  ldr r3, [sp, #4]
    c0e4: e3530000  cmp r3, #0
    c0e8: 0a00000b  beq c11c <__call_exitprocs+0x12c>
    c0ec: e5973004  ldr r3, [r7, #4]
    c0f0: e3530000  cmp r3, #0
    c0f4: e5973000  ldr r3, [r7]
    c0f8: 1a000013  bne c14c <__call_exitprocs+0x15c>
    c0fc: e3530000  cmp r3, #0
    c100: 0a000011  beq c14c <__call_exitprocs+0x15c>
    c104: e1a00007  mov r0, r7
    c108: e5893000  str r3, [r9]
    c10c: e320f000  nop {0}
    c110: e5997000  ldr r7, [r9]
    c114: e3570000  cmp r7, #0
    c118: 1affffc7  bne c03c <__call_exitprocs+0x4c>
    c11c: e28dd014  add sp, sp, #20
    c120: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c124: e597318c  ldr r3, [r7, #396]  ; 0x18c
    c128: e1110003  tst r1, r3
    c12c: 1a000003  bne c140 <__call_exitprocs+0x150>
    c130: e1a0000a  mov r0, sl
    c134: e5941080  ldr r1, [r4, #128]  ; 0x80
    c138: e12fff32  blx r2
    c13c: eaffffdd  b c0b8 <__call_exitprocs+0xc8>
    c140: e5940080  ldr r0, [r4, #128]  ; 0x80
    c144: e12fff32  blx r2
    c148: eaffffda  b c0b8 <__call_exitprocs+0xc8>
    c14c: e1a09007  mov r9, r7
    c150: e1a07003  mov r7, r3
    c154: eaffffee  b c114 <__call_exitprocs+0x124>

0000c158 <atexit>:
    c158: e1a01000  mov r1, r0
    c15c: e3a00000  mov r0, #0
    c160: e1a02000  mov r2, r0
    c164: e1a03000  mov r3, r0
    c168: ea0013b3  b 1103c <__register_exitproc>
    c16c: 00000000  andeq r0, r0, r0

0000c170 <quorem>:
    c170: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c174: e24dd00c  sub sp, sp, #12
    c178: e5903010  ldr r3, [r0, #16]
    c17c: e5915010  ldr r5, [r1, #16]
    c180: e1550003  cmp r5, r3
    c184: c3a00000  movgt r0, #0
    c188: ca000067  bgt c32c <quorem+0x1bc>
    c18c: e2455001  sub r5, r5, #1
    c190: e2814014  add r4, r1, #20
    c194: e58d1000  str r1, [sp]
    c198: e2809014  add r9, r0, #20
    c19c: e7941105  ldr r1, [r4, r5, lsl #2]
    c1a0: e1a0a105  lsl sl, r5, #2
    c1a4: e1a08000  mov r8, r0
    c1a8: e7990105  ldr r0, [r9, r5, lsl #2]
    c1ac: e2811001  add r1, r1, #1
    c1b0: e089300a  add r3, r9, sl
    c1b4: e58d3004  str r3, [sp, #4]
    c1b8: ebfff3fc  bl  91b0 <__aeabi_uidiv>
    c1bc: e084700a  add r7, r4, sl
    c1c0: e2506000  subs  r6, r0, #0
    c1c4: 0a00002c  beq c27c <quorem+0x10c>
    c1c8: e3a0c000  mov ip, #0
    c1cc: e1a0b004  mov fp, r4
    c1d0: e1a0200c  mov r2, ip
    c1d4: e1a0e009  mov lr, r9
    c1d8: e49b3004  ldr r3, [fp], #4
    c1dc: e59e0000  ldr r0, [lr]
    c1e0: e157000b  cmp r7, fp
    c1e4: e6ff1073  uxth  r1, r3
    c1e8: e1a03823  lsr r3, r3, #16
    c1ec: e021c691  mla r1, r1, r6, ip
    c1f0: e00c0693  mul ip, r3, r6
    c1f4: e6ff3071  uxth  r3, r1
    c1f8: e08cc821  add ip, ip, r1, lsr #16
    c1fc: e0633002  rsb r3, r3, r2
    c200: e6f33070  uxtah r3, r3, r0
    c204: e6ff207c  uxth  r2, ip
    c208: e0622820  rsb r2, r2, r0, lsr #16
    c20c: e1a0c82c  lsr ip, ip, #16
    c210: e0822843  add r2, r2, r3, asr #16
    c214: e6ff3073  uxth  r3, r3
    c218: e1830802  orr r0, r3, r2, lsl #16
    c21c: e1a02842  asr r2, r2, #16
    c220: e48e0004  str r0, [lr], #4
    c224: 2affffeb  bcs c1d8 <quorem+0x68>
    c228: e799300a  ldr r3, [r9, sl]
    c22c: e3530000  cmp r3, #0
    c230: 1a000011  bne c27c <quorem+0x10c>
    c234: e59d2004  ldr r2, [sp, #4]
    c238: e2423004  sub r3, r2, #4
    c23c: e1590003  cmp r9, r3
    c240: 2a00000c  bcs c278 <quorem+0x108>
    c244: e5123004  ldr r3, [r2, #-4]
    c248: e3530000  cmp r3, #0
    c24c: 1a000009  bne c278 <quorem+0x108>
    c250: e2423008  sub r3, r2, #8
    c254: ea000002  b c264 <quorem+0xf4>
    c258: e5922000  ldr r2, [r2]
    c25c: e3520000  cmp r2, #0
    c260: 1a000004  bne c278 <quorem+0x108>
    c264: e1590003  cmp r9, r3
    c268: e1a02003  mov r2, r3
    c26c: e2455001  sub r5, r5, #1
    c270: e2433004  sub r3, r3, #4
    c274: 3afffff7  bcc c258 <quorem+0xe8>
    c278: e5885010  str r5, [r8, #16]
    c27c: e59d1000  ldr r1, [sp]
    c280: e1a00008  mov r0, r8
    c284: eb000c0d  bl  f2c0 <__mcmp>
    c288: e3500000  cmp r0, #0
    c28c: ba000025  blt c328 <quorem+0x1b8>
    c290: e2866001  add r6, r6, #1
    c294: e1a0c009  mov ip, r9
    c298: e3a03000  mov r3, #0
    c29c: e4940004  ldr r0, [r4], #4
    c2a0: e59c1000  ldr r1, [ip]
    c2a4: e1570004  cmp r7, r4
    c2a8: e6ff2070  uxth  r2, r0
    c2ac: e1a00820  lsr r0, r0, #16
    c2b0: e0622003  rsb r2, r2, r3
    c2b4: e0603821  rsb r3, r0, r1, lsr #16
    c2b8: e6f22071  uxtah r2, r2, r1
    c2bc: e0833842  add r3, r3, r2, asr #16
    c2c0: e6ff2072  uxth  r2, r2
    c2c4: e1821803  orr r1, r2, r3, lsl #16
    c2c8: e1a03843  asr r3, r3, #16
    c2cc: e48c1004  str r1, [ip], #4
    c2d0: 2afffff1  bcs c29c <quorem+0x12c>
    c2d4: e7992105  ldr r2, [r9, r5, lsl #2]
    c2d8: e0893105  add r3, r9, r5, lsl #2
    c2dc: e3520000  cmp r2, #0
    c2e0: 1a000010  bne c328 <quorem+0x1b8>
    c2e4: e2432004  sub r2, r3, #4
    c2e8: e1590002  cmp r9, r2
    c2ec: 2a00000c  bcs c324 <quorem+0x1b4>
    c2f0: e5132004  ldr r2, [r3, #-4]
    c2f4: e3520000  cmp r2, #0
    c2f8: 1a000009  bne c324 <quorem+0x1b4>
    c2fc: e2433008  sub r3, r3, #8
    c300: ea000002  b c310 <quorem+0x1a0>
    c304: e5922000  ldr r2, [r2]
    c308: e3520000  cmp r2, #0
    c30c: 1a000004  bne c324 <quorem+0x1b4>
    c310: e1590003  cmp r9, r3
    c314: e1a02003  mov r2, r3
    c318: e2455001  sub r5, r5, #1
    c31c: e2433004  sub r3, r3, #4
    c320: 3afffff7  bcc c304 <quorem+0x194>
    c324: e5885010  str r5, [r8, #16]
    c328: e1a00006  mov r0, r6
    c32c: e28dd00c  add sp, sp, #12
    c330: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000c334 <_dtoa_r>:
    c334: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    c338: e1a04000  mov r4, r0
    c33c: ed2d8b02  vpush {d8}
    c340: e1a0a002  mov sl, r2
    c344: e590c040  ldr ip, [r0, #64] ; 0x40
    c348: e1a0b003  mov fp, r3
    c34c: e35c0000  cmp ip, #0
    c350: e24dd03c  sub sp, sp, #60 ; 0x3c
    c354: e59d6074  ldr r6, [sp, #116]  ; 0x74
    c358: 0a000007  beq c37c <_dtoa_r+0x48>
    c35c: e5902044  ldr r2, [r0, #68] ; 0x44
    c360: e3a03001  mov r3, #1
    c364: e1a0100c  mov r1, ip
    c368: e1a03213  lsl r3, r3, r2
    c36c: e98c000c  stmib ip, {r2, r3}
    c370: eb000a24  bl  ec08 <_Bfree>
    c374: e3a03000  mov r3, #0
    c378: e5843040  str r3, [r4, #64] ; 0x40
    c37c: e35b0000  cmp fp, #0
    c380: e1a0500b  mov r5, fp
    c384: b3cb5102  biclt r5, fp, #-2147483648  ; 0x80000000
    c388: b3a03001  movlt r3, #1
    c38c: a3a03000  movge r3, #0
    c390: b5863000  strlt r3, [r6]
    c394: b1a0b005  movlt fp, r5
    c398: a5863000  strge r3, [r6]
    c39c: e3a03000  mov r3, #0
    c3a0: e1a02003  mov r2, r3
    c3a4: e3473ff0  movt  r3, #32752  ; 0x7ff0
    c3a8: e0033005  and r3, r3, r5
    c3ac: e3472ff0  movt  r2, #32752  ; 0x7ff0
    c3b0: e1530002  cmp r3, r2
    c3b4: 0a000010  beq c3fc <_dtoa_r+0xc8>
    c3b8: ec4bab18  vmov  d8, sl, fp
    c3bc: eeb58b40  vcmp.f64  d8, #0.0
    c3c0: eef1fa10  vmrs  APSR_nzcv, fpscr
    c3c4: 1a00001b  bne c438 <_dtoa_r+0x104>
    c3c8: e59d3078  ldr r3, [sp, #120]  ; 0x78
    c3cc: e59d2070  ldr r2, [sp, #112]  ; 0x70
    c3d0: e3530000  cmp r3, #0
    c3d4: e3a03001  mov r3, #1
    c3d8: e5823000  str r3, [r2]
    c3dc: 0a00008b  beq c610 <_dtoa_r+0x2dc>
    c3e0: e59f3328  ldr r3, [pc, #808]  ; c710 <_dtoa_r+0x3dc>
    c3e4: e2430001  sub r0, r3, #1
    c3e8: e59d2078  ldr r2, [sp, #120]  ; 0x78
    c3ec: e5823000  str r3, [r2]
    c3f0: e28dd03c  add sp, sp, #60 ; 0x3c
    c3f4: ecbd8b02  vpop  {d8}
    c3f8: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c3fc: e35a0000  cmp sl, #0
    c400: e59d2070  ldr r2, [sp, #112]  ; 0x70
    c404: e302370f  movw  r3, #9999 ; 0x270f
    c408: 13080778  movwne  r0, #34680  ; 0x8778
    c40c: e5823000  str r3, [r2]
    c410: 13400001  movtne  r0, #1
    c414: 0a000069  beq c5c0 <_dtoa_r+0x28c>
    c418: e59d3078  ldr r3, [sp, #120]  ; 0x78
    c41c: e3530000  cmp r3, #0
    c420: 0afffff2  beq c3f0 <_dtoa_r+0xbc>
    c424: e5d03003  ldrb  r3, [r0, #3]
    c428: e3530000  cmp r3, #0
    c42c: 12803008  addne r3, r0, #8
    c430: 02803003  addeq r3, r0, #3
    c434: eaffffeb  b c3e8 <_dtoa_r+0xb4>
    c438: e28d2034  add r2, sp, #52 ; 0x34
    c43c: e28d3030  add r3, sp, #48 ; 0x30
    c440: e58d2000  str r2, [sp]
    c444: e1a00004  mov r0, r4
    c448: e58d3004  str r3, [sp, #4]
    c44c: e1a0200a  mov r2, sl
    c450: e1a0300b  mov r3, fp
    c454: eb000c52  bl  f5a4 <__d2b>
    c458: e1b08a25  lsrs  r8, r5, #20
    c45c: e1a09000  mov r9, r0
    c460: 1a00005f  bne c5e4 <_dtoa_r+0x2b0>
    c464: e59d8030  ldr r8, [sp, #48] ; 0x30
    c468: e3e03e41  mvn r3, #1040 ; 0x410
    c46c: e59d1034  ldr r1, [sp, #52] ; 0x34
    c470: e0881001  add r1, r8, r1
    c474: e1510003  cmp r1, r3
    c478: ba00014b  blt c9ac <_dtoa_r+0x678>
    c47c: e2813e41  add r3, r1, #1040 ; 0x410
    c480: e30f2c0e  movw  r2, #64526  ; 0xfc0e
    c484: e2833002  add r3, r3, #2
    c488: e34f2fff  movt  r2, #65535  ; 0xffff
    c48c: e1a0333a  lsr r3, sl, r3
    c490: e0612002  rsb r2, r1, r2
    c494: e1833215  orr r3, r3, r5, lsl r2
    c498: ee073a90  vmov  s15, r3
    c49c: eef80b67  vcvt.f64.u32  d16, s15
    c4a0: e2411001  sub r1, r1, #1
    c4a4: e3a00001  mov r0, #1
    c4a8: e58d0020  str r0, [sp, #32]
    c4ac: ec532b30  vmov  r2, r3, d16
    c4b0: e243361f  sub r3, r3, #32505856 ; 0x1f00000
    c4b4: eef71b08  vmov.f64  d17, #120 ; 0x78
    c4b8: ec432b34  vmov  d20, r2, r3
    c4bc: eddf3b8d  vldr  d19, [pc, #564] ; c6f8 <_dtoa_r+0x3c4>
    c4c0: eddf0b8e  vldr  d16, [pc, #568] ; c700 <_dtoa_r+0x3cc>
    c4c4: ee071a90  vmov  s15, r1
    c4c8: ee741be1  vsub.f64  d17, d20, d17
    c4cc: eddf2b8d  vldr  d18, [pc, #564] ; c708 <_dtoa_r+0x3d4>
    c4d0: ee410ba3  vmla.f64  d16, d17, d19
    c4d4: eef81be7  vcvt.f64.s32  d17, s15
    c4d8: ee410ba2  vmla.f64  d16, d17, d18
    c4dc: eefd7be0  vcvt.s32.f64  s15, d16
    c4e0: eef50bc0  vcmpe.f64 d16, #0.0
    c4e4: edcd7a02  vstr  s15, [sp, #8]
    c4e8: eef1fa10  vmrs  APSR_nzcv, fpscr
    c4ec: 4a000127  bmi c990 <_dtoa_r+0x65c>
    c4f0: e59d3008  ldr r3, [sp, #8]
    c4f4: e3530016  cmp r3, #22
    c4f8: 83a03001  movhi r3, #1
    c4fc: 858d301c  strhi r3, [sp, #28]
    c500: 8a00000c  bhi c538 <_dtoa_r+0x204>
    c504: e59d2008  ldr r2, [sp, #8]
    c508: e30835b0  movw  r3, #34224  ; 0x85b0
    c50c: e3403001  movt  r3, #1
    c510: ec4bab31  vmov  d17, sl, fp
    c514: e0833182  add r3, r3, r2, lsl #3
    c518: edd30b00  vldr  d16, [r3]
    c51c: eef40be1  vcmpe.f64 d16, d17
    c520: eef1fa10  vmrs  APSR_nzcv, fpscr
    c524: c1a03002  movgt r3, r2
    c528: c2433001  subgt r3, r3, #1
    c52c: c58d3008  strgt r3, [sp, #8]
    c530: e3a03000  mov r3, #0
    c534: e58d301c  str r3, [sp, #28]
    c538: e0618008  rsb r8, r1, r8
    c53c: e59d3008  ldr r3, [sp, #8]
    c540: e2588001  subs  r8, r8, #1
    c544: 42687000  rsbmi r7, r8, #0
    c548: 53a07000  movpl r7, #0
    c54c: 43a08000  movmi r8, #0
    c550: e3530000  cmp r3, #0
    c554: a58d3018  strge r3, [sp, #24]
    c558: a0888003  addge r8, r8, r3
    c55c: b59d3008  ldrlt r3, [sp, #8]
    c560: a3a03000  movge r3, #0
    c564: a58d300c  strge r3, [sp, #12]
    c568: b0637007  rsblt r7, r3, r7
    c56c: b2633000  rsblt r3, r3, #0
    c570: b58d300c  strlt r3, [sp, #12]
    c574: b3a03000  movlt r3, #0
    c578: b58d3018  strlt r3, [sp, #24]
    c57c: e59d3068  ldr r3, [sp, #104]  ; 0x68
    c580: e3530009  cmp r3, #9
    c584: 8a000024  bhi c61c <_dtoa_r+0x2e8>
    c588: e3530005  cmp r3, #5
    c58c: d3a05001  movle r5, #1
    c590: c3a05000  movgt r5, #0
    c594: c2433004  subgt r3, r3, #4
    c598: c58d3068  strgt r3, [sp, #104]  ; 0x68
    c59c: e59d3068  ldr r3, [sp, #104]  ; 0x68
    c5a0: e2433002  sub r3, r3, #2
    c5a4: e3530003  cmp r3, #3
    c5a8: 979ff103  ldrls pc, [pc, r3, lsl #2]
    c5ac: ea000104  b c9c4 <_dtoa_r+0x690>
    c5b0: 0000cce4  .word 0x0000cce4
    c5b4: 0000cca4  .word 0x0000cca4
    c5b8: 0000ca94  .word 0x0000ca94
    c5bc: 0000d57c  .word 0x0000d57c
    c5c0: e7f30055  ubfx  r0, r5, #0, #20
    c5c4: e3083778  movw  r3, #34680  ; 0x8778
    c5c8: e3500000  cmp r0, #0
    c5cc: e308276c  movw  r2, #34668  ; 0x876c
    c5d0: e3403001  movt  r3, #1
    c5d4: e3402001  movt  r2, #1
    c5d8: 11a00003  movne r0, r3
    c5dc: 01a00002  moveq r0, r2
    c5e0: eaffff8c  b c418 <_dtoa_r+0xe4>
    c5e4: e1a0300b  mov r3, fp
    c5e8: e7f30053  ubfx  r0, r3, #0, #20
    c5ec: e2481fff  sub r1, r8, #1020 ; 0x3fc
    c5f0: e38035ff  orr r3, r0, #1069547520 ; 0x3fc00000
    c5f4: e1a0200a  mov r2, sl
    c5f8: e3a00000  mov r0, #0
    c5fc: e2411003  sub r1, r1, #3
    c600: e59d8030  ldr r8, [sp, #48] ; 0x30
    c604: e3833603  orr r3, r3, #3145728  ; 0x300000
    c608: e58d0020  str r0, [sp, #32]
    c60c: eaffffa8  b c4b4 <_dtoa_r+0x180>
    c610: e3080768  movw  r0, #34664  ; 0x8768
    c614: e3400001  movt  r0, #1
    c618: eaffff74  b c3f0 <_dtoa_r+0xbc>
    c61c: e3e03000  mvn r3, #0
    c620: e3a01000  mov r1, #0
    c624: e1a00004  mov r0, r4
    c628: e5841044  str r1, [r4, #68] ; 0x44
    c62c: e1a05003  mov r5, r3
    c630: e58d3024  str r3, [sp, #36] ; 0x24
    c634: e58d106c  str r1, [sp, #108]  ; 0x6c
    c638: eb00094f  bl  eb7c <_Balloc>
    c63c: e59d306c  ldr r3, [sp, #108]  ; 0x6c
    c640: e58d5010  str r5, [sp, #16]
    c644: e58d3068  str r3, [sp, #104]  ; 0x68
    c648: e3a03001  mov r3, #1
    c64c: e58d3014  str r3, [sp, #20]
    c650: e1a06000  mov r6, r0
    c654: e5840040  str r0, [r4, #64] ; 0x40
    c658: e59d2008  ldr r2, [sp, #8]
    c65c: e59d3034  ldr r3, [sp, #52] ; 0x34
    c660: e352000e  cmp r2, #14
    c664: c3a02000  movgt r2, #0
    c668: d3a02001  movle r2, #1
    c66c: e3530000  cmp r3, #0
    c670: b3a02000  movlt r2, #0
    c674: e3520000  cmp r2, #0
    c678: 0a000025  beq c714 <_dtoa_r+0x3e0>
    c67c: e59d206c  ldr r2, [sp, #108]  ; 0x6c
    c680: e30835b0  movw  r3, #34224  ; 0x85b0
    c684: e59d1010  ldr r1, [sp, #16]
    c688: e3403001  movt  r3, #1
    c68c: e1a02fa2  lsr r2, r2, #31
    c690: e3510000  cmp r1, #0
    c694: c3a02000  movgt r2, #0
    c698: d2022001  andle r2, r2, #1
    c69c: e3520000  cmp r2, #0
    c6a0: e59d2008  ldr r2, [sp, #8]
    c6a4: e0833182  add r3, r3, r2, lsl #3
    c6a8: edd32b00  vldr  d18, [r3]
    c6ac: 0a00018f  beq ccf0 <_dtoa_r+0x9bc>
    c6b0: e59d3010  ldr r3, [sp, #16]
    c6b4: e3530000  cmp r3, #0
    c6b8: 1a0001df  bne ce3c <_dtoa_r+0xb08>
    c6bc: eef10b04  vmov.f64  d16, #20
    c6c0: ee622ba0  vmul.f64  d18, d18, d16
    c6c4: ec4bab30  vmov  d16, sl, fp
    c6c8: eef42be0  vcmpe.f64 d18, d16
    c6cc: eef1fa10  vmrs  APSR_nzcv, fpscr
    c6d0: ba000220  blt cf58 <_dtoa_r+0xc24>
    c6d4: e59d3010  ldr r3, [sp, #16]
    c6d8: e1a05003  mov r5, r3
    c6dc: e58d300c  str r3, [sp, #12]
    c6e0: e59d306c  ldr r3, [sp, #108]  ; 0x6c
    c6e4: e1e03003  mvn r3, r3
    c6e8: e58d3008  str r3, [sp, #8]
    c6ec: e1a03006  mov r3, r6
    c6f0: ea000085  b c90c <_dtoa_r+0x5d8>
    c6f4: e320f000  nop {0}
    c6f8: 636f4361  .word 0x636f4361
    c6fc: 3fd287a7  .word 0x3fd287a7
    c700: 8b60c8b3  .word 0x8b60c8b3
    c704: 3fc68a28  .word 0x3fc68a28
    c708: 509f79fb  .word 0x509f79fb
    c70c: 3fd34413  .word 0x3fd34413
    c710: 00018769  .word 0x00018769
    c714: e59d2014  ldr r2, [sp, #20]
    c718: e3520000  cmp r2, #0
    c71c: 1a0000be  bne ca1c <_dtoa_r+0x6e8>
    c720: e59d300c  ldr r3, [sp, #12]
    c724: e59d5014  ldr r5, [sp, #20]
    c728: e58d7020  str r7, [sp, #32]
    c72c: e58d3028  str r3, [sp, #40] ; 0x28
    c730: e59d3020  ldr r3, [sp, #32]
    c734: e3580000  cmp r8, #0
    c738: c3530000  cmpgt r3, #0
    c73c: da000006  ble c75c <_dtoa_r+0x428>
    c740: e1580003  cmp r8, r3
    c744: e1a02003  mov r2, r3
    c748: b1a03008  movlt r3, r8
    c74c: e0637007  rsb r7, r3, r7
    c750: e0638008  rsb r8, r3, r8
    c754: e0632002  rsb r2, r3, r2
    c758: e58d2020  str r2, [sp, #32]
    c75c: e59d300c  ldr r3, [sp, #12]
    c760: e3530000  cmp r3, #0
    c764: da000018  ble c7cc <_dtoa_r+0x498>
    c768: e59d3014  ldr r3, [sp, #20]
    c76c: e3530000  cmp r3, #0
    c770: 0a0002f2  beq d340 <_dtoa_r+0x100c>
    c774: e59d3028  ldr r3, [sp, #40] ; 0x28
    c778: e3530000  cmp r3, #0
    c77c: da00000e  ble c7bc <_dtoa_r+0x488>
    c780: e1a02003  mov r2, r3
    c784: e1a01005  mov r1, r5
    c788: e1a00004  mov r0, r4
    c78c: eb000a4d  bl  f0c8 <__pow5mult>
    c790: e1a02009  mov r2, r9
    c794: e1a05000  mov r5, r0
    c798: e1a00004  mov r0, r4
    c79c: e1a01005  mov r1, r5
    c7a0: eb0009d1  bl  eeec <__multiply>
    c7a4: e1a01009  mov r1, r9
    c7a8: e58d002c  str r0, [sp, #44] ; 0x2c
    c7ac: e1a00004  mov r0, r4
    c7b0: eb000914  bl  ec08 <_Bfree>
    c7b4: e59d302c  ldr r3, [sp, #44] ; 0x2c
    c7b8: e1a09003  mov r9, r3
    c7bc: e59d300c  ldr r3, [sp, #12]
    c7c0: e59d2028  ldr r2, [sp, #40] ; 0x28
    c7c4: e0532002  subs  r2, r3, r2
    c7c8: 1a0002fb  bne d3bc <_dtoa_r+0x1088>
    c7cc: e1a00004  mov r0, r4
    c7d0: e3a01001  mov r1, #1
    c7d4: eb0009bc  bl  eecc <__i2b>
    c7d8: e59d3018  ldr r3, [sp, #24]
    c7dc: e3530000  cmp r3, #0
    c7e0: e58d000c  str r0, [sp, #12]
    c7e4: da00017a  ble cdd4 <_dtoa_r+0xaa0>
    c7e8: e1a01000  mov r1, r0
    c7ec: e1a02003  mov r2, r3
    c7f0: e1a00004  mov r0, r4
    c7f4: eb000a33  bl  f0c8 <__pow5mult>
    c7f8: e59d3068  ldr r3, [sp, #104]  ; 0x68
    c7fc: e3530001  cmp r3, #1
    c800: e58d000c  str r0, [sp, #12]
    c804: da0002f1  ble d3d0 <_dtoa_r+0x109c>
    c808: e3a03000  mov r3, #0
    c80c: e58d3028  str r3, [sp, #40] ; 0x28
    c810: e59d200c  ldr r2, [sp, #12]
    c814: e5923010  ldr r3, [r2, #16]
    c818: e0823103  add r3, r2, r3, lsl #2
    c81c: e5930010  ldr r0, [r3, #16]
    c820: eb00096c  bl  edd8 <__hi0bits>
    c824: e2600020  rsb r0, r0, #32
    c828: e0800008  add r0, r0, r8
    c82c: e210001f  ands  r0, r0, #31
    c830: 0a0001c5  beq cf4c <_dtoa_r+0xc18>
    c834: e2603020  rsb r3, r0, #32
    c838: e3530004  cmp r3, #4
    c83c: da00034b  ble d570 <_dtoa_r+0x123c>
    c840: e260001c  rsb r0, r0, #28
    c844: e59d3020  ldr r3, [sp, #32]
    c848: e0877000  add r7, r7, r0
    c84c: e0888000  add r8, r8, r0
    c850: e0833000  add r3, r3, r0
    c854: e58d3020  str r3, [sp, #32]
    c858: e3570000  cmp r7, #0
    c85c: da000004  ble c874 <_dtoa_r+0x540>
    c860: e1a01009  mov r1, r9
    c864: e1a02007  mov r2, r7
    c868: e1a00004  mov r0, r4
    c86c: eb000a54  bl  f1c4 <__lshift>
    c870: e1a09000  mov r9, r0
    c874: e3580000  cmp r8, #0
    c878: da000004  ble c890 <_dtoa_r+0x55c>
    c87c: e59d100c  ldr r1, [sp, #12]
    c880: e1a02008  mov r2, r8
    c884: e1a00004  mov r0, r4
    c888: eb000a4d  bl  f1c4 <__lshift>
    c88c: e58d000c  str r0, [sp, #12]
    c890: e59d301c  ldr r3, [sp, #28]
    c894: e3530000  cmp r3, #0
    c898: 1a0001f9  bne d084 <_dtoa_r+0xd50>
    c89c: e59d3068  ldr r3, [sp, #104]  ; 0x68
    c8a0: e59d2010  ldr r2, [sp, #16]
    c8a4: e3530002  cmp r3, #2
    c8a8: c3a03001  movgt r3, #1
    c8ac: d3a03000  movle r3, #0
    c8b0: e3520000  cmp r2, #0
    c8b4: c3a03000  movgt r3, #0
    c8b8: e3530000  cmp r3, #0
    c8bc: 0a000162  beq ce4c <_dtoa_r+0xb18>
    c8c0: e59d3010  ldr r3, [sp, #16]
    c8c4: e3530000  cmp r3, #0
    c8c8: 1affff84  bne c6e0 <_dtoa_r+0x3ac>
    c8cc: e59d100c  ldr r1, [sp, #12]
    c8d0: e3a02005  mov r2, #5
    c8d4: e1a00004  mov r0, r4
    c8d8: eb0008d1  bl  ec24 <__multadd>
    c8dc: e1a01000  mov r1, r0
    c8e0: e58d000c  str r0, [sp, #12]
    c8e4: e1a00009  mov r0, r9
    c8e8: eb000a74  bl  f2c0 <__mcmp>
    c8ec: e3500000  cmp r0, #0
    c8f0: daffff7a  ble c6e0 <_dtoa_r+0x3ac>
    c8f4: e59d3008  ldr r3, [sp, #8]
    c8f8: e3a02031  mov r2, #49 ; 0x31
    c8fc: e5c62000  strb  r2, [r6]
    c900: e2833001  add r3, r3, #1
    c904: e58d3008  str r3, [sp, #8]
    c908: e2863001  add r3, r6, #1
    c90c: e59d100c  ldr r1, [sp, #12]
    c910: e1a00004  mov r0, r4
    c914: e58d3010  str r3, [sp, #16]
    c918: eb0008ba  bl  ec08 <_Bfree>
    c91c: e3550000  cmp r5, #0
    c920: e59d3010  ldr r3, [sp, #16]
    c924: 0a000004  beq c93c <_dtoa_r+0x608>
    c928: e1a01005  mov r1, r5
    c92c: e1a00004  mov r0, r4
    c930: e58d300c  str r3, [sp, #12]
    c934: eb0008b3  bl  ec08 <_Bfree>
    c938: e59d300c  ldr r3, [sp, #12]
    c93c: e1a00004  mov r0, r4
    c940: e1a01009  mov r1, r9
    c944: e58d300c  str r3, [sp, #12]
    c948: eb0008ae  bl  ec08 <_Bfree>
    c94c: e59d3078  ldr r3, [sp, #120]  ; 0x78
    c950: e3a01000  mov r1, #0
    c954: e3530000  cmp r3, #0
    c958: e59d3008  ldr r3, [sp, #8]
    c95c: e2832001  add r2, r3, #1
    c960: e59d300c  ldr r3, [sp, #12]
    c964: 01a00006  moveq r0, r6
    c968: e5c31000  strb  r1, [r3]
    c96c: e59d1070  ldr r1, [sp, #112]  ; 0x70
    c970: e5812000  str r2, [r1]
    c974: 0afffe9d  beq c3f0 <_dtoa_r+0xbc>
    c978: e59d2078  ldr r2, [sp, #120]  ; 0x78
    c97c: e1a00006  mov r0, r6
    c980: e5823000  str r3, [r2]
    c984: e28dd03c  add sp, sp, #60 ; 0x3c
    c988: ecbd8b02  vpop  {d8}
    c98c: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    c990: eef81be7  vcvt.f64.s32  d17, s15
    c994: eef41b60  vcmp.f64  d17, d16
    c998: eef1fa10  vmrs  APSR_nzcv, fpscr
    c99c: 1e173a90  vmovne  r3, s15
    c9a0: 12433001  subne r3, r3, #1
    c9a4: 158d3008  strne r3, [sp, #8]
    c9a8: eafffed0  b c4f0 <_dtoa_r+0x1bc>
    c9ac: e30f3bee  movw  r3, #64494  ; 0xfbee
    c9b0: e34f3fff  movt  r3, #65535  ; 0xffff
    c9b4: e0613003  rsb r3, r1, r3
    c9b8: e1a0331a  lsl r3, sl, r3
    c9bc: ee073a90  vmov  s15, r3
    c9c0: eafffeb5  b c49c <_dtoa_r+0x168>
    c9c4: e3a05000  mov r5, #0
    c9c8: e1a00004  mov r0, r4
    c9cc: e5845044  str r5, [r4, #68] ; 0x44
    c9d0: e1a01005  mov r1, r5
    c9d4: eb000868  bl  eb7c <_Balloc>
    c9d8: e59d2008  ldr r2, [sp, #8]
    c9dc: e59d3034  ldr r3, [sp, #52] ; 0x34
    c9e0: e352000e  cmp r2, #14
    c9e4: c3a02000  movgt r2, #0
    c9e8: d3a02001  movle r2, #1
    c9ec: e1530005  cmp r3, r5
    c9f0: b3a02000  movlt r2, #0
    c9f4: e1520005  cmp r2, r5
    c9f8: e1a06000  mov r6, r0
    c9fc: e5840040  str r0, [r4, #64] ; 0x40
    ca00: 1a0002e0  bne d588 <_dtoa_r+0x1254>
    ca04: e3e01000  mvn r1, #0
    ca08: e58d206c  str r2, [sp, #108]  ; 0x6c
    ca0c: e58d1010  str r1, [sp, #16]
    ca10: e3a02001  mov r2, #1
    ca14: e58d1024  str r1, [sp, #36] ; 0x24
    ca18: e58d2014  str r2, [sp, #20]
    ca1c: e59d2068  ldr r2, [sp, #104]  ; 0x68
    ca20: e3520001  cmp r2, #1
    ca24: da000272  ble d3f4 <_dtoa_r+0x10c0>
    ca28: e59d3010  ldr r3, [sp, #16]
    ca2c: e2432001  sub r2, r3, #1
    ca30: e59d300c  ldr r3, [sp, #12]
    ca34: e1530002  cmp r3, r2
    ca38: a0623003  rsbge r3, r2, r3
    ca3c: b59d300c  ldrlt r3, [sp, #12]
    ca40: b58d200c  strlt r2, [sp, #12]
    ca44: b0633002  rsblt r3, r3, r2
    ca48: b59d2018  ldrlt r2, [sp, #24]
    ca4c: b0823003  addlt r3, r2, r3
    ca50: b58d3018  strlt r3, [sp, #24]
    ca54: b3a03000  movlt r3, #0
    ca58: e58d3028  str r3, [sp, #40] ; 0x28
    ca5c: e59d3010  ldr r3, [sp, #16]
    ca60: e3530000  cmp r3, #0
    ca64: a58d7020  strge r7, [sp, #32]
    ca68: b0633007  rsblt r3, r3, r7
    ca6c: b58d3020  strlt r3, [sp, #32]
    ca70: a59d3010  ldrge r3, [sp, #16]
    ca74: b3a03000  movlt r3, #0
    ca78: e1a00004  mov r0, r4
    ca7c: e3a01001  mov r1, #1
    ca80: e0877003  add r7, r7, r3
    ca84: e0888003  add r8, r8, r3
    ca88: eb00090f  bl  eecc <__i2b>
    ca8c: e1a05000  mov r5, r0
    ca90: eaffff26  b c730 <_dtoa_r+0x3fc>
    ca94: e3a03001  mov r3, #1
    ca98: e58d3014  str r3, [sp, #20]
    ca9c: e59d306c  ldr r3, [sp, #108]  ; 0x6c
    caa0: e3530000  cmp r3, #0
    caa4: da000220  ble d32c <_dtoa_r+0xff8>
    caa8: e353000e  cmp r3, #14
    caac: 83a05000  movhi r5, #0
    cab0: 92055001  andls r5, r5, #1
    cab4: e1a0c003  mov ip, r3
    cab8: e58d3024  str r3, [sp, #36] ; 0x24
    cabc: e58d3010  str r3, [sp, #16]
    cac0: e35c0017  cmp ip, #23
    cac4: e3a01000  mov r1, #0
    cac8: e5841044  str r1, [r4, #68] ; 0x44
    cacc: 9a000008  bls caf4 <_dtoa_r+0x7c0>
    cad0: e3a02001  mov r2, #1
    cad4: e3a03004  mov r3, #4
    cad8: e1a03083  lsl r3, r3, #1
    cadc: e1a01002  mov r1, r2
    cae0: e2830014  add r0, r3, #20
    cae4: e2822001  add r2, r2, #1
    cae8: e150000c  cmp r0, ip
    caec: 9afffff9  bls cad8 <_dtoa_r+0x7a4>
    caf0: e5841044  str r1, [r4, #68] ; 0x44
    caf4: e1a00004  mov r0, r4
    caf8: eb00081f  bl  eb7c <_Balloc>
    cafc: e3550000  cmp r5, #0
    cb00: e1a06000  mov r6, r0
    cb04: e5840040  str r0, [r4, #64] ; 0x40
    cb08: 0afffed2  beq c658 <_dtoa_r+0x324>
    cb0c: e59d3008  ldr r3, [sp, #8]
    cb10: ec4bab35  vmov  d21, sl, fp
    cb14: e3530000  cmp r3, #0
    cb18: da000113  ble cf6c <_dtoa_r+0xc38>
    cb1c: e203100f  and r1, r3, #15
    cb20: e30825b0  movw  r2, #34224  ; 0x85b0
    cb24: e1a03243  asr r3, r3, #4
    cb28: e3402001  movt  r2, #1
    cb2c: e3130010  tst r3, #16
    cb30: e0822181  add r2, r2, r1, lsl #3
    cb34: 1203300f  andne r3, r3, #15
    cb38: edd20b00  vldr  d16, [r2]
    cb3c: 130826a0  movwne  r2, #34464  ; 0x86a0
    cb40: 13402001  movtne  r2, #1
    cb44: 13a01003  movne r1, #3
    cb48: 03a01002  moveq r1, #2
    cb4c: 1dd23b08  vldrne  d19, [r2, #32]
    cb50: 0ef03b65  vmoveq.f64  d19, d21
    cb54: 1ec53ba3  vdivne.f64  d19, d21, d19
    cb58: e3530000  cmp r3, #0
    cb5c: 0a000008  beq cb84 <_dtoa_r+0x850>
    cb60: e30826a0  movw  r2, #34464  ; 0x86a0
    cb64: e3402001  movt  r2, #1
    cb68: e3130001  tst r3, #1
    cb6c: e2822008  add r2, r2, #8
    cb70: 12811001  addne r1, r1, #1
    cb74: 1d521b02  vldrne  d17, [r2, #-8]
    cb78: 1e600ba1  vmulne.f64  d16, d16, d17
    cb7c: e1b030c3  asrs  r3, r3, #1
    cb80: 1afffff8  bne cb68 <_dtoa_r+0x834>
    cb84: eec33ba0  vdiv.f64  d19, d19, d16
    cb88: e59d301c  ldr r3, [sp, #28]
    cb8c: e3530000  cmp r3, #0
    cb90: 0a000003  beq cba4 <_dtoa_r+0x870>
    cb94: eef70b00  vmov.f64  d16, #112 ; 0x70
    cb98: eef43be0  vcmpe.f64 d19, d16
    cb9c: eef1fa10  vmrs  APSR_nzcv, fpscr
    cba0: 4a0001f2  bmi d370 <_dtoa_r+0x103c>
    cba4: eef12b0c  vmov.f64  d18, #28
    cba8: e59d3010  ldr r3, [sp, #16]
    cbac: ee071a90  vmov  s15, r1
    cbb0: e3530000  cmp r3, #0
    cbb4: eef80be7  vcvt.f64.s32  d16, s15
    cbb8: ee402ba3  vmla.f64  d18, d16, d19
    cbbc: ec5bab32  vmov  sl, fp, d18
    cbc0: e24bb50d  sub fp, fp, #54525952 ; 0x3400000
    cbc4: 0a000092  beq ce14 <_dtoa_r+0xae0>
    cbc8: e59de008  ldr lr, [sp, #8]
    cbcc: e59d0010  ldr r0, [sp, #16]
    cbd0: e59d3014  ldr r3, [sp, #20]
    cbd4: e3530000  cmp r3, #0
    cbd8: 0a0000fc  beq cfd0 <_dtoa_r+0xc9c>
    cbdc: eef61b00  vmov.f64  d17, #96  ; 0x60
    cbe0: e2402001  sub r2, r0, #1
    cbe4: e30815b0  movw  r1, #34224  ; 0x85b0
    cbe8: e2863001  add r3, r6, #1
    cbec: e3401001  movt  r1, #1
    cbf0: e0812182  add r2, r1, r2, lsl #3
    cbf4: edd22b00  vldr  d18, [r2]
    cbf8: eec11ba2  vdiv.f64  d17, d17, d18
    cbfc: ec4bab32  vmov  d18, sl, fp
    cc00: eefd7be3  vcvt.s32.f64  s15, d19
    cc04: ee172a90  vmov  r2, s15
    cc08: eef80be7  vcvt.f64.s32  d16, s15
    cc0c: ee712be2  vsub.f64  d18, d17, d18
    cc10: ee730be0  vsub.f64  d16, d19, d16
    cc14: e2822030  add r2, r2, #48 ; 0x30
    cc18: e6ef2072  uxtb  r2, r2
    cc1c: e5c62000  strb  r2, [r6]
    cc20: eef42be0  vcmpe.f64 d18, d16
    cc24: eef1fa10  vmrs  APSR_nzcv, fpscr
    cc28: ca00001b  bgt cc9c <_dtoa_r+0x968>
    cc2c: eef74b00  vmov.f64  d20, #112 ; 0x70
    cc30: ee741be0  vsub.f64  d17, d20, d16
    cc34: eef42be1  vcmpe.f64 d18, d17
    cc38: eef1fa10  vmrs  APSR_nzcv, fpscr
    cc3c: ca000057  bgt cda0 <_dtoa_r+0xa6c>
    cc40: e3500001  cmp r0, #1
    cc44: da0000c6  ble cf64 <_dtoa_r+0xc30>
    cc48: e0860000  add r0, r6, r0
    cc4c: eef23b04  vmov.f64  d19, #36  ; 0x24
    cc50: ea000005  b cc6c <_dtoa_r+0x938>
    cc54: ee741be0  vsub.f64  d17, d20, d16
    cc58: eef41be2  vcmpe.f64 d17, d18
    cc5c: eef1fa10  vmrs  APSR_nzcv, fpscr
    cc60: 4a00004e  bmi cda0 <_dtoa_r+0xa6c>
    cc64: e1530000  cmp r3, r0
    cc68: 0a0000bd  beq cf64 <_dtoa_r+0xc30>
    cc6c: ee600ba3  vmul.f64  d16, d16, d19
    cc70: eefd7be0  vcvt.s32.f64  s15, d16
    cc74: ee172a90  vmov  r2, s15
    cc78: ee622ba3  vmul.f64  d18, d18, d19
    cc7c: eef81be7  vcvt.f64.s32  d17, s15
    cc80: e2822030  add r2, r2, #48 ; 0x30
    cc84: e6ef2072  uxtb  r2, r2
    cc88: e4c32001  strb  r2, [r3], #1
    cc8c: ee700be1  vsub.f64  d16, d16, d17
    cc90: eef40be2  vcmpe.f64 d16, d18
    cc94: eef1fa10  vmrs  APSR_nzcv, fpscr
    cc98: 5affffed  bpl cc54 <_dtoa_r+0x920>
    cc9c: e58de008  str lr, [sp, #8]
    cca0: eaffff25  b c93c <_dtoa_r+0x608>
    cca4: e3a03000  mov r3, #0
    cca8: e58d3014  str r3, [sp, #20]
    ccac: e59d306c  ldr r3, [sp, #108]  ; 0x6c
    ccb0: e59d2008  ldr r2, [sp, #8]
    ccb4: e0833002  add r3, r3, r2
    ccb8: e58d3024  str r3, [sp, #36] ; 0x24
    ccbc: e2833001  add r3, r3, #1
    ccc0: e58d3010  str r3, [sp, #16]
    ccc4: e3530000  cmp r3, #0
    ccc8: da000190  ble d310 <_dtoa_r+0xfdc>
    cccc: e59d3010  ldr r3, [sp, #16]
    ccd0: e353000e  cmp r3, #14
    ccd4: 83a05000  movhi r5, #0
    ccd8: 92055001  andls r5, r5, #1
    ccdc: e1a0c003  mov ip, r3
    cce0: eaffff76  b cac0 <_dtoa_r+0x78c>
    cce4: e3a03000  mov r3, #0
    cce8: e58d3014  str r3, [sp, #20]
    ccec: eaffff6a  b ca9c <_dtoa_r+0x768>
    ccf0: ec4bab30  vmov  d16, sl, fp
    ccf4: e3510001  cmp r1, #1
    ccf8: e2863001  add r3, r6, #1
    ccfc: eec01ba2  vdiv.f64  d17, d16, d18
    cd00: eefd7be1  vcvt.s32.f64  s15, d17
    cd04: ee172a90  vmov  r2, s15
    cd08: eef81be7  vcvt.f64.s32  d17, s15
    cd0c: ee410be2  vmls.f64  d16, d17, d18
    cd10: e2822030  add r2, r2, #48 ; 0x30
    cd14: e5c62000  strb  r2, [r6]
    cd18: 0a000014  beq cd70 <_dtoa_r+0xa3c>
    cd1c: eef23b04  vmov.f64  d19, #36  ; 0x24
    cd20: ee600ba3  vmul.f64  d16, d16, d19
    cd24: eef50b40  vcmp.f64  d16, #0.0
    cd28: eef1fa10  vmrs  APSR_nzcv, fpscr
    cd2c: 159d1010  ldrne r1, [sp, #16]
    cd30: 1a000004  bne cd48 <_dtoa_r+0xa14>
    cd34: eaffff00  b c93c <_dtoa_r+0x608>
    cd38: ee600ba3  vmul.f64  d16, d16, d19
    cd3c: eef50b40  vcmp.f64  d16, #0.0
    cd40: eef1fa10  vmrs  APSR_nzcv, fpscr
    cd44: 0afffefc  beq c93c <_dtoa_r+0x608>
    cd48: eec01ba2  vdiv.f64  d17, d16, d18
    cd4c: eefd7be1  vcvt.s32.f64  s15, d17
    cd50: ee172a90  vmov  r2, s15
    cd54: eef81be7  vcvt.f64.s32  d17, s15
    cd58: ee410be2  vmls.f64  d16, d17, d18
    cd5c: e2822030  add r2, r2, #48 ; 0x30
    cd60: e4c32001  strb  r2, [r3], #1
    cd64: e0662003  rsb r2, r6, r3
    cd68: e1510002  cmp r1, r2
    cd6c: 1afffff1  bne cd38 <_dtoa_r+0xa04>
    cd70: ee700ba0  vadd.f64  d16, d16, d16
    cd74: eef42be0  vcmpe.f64 d18, d16
    cd78: eef1fa10  vmrs  APSR_nzcv, fpscr
    cd7c: 4a000005  bmi cd98 <_dtoa_r+0xa64>
    cd80: eef42b60  vcmp.f64  d18, d16
    cd84: eef1fa10  vmrs  APSR_nzcv, fpscr
    cd88: 1afffeeb  bne c93c <_dtoa_r+0x608>
    cd8c: ee172a90  vmov  r2, s15
    cd90: e3120001  tst r2, #1
    cd94: 0afffee8  beq c93c <_dtoa_r+0x608>
    cd98: e59de008  ldr lr, [sp, #8]
    cd9c: e5532001  ldrb  r2, [r3, #-1]
    cda0: e2431001  sub r1, r3, #1
    cda4: ea000002  b cdb4 <_dtoa_r+0xa80>
    cda8: e1510006  cmp r1, r6
    cdac: 0a000169  beq d358 <_dtoa_r+0x1024>
    cdb0: e5712001  ldrb  r2, [r1, #-1]!
    cdb4: e3520039  cmp r2, #57 ; 0x39
    cdb8: e2813001  add r3, r1, #1
    cdbc: 0afffff9  beq cda8 <_dtoa_r+0xa74>
    cdc0: e2822001  add r2, r2, #1
    cdc4: e58de008  str lr, [sp, #8]
    cdc8: e6ef2072  uxtb  r2, r2
    cdcc: e5c12000  strb  r2, [r1]
    cdd0: eafffed9  b c93c <_dtoa_r+0x608>
    cdd4: e59d3068  ldr r3, [sp, #104]  ; 0x68
    cdd8: e3530001  cmp r3, #1
    cddc: da0000c7  ble d100 <_dtoa_r+0xdcc>
    cde0: e3a03000  mov r3, #0
    cde4: e58d3028  str r3, [sp, #40] ; 0x28
    cde8: e59d3018  ldr r3, [sp, #24]
    cdec: e3530000  cmp r3, #0
    cdf0: 03a00001  moveq r0, #1
    cdf4: 0afffe8b  beq c828 <_dtoa_r+0x4f4>
    cdf8: eafffe84  b c810 <_dtoa_r+0x4dc>
    cdfc: eef12b0c  vmov.f64  d18, #28
    ce00: ee071a90  vmov  s15, r1
    ce04: eef81be7  vcvt.f64.s32  d17, s15
    ce08: ee432ba1  vmla.f64  d18, d19, d17
    ce0c: ec5bab32  vmov  sl, fp, d18
    ce10: e24bb50d  sub fp, fp, #54525952 ; 0x3400000
    ce14: eef10b04  vmov.f64  d16, #20
    ce18: ec4bab32  vmov  d18, sl, fp
    ce1c: ee730be0  vsub.f64  d16, d19, d16
    ce20: eef40be2  vcmpe.f64 d16, d18
    ce24: eef1fa10  vmrs  APSR_nzcv, fpscr
    ce28: ca000049  bgt cf54 <_dtoa_r+0xc20>
    ce2c: eef12b62  vneg.f64  d18, d18
    ce30: eef40be2  vcmpe.f64 d16, d18
    ce34: eef1fa10  vmrs  APSR_nzcv, fpscr
    ce38: 5a000049  bpl cf64 <_dtoa_r+0xc30>
    ce3c: e3a03000  mov r3, #0
    ce40: e58d300c  str r3, [sp, #12]
    ce44: e1a05003  mov r5, r3
    ce48: eafffe24  b c6e0 <_dtoa_r+0x3ac>
    ce4c: e59d3014  ldr r3, [sp, #20]
    ce50: e3530000  cmp r3, #0
    ce54: 1a0000c9  bne d180 <_dtoa_r+0xe4c>
    ce58: e1a07006  mov r7, r6
    ce5c: e59da00c  ldr sl, [sp, #12]
    ce60: e59db010  ldr fp, [sp, #16]
    ce64: ea000001  b ce70 <_dtoa_r+0xb3c>
    ce68: eb00076d  bl  ec24 <__multadd>
    ce6c: e1a09000  mov r9, r0
    ce70: e1a0100a  mov r1, sl
    ce74: e1a00009  mov r0, r9
    ce78: ebfffcbc  bl  c170 <quorem>
    ce7c: e1a01009  mov r1, r9
    ce80: e3a0200a  mov r2, #10
    ce84: e3a03000  mov r3, #0
    ce88: e2808030  add r8, r0, #48 ; 0x30
    ce8c: e4c78001  strb  r8, [r7], #1
    ce90: e066c007  rsb ip, r6, r7
    ce94: e1a00004  mov r0, r4
    ce98: e15c000b  cmp ip, fp
    ce9c: bafffff1  blt ce68 <_dtoa_r+0xb34>
    cea0: e59d3010  ldr r3, [sp, #16]
    cea4: e3a0a000  mov sl, #0
    cea8: e3530001  cmp r3, #1
    ceac: a0863003  addge r3, r6, r3
    ceb0: b2863001  addlt r3, r6, #1
    ceb4: e1a01009  mov r1, r9
    ceb8: e3a02001  mov r2, #1
    cebc: e1a00004  mov r0, r4
    cec0: e58d3010  str r3, [sp, #16]
    cec4: eb0008be  bl  f1c4 <__lshift>
    cec8: e59d100c  ldr r1, [sp, #12]
    cecc: e1a09000  mov r9, r0
    ced0: eb0008fa  bl  f2c0 <__mcmp>
    ced4: e59d3010  ldr r3, [sp, #16]
    ced8: e3500000  cmp r0, #0
    cedc: da000167  ble d480 <_dtoa_r+0x114c>
    cee0: e5531001  ldrb  r1, [r3, #-1]
    cee4: e2432001  sub r2, r3, #1
    cee8: ea000002  b cef8 <_dtoa_r+0xbc4>
    ceec: e1520006  cmp r2, r6
    cef0: 0a000139  beq d3dc <_dtoa_r+0x10a8>
    cef4: e5721001  ldrb  r1, [r2, #-1]!
    cef8: e3510039  cmp r1, #57 ; 0x39
    cefc: e2823001  add r3, r2, #1
    cf00: 0afffff9  beq ceec <_dtoa_r+0xbb8>
    cf04: e2811001  add r1, r1, #1
    cf08: e5c21000  strb  r1, [r2]
    cf0c: e59d100c  ldr r1, [sp, #12]
    cf10: e1a00004  mov r0, r4
    cf14: e58d3010  str r3, [sp, #16]
    cf18: eb00073a  bl  ec08 <_Bfree>
    cf1c: e3550000  cmp r5, #0
    cf20: e59d3010  ldr r3, [sp, #16]
    cf24: 0afffe84  beq c93c <_dtoa_r+0x608>
    cf28: e15a0005  cmp sl, r5
    cf2c: 135a0000  cmpne sl, #0
    cf30: 0afffe7c  beq c928 <_dtoa_r+0x5f4>
    cf34: e1a0100a  mov r1, sl
    cf38: e1a00004  mov r0, r4
    cf3c: e58d300c  str r3, [sp, #12]
    cf40: eb000730  bl  ec08 <_Bfree>
    cf44: e59d300c  ldr r3, [sp, #12]
    cf48: eafffe76  b c928 <_dtoa_r+0x5f4>
    cf4c: e3a0001c  mov r0, #28
    cf50: eafffe3b  b c844 <_dtoa_r+0x510>
    cf54: e3a03000  mov r3, #0
    cf58: e58d300c  str r3, [sp, #12]
    cf5c: e1a05003  mov r5, r3
    cf60: eafffe63  b c8f4 <_dtoa_r+0x5c0>
    cf64: ec5bab35  vmov  sl, fp, d21
    cf68: eafffdba  b c658 <_dtoa_r+0x324>
    cf6c: e59d3008  ldr r3, [sp, #8]
    cf70: e2633000  rsb r3, r3, #0
    cf74: e3530000  cmp r3, #0
    cf78: 0ef03b65  vmoveq.f64  d19, d21
    cf7c: 03a01002  moveq r1, #2
    cf80: 0affff00  beq cb88 <_dtoa_r+0x854>
    cf84: e203100f  and r1, r3, #15
    cf88: e30825b0  movw  r2, #34224  ; 0x85b0
    cf8c: e3402001  movt  r2, #1
    cf90: e1b00243  asrs  r0, r3, #4
    cf94: e0822181  add r2, r2, r1, lsl #3
    cf98: edd20b00  vldr  d16, [r2]
    cf9c: ee653ba0  vmul.f64  d19, d21, d16
    cfa0: 0a00016c  beq d558 <_dtoa_r+0x1224>
    cfa4: e30836a0  movw  r3, #34464  ; 0x86a0
    cfa8: e3a01002  mov r1, #2
    cfac: e3403001  movt  r3, #1
    cfb0: e3100001  tst r0, #1
    cfb4: e2833008  add r3, r3, #8
    cfb8: 12811001  addne r1, r1, #1
    cfbc: 1d530b02  vldrne  d16, [r3, #-8]
    cfc0: 1e633ba0  vmulne.f64  d19, d19, d16
    cfc4: e1b000c0  asrs  r0, r0, #1
    cfc8: 1afffff8  bne cfb0 <_dtoa_r+0xc7c>
    cfcc: eafffeed  b cb88 <_dtoa_r+0x854>
    cfd0: eefd7be3  vcvt.s32.f64  s15, d19
    cfd4: e240c001  sub ip, r0, #1
    cfd8: e30835b0  movw  r3, #34224  ; 0x85b0
    cfdc: e3500001  cmp r0, #1
    cfe0: e3403001  movt  r3, #1
    cfe4: e083218c  add r2, r3, ip, lsl #3
    cfe8: ec4bab30  vmov  d16, sl, fp
    cfec: e2863001  add r3, r6, #1
    cff0: 10860000  addne r0, r6, r0
    cff4: edd22b00  vldr  d18, [r2]
    cff8: 11a01003  movne r1, r3
    cffc: ee172a90  vmov  r2, s15
    d000: eef81be7  vcvt.f64.s32  d17, s15
    d004: ee622ba0  vmul.f64  d18, d18, d16
    d008: e2822030  add r2, r2, #48 ; 0x30
    d00c: e5c62000  strb  r2, [r6]
    d010: ee730be1  vsub.f64  d16, d19, d17
    d014: 1ef23b04  vmovne.f64  d19, #36  ; 0x24
    d018: 0a000009  beq d044 <_dtoa_r+0xd10>
    d01c: ee600ba3  vmul.f64  d16, d16, d19
    d020: eefd7be0  vcvt.s32.f64  s15, d16
    d024: ee172a90  vmov  r2, s15
    d028: eef81be7  vcvt.f64.s32  d17, s15
    d02c: ee700be1  vsub.f64  d16, d16, d17
    d030: e2822030  add r2, r2, #48 ; 0x30
    d034: e4c12001  strb  r2, [r1], #1
    d038: e1510000  cmp r1, r0
    d03c: 1afffff6  bne d01c <_dtoa_r+0xce8>
    d040: e083300c  add r3, r3, ip
    d044: eef61b00  vmov.f64  d17, #96  ; 0x60
    d048: ee723ba1  vadd.f64  d19, d18, d17
    d04c: eef43be0  vcmpe.f64 d19, d16
    d050: eef1fa10  vmrs  APSR_nzcv, fpscr
    d054: 4affff50  bmi cd9c <_dtoa_r+0xa68>
    d058: ee711be2  vsub.f64  d17, d17, d18
    d05c: eef41be0  vcmpe.f64 d17, d16
    d060: eef1fa10  vmrs  APSR_nzcv, fpscr
    d064: ca000001  bgt d070 <_dtoa_r+0xd3c>
    d068: eaffffbd  b cf64 <_dtoa_r+0xc30>
    d06c: e1a03001  mov r3, r1
    d070: e5532001  ldrb  r2, [r3, #-1]
    d074: e2431001  sub r1, r3, #1
    d078: e3520030  cmp r2, #48 ; 0x30
    d07c: 0afffffa  beq d06c <_dtoa_r+0xd38>
    d080: eaffff05  b cc9c <_dtoa_r+0x968>
    d084: e1a00009  mov r0, r9
    d088: e59d100c  ldr r1, [sp, #12]
    d08c: eb00088b  bl  f2c0 <__mcmp>
    d090: e3500000  cmp r0, #0
    d094: aafffe00  bge c89c <_dtoa_r+0x568>
    d098: e1a01009  mov r1, r9
    d09c: e3a03000  mov r3, #0
    d0a0: e1a00004  mov r0, r4
    d0a4: e3a0200a  mov r2, #10
    d0a8: eb0006dd  bl  ec24 <__multadd>
    d0ac: e59d3014  ldr r3, [sp, #20]
    d0b0: e3530000  cmp r3, #0
    d0b4: e59d3008  ldr r3, [sp, #8]
    d0b8: e2433001  sub r3, r3, #1
    d0bc: e58d3008  str r3, [sp, #8]
    d0c0: e1a09000  mov r9, r0
    d0c4: 1a00001c  bne d13c <_dtoa_r+0xe08>
    d0c8: e59d3068  ldr r3, [sp, #104]  ; 0x68
    d0cc: e59d2024  ldr r2, [sp, #36] ; 0x24
    d0d0: e3530002  cmp r3, #2
    d0d4: c3a03001  movgt r3, #1
    d0d8: d3a03000  movle r3, #0
    d0dc: e3520000  cmp r2, #0
    d0e0: c3a03000  movgt r3, #0
    d0e4: e3530000  cmp r3, #0
    d0e8: 01a03002  moveq r3, r2
    d0ec: 058d3010  streq r3, [sp, #16]
    d0f0: 0affff58  beq ce58 <_dtoa_r+0xb24>
    d0f4: e59d3024  ldr r3, [sp, #36] ; 0x24
    d0f8: e58d3010  str r3, [sp, #16]
    d0fc: eafffdef  b c8c0 <_dtoa_r+0x58c>
    d100: e35a0000  cmp sl, #0
    d104: 1affff35  bne cde0 <_dtoa_r+0xaac>
    d108: e7f3305b  ubfx  r3, fp, #0, #20
    d10c: e3530000  cmp r3, #0
    d110: 1affff32  bne cde0 <_dtoa_r+0xaac>
    d114: e3cb3102  bic r3, fp, #-2147483648  ; 0x80000000
    d118: e1a03a23  lsr r3, r3, #20
    d11c: e1a03a03  lsl r3, r3, #20
    d120: e3530000  cmp r3, #0
    d124: 058d3028  streq r3, [sp, #40] ; 0x28
    d128: 13a03001  movne r3, #1
    d12c: 12877001  addne r7, r7, #1
    d130: 12888001  addne r8, r8, #1
    d134: 158d3028  strne r3, [sp, #40] ; 0x28
    d138: eaffff2a  b cde8 <_dtoa_r+0xab4>
    d13c: e1a01005  mov r1, r5
    d140: e3a0200a  mov r2, #10
    d144: e3a03000  mov r3, #0
    d148: e1a00004  mov r0, r4
    d14c: eb0006b4  bl  ec24 <__multadd>
    d150: e59d3068  ldr r3, [sp, #104]  ; 0x68
    d154: e59d2024  ldr r2, [sp, #36] ; 0x24
    d158: e3530002  cmp r3, #2
    d15c: c3a03001  movgt r3, #1
    d160: d3a03000  movle r3, #0
    d164: e3520000  cmp r2, #0
    d168: c3a03000  movgt r3, #0
    d16c: e3530000  cmp r3, #0
    d170: 01a03002  moveq r3, r2
    d174: 058d3010  streq r3, [sp, #16]
    d178: e1a05000  mov r5, r0
    d17c: 1affffdc  bne d0f4 <_dtoa_r+0xdc0>
    d180: e59d3020  ldr r3, [sp, #32]
    d184: e3530000  cmp r3, #0
    d188: da000004  ble d1a0 <_dtoa_r+0xe6c>
    d18c: e1a01005  mov r1, r5
    d190: e1a02003  mov r2, r3
    d194: e1a00004  mov r0, r4
    d198: eb000809  bl  f1c4 <__lshift>
    d19c: e1a05000  mov r5, r0
    d1a0: e59d3028  ldr r3, [sp, #40] ; 0x28
    d1a4: e3530000  cmp r3, #0
    d1a8: 058d501c  streq r5, [sp, #28]
    d1ac: 1a0000bd  bne d4a8 <_dtoa_r+0x1174>
    d1b0: e59d3010  ldr r3, [sp, #16]
    d1b4: e20a2001  and r2, sl, #1
    d1b8: e1a07006  mov r7, r6
    d1bc: e58d6020  str r6, [sp, #32]
    d1c0: e2433001  sub r3, r3, #1
    d1c4: e58d2014  str r2, [sp, #20]
    d1c8: e0863003  add r3, r6, r3
    d1cc: e59d601c  ldr r6, [sp, #28]
    d1d0: e58d3018  str r3, [sp, #24]
    d1d4: ea000008  b d1fc <_dtoa_r+0xec8>
    d1d8: eb000691  bl  ec24 <__multadd>
    d1dc: e1a01006  mov r1, r6
    d1e0: e3a0200a  mov r2, #10
    d1e4: e3a03000  mov r3, #0
    d1e8: e1a05000  mov r5, r0
    d1ec: e1a00004  mov r0, r4
    d1f0: eb00068b  bl  ec24 <__multadd>
    d1f4: e1a06000  mov r6, r0
    d1f8: e1a0700a  mov r7, sl
    d1fc: e59d800c  ldr r8, [sp, #12]
    d200: e1a00009  mov r0, r9
    d204: e1a01008  mov r1, r8
    d208: ebfffbd8  bl  c170 <quorem>
    d20c: e1a01005  mov r1, r5
    d210: e1a0b000  mov fp, r0
    d214: e1a00009  mov r0, r9
    d218: eb000828  bl  f2c0 <__mcmp>
    d21c: e1a01008  mov r1, r8
    d220: e1a02006  mov r2, r6
    d224: e28b8030  add r8, fp, #48 ; 0x30
    d228: e1a0a000  mov sl, r0
    d22c: e1a00004  mov r0, r4
    d230: eb00083b  bl  f324 <__mdiff>
    d234: e590300c  ldr r3, [r0, #12]
    d238: e1a02000  mov r2, r0
    d23c: e3530000  cmp r3, #0
    d240: 1a000030  bne d308 <_dtoa_r+0xfd4>
    d244: e1a01002  mov r1, r2
    d248: e1a00009  mov r0, r9
    d24c: e58d2010  str r2, [sp, #16]
    d250: eb00081a  bl  f2c0 <__mcmp>
    d254: e59d2010  ldr r2, [sp, #16]
    d258: e1a03000  mov r3, r0
    d25c: e1a01002  mov r1, r2
    d260: e1a00004  mov r0, r4
    d264: e58d3010  str r3, [sp, #16]
    d268: eb000666  bl  ec08 <_Bfree>
    d26c: e59d2068  ldr r2, [sp, #104]  ; 0x68
    d270: e59d3010  ldr r3, [sp, #16]
    d274: e1932002  orrs  r2, r3, r2
    d278: 1a000002  bne d288 <_dtoa_r+0xf54>
    d27c: e59d2014  ldr r2, [sp, #20]
    d280: e3520000  cmp r2, #0
    d284: 0a0000ac  beq d53c <_dtoa_r+0x1208>
    d288: e35a0000  cmp sl, #0
    d28c: ba000065  blt d428 <_dtoa_r+0x10f4>
    d290: e59d2068  ldr r2, [sp, #104]  ; 0x68
    d294: e19a2002  orrs  r2, sl, r2
    d298: 1a000002  bne d2a8 <_dtoa_r+0xf74>
    d29c: e59d2014  ldr r2, [sp, #20]
    d2a0: e3520000  cmp r2, #0
    d2a4: 0a00005f  beq d428 <_dtoa_r+0x10f4>
    d2a8: e3530000  cmp r3, #0
    d2ac: ca00008d  bgt d4e8 <_dtoa_r+0x11b4>
    d2b0: e59d3018  ldr r3, [sp, #24]
    d2b4: e287a001  add sl, r7, #1
    d2b8: e5c78000  strb  r8, [r7]
    d2bc: e1570003  cmp r7, r3
    d2c0: e1a0300a  mov r3, sl
    d2c4: 0a000091  beq d510 <_dtoa_r+0x11dc>
    d2c8: e1a01009  mov r1, r9
    d2cc: e3a0200a  mov r2, #10
    d2d0: e3a03000  mov r3, #0
    d2d4: e1a00004  mov r0, r4
    d2d8: eb000651  bl  ec24 <__multadd>
    d2dc: e1550006  cmp r5, r6
    d2e0: e1a01005  mov r1, r5
    d2e4: e3a0200a  mov r2, #10
    d2e8: e3a03000  mov r3, #0
    d2ec: e1a09000  mov r9, r0
    d2f0: e1a00004  mov r0, r4
    d2f4: 1affffb7  bne d1d8 <_dtoa_r+0xea4>
    d2f8: eb000649  bl  ec24 <__multadd>
    d2fc: e1a05000  mov r5, r0
    d300: e1a06000  mov r6, r0
    d304: eaffffbb  b d1f8 <_dtoa_r+0xec4>
    d308: e3a03001  mov r3, #1
    d30c: eaffffd2  b d25c <_dtoa_r+0xf28>
    d310: e353000e  cmp r3, #14
    d314: 83a03000  movhi r3, #0
    d318: 93a03001  movls r3, #1
    d31c: e3a01000  mov r1, #0
    d320: e0055003  and r5, r5, r3
    d324: e5841044  str r1, [r4, #68] ; 0x44
    d328: eafffdf1  b caf4 <_dtoa_r+0x7c0>
    d32c: e3a03001  mov r3, #1
    d330: e58d306c  str r3, [sp, #108]  ; 0x6c
    d334: e58d3024  str r3, [sp, #36] ; 0x24
    d338: e58d3010  str r3, [sp, #16]
    d33c: eafffff6  b d31c <_dtoa_r+0xfe8>
    d340: e1a01009  mov r1, r9
    d344: e59d200c  ldr r2, [sp, #12]
    d348: e1a00004  mov r0, r4
    d34c: eb00075d  bl  f0c8 <__pow5mult>
    d350: e1a09000  mov r9, r0
    d354: eafffd1c  b c7cc <_dtoa_r+0x498>
    d358: e28e2001  add r2, lr, #1
    d35c: e3a00030  mov r0, #48 ; 0x30
    d360: e58d2008  str r2, [sp, #8]
    d364: e3a02031  mov r2, #49 ; 0x31
    d368: e5c10000  strb  r0, [r1]
    d36c: eafffe96  b cdcc <_dtoa_r+0xa98>
    d370: e59d3010  ldr r3, [sp, #16]
    d374: e3530000  cmp r3, #0
    d378: 0afffe9f  beq cdfc <_dtoa_r+0xac8>
    d37c: e59d3024  ldr r3, [sp, #36] ; 0x24
    d380: e3530000  cmp r3, #0
    d384: dafffef6  ble cf64 <_dtoa_r+0xc30>
    d388: eef20b04  vmov.f64  d16, #36  ; 0x24
    d38c: e2811001  add r1, r1, #1
    d390: e59d2008  ldr r2, [sp, #8]
    d394: e1a00003  mov r0, r3
    d398: ee071a90  vmov  s15, r1
    d39c: e242e001  sub lr, r2, #1
    d3a0: ee633ba0  vmul.f64  d19, d19, d16
    d3a4: eef12b0c  vmov.f64  d18, #28
    d3a8: eef80be7  vcvt.f64.s32  d16, s15
    d3ac: ee432ba0  vmla.f64  d18, d19, d16
    d3b0: ec5bab32  vmov  sl, fp, d18
    d3b4: e24bb50d  sub fp, fp, #54525952 ; 0x3400000
    d3b8: eafffe04  b cbd0 <_dtoa_r+0x89c>
    d3bc: e1a01009  mov r1, r9
    d3c0: e1a00004  mov r0, r4
    d3c4: eb00073f  bl  f0c8 <__pow5mult>
    d3c8: e1a09000  mov r9, r0
    d3cc: eafffcfe  b c7cc <_dtoa_r+0x498>
    d3d0: e35a0000  cmp sl, #0
    d3d4: 0affff4b  beq d108 <_dtoa_r+0xdd4>
    d3d8: eafffd0a  b c808 <_dtoa_r+0x4d4>
    d3dc: e59d2008  ldr r2, [sp, #8]
    d3e0: e2822001  add r2, r2, #1
    d3e4: e58d2008  str r2, [sp, #8]
    d3e8: e3a02031  mov r2, #49 ; 0x31
    d3ec: e5c62000  strb  r2, [r6]
    d3f0: eafffec5  b cf0c <_dtoa_r+0xbd8>
    d3f4: e59d2020  ldr r2, [sp, #32]
    d3f8: e3520000  cmp r2, #0
    d3fc: 158d7020  strne r7, [sp, #32]
    d400: 12833e43  addne r3, r3, #1072 ; 0x430
    d404: 058d7020  streq r7, [sp, #32]
    d408: 159d200c  ldrne r2, [sp, #12]
    d40c: 12833003  addne r3, r3, #3
    d410: 059d200c  ldreq r2, [sp, #12]
    d414: 059d3030  ldreq r3, [sp, #48] ; 0x30
    d418: 158d2028  strne r2, [sp, #40] ; 0x28
    d41c: 058d2028  streq r2, [sp, #40] ; 0x28
    d420: 02633036  rsbeq r3, r3, #54 ; 0x36
    d424: eafffd93  b ca78 <_dtoa_r+0x744>
    d428: e3530000  cmp r3, #0
    d42c: e58d601c  str r6, [sp, #28]
    d430: e1a0b008  mov fp, r8
    d434: e59d6020  ldr r6, [sp, #32]
    d438: da00000b  ble d46c <_dtoa_r+0x1138>
    d43c: e1a01009  mov r1, r9
    d440: e3a02001  mov r2, #1
    d444: e1a00004  mov r0, r4
    d448: eb00075d  bl  f1c4 <__lshift>
    d44c: e59d100c  ldr r1, [sp, #12]
    d450: e1a09000  mov r9, r0
    d454: eb000799  bl  f2c0 <__mcmp>
    d458: e3500000  cmp r0, #0
    d45c: da00003f  ble d560 <_dtoa_r+0x122c>
    d460: e3580039  cmp r8, #57 ; 0x39
    d464: 0a00002e  beq d524 <_dtoa_r+0x11f0>
    d468: e288b001  add fp, r8, #1
    d46c: e1a0a005  mov sl, r5
    d470: e5c7b000  strb  fp, [r7]
    d474: e2873001  add r3, r7, #1
    d478: e59d501c  ldr r5, [sp, #28]
    d47c: eafffea2  b cf0c <_dtoa_r+0xbd8>
    d480: 1a000003  bne d494 <_dtoa_r+0x1160>
    d484: e3180001  tst r8, #1
    d488: 0a000001  beq d494 <_dtoa_r+0x1160>
    d48c: eafffe93  b cee0 <_dtoa_r+0xbac>
    d490: e1a03001  mov r3, r1
    d494: e5532001  ldrb  r2, [r3, #-1]
    d498: e2431001  sub r1, r3, #1
    d49c: e3520030  cmp r2, #48 ; 0x30
    d4a0: 0afffffa  beq d490 <_dtoa_r+0x115c>
    d4a4: eafffe98  b cf0c <_dtoa_r+0xbd8>
    d4a8: e5951004  ldr r1, [r5, #4]
    d4ac: e1a00004  mov r0, r4
    d4b0: eb0005b1  bl  eb7c <_Balloc>
    d4b4: e5952010  ldr r2, [r5, #16]
    d4b8: e285100c  add r1, r5, #12
    d4bc: e2822002  add r2, r2, #2
    d4c0: e1a02102  lsl r2, r2, #2
    d4c4: e1a07000  mov r7, r0
    d4c8: e280000c  add r0, r0, #12
    d4cc: ebfff0eb  bl  9880 <memcpy>
    d4d0: e1a00004  mov r0, r4
    d4d4: e1a01007  mov r1, r7
    d4d8: e3a02001  mov r2, #1
    d4dc: eb000738  bl  f1c4 <__lshift>
    d4e0: e58d001c  str r0, [sp, #28]
    d4e4: eaffff31  b d1b0 <_dtoa_r+0xe7c>
    d4e8: e3580039  cmp r8, #57 ; 0x39
    d4ec: e58d601c  str r6, [sp, #28]
    d4f0: 12888001  addne r8, r8, #1
    d4f4: e59d6020  ldr r6, [sp, #32]
    d4f8: 0a000009  beq d524 <_dtoa_r+0x11f0>
    d4fc: e5c78000  strb  r8, [r7]
    d500: e1a0a005  mov sl, r5
    d504: e2873001  add r3, r7, #1
    d508: e59d501c  ldr r5, [sp, #28]
    d50c: eafffe7e  b cf0c <_dtoa_r+0xbd8>
    d510: e1a02006  mov r2, r6
    d514: e1a0a005  mov sl, r5
    d518: e59d6020  ldr r6, [sp, #32]
    d51c: e1a05002  mov r5, r2
    d520: eafffe63  b ceb4 <_dtoa_r+0xb80>
    d524: e1a0a005  mov sl, r5
    d528: e3a01039  mov r1, #57 ; 0x39
    d52c: e59d501c  ldr r5, [sp, #28]
    d530: e2873001  add r3, r7, #1
    d534: e5c71000  strb  r1, [r7]
    d538: eafffe69  b cee4 <_dtoa_r+0xbb0>
    d53c: e3580039  cmp r8, #57 ; 0x39
    d540: e58d601c  str r6, [sp, #28]
    d544: e59d6020  ldr r6, [sp, #32]
    d548: 0afffff5  beq d524 <_dtoa_r+0x11f0>
    d54c: e35a0000  cmp sl, #0
    d550: c28b8031  addgt r8, fp, #49 ; 0x31
    d554: eaffffe8  b d4fc <_dtoa_r+0x11c8>
    d558: e3a01002  mov r1, #2
    d55c: eafffd89  b cb88 <_dtoa_r+0x854>
    d560: 1affffc1  bne d46c <_dtoa_r+0x1138>
    d564: e3180001  tst r8, #1
    d568: 0affffbf  beq d46c <_dtoa_r+0x1138>
    d56c: eaffffbb  b d460 <_dtoa_r+0x112c>
    d570: 1260003c  rsbne r0, r0, #60 ; 0x3c
    d574: 0afffcb7  beq c858 <_dtoa_r+0x524>
    d578: eafffcb1  b c844 <_dtoa_r+0x510>
    d57c: e3a03001  mov r3, #1
    d580: e58d3014  str r3, [sp, #20]
    d584: eafffdc8  b ccac <_dtoa_r+0x978>
    d588: e3e03000  mvn r3, #0
    d58c: e58d506c  str r5, [sp, #108]  ; 0x6c
    d590: e58d3010  str r3, [sp, #16]
    d594: eafffc38  b c67c <_dtoa_r+0x348>

0000d598 <__sflush_r>:
    d598: e1d130bc  ldrh  r3, [r1, #12]
    d59c: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    d5a0: e1a05001  mov r5, r1
    d5a4: e6ff2073  uxth  r2, r3
    d5a8: e1a08000  mov r8, r0
    d5ac: e3120008  tst r2, #8
    d5b0: 1a000034  bne d688 <__sflush_r+0xf0>
    d5b4: e5912004  ldr r2, [r1, #4]
    d5b8: e3833b02  orr r3, r3, #2048 ; 0x800
    d5bc: e1c130bc  strh  r3, [r1, #12]
    d5c0: e3520000  cmp r2, #0
    d5c4: da00004d  ble d700 <__sflush_r+0x168>
    d5c8: e5957028  ldr r7, [r5, #40] ; 0x28
    d5cc: e3570000  cmp r7, #0
    d5d0: 0a00004d  beq d70c <__sflush_r+0x174>
    d5d4: e6ff3073  uxth  r3, r3
    d5d8: e3a02000  mov r2, #0
    d5dc: e2030a01  and r0, r3, #4096 ; 0x1000
    d5e0: e5984000  ldr r4, [r8]
    d5e4: e5882000  str r2, [r8]
    d5e8: e6ff6070  uxth  r6, r0
    d5ec: e1560002  cmp r6, r2
    d5f0: 0a00005f  beq d774 <__sflush_r+0x1dc>
    d5f4: e5952050  ldr r2, [r5, #80] ; 0x50
    d5f8: e3130004  tst r3, #4
    d5fc: 0a000005  beq d618 <__sflush_r+0x80>
    d600: e5951030  ldr r1, [r5, #48] ; 0x30
    d604: e5953004  ldr r3, [r5, #4]
    d608: e3510000  cmp r1, #0
    d60c: e0632002  rsb r2, r3, r2
    d610: 1595303c  ldrne r3, [r5, #60] ; 0x3c
    d614: 10632002  rsbne r2, r3, r2
    d618: e1a00008  mov r0, r8
    d61c: e595101c  ldr r1, [r5, #28]
    d620: e3a03000  mov r3, #0
    d624: e12fff37  blx r7
    d628: e3700001  cmn r0, #1
    d62c: 0a000038  beq d714 <__sflush_r+0x17c>
    d630: e1d530bc  ldrh  r3, [r5, #12]
    d634: e3a01000  mov r1, #0
    d638: e5952010  ldr r2, [r5, #16]
    d63c: e3c33b02  bic r3, r3, #2048 ; 0x800
    d640: e5851004  str r1, [r5, #4]
    d644: e6ff3073  uxth  r3, r3
    d648: e5852000  str r2, [r5]
    d64c: e3130a01  tst r3, #4096 ; 0x1000
    d650: e1c530bc  strh  r3, [r5, #12]
    d654: 1a000044  bne d76c <__sflush_r+0x1d4>
    d658: e5951030  ldr r1, [r5, #48] ; 0x30
    d65c: e5884000  str r4, [r8]
    d660: e3510000  cmp r1, #0
    d664: 0a000028  beq d70c <__sflush_r+0x174>
    d668: e2853040  add r3, r5, #64 ; 0x40
    d66c: e1510003  cmp r1, r3
    d670: 0a000001  beq d67c <__sflush_r+0xe4>
    d674: e1a00008  mov r0, r8
    d678: eb000179  bl  dc64 <_free_r>
    d67c: e3a00000  mov r0, #0
    d680: e5850030  str r0, [r5, #48] ; 0x30
    d684: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    d688: e5916010  ldr r6, [r1, #16]
    d68c: e3560000  cmp r6, #0
    d690: 0a00001d  beq d70c <__sflush_r+0x174>
    d694: e3120003  tst r2, #3
    d698: e5914000  ldr r4, [r1]
    d69c: e5816000  str r6, [r1]
    d6a0: 05913014  ldreq r3, [r1, #20]
    d6a4: e0664004  rsb r4, r6, r4
    d6a8: 13a03000  movne r3, #0
    d6ac: e3540000  cmp r4, #0
    d6b0: e5813008  str r3, [r1, #8]
    d6b4: ca000002  bgt d6c4 <__sflush_r+0x12c>
    d6b8: ea000013  b d70c <__sflush_r+0x174>
    d6bc: e3540000  cmp r4, #0
    d6c0: da000011  ble d70c <__sflush_r+0x174>
    d6c4: e1a02006  mov r2, r6
    d6c8: e1a03004  mov r3, r4
    d6cc: e5957024  ldr r7, [r5, #36] ; 0x24
    d6d0: e1a00008  mov r0, r8
    d6d4: e595101c  ldr r1, [r5, #28]
    d6d8: e12fff37  blx r7
    d6dc: e3500000  cmp r0, #0
    d6e0: e0604004  rsb r4, r0, r4
    d6e4: e0866000  add r6, r6, r0
    d6e8: cafffff3  bgt d6bc <__sflush_r+0x124>
    d6ec: e1d530bc  ldrh  r3, [r5, #12]
    d6f0: e3e00000  mvn r0, #0
    d6f4: e3833040  orr r3, r3, #64 ; 0x40
    d6f8: e1c530bc  strh  r3, [r5, #12]
    d6fc: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    d700: e591203c  ldr r2, [r1, #60] ; 0x3c
    d704: e3520000  cmp r2, #0
    d708: caffffae  bgt d5c8 <__sflush_r+0x30>
    d70c: e3a00000  mov r0, #0
    d710: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    d714: e5981000  ldr r1, [r8]
    d718: e16f2f11  clz r2, r1
    d71c: e1a022a2  lsr r2, r2, #5
    d720: e351001d  cmp r1, #29
    d724: 11a03002  movne r3, r2
    d728: 03823001  orreq r3, r2, #1
    d72c: e3510016  cmp r1, #22
    d730: 03833001  orreq r3, r3, #1
    d734: e3530000  cmp r3, #0
    d738: 0a000021  beq d7c4 <__sflush_r+0x22c>
    d73c: e1d530bc  ldrh  r3, [r5, #12]
    d740: e3a0c000  mov ip, #0
    d744: e5951010  ldr r1, [r5, #16]
    d748: e3c33b02  bic r3, r3, #2048 ; 0x800
    d74c: e585c004  str ip, [r5, #4]
    d750: e6ff3073  uxth  r3, r3
    d754: e5851000  str r1, [r5]
    d758: e3130a01  tst r3, #4096 ; 0x1000
    d75c: e1c530bc  strh  r3, [r5, #12]
    d760: 0affffbc  beq d658 <__sflush_r+0xc0>
    d764: e3520000  cmp r2, #0
    d768: 0affffba  beq d658 <__sflush_r+0xc0>
    d76c: e5850050  str r0, [r5, #80] ; 0x50
    d770: eaffffb8  b d658 <__sflush_r+0xc0>
    d774: e1a02006  mov r2, r6
    d778: e1a00008  mov r0, r8
    d77c: e595101c  ldr r1, [r5, #28]
    d780: e3a03001  mov r3, #1
    d784: e12fff37  blx r7
    d788: e3700001  cmn r0, #1
    d78c: e1a02000  mov r2, r0
    d790: 0a000002  beq d7a0 <__sflush_r+0x208>
    d794: e1d530bc  ldrh  r3, [r5, #12]
    d798: e5957028  ldr r7, [r5, #40] ; 0x28
    d79c: eaffff95  b d5f8 <__sflush_r+0x60>
    d7a0: e5983000  ldr r3, [r8]
    d7a4: e3530000  cmp r3, #0
    d7a8: 0afffff9  beq d794 <__sflush_r+0x1fc>
    d7ac: e353001d  cmp r3, #29
    d7b0: 13530016  cmpne r3, #22
    d7b4: 1affffcc  bne d6ec <__sflush_r+0x154>
    d7b8: e5884000  str r4, [r8]
    d7bc: e1a00006  mov r0, r6
    d7c0: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    d7c4: e1d530bc  ldrh  r3, [r5, #12]
    d7c8: e3833040  orr r3, r3, #64 ; 0x40
    d7cc: e1c530bc  strh  r3, [r5, #12]
    d7d0: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

0000d7d4 <_fflush_r>:
    d7d4: e92d4010  push  {r4, lr}
    d7d8: e2504000  subs  r4, r0, #0
    d7dc: e24dd008  sub sp, sp, #8
    d7e0: 0a000002  beq d7f0 <_fflush_r+0x1c>
    d7e4: e5943038  ldr r3, [r4, #56] ; 0x38
    d7e8: e3530000  cmp r3, #0
    d7ec: 0a000008  beq d814 <_fflush_r+0x40>
    d7f0: e1d100fc  ldrsh r0, [r1, #12]
    d7f4: e3500000  cmp r0, #0
    d7f8: 1a000001  bne d804 <_fflush_r+0x30>
    d7fc: e28dd008  add sp, sp, #8
    d800: e8bd8010  pop {r4, pc}
    d804: e1a00004  mov r0, r4
    d808: e28dd008  add sp, sp, #8
    d80c: e8bd4010  pop {r4, lr}
    d810: eaffff60  b d598 <__sflush_r>
    d814: e58d1004  str r1, [sp, #4]
    d818: eb0000be  bl  db18 <__sinit>
    d81c: e59d1004  ldr r1, [sp, #4]
    d820: eafffff2  b d7f0 <_fflush_r+0x1c>

0000d824 <fflush>:
    d824: e2501000  subs  r1, r0, #0
    d828: 0a000003  beq d83c <fflush+0x18>
    d82c: e30b3390  movw  r3, #45968  ; 0xb390
    d830: e3403001  movt  r3, #1
    d834: e5930000  ldr r0, [r3]
    d838: eaffffe5  b d7d4 <_fflush_r>
    d83c: e308357c  movw  r3, #34172  ; 0x857c
    d840: e30d17d4  movw  r1, #55252  ; 0xd7d4
    d844: e3403001  movt  r3, #1
    d848: e3401000  movt  r1, #0
    d84c: e5930000  ldr r0, [r3]
    d850: ea0001cd  b df8c <_fwalk_reent>

0000d854 <__fp_lock>:
    d854: e3a00000  mov r0, #0
    d858: e12fff1e  bx  lr

0000d85c <__fp_unlock>:
    d85c: e3a00000  mov r0, #0
    d860: e12fff1e  bx  lr

0000d864 <_cleanup_r>:
    d864: e30111e0  movw  r1, #4576 ; 0x11e0
    d868: e3401001  movt  r1, #1
    d86c: ea0001c6  b df8c <_fwalk_reent>

0000d870 <__sinit.part.1>:
    d870: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    d874: e30d3864  movw  r3, #55396  ; 0xd864
    d878: e5905004  ldr r5, [r0, #4]
    d87c: e3a04000  mov r4, #0
    d880: e1a07000  mov r7, r0
    d884: e24dd00c  sub sp, sp, #12
    d888: e2802fbb  add r2, r0, #748  ; 0x2ec
    d88c: e3403000  movt  r3, #0
    d890: e58022e8  str r2, [r0, #744]  ; 0x2e8
    d894: e3a01003  mov r1, #3
    d898: e580303c  str r3, [r0, #60] ; 0x3c
    d89c: e3a02008  mov r2, #8
    d8a0: e58012e4  str r1, [r0, #740]  ; 0x2e4
    d8a4: e3a03004  mov r3, #4
    d8a8: e58742e0  str r4, [r7, #736]  ; 0x2e0
    d8ac: e1a01004  mov r1, r4
    d8b0: e5854000  str r4, [r5]
    d8b4: e285005c  add r0, r5, #92 ; 0x5c
    d8b8: e5854004  str r4, [r5, #4]
    d8bc: e30fb8e8  movw  fp, #63720  ; 0xf8e8
    d8c0: e5854008  str r4, [r5, #8]
    d8c4: e30fa920  movw  sl, #63776  ; 0xf920
    d8c8: e5854064  str r4, [r5, #100]  ; 0x64
    d8cc: e30f9974  movw  r9, #63860  ; 0xf974
    d8d0: e1c540be  strh  r4, [r5, #14]
    d8d4: e30f89a0  movw  r8, #63904  ; 0xf9a0
    d8d8: e5854010  str r4, [r5, #16]
    d8dc: e340b000  movt  fp, #0
    d8e0: e5854014  str r4, [r5, #20]
    d8e4: e340a000  movt  sl, #0
    d8e8: e5854018  str r4, [r5, #24]
    d8ec: e3409000  movt  r9, #0
    d8f0: e1c530bc  strh  r3, [r5, #12]
    d8f4: e3408000  movt  r8, #0
    d8f8: eb000460  bl  ea80 <memset>
    d8fc: e5976008  ldr r6, [r7, #8]
    d900: e3a03001  mov r3, #1
    d904: e585b020  str fp, [r5, #32]
    d908: e585a024  str sl, [r5, #36] ; 0x24
    d90c: e3a0c009  mov ip, #9
    d910: e5859028  str r9, [r5, #40] ; 0x28
    d914: e1a01004  mov r1, r4
    d918: e585802c  str r8, [r5, #44] ; 0x2c
    d91c: e286005c  add r0, r6, #92 ; 0x5c
    d920: e585501c  str r5, [r5, #28]
    d924: e3a02008  mov r2, #8
    d928: e1c630be  strh  r3, [r6, #14]
    d92c: e1c6c0bc  strh  ip, [r6, #12]
    d930: e5864000  str r4, [r6]
    d934: e5864004  str r4, [r6, #4]
    d938: e5864008  str r4, [r6, #8]
    d93c: e5864064  str r4, [r6, #100]  ; 0x64
    d940: e5864010  str r4, [r6, #16]
    d944: e5864014  str r4, [r6, #20]
    d948: e5864018  str r4, [r6, #24]
    d94c: e58d3004  str r3, [sp, #4]
    d950: eb00044a  bl  ea80 <memset>
    d954: e597500c  ldr r5, [r7, #12]
    d958: e3a0e012  mov lr, #18
    d95c: e586601c  str r6, [r6, #28]
    d960: e3a0c002  mov ip, #2
    d964: e586b020  str fp, [r6, #32]
    d968: e1a01004  mov r1, r4
    d96c: e586a024  str sl, [r6, #36] ; 0x24
    d970: e285005c  add r0, r5, #92 ; 0x5c
    d974: e5869028  str r9, [r6, #40] ; 0x28
    d978: e3a02008  mov r2, #8
    d97c: e586802c  str r8, [r6, #44] ; 0x2c
    d980: e5854000  str r4, [r5]
    d984: e5854004  str r4, [r5, #4]
    d988: e5854008  str r4, [r5, #8]
    d98c: e5854064  str r4, [r5, #100]  ; 0x64
    d990: e5854010  str r4, [r5, #16]
    d994: e5854014  str r4, [r5, #20]
    d998: e5854018  str r4, [r5, #24]
    d99c: e1c5e0bc  strh  lr, [r5, #12]
    d9a0: e1c5c0be  strh  ip, [r5, #14]
    d9a4: eb000435  bl  ea80 <memset>
    d9a8: e59d3004  ldr r3, [sp, #4]
    d9ac: e585501c  str r5, [r5, #28]
    d9b0: e585b020  str fp, [r5, #32]
    d9b4: e585a024  str sl, [r5, #36] ; 0x24
    d9b8: e5859028  str r9, [r5, #40] ; 0x28
    d9bc: e585802c  str r8, [r5, #44] ; 0x2c
    d9c0: e5873038  str r3, [r7, #56] ; 0x38
    d9c4: e28dd00c  add sp, sp, #12
    d9c8: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000d9cc <__sfmoreglue>:
    d9cc: e2413001  sub r3, r1, #1
    d9d0: e92d4070  push  {r4, r5, r6, lr}
    d9d4: e0834083  add r4, r3, r3, lsl #1
    d9d8: e1a06001  mov r6, r1
    d9dc: e0833104  add r3, r3, r4, lsl #2
    d9e0: e1a04183  lsl r4, r3, #3
    d9e4: e2841074  add r1, r4, #116  ; 0x74
    d9e8: eb00021b  bl  e25c <_malloc_r>
    d9ec: e2505000  subs  r5, r0, #0
    d9f0: 0a000006  beq da10 <__sfmoreglue+0x44>
    d9f4: e285000c  add r0, r5, #12
    d9f8: e3a01000  mov r1, #0
    d9fc: e5856004  str r6, [r5, #4]
    da00: e2842068  add r2, r4, #104  ; 0x68
    da04: e5850008  str r0, [r5, #8]
    da08: e5851000  str r1, [r5]
    da0c: eb00041b  bl  ea80 <memset>
    da10: e1a00005  mov r0, r5
    da14: e8bd8070  pop {r4, r5, r6, pc}

0000da18 <__sfp>:
    da18: e308357c  movw  r3, #34172  ; 0x857c
    da1c: e3403001  movt  r3, #1
    da20: e92d4070  push  {r4, r5, r6, lr}
    da24: e1a06000  mov r6, r0
    da28: e5935000  ldr r5, [r3]
    da2c: e5953038  ldr r3, [r5, #56] ; 0x38
    da30: e3530000  cmp r3, #0
    da34: 1a000001  bne da40 <__sfp+0x28>
    da38: e1a00005  mov r0, r5
    da3c: ebffff8b  bl  d870 <__sinit.part.1>
    da40: e2855e2e  add r5, r5, #736  ; 0x2e0
    da44: e9950018  ldmib r5, {r3, r4}
    da48: e2533001  subs  r3, r3, #1
    da4c: 5a000004  bpl da64 <__sfp+0x4c>
    da50: ea00001c  b dac8 <__sfp+0xb0>
    da54: e2433001  sub r3, r3, #1
    da58: e2844068  add r4, r4, #104  ; 0x68
    da5c: e3730001  cmn r3, #1
    da60: 0a000018  beq dac8 <__sfp+0xb0>
    da64: e1d420fc  ldrsh r2, [r4, #12]
    da68: e3520000  cmp r2, #0
    da6c: 1afffff8  bne da54 <__sfp+0x3c>
    da70: e3a05000  mov r5, #0
    da74: e3e0c000  mvn ip, #0
    da78: e3a03001  mov r3, #1
    da7c: e5845064  str r5, [r4, #100]  ; 0x64
    da80: e1a01005  mov r1, r5
    da84: e5845000  str r5, [r4]
    da88: e5845008  str r5, [r4, #8]
    da8c: e284005c  add r0, r4, #92 ; 0x5c
    da90: e5845004  str r5, [r4, #4]
    da94: e3a02008  mov r2, #8
    da98: e5845010  str r5, [r4, #16]
    da9c: e5845014  str r5, [r4, #20]
    daa0: e5845018  str r5, [r4, #24]
    daa4: e1c4c0be  strh  ip, [r4, #14]
    daa8: e1c430bc  strh  r3, [r4, #12]
    daac: eb0003f3  bl  ea80 <memset>
    dab0: e1a00004  mov r0, r4
    dab4: e5845030  str r5, [r4, #48] ; 0x30
    dab8: e5845034  str r5, [r4, #52] ; 0x34
    dabc: e5845044  str r5, [r4, #68] ; 0x44
    dac0: e5845048  str r5, [r4, #72] ; 0x48
    dac4: e8bd8070  pop {r4, r5, r6, pc}
    dac8: e5953000  ldr r3, [r5]
    dacc: e3530000  cmp r3, #0
    dad0: 11a05003  movne r5, r3
    dad4: 1affffda  bne da44 <__sfp+0x2c>
    dad8: e1a00006  mov r0, r6
    dadc: e3a01004  mov r1, #4
    dae0: ebffffb9  bl  d9cc <__sfmoreglue>
    dae4: e3500000  cmp r0, #0
    dae8: e5850000  str r0, [r5]
    daec: 11a05000  movne r5, r0
    daf0: 1affffd3  bne da44 <__sfp+0x2c>
    daf4: e3a0300c  mov r3, #12
    daf8: e5863000  str r3, [r6]
    dafc: e8bd8070  pop {r4, r5, r6, pc}

0000db00 <_cleanup>:
    db00: e308357c  movw  r3, #34172  ; 0x857c
    db04: e30111e0  movw  r1, #4576 ; 0x11e0
    db08: e3403001  movt  r3, #1
    db0c: e3401001  movt  r1, #1
    db10: e5930000  ldr r0, [r3]
    db14: ea00011c  b df8c <_fwalk_reent>

0000db18 <__sinit>:
    db18: e5903038  ldr r3, [r0, #56] ; 0x38
    db1c: e3530000  cmp r3, #0
    db20: 112fff1e  bxne  lr
    db24: eaffff51  b d870 <__sinit.part.1>

0000db28 <__sfp_lock_acquire>:
    db28: e12fff1e  bx  lr

0000db2c <__sfp_lock_release>:
    db2c: e12fff1e  bx  lr

0000db30 <__sinit_lock_acquire>:
    db30: e12fff1e  bx  lr

0000db34 <__sinit_lock_release>:
    db34: e12fff1e  bx  lr

0000db38 <__fp_lock_all>:
    db38: e30b3390  movw  r3, #45968  ; 0xb390
    db3c: e30d1854  movw  r1, #55380  ; 0xd854
    db40: e3403001  movt  r3, #1
    db44: e3401000  movt  r1, #0
    db48: e5930000  ldr r0, [r3]
    db4c: ea0000f0  b df14 <_fwalk>

0000db50 <__fp_unlock_all>:
    db50: e30b3390  movw  r3, #45968  ; 0xb390
    db54: e30d185c  movw  r1, #55388  ; 0xd85c
    db58: e3403001  movt  r3, #1
    db5c: e3401000  movt  r1, #0
    db60: e5930000  ldr r0, [r3]
    db64: ea0000ea  b df14 <_fwalk>

0000db68 <_malloc_trim_r>:
    db68: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
    db6c: e30b783c  movw  r7, #47164  ; 0xb83c
    db70: e3407001  movt  r7, #1
    db74: e1a04001  mov r4, r1
    db78: e1a06000  mov r6, r0
    db7c: eb0003fc  bl  eb74 <__malloc_lock>
    db80: e5973008  ldr r3, [r7, #8]
    db84: e5935004  ldr r5, [r3, #4]
    db88: e3c55003  bic r5, r5, #3
    db8c: e0641005  rsb r1, r4, r5
    db90: e2811efe  add r1, r1, #4064 ; 0xfe0
    db94: e281100f  add r1, r1, #15
    db98: e3c11eff  bic r1, r1, #4080 ; 0xff0
    db9c: e3c1100f  bic r1, r1, #15
    dba0: e2414a01  sub r4, r1, #4096 ; 0x1000
    dba4: e3540a01  cmp r4, #4096 ; 0x1000
    dba8: ba000006  blt dbc8 <_malloc_trim_r+0x60>
    dbac: e1a00006  mov r0, r6
    dbb0: e3a01000  mov r1, #0
    dbb4: eb00073d  bl  f8b0 <_sbrk_r>
    dbb8: e5973008  ldr r3, [r7, #8]
    dbbc: e0833005  add r3, r3, r5
    dbc0: e1500003  cmp r0, r3
    dbc4: 0a000003  beq dbd8 <_malloc_trim_r+0x70>
    dbc8: e1a00006  mov r0, r6
    dbcc: eb0003e9  bl  eb78 <__malloc_unlock>
    dbd0: e3a00000  mov r0, #0
    dbd4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    dbd8: e1a00006  mov r0, r6
    dbdc: e2641000  rsb r1, r4, #0
    dbe0: eb000732  bl  f8b0 <_sbrk_r>
    dbe4: e3700001  cmn r0, #1
    dbe8: 0a00000c  beq dc20 <_malloc_trim_r+0xb8>
    dbec: e5972008  ldr r2, [r7, #8]
    dbf0: e3013534  movw  r3, #5428 ; 0x1534
    dbf4: e3403002  movt  r3, #2
    dbf8: e0645005  rsb r5, r4, r5
    dbfc: e5931000  ldr r1, [r3]
    dc00: e1a00006  mov r0, r6
    dc04: e3855001  orr r5, r5, #1
    dc08: e5825004  str r5, [r2, #4]
    dc0c: e0641001  rsb r1, r4, r1
    dc10: e5831000  str r1, [r3]
    dc14: eb0003d7  bl  eb78 <__malloc_unlock>
    dc18: e3a00001  mov r0, #1
    dc1c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    dc20: e1a00006  mov r0, r6
    dc24: e3a01000  mov r1, #0
    dc28: eb000720  bl  f8b0 <_sbrk_r>
    dc2c: e5972008  ldr r2, [r7, #8]
    dc30: e0623000  rsb r3, r2, r0
    dc34: e353000f  cmp r3, #15
    dc38: daffffe2  ble dbc8 <_malloc_trim_r+0x60>
    dc3c: e30bcc44  movw  ip, #48196  ; 0xbc44
    dc40: e3011534  movw  r1, #5428 ; 0x1534
    dc44: e340c001  movt  ip, #1
    dc48: e3401002  movt  r1, #2
    dc4c: e59cc000  ldr ip, [ip]
    dc50: e3833001  orr r3, r3, #1
    dc54: e5823004  str r3, [r2, #4]
    dc58: e06c0000  rsb r0, ip, r0
    dc5c: e5810000  str r0, [r1]
    dc60: eaffffd8  b dbc8 <_malloc_trim_r+0x60>

0000dc64 <_free_r>:
    dc64: e3510000  cmp r1, #0
    dc68: 012fff1e  bxeq  lr
    dc6c: e92d4070  push  {r4, r5, r6, lr}
    dc70: e1a04001  mov r4, r1
    dc74: e1a05000  mov r5, r0
    dc78: eb0003bd  bl  eb74 <__malloc_lock>
    dc7c: e5140004  ldr r0, [r4, #-4]
    dc80: e30b383c  movw  r3, #47164  ; 0xb83c
    dc84: e244c008  sub ip, r4, #8
    dc88: e3403001  movt  r3, #1
    dc8c: e3c02001  bic r2, r0, #1
    dc90: e5936008  ldr r6, [r3, #8]
    dc94: e08ce002  add lr, ip, r2
    dc98: e156000e  cmp r6, lr
    dc9c: e59e1004  ldr r1, [lr, #4]
    dca0: e3c11003  bic r1, r1, #3
    dca4: 0a00004b  beq ddd8 <_free_r+0x174>
    dca8: e3100001  tst r0, #1
    dcac: e58e1004  str r1, [lr, #4]
    dcb0: 1a000009  bne dcdc <_free_r+0x78>
    dcb4: e5140008  ldr r0, [r4, #-8]
    dcb8: e2834008  add r4, r3, #8
    dcbc: e060c00c  rsb ip, r0, ip
    dcc0: e0822000  add r2, r2, r0
    dcc4: e59c0008  ldr r0, [ip, #8]
    dcc8: e1500004  cmp r0, r4
    dccc: 0a000059  beq de38 <_free_r+0x1d4>
    dcd0: e59c400c  ldr r4, [ip, #12]
    dcd4: e580400c  str r4, [r0, #12]
    dcd8: e5840008  str r0, [r4, #8]
    dcdc: e08e0001  add r0, lr, r1
    dce0: e5900004  ldr r0, [r0, #4]
    dce4: e3100001  tst r0, #1
    dce8: 1a00000b  bne dd1c <_free_r+0xb8>
    dcec: e59f021c  ldr r0, [pc, #540]  ; df10 <SLCRUnlockKey+0x3>
    dcf0: e0822001  add r2, r2, r1
    dcf4: e59e1008  ldr r1, [lr, #8]
    dcf8: e1510000  cmp r1, r0
    dcfc: 0a00006f  beq dec0 <_free_r+0x25c>
    dd00: e59ee00c  ldr lr, [lr, #12]
    dd04: e3820001  orr r0, r2, #1
    dd08: e581e00c  str lr, [r1, #12]
    dd0c: e58e1008  str r1, [lr, #8]
    dd10: e58c0004  str r0, [ip, #4]
    dd14: e78c2002  str r2, [ip, r2]
    dd18: ea000002  b dd28 <_free_r+0xc4>
    dd1c: e3821001  orr r1, r2, #1
    dd20: e58c1004  str r1, [ip, #4]
    dd24: e78c2002  str r2, [ip, r2]
    dd28: e3520c02  cmp r2, #512  ; 0x200
    dd2c: 2a00000e  bcs dd6c <_free_r+0x108>
    dd30: e1a021a2  lsr r2, r2, #3
    dd34: e5930004  ldr r0, [r3, #4]
    dd38: e3a0e001  mov lr, #1
    dd3c: e0831182  add r1, r3, r2, lsl #3
    dd40: e1a02142  asr r2, r2, #2
    dd44: e180221e  orr r2, r0, lr, lsl r2
    dd48: e5832004  str r2, [r3, #4]
    dd4c: e5913008  ldr r3, [r1, #8]
    dd50: e58c100c  str r1, [ip, #12]
    dd54: e58c3008  str r3, [ip, #8]
    dd58: e581c008  str ip, [r1, #8]
    dd5c: e583c00c  str ip, [r3, #12]
    dd60: e1a00005  mov r0, r5
    dd64: e8bd4070  pop {r4, r5, r6, lr}
    dd68: ea000382  b eb78 <__malloc_unlock>
    dd6c: e1a014a2  lsr r1, r2, #9
    dd70: e3510004  cmp r1, #4
    dd74: 8a000040  bhi de7c <_free_r+0x218>
    dd78: e1a01322  lsr r1, r2, #6
    dd7c: e2811038  add r1, r1, #56 ; 0x38
    dd80: e1a00081  lsl r0, r1, #1
    dd84: e0830100  add r0, r3, r0, lsl #2
    dd88: e30be83c  movw  lr, #47164  ; 0xb83c
    dd8c: e340e001  movt  lr, #1
    dd90: e5903008  ldr r3, [r0, #8]
    dd94: e1530000  cmp r3, r0
    dd98: 0a000041  beq dea4 <_free_r+0x240>
    dd9c: e5931004  ldr r1, [r3, #4]
    dda0: e3c11003  bic r1, r1, #3
    dda4: e1510002  cmp r1, r2
    dda8: 9a000002  bls ddb8 <_free_r+0x154>
    ddac: e5933008  ldr r3, [r3, #8]
    ddb0: e1500003  cmp r0, r3
    ddb4: 1afffff8  bne dd9c <_free_r+0x138>
    ddb8: e593200c  ldr r2, [r3, #12]
    ddbc: e58c200c  str r2, [ip, #12]
    ddc0: e1a00005  mov r0, r5
    ddc4: e58c3008  str r3, [ip, #8]
    ddc8: e8bd4070  pop {r4, r5, r6, lr}
    ddcc: e582c008  str ip, [r2, #8]
    ddd0: e583c00c  str ip, [r3, #12]
    ddd4: ea000367  b eb78 <__malloc_unlock>
    ddd8: e3100001  tst r0, #1
    dddc: e0812002  add r2, r1, r2
    dde0: 1a000006  bne de00 <_free_r+0x19c>
    dde4: e5141008  ldr r1, [r4, #-8]
    dde8: e061c00c  rsb ip, r1, ip
    ddec: e0822001  add r2, r2, r1
    ddf0: e59c0008  ldr r0, [ip, #8]
    ddf4: e59c100c  ldr r1, [ip, #12]
    ddf8: e580100c  str r1, [r0, #12]
    ddfc: e5810008  str r0, [r1, #8]
    de00: e30b0c48  movw  r0, #48200  ; 0xbc48
    de04: e3821001  orr r1, r2, #1
    de08: e3400001  movt  r0, #1
    de0c: e58c1004  str r1, [ip, #4]
    de10: e5901000  ldr r1, [r0]
    de14: e583c008  str ip, [r3, #8]
    de18: e1520001  cmp r2, r1
    de1c: 3affffcf  bcc dd60 <_free_r+0xfc>
    de20: e3013530  movw  r3, #5424 ; 0x1530
    de24: e1a00005  mov r0, r5
    de28: e3403002  movt  r3, #2
    de2c: e5931000  ldr r1, [r3]
    de30: ebffff4c  bl  db68 <_malloc_trim_r>
    de34: eaffffc9  b dd60 <_free_r+0xfc>
    de38: e08e3001  add r3, lr, r1
    de3c: e5933004  ldr r3, [r3, #4]
    de40: e3130001  tst r3, #1
    de44: 1a000008  bne de6c <_free_r+0x208>
    de48: e59e300c  ldr r3, [lr, #12]
    de4c: e0822001  add r2, r2, r1
    de50: e59e1008  ldr r1, [lr, #8]
    de54: e3820001  orr r0, r2, #1
    de58: e581300c  str r3, [r1, #12]
    de5c: e5831008  str r1, [r3, #8]
    de60: e58c0004  str r0, [ip, #4]
    de64: e78c2002  str r2, [ip, r2]
    de68: eaffffbc  b dd60 <_free_r+0xfc>
    de6c: e3823001  orr r3, r2, #1
    de70: e58c3004  str r3, [ip, #4]
    de74: e78c2002  str r2, [ip, r2]
    de78: eaffffb8  b dd60 <_free_r+0xfc>
    de7c: e3510014  cmp r1, #20
    de80: 9281105b  addls r1, r1, #91 ; 0x5b
    de84: 91a00081  lslls r0, r1, #1
    de88: 9affffbd  bls dd84 <_free_r+0x120>
    de8c: e3510054  cmp r1, #84 ; 0x54
    de90: 8a000011  bhi dedc <_free_r+0x278>
    de94: e1a01622  lsr r1, r2, #12
    de98: e281106e  add r1, r1, #110  ; 0x6e
    de9c: e1a00081  lsl r0, r1, #1
    dea0: eaffffb7  b dd84 <_free_r+0x120>
    dea4: e59e0004  ldr r0, [lr, #4]
    dea8: e1a01141  asr r1, r1, #2
    deac: e3a04001  mov r4, #1
    deb0: e1a02003  mov r2, r3
    deb4: e1801114  orr r1, r0, r4, lsl r1
    deb8: e58e1004  str r1, [lr, #4]
    debc: eaffffbe  b ddbc <_free_r+0x158>
    dec0: e583c014  str ip, [r3, #20]
    dec4: e3820001  orr r0, r2, #1
    dec8: e583c010  str ip, [r3, #16]
    decc: e58c100c  str r1, [ip, #12]
    ded0: e98c0003  stmib ip, {r0, r1}
    ded4: e78c2002  str r2, [ip, r2]
    ded8: eaffffa0  b dd60 <_free_r+0xfc>
    dedc: e3510f55  cmp r1, #340  ; 0x154
    dee0: 91a017a2  lsrls r1, r2, #15
    dee4: 92811077  addls r1, r1, #119  ; 0x77
    dee8: 91a00081  lslls r0, r1, #1
    deec: 9affffa4  bls dd84 <_free_r+0x120>
    def0: e3000554  movw  r0, #1364 ; 0x554
    def4: e1510000  cmp r1, r0
    def8: 91a01922  lsrls r1, r2, #18
    defc: 9281107c  addls r1, r1, #124  ; 0x7c
    df00: 83a000fc  movhi r0, #252  ; 0xfc
    df04: 83a0107e  movhi r1, #126  ; 0x7e
    df08: 91a00081  lslls r0, r1, #1
    df0c: eaffff9c  b dd84 <_free_r+0x120>
    df10: 0001b844  .word 0x0001b844

0000df14 <_fwalk>:
    df14: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    df18: e2907e2e  adds  r7, r0, #736  ; 0x2e0
    df1c: 0a000017  beq df80 <_fwalk+0x6c>
    df20: e1a08001  mov r8, r1
    df24: e3a06000  mov r6, #0
    df28: e5975004  ldr r5, [r7, #4]
    df2c: e5974008  ldr r4, [r7, #8]
    df30: e2555001  subs  r5, r5, #1
    df34: 4a00000c  bmi df6c <_fwalk+0x58>
    df38: e1d430bc  ldrh  r3, [r4, #12]
    df3c: e2455001  sub r5, r5, #1
    df40: e3530001  cmp r3, #1
    df44: 9a000005  bls df60 <_fwalk+0x4c>
    df48: e1d430fe  ldrsh r3, [r4, #14]
    df4c: e1a00004  mov r0, r4
    df50: e3730001  cmn r3, #1
    df54: 0a000001  beq df60 <_fwalk+0x4c>
    df58: e12fff38  blx r8
    df5c: e1866000  orr r6, r6, r0
    df60: e3750001  cmn r5, #1
    df64: e2844068  add r4, r4, #104  ; 0x68
    df68: 1afffff2  bne df38 <_fwalk+0x24>
    df6c: e5977000  ldr r7, [r7]
    df70: e3570000  cmp r7, #0
    df74: 1affffeb  bne df28 <_fwalk+0x14>
    df78: e1a00006  mov r0, r6
    df7c: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    df80: e1a06007  mov r6, r7
    df84: e1a00006  mov r0, r6
    df88: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

0000df8c <_fwalk_reent>:
    df8c: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
    df90: e2906e2e  adds  r6, r0, #736  ; 0x2e0
    df94: 0a000019  beq e000 <_fwalk_reent+0x74>
    df98: e1a08001  mov r8, r1
    df9c: e1a07000  mov r7, r0
    dfa0: e3a09000  mov r9, #0
    dfa4: e5965004  ldr r5, [r6, #4]
    dfa8: e5964008  ldr r4, [r6, #8]
    dfac: e2555001  subs  r5, r5, #1
    dfb0: 4a00000d  bmi dfec <_fwalk_reent+0x60>
    dfb4: e1d430bc  ldrh  r3, [r4, #12]
    dfb8: e2455001  sub r5, r5, #1
    dfbc: e3530001  cmp r3, #1
    dfc0: 9a000006  bls dfe0 <_fwalk_reent+0x54>
    dfc4: e1d430fe  ldrsh r3, [r4, #14]
    dfc8: e1a01004  mov r1, r4
    dfcc: e1a00007  mov r0, r7
    dfd0: e3730001  cmn r3, #1
    dfd4: 0a000001  beq dfe0 <_fwalk_reent+0x54>
    dfd8: e12fff38  blx r8
    dfdc: e1899000  orr r9, r9, r0
    dfe0: e3750001  cmn r5, #1
    dfe4: e2844068  add r4, r4, #104  ; 0x68
    dfe8: 1afffff1  bne dfb4 <_fwalk_reent+0x28>
    dfec: e5966000  ldr r6, [r6]
    dff0: e3560000  cmp r6, #0
    dff4: 1affffea  bne dfa4 <_fwalk_reent+0x18>
    dff8: e1a00009  mov r0, r9
    dffc: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
    e000: e1a09006  mov r9, r6
    e004: e1a00009  mov r0, r9
    e008: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

0000e00c <_setlocale_r>:
    e00c: e3520000  cmp r2, #0
    e010: 0a00001a  beq e080 <_setlocale_r+0x74>
    e014: e308177c  movw  r1, #34684  ; 0x877c
    e018: e1a00002  mov r0, r2
    e01c: e92d4010  push  {r4, lr}
    e020: e3401001  movt  r1, #1
    e024: e1a04002  mov r4, r2
    e028: fa000666  blx f9c8 <strcmp>
    e02c: e3500000  cmp r0, #0
    e030: 1a000002  bne e040 <_setlocale_r+0x34>
    e034: e3080738  movw  r0, #34616  ; 0x8738
    e038: e3400001  movt  r0, #1
    e03c: e8bd8010  pop {r4, pc}
    e040: e3081738  movw  r1, #34616  ; 0x8738
    e044: e1a00004  mov r0, r4
    e048: e3401001  movt  r1, #1
    e04c: fa00065d  blx f9c8 <strcmp>
    e050: e3500000  cmp r0, #0
    e054: 0afffff6  beq e034 <_setlocale_r+0x28>
    e058: e30816f8  movw  r1, #34552  ; 0x86f8
    e05c: e1a00004  mov r0, r4
    e060: e3401001  movt  r1, #1
    e064: fa000657  blx f9c8 <strcmp>
    e068: e3083738  movw  r3, #34616  ; 0x8738
    e06c: e3403001  movt  r3, #1
    e070: e3500000  cmp r0, #0
    e074: 01a00003  moveq r0, r3
    e078: 13a00000  movne r0, #0
    e07c: e8bd8010  pop {r4, pc}
    e080: e3080738  movw  r0, #34616  ; 0x8738
    e084: e3400001  movt  r0, #1
    e088: e12fff1e  bx  lr

0000e08c <__locale_charset>:
    e08c: e30b07c0  movw  r0, #47040  ; 0xb7c0
    e090: e3400001  movt  r0, #1
    e094: e12fff1e  bx  lr

0000e098 <__locale_mb_cur_max>:
    e098: e30b37c0  movw  r3, #47040  ; 0xb7c0
    e09c: e3403001  movt  r3, #1
    e0a0: e5930020  ldr r0, [r3, #32]
    e0a4: e12fff1e  bx  lr

0000e0a8 <__locale_msgcharset>:
    e0a8: e59f0000  ldr r0, [pc]  ; e0b0 <__locale_msgcharset+0x8>
    e0ac: e12fff1e  bx  lr
    e0b0: 0001b7e4  .word 0x0001b7e4

0000e0b4 <__locale_cjk_lang>:
    e0b4: e3a00000  mov r0, #0
    e0b8: e12fff1e  bx  lr

0000e0bc <_localeconv_r>:
    e0bc: e59f0000  ldr r0, [pc]  ; e0c4 <_localeconv_r+0x8>
    e0c0: e12fff1e  bx  lr
    e0c4: 0001b804  .word 0x0001b804

0000e0c8 <setlocale>:
    e0c8: e30b3390  movw  r3, #45968  ; 0xb390
    e0cc: e1a02001  mov r2, r1
    e0d0: e3403001  movt  r3, #1
    e0d4: e1a01000  mov r1, r0
    e0d8: e5930000  ldr r0, [r3]
    e0dc: eaffffca  b e00c <_setlocale_r>

0000e0e0 <localeconv>:
    e0e0: e59f0000  ldr r0, [pc]  ; e0e8 <localeconv+0x8>
    e0e4: e12fff1e  bx  lr
    e0e8: 0001b804  .word 0x0001b804

0000e0ec <__smakebuf_r>:
    e0ec: e1d130bc  ldrh  r3, [r1, #12]
    e0f0: e6ff2073  uxth  r2, r3
    e0f4: e3120002  tst r2, #2
    e0f8: 1a000031  bne e1c4 <__smakebuf_r+0xd8>
    e0fc: e92d40f0  push  {r4, r5, r6, r7, lr}
    e100: e1a04001  mov r4, r1
    e104: e1d110be  ldrh  r1, [r1, #14]
    e108: e24dd044  sub sp, sp, #68 ; 0x44
    e10c: e1a05000  mov r5, r0
    e110: e6bf1071  sxth  r1, r1
    e114: e3510000  cmp r1, #0
    e118: ba000011  blt e164 <__smakebuf_r+0x78>
    e11c: e28d2004  add r2, sp, #4
    e120: eb000cd2  bl  11470 <_fstat_r>
    e124: e3500000  cmp r0, #0
    e128: ba00000b  blt e15c <__smakebuf_r+0x70>
    e12c: e59d3008  ldr r3, [sp, #8]
    e130: e2033a0f  and r3, r3, #61440  ; 0xf000
    e134: e2437a02  sub r7, r3, #8192 ; 0x2000
    e138: e3530902  cmp r3, #32768  ; 0x8000
    e13c: e16f7f17  clz r7, r7
    e140: e1a072a7  lsr r7, r7, #5
    e144: 0a000024  beq e1dc <__smakebuf_r+0xf0>
    e148: e1d430bc  ldrh  r3, [r4, #12]
    e14c: e3a06b01  mov r6, #1024 ; 0x400
    e150: e3833b02  orr r3, r3, #2048 ; 0x800
    e154: e1c430bc  strh  r3, [r4, #12]
    e158: ea000007  b e17c <__smakebuf_r+0x90>
    e15c: e1d430bc  ldrh  r3, [r4, #12]
    e160: e6ff2073  uxth  r2, r3
    e164: e3120080  tst r2, #128  ; 0x80
    e168: e3a07000  mov r7, #0
    e16c: e3833b02  orr r3, r3, #2048 ; 0x800
    e170: e1c430bc  strh  r3, [r4, #12]
    e174: 03a06b01  moveq r6, #1024 ; 0x400
    e178: 13a06040  movne r6, #64 ; 0x40
    e17c: e1a00005  mov r0, r5
    e180: e1a01006  mov r1, r6
    e184: eb000034  bl  e25c <_malloc_r>
    e188: e3500000  cmp r0, #0
    e18c: 0a000027  beq e230 <__smakebuf_r+0x144>
    e190: e1d430bc  ldrh  r3, [r4, #12]
    e194: e3570000  cmp r7, #0
    e198: e30d2864  movw  r2, #55396  ; 0xd864
    e19c: e3402000  movt  r2, #0
    e1a0: e3833080  orr r3, r3, #128  ; 0x80
    e1a4: e585203c  str r2, [r5, #60] ; 0x3c
    e1a8: e5840000  str r0, [r4]
    e1ac: e5840010  str r0, [r4, #16]
    e1b0: e5846014  str r6, [r4, #20]
    e1b4: e1c430bc  strh  r3, [r4, #12]
    e1b8: 1a000013  bne e20c <__smakebuf_r+0x120>
    e1bc: e28dd044  add sp, sp, #68 ; 0x44
    e1c0: e8bd80f0  pop {r4, r5, r6, r7, pc}
    e1c4: e2813043  add r3, r1, #67 ; 0x43
    e1c8: e3a02001  mov r2, #1
    e1cc: e5813000  str r3, [r1]
    e1d0: e5813010  str r3, [r1, #16]
    e1d4: e5812014  str r2, [r1, #20]
    e1d8: e12fff1e  bx  lr
    e1dc: e5942028  ldr r2, [r4, #40] ; 0x28
    e1e0: e30f3974  movw  r3, #63860  ; 0xf974
    e1e4: e3403000  movt  r3, #0
    e1e8: e1520003  cmp r2, r3
    e1ec: 1affffd5  bne e148 <__smakebuf_r+0x5c>
    e1f0: e1d430bc  ldrh  r3, [r4, #12]
    e1f4: e3a02b01  mov r2, #1024 ; 0x400
    e1f8: e1a06002  mov r6, r2
    e1fc: e584204c  str r2, [r4, #76] ; 0x4c
    e200: e1833002  orr r3, r3, r2
    e204: e1c430bc  strh  r3, [r4, #12]
    e208: eaffffdb  b e17c <__smakebuf_r+0x90>
    e20c: e1a00005  mov r0, r5
    e210: e1d410fe  ldrsh r1, [r4, #14]
    e214: eb000dce  bl  11954 <_isatty_r>
    e218: e3500000  cmp r0, #0
    e21c: 11d430bc  ldrhne  r3, [r4, #12]
    e220: 13833001  orrne r3, r3, #1
    e224: 11c430bc  strhne  r3, [r4, #12]
    e228: e28dd044  add sp, sp, #68 ; 0x44
    e22c: e8bd80f0  pop {r4, r5, r6, r7, pc}
    e230: e1d430bc  ldrh  r3, [r4, #12]
    e234: e3130c02  tst r3, #512  ; 0x200
    e238: 1affffdf  bne e1bc <__smakebuf_r+0xd0>
    e23c: e3833002  orr r3, r3, #2
    e240: e2842043  add r2, r4, #67 ; 0x43
    e244: e1c430bc  strh  r3, [r4, #12]
    e248: e3a03001  mov r3, #1
    e24c: e5842000  str r2, [r4]
    e250: e5842010  str r2, [r4, #16]
    e254: e5843014  str r3, [r4, #20]
    e258: eaffffd7  b e1bc <__smakebuf_r+0xd0>

0000e25c <_malloc_r>:
    e25c: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    e260: e281400b  add r4, r1, #11
    e264: e3540016  cmp r4, #22
    e268: e24dd00c  sub sp, sp, #12
    e26c: e1a05000  mov r5, r0
    e270: 9a00001f  bls e2f4 <_malloc_r+0x98>
    e274: e3c44007  bic r4, r4, #7
    e278: e1510004  cmp r1, r4
    e27c: 93a01000  movls r1, #0
    e280: 83a01001  movhi r1, #1
    e284: e1913fa4  orrs  r3, r1, r4, lsr #31
    e288: 1a000085  bne e4a4 <_malloc_r+0x248>
    e28c: eb000238  bl  eb74 <__malloc_lock>
    e290: e3540f7e  cmp r4, #504  ; 0x1f8
    e294: 2a00001b  bcs e308 <_malloc_r+0xac>
    e298: e1a011a4  lsr r1, r4, #3
    e29c: e30b683c  movw  r6, #47164  ; 0xb83c
    e2a0: e3406001  movt  r6, #1
    e2a4: e0863181  add r3, r6, r1, lsl #3
    e2a8: e593200c  ldr r2, [r3, #12]
    e2ac: e1520003  cmp r2, r3
    e2b0: 0a000117  beq e714 <_malloc_r+0x4b8>
    e2b4: e5923004  ldr r3, [r2, #4]
    e2b8: e2828008  add r8, r2, #8
    e2bc: e592100c  ldr r1, [r2, #12]
    e2c0: e1a00005  mov r0, r5
    e2c4: e3c33003  bic r3, r3, #3
    e2c8: e592c008  ldr ip, [r2, #8]
    e2cc: e0822003  add r2, r2, r3
    e2d0: e5923004  ldr r3, [r2, #4]
    e2d4: e58c100c  str r1, [ip, #12]
    e2d8: e3833001  orr r3, r3, #1
    e2dc: e581c008  str ip, [r1, #8]
    e2e0: e5823004  str r3, [r2, #4]
    e2e4: eb000223  bl  eb78 <__malloc_unlock>
    e2e8: e1a00008  mov r0, r8
    e2ec: e28dd00c  add sp, sp, #12
    e2f0: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e2f4: e3510010  cmp r1, #16
    e2f8: 8a000069  bhi e4a4 <_malloc_r+0x248>
    e2fc: eb00021c  bl  eb74 <__malloc_lock>
    e300: e3a04010  mov r4, #16
    e304: eaffffe3  b e298 <_malloc_r+0x3c>
    e308: e1b014a4  lsrs  r1, r4, #9
    e30c: 03a0007e  moveq r0, #126  ; 0x7e
    e310: 03a0c03f  moveq ip, #63 ; 0x3f
    e314: 1a000068  bne e4bc <_malloc_r+0x260>
    e318: e30b683c  movw  r6, #47164  ; 0xb83c
    e31c: e3406001  movt  r6, #1
    e320: e0860100  add r0, r6, r0, lsl #2
    e324: e590300c  ldr r3, [r0, #12]
    e328: e1500003  cmp r0, r3
    e32c: 1a000005  bne e348 <_malloc_r+0xec>
    e330: ea00000a  b e360 <_malloc_r+0x104>
    e334: e3510000  cmp r1, #0
    e338: aa0000a5  bge e5d4 <_malloc_r+0x378>
    e33c: e593300c  ldr r3, [r3, #12]
    e340: e1500003  cmp r0, r3
    e344: 0a000005  beq e360 <_malloc_r+0x104>
    e348: e5932004  ldr r2, [r3, #4]
    e34c: e3c22003  bic r2, r2, #3
    e350: e0641002  rsb r1, r4, r2
    e354: e351000f  cmp r1, #15
    e358: dafffff5  ble e334 <_malloc_r+0xd8>
    e35c: e24cc001  sub ip, ip, #1
    e360: e28c1001  add r1, ip, #1
    e364: e30be83c  movw  lr, #47164  ; 0xb83c
    e368: e5963010  ldr r3, [r6, #16]
    e36c: e340e001  movt  lr, #1
    e370: e28e7008  add r7, lr, #8
    e374: e1530007  cmp r3, r7
    e378: 059e2004  ldreq r2, [lr, #4]
    e37c: 0a000016  beq e3dc <_malloc_r+0x180>
    e380: e5932004  ldr r2, [r3, #4]
    e384: e3c22003  bic r2, r2, #3
    e388: e064c002  rsb ip, r4, r2
    e38c: e35c000f  cmp ip, #15
    e390: ca0000cd  bgt e6cc <_malloc_r+0x470>
    e394: e35c0000  cmp ip, #0
    e398: e58e7014  str r7, [lr, #20]
    e39c: e58e7010  str r7, [lr, #16]
    e3a0: aa00004b  bge e4d4 <_malloc_r+0x278>
    e3a4: e3520c02  cmp r2, #512  ; 0x200
    e3a8: 2a0000ad  bcs e664 <_malloc_r+0x408>
    e3ac: e1a0c1a2  lsr ip, r2, #3
    e3b0: e59e0004  ldr r0, [lr, #4]
    e3b4: e3a09001  mov r9, #1
    e3b8: e08e818c  add r8, lr, ip, lsl #3
    e3bc: e1a0214c  asr r2, ip, #2
    e3c0: e1802219  orr r2, r0, r9, lsl r2
    e3c4: e58e2004  str r2, [lr, #4]
    e3c8: e5980008  ldr r0, [r8, #8]
    e3cc: e583800c  str r8, [r3, #12]
    e3d0: e5830008  str r0, [r3, #8]
    e3d4: e5883008  str r3, [r8, #8]
    e3d8: e580300c  str r3, [r0, #12]
    e3dc: e1a03141  asr r3, r1, #2
    e3e0: e3a00001  mov r0, #1
    e3e4: e1a00310  lsl r0, r0, r3
    e3e8: e1500002  cmp r0, r2
    e3ec: 8a000042  bhi e4fc <_malloc_r+0x2a0>
    e3f0: e1120000  tst r2, r0
    e3f4: 1a000008  bne e41c <_malloc_r+0x1c0>
    e3f8: e1a00080  lsl r0, r0, #1
    e3fc: e3c11003  bic r1, r1, #3
    e400: e1120000  tst r2, r0
    e404: e2811004  add r1, r1, #4
    e408: 1a000003  bne e41c <_malloc_r+0x1c0>
    e40c: e1a00080  lsl r0, r0, #1
    e410: e2811004  add r1, r1, #4
    e414: e1120000  tst r2, r0
    e418: 0afffffb  beq e40c <_malloc_r+0x1b0>
    e41c: e0868181  add r8, r6, r1, lsl #3
    e420: e1a09001  mov r9, r1
    e424: e1a0c008  mov ip, r8
    e428: e59ce00c  ldr lr, [ip, #12]
    e42c: e15c000e  cmp ip, lr
    e430: 1a000005  bne e44c <_malloc_r+0x1f0>
    e434: ea0000b1  b e700 <_malloc_r+0x4a4>
    e438: e3520000  cmp r2, #0
    e43c: aa0000ba  bge e72c <_malloc_r+0x4d0>
    e440: e59ee00c  ldr lr, [lr, #12]
    e444: e15c000e  cmp ip, lr
    e448: 0a0000ac  beq e700 <_malloc_r+0x4a4>
    e44c: e59e3004  ldr r3, [lr, #4]
    e450: e3c33003  bic r3, r3, #3
    e454: e0642003  rsb r2, r4, r3
    e458: e352000f  cmp r2, #15
    e45c: dafffff5  ble e438 <_malloc_r+0x1dc>
    e460: e1a0800e  mov r8, lr
    e464: e59e100c  ldr r1, [lr, #12]
    e468: e5b8c008  ldr ip, [r8, #8]!
    e46c: e08e3004  add r3, lr, r4
    e470: e1a00005  mov r0, r5
    e474: e3844001  orr r4, r4, #1
    e478: e3825001  orr r5, r2, #1
    e47c: e58e4004  str r4, [lr, #4]
    e480: e58c100c  str r1, [ip, #12]
    e484: e581c008  str ip, [r1, #8]
    e488: e5863014  str r3, [r6, #20]
    e48c: e5863010  str r3, [r6, #16]
    e490: e583700c  str r7, [r3, #12]
    e494: e98300a0  stmib r3, {r5, r7}
    e498: e7832002  str r2, [r3, r2]
    e49c: eb0001b5  bl  eb78 <__malloc_unlock>
    e4a0: eaffff90  b e2e8 <_malloc_r+0x8c>
    e4a4: e3a08000  mov r8, #0
    e4a8: e3a0300c  mov r3, #12
    e4ac: e1a00008  mov r0, r8
    e4b0: e5853000  str r3, [r5]
    e4b4: e28dd00c  add sp, sp, #12
    e4b8: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e4bc: e3510004  cmp r1, #4
    e4c0: 8a00005d  bhi e63c <_malloc_r+0x3e0>
    e4c4: e1a01324  lsr r1, r4, #6
    e4c8: e281c038  add ip, r1, #56 ; 0x38
    e4cc: e1a0008c  lsl r0, ip, #1
    e4d0: eaffff90  b e318 <_malloc_r+0xbc>
    e4d4: e0832002  add r2, r3, r2
    e4d8: e2838008  add r8, r3, #8
    e4dc: e1a00005  mov r0, r5
    e4e0: e5923004  ldr r3, [r2, #4]
    e4e4: e3833001  orr r3, r3, #1
    e4e8: e5823004  str r3, [r2, #4]
    e4ec: eb0001a1  bl  eb78 <__malloc_unlock>
    e4f0: e1a00008  mov r0, r8
    e4f4: e28dd00c  add sp, sp, #12
    e4f8: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e4fc: e5968008  ldr r8, [r6, #8]
    e500: e30b183c  movw  r1, #47164  ; 0xb83c
    e504: e3401001  movt  r1, #1
    e508: e5987004  ldr r7, [r8, #4]
    e50c: e3c77003  bic r7, r7, #3
    e510: e1570004  cmp r7, r4
    e514: e0642007  rsb r2, r4, r7
    e518: 23a03000  movcs r3, #0
    e51c: 33a03001  movcc r3, #1
    e520: e352000f  cmp r2, #15
    e524: d3833001  orrle r3, r3, #1
    e528: e3530000  cmp r3, #0
    e52c: 0a000036  beq e60c <_malloc_r+0x3b0>
    e530: e3019530  movw  r9, #5424 ; 0x1530
    e534: e5913408  ldr r3, [r1, #1032] ; 0x408
    e538: e3409002  movt  r9, #2
    e53c: e1a00005  mov r0, r5
    e540: e5992000  ldr r2, [r9]
    e544: e3730001  cmn r3, #1
    e548: e0842002  add r2, r4, r2
    e54c: 12822a01  addne r2, r2, #4096 ; 0x1000
    e550: 0282a010  addeq sl, r2, #16
    e554: 1282200f  addne r2, r2, #15
    e558: 13c2aeff  bicne sl, r2, #4080 ; 0xff0
    e55c: 13caa00f  bicne sl, sl, #15
    e560: e1a0100a  mov r1, sl
    e564: eb0004d1  bl  f8b0 <_sbrk_r>
    e568: e3700001  cmn r0, #1
    e56c: e1a0b000  mov fp, r0
    e570: 0a000008  beq e598 <_malloc_r+0x33c>
    e574: e0582006  subs  r2, r8, r6
    e578: e0883007  add r3, r8, r7
    e57c: 13a02001  movne r2, #1
    e580: e1580006  cmp r8, r6
    e584: 11530000  cmpne r3, r0
    e588: e30b083c  movw  r0, #47164  ; 0xb83c
    e58c: e58d2000  str r2, [sp]
    e590: e3400001  movt  r0, #1
    e594: 9a000094  bls e7ec <_malloc_r+0x590>
    e598: e5968008  ldr r8, [r6, #8]
    e59c: e5983004  ldr r3, [r8, #4]
    e5a0: e3c33003  bic r3, r3, #3
    e5a4: e1540003  cmp r4, r3
    e5a8: e0642003  rsb r2, r4, r3
    e5ac: 93a03000  movls r3, #0
    e5b0: 83a03001  movhi r3, #1
    e5b4: e352000f  cmp r2, #15
    e5b8: d3833001  orrle r3, r3, #1
    e5bc: e3530000  cmp r3, #0
    e5c0: 0a000011  beq e60c <_malloc_r+0x3b0>
    e5c4: e1a00005  mov r0, r5
    e5c8: e3a08000  mov r8, #0
    e5cc: eb000169  bl  eb78 <__malloc_unlock>
    e5d0: eaffff44  b e2e8 <_malloc_r+0x8c>
    e5d4: e0832002  add r2, r3, r2
    e5d8: e593c00c  ldr ip, [r3, #12]
    e5dc: e593e008  ldr lr, [r3, #8]
    e5e0: e1a00005  mov r0, r5
    e5e4: e5921004  ldr r1, [r2, #4]
    e5e8: e2838008  add r8, r3, #8
    e5ec: e58ec00c  str ip, [lr, #12]
    e5f0: e3813001  orr r3, r1, #1
    e5f4: e58ce008  str lr, [ip, #8]
    e5f8: e5823004  str r3, [r2, #4]
    e5fc: eb00015d  bl  eb78 <__malloc_unlock>
    e600: e1a00008  mov r0, r8
    e604: e28dd00c  add sp, sp, #12
    e608: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e60c: e0883004  add r3, r8, r4
    e610: e3822001  orr r2, r2, #1
    e614: e1a00005  mov r0, r5
    e618: e3844001  orr r4, r4, #1
    e61c: e5884004  str r4, [r8, #4]
    e620: e2888008  add r8, r8, #8
    e624: e5863008  str r3, [r6, #8]
    e628: e5832004  str r2, [r3, #4]
    e62c: eb000151  bl  eb78 <__malloc_unlock>
    e630: e1a00008  mov r0, r8
    e634: e28dd00c  add sp, sp, #12
    e638: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    e63c: e3510014  cmp r1, #20
    e640: 9281c05b  addls ip, r1, #91 ; 0x5b
    e644: 91a0008c  lslls r0, ip, #1
    e648: 9affff32  bls e318 <_malloc_r+0xbc>
    e64c: e3510054  cmp r1, #84 ; 0x54
    e650: 8a0000ae  bhi e910 <_malloc_r+0x6b4>
    e654: e1a01624  lsr r1, r4, #12
    e658: e281c06e  add ip, r1, #110  ; 0x6e
    e65c: e1a0008c  lsl r0, ip, #1
    e660: eaffff2c  b e318 <_malloc_r+0xbc>
    e664: e1a004a2  lsr r0, r2, #9
    e668: e3500004  cmp r0, #4
    e66c: 8a00003a  bhi e75c <_malloc_r+0x500>
    e670: e1a00322  lsr r0, r2, #6
    e674: e280e038  add lr, r0, #56 ; 0x38
    e678: e1a0008e  lsl r0, lr, #1
    e67c: e0860100  add r0, r6, r0, lsl #2
    e680: e30b883c  movw  r8, #47164  ; 0xb83c
    e684: e3408001  movt  r8, #1
    e688: e590c008  ldr ip, [r0, #8]
    e68c: e15c0000  cmp ip, r0
    e690: 0a0000a4  beq e928 <_malloc_r+0x6cc>
    e694: e59ce004  ldr lr, [ip, #4]
    e698: e3cee003  bic lr, lr, #3
    e69c: e152000e  cmp r2, lr
    e6a0: 2a000002  bcs e6b0 <_malloc_r+0x454>
    e6a4: e59cc008  ldr ip, [ip, #8]
    e6a8: e150000c  cmp r0, ip
    e6ac: 1afffff8  bne e694 <_malloc_r+0x438>
    e6b0: e59c900c  ldr r9, [ip, #12]
    e6b4: e5962004  ldr r2, [r6, #4]
    e6b8: e583900c  str r9, [r3, #12]
    e6bc: e583c008  str ip, [r3, #8]
    e6c0: e5893008  str r3, [r9, #8]
    e6c4: e58c300c  str r3, [ip, #12]
    e6c8: eaffff43  b e3dc <_malloc_r+0x180>
    e6cc: e0832004  add r2, r3, r4
    e6d0: e38c1001  orr r1, ip, #1
    e6d4: e3844001  orr r4, r4, #1
    e6d8: e1a00005  mov r0, r5
    e6dc: e5834004  str r4, [r3, #4]
    e6e0: e2838008  add r8, r3, #8
    e6e4: e58e2014  str r2, [lr, #20]
    e6e8: e58e2010  str r2, [lr, #16]
    e6ec: e582700c  str r7, [r2, #12]
    e6f0: e9820082  stmib r2, {r1, r7}
    e6f4: e782c00c  str ip, [r2, ip]
    e6f8: eb00011e  bl  eb78 <__malloc_unlock>
    e6fc: eafffef9  b e2e8 <_malloc_r+0x8c>
    e700: e2899001  add r9, r9, #1
    e704: e28cc008  add ip, ip, #8
    e708: e3190003  tst r9, #3
    e70c: 1affff45  bne e428 <_malloc_r+0x1cc>
    e710: ea00001e  b e790 <_malloc_r+0x534>
    e714: e2823008  add r3, r2, #8
    e718: e5922014  ldr r2, [r2, #20]
    e71c: e1530002  cmp r3, r2
    e720: 02811002  addeq r1, r1, #2
    e724: 0affff0e  beq e364 <_malloc_r+0x108>
    e728: eafffee1  b e2b4 <_malloc_r+0x58>
    e72c: e08e2003  add r2, lr, r3
    e730: e1a0800e  mov r8, lr
    e734: e59e100c  ldr r1, [lr, #12]
    e738: e1a00005  mov r0, r5
    e73c: e5b8c008  ldr ip, [r8, #8]!
    e740: e5923004  ldr r3, [r2, #4]
    e744: e3833001  orr r3, r3, #1
    e748: e5823004  str r3, [r2, #4]
    e74c: e58c100c  str r1, [ip, #12]
    e750: e581c008  str ip, [r1, #8]
    e754: eb000107  bl  eb78 <__malloc_unlock>
    e758: eafffee2  b e2e8 <_malloc_r+0x8c>
    e75c: e3500014  cmp r0, #20
    e760: 9280e05b  addls lr, r0, #91 ; 0x5b
    e764: 91a0008e  lslls r0, lr, #1
    e768: 9affffc3  bls e67c <_malloc_r+0x420>
    e76c: e3500054  cmp r0, #84 ; 0x54
    e770: 8a000088  bhi e998 <_malloc_r+0x73c>
    e774: e1a00622  lsr r0, r2, #12
    e778: e280e06e  add lr, r0, #110  ; 0x6e
    e77c: e1a0008e  lsl r0, lr, #1
    e780: eaffffbd  b e67c <_malloc_r+0x420>
    e784: e5988000  ldr r8, [r8]
    e788: e1580003  cmp r8, r3
    e78c: 1a00008e  bne e9cc <_malloc_r+0x770>
    e790: e3110003  tst r1, #3
    e794: e2483008  sub r3, r8, #8
    e798: e2411001  sub r1, r1, #1
    e79c: 1afffff8  bne e784 <_malloc_r+0x528>
    e7a0: e5963004  ldr r3, [r6, #4]
    e7a4: e1c33000  bic r3, r3, r0
    e7a8: e5863004  str r3, [r6, #4]
    e7ac: e1a00080  lsl r0, r0, #1
    e7b0: e1500003  cmp r0, r3
    e7b4: 83a02000  movhi r2, #0
    e7b8: 93a02001  movls r2, #1
    e7bc: e3500000  cmp r0, #0
    e7c0: 03a02000  moveq r2, #0
    e7c4: e3520000  cmp r2, #0
    e7c8: 0affff4b  beq e4fc <_malloc_r+0x2a0>
    e7cc: e1130000  tst r3, r0
    e7d0: e1a01009  mov r1, r9
    e7d4: 1affff10  bne e41c <_malloc_r+0x1c0>
    e7d8: e1a00080  lsl r0, r0, #1
    e7dc: e2811004  add r1, r1, #4
    e7e0: e1130000  tst r3, r0
    e7e4: 0afffffb  beq e7d8 <_malloc_r+0x57c>
    e7e8: eaffff0b  b e41c <_malloc_r+0x1c0>
    e7ec: e5991004  ldr r1, [r9, #4]
    e7f0: e153000b  cmp r3, fp
    e7f4: e08a1001  add r1, sl, r1
    e7f8: e5891004  str r1, [r9, #4]
    e7fc: 0a000058  beq e964 <_malloc_r+0x708>
    e800: e596c408  ldr ip, [r6, #1032] ; 0x408
    e804: e30b083c  movw  r0, #47164  ; 0xb83c
    e808: e3400001  movt  r0, #1
    e80c: e37c0001  cmn ip, #1
    e810: 0580b408  streq fp, [r0, #1032] ; 0x408
    e814: 1063300b  rsbne r3, r3, fp
    e818: 10811003  addne r1, r1, r3
    e81c: 15891004  strne r1, [r9, #4]
    e820: e21b3007  ands  r3, fp, #7
    e824: 12630008  rsbne r0, r3, #8
    e828: 12631a01  rsbne r1, r3, #4096 ; 0x1000
    e82c: 108bb000  addne fp, fp, r0
    e830: 12811008  addne r1, r1, #8
    e834: e08b300a  add r3, fp, sl
    e838: 03a01a01  moveq r1, #4096 ; 0x1000
    e83c: e7eb3053  ubfx  r3, r3, #0, #12
    e840: e1a00005  mov r0, r5
    e844: e0633001  rsb r3, r3, r1
    e848: e58d3004  str r3, [sp, #4]
    e84c: e301a530  movw  sl, #5424 ; 0x1530
    e850: e1a01003  mov r1, r3
    e854: e340a002  movt  sl, #2
    e858: eb000414  bl  f8b0 <_sbrk_r>
    e85c: e59d1000  ldr r1, [sp]
    e860: e586b008  str fp, [r6, #8]
    e864: e3700001  cmn r0, #1
    e868: 106b2000  rsbne r2, fp, r0
    e86c: 159d3004  ldrne r3, [sp, #4]
    e870: 03a02001  moveq r2, #1
    e874: 03a03000  moveq r3, #0
    e878: 10832002  addne r2, r3, r2
    e87c: 13822001  orrne r2, r2, #1
    e880: e3510000  cmp r1, #0
    e884: e5991004  ldr r1, [r9, #4]
    e888: e58b2004  str r2, [fp, #4]
    e88c: e0831001  add r1, r3, r1
    e890: e5891004  str r1, [r9, #4]
    e894: 0a00000f  beq e8d8 <_malloc_r+0x67c>
    e898: e357000f  cmp r7, #15
    e89c: 93a03001  movls r3, #1
    e8a0: 958b3004  strls r3, [fp, #4]
    e8a4: 9affff46  bls e5c4 <_malloc_r+0x368>
    e8a8: e247300c  sub r3, r7, #12
    e8ac: e5982004  ldr r2, [r8, #4]
    e8b0: e3c33007  bic r3, r3, #7
    e8b4: e3a0c005  mov ip, #5
    e8b8: e0880003  add r0, r8, r3
    e8bc: e353000f  cmp r3, #15
    e8c0: e2022001  and r2, r2, #1
    e8c4: e1833002  orr r3, r3, r2
    e8c8: e5883004  str r3, [r8, #4]
    e8cc: e580c004  str ip, [r0, #4]
    e8d0: e580c008  str ip, [r0, #8]
    e8d4: 8a00002a  bhi e984 <_malloc_r+0x728>
    e8d8: e599202c  ldr r2, [r9, #44] ; 0x2c
    e8dc: e3013530  movw  r3, #5424 ; 0x1530
    e8e0: e3403002  movt  r3, #2
    e8e4: e5968008  ldr r8, [r6, #8]
    e8e8: e1510002  cmp r1, r2
    e8ec: e5992030  ldr r2, [r9, #48] ; 0x30
    e8f0: 8583102c  strhi r1, [r3, #44] ; 0x2c
    e8f4: e3013530  movw  r3, #5424 ; 0x1530
    e8f8: e3403002  movt  r3, #2
    e8fc: e1510002  cmp r1, r2
    e900: 85831030  strhi r1, [r3, #48] ; 0x30
    e904: e5983004  ldr r3, [r8, #4]
    e908: e3c33003  bic r3, r3, #3
    e90c: eaffff24  b e5a4 <_malloc_r+0x348>
    e910: e3510f55  cmp r1, #340  ; 0x154
    e914: 8a00000a  bhi e944 <_malloc_r+0x6e8>
    e918: e1a017a4  lsr r1, r4, #15
    e91c: e281c077  add ip, r1, #119  ; 0x77
    e920: e1a0008c  lsl r0, ip, #1
    e924: eafffe7b  b e318 <_malloc_r+0xbc>
    e928: e5982004  ldr r2, [r8, #4]
    e92c: e1a0014e  asr r0, lr, #2
    e930: e3a0e001  mov lr, #1
    e934: e1a0900c  mov r9, ip
    e938: e182201e  orr r2, r2, lr, lsl r0
    e93c: e5882004  str r2, [r8, #4]
    e940: eaffff5c  b e6b8 <_malloc_r+0x45c>
    e944: e3003554  movw  r3, #1364 ; 0x554
    e948: e1510003  cmp r1, r3
    e94c: 91a01924  lsrls r1, r4, #18
    e950: 9281c07c  addls ip, r1, #124  ; 0x7c
    e954: 83a000fc  movhi r0, #252  ; 0xfc
    e958: 83a0c07e  movhi ip, #126  ; 0x7e
    e95c: 91a0008c  lslls r0, ip, #1
    e960: eafffe6c  b e318 <_malloc_r+0xbc>
    e964: e7ebc053  ubfx  ip, r3, #0, #12
    e968: e35c0000  cmp ip, #0
    e96c: 1affffa3  bne e800 <_malloc_r+0x5a4>
    e970: e5900008  ldr r0, [r0, #8]
    e974: e08a2007  add r2, sl, r7
    e978: e3823001  orr r3, r2, #1
    e97c: e5803004  str r3, [r0, #4]
    e980: eaffffd4  b e8d8 <_malloc_r+0x67c>
    e984: e2881008  add r1, r8, #8
    e988: e1a00005  mov r0, r5
    e98c: ebfffcb4  bl  dc64 <_free_r>
    e990: e59a1004  ldr r1, [sl, #4]
    e994: eaffffcf  b e8d8 <_malloc_r+0x67c>
    e998: e3500f55  cmp r0, #340  ; 0x154
    e99c: 91a007a2  lsrls r0, r2, #15
    e9a0: 9280e077  addls lr, r0, #119  ; 0x77
    e9a4: 91a0008e  lslls r0, lr, #1
    e9a8: 9affff33  bls e67c <_malloc_r+0x420>
    e9ac: e300c554  movw  ip, #1364 ; 0x554
    e9b0: e150000c  cmp r0, ip
    e9b4: 91a00922  lsrls r0, r2, #18
    e9b8: 9280e07c  addls lr, r0, #124  ; 0x7c
    e9bc: 83a000fc  movhi r0, #252  ; 0xfc
    e9c0: 83a0e07e  movhi lr, #126  ; 0x7e
    e9c4: 91a0008e  lslls r0, lr, #1
    e9c8: eaffff2b  b e67c <_malloc_r+0x420>
    e9cc: e5963004  ldr r3, [r6, #4]
    e9d0: eaffff75  b e7ac <_malloc_r+0x550>
  ...

0000e9e0 <memchr>:
    e9e0: f001 01ff   and.w r1, r1, #255  ; 0xff
    e9e4: 2a10        cmp r2, #16
    e9e6: db2b        blt.n ea40 <memchr+0x60>
    e9e8: f010 0f07   tst.w r0, #7
    e9ec: d008        beq.n ea00 <memchr+0x20>
    e9ee: f810 3b01   ldrb.w  r3, [r0], #1
    e9f2: 3a01        subs  r2, #1
    e9f4: 428b        cmp r3, r1
    e9f6: d02d        beq.n ea54 <memchr+0x74>
    e9f8: f010 0f07   tst.w r0, #7
    e9fc: b342        cbz r2, ea50 <memchr+0x70>
    e9fe: d1f6        bne.n e9ee <memchr+0xe>
    ea00: b4f0        push  {r4, r5, r6, r7}
    ea02: ea41 2101   orr.w r1, r1, r1, lsl #8
    ea06: ea41 4101   orr.w r1, r1, r1, lsl #16
    ea0a: f022 0407   bic.w r4, r2, #7
    ea0e: f07f 0700   mvns.w  r7, #0
    ea12: 2300        movs  r3, #0
    ea14: e8f0 5602   ldrd  r5, r6, [r0], #8
    ea18: 3c08        subs  r4, #8
    ea1a: ea85 0501   eor.w r5, r5, r1
    ea1e: ea86 0601   eor.w r6, r6, r1
    ea22: fa85 f547   uadd8 r5, r5, r7
    ea26: faa3 f587   sel r5, r3, r7
    ea2a: fa86 f647   uadd8 r6, r6, r7
    ea2e: faa5 f687   sel r6, r5, r7
    ea32: b98e        cbnz  r6, ea58 <memchr+0x78>
    ea34: d1ee        bne.n ea14 <memchr+0x34>
    ea36: bcf0        pop {r4, r5, r6, r7}
    ea38: f001 01ff   and.w r1, r1, #255  ; 0xff
    ea3c: f002 0207   and.w r2, r2, #7
    ea40: b132        cbz r2, ea50 <memchr+0x70>
    ea42: f810 3b01   ldrb.w  r3, [r0], #1
    ea46: 3a01        subs  r2, #1
    ea48: ea83 0301   eor.w r3, r3, r1
    ea4c: b113        cbz r3, ea54 <memchr+0x74>
    ea4e: d1f8        bne.n ea42 <memchr+0x62>
    ea50: 2000        movs  r0, #0
    ea52: 4770        bx  lr
    ea54: 3801        subs  r0, #1
    ea56: 4770        bx  lr
    ea58: 2d00        cmp r5, #0
    ea5a: bf06        itte  eq
    ea5c: 4635        moveq r5, r6
    ea5e: 3803        subeq r0, #3
    ea60: 3807        subne r0, #7
    ea62: f015 0f01   tst.w r5, #1
    ea66: d107        bne.n ea78 <memchr+0x98>
    ea68: 3001        adds  r0, #1
    ea6a: f415 7f80   tst.w r5, #256  ; 0x100
    ea6e: bf02        ittt  eq
    ea70: 3001        addeq r0, #1
    ea72: f415 3fc0   tsteq.w r5, #98304  ; 0x18000
    ea76: 3001        addeq r0, #1
    ea78: bcf0        pop {r4, r5, r6, r7}
    ea7a: 3801        subs  r0, #1
    ea7c: 4770        bx  lr
    ea7e: bf00        nop

0000ea80 <memset>:
    ea80: e3100003  tst r0, #3
    ea84: e92d4010  push  {r4, lr}
    ea88: 0a000037  beq eb6c <memset+0xec>
    ea8c: e3520000  cmp r2, #0
    ea90: e2422001  sub r2, r2, #1
    ea94: 08bd8010  popeq {r4, pc}
    ea98: e6efe071  uxtb  lr, r1
    ea9c: e1a03000  mov r3, r0
    eaa0: ea000002  b eab0 <memset+0x30>
    eaa4: e3520000  cmp r2, #0
    eaa8: e1a0200c  mov r2, ip
    eaac: 08bd8010  popeq {r4, pc}
    eab0: e4c3e001  strb  lr, [r3], #1
    eab4: e3130003  tst r3, #3
    eab8: e242c001  sub ip, r2, #1
    eabc: 1afffff8  bne eaa4 <memset+0x24>
    eac0: e3520003  cmp r2, #3
    eac4: 9a000020  bls eb4c <memset+0xcc>
    eac8: e6efe071  uxtb  lr, r1
    eacc: e352000f  cmp r2, #15
    ead0: e18ee40e  orr lr, lr, lr, lsl #8
    ead4: e18ee80e  orr lr, lr, lr, lsl #16
    ead8: 9a000010  bls eb20 <memset+0xa0>
    eadc: e283c010  add ip, r3, #16
    eae0: e1a04002  mov r4, r2
    eae4: e2444010  sub r4, r4, #16
    eae8: e50ce010  str lr, [ip, #-16]
    eaec: e354000f  cmp r4, #15
    eaf0: e50ce00c  str lr, [ip, #-12]
    eaf4: e50ce008  str lr, [ip, #-8]
    eaf8: e28cc010  add ip, ip, #16
    eafc: e50ce014  str lr, [ip, #-20]  ; 0xffffffec
    eb00: 8afffff7  bhi eae4 <memset+0x64>
    eb04: e242c010  sub ip, r2, #16
    eb08: e202200f  and r2, r2, #15
    eb0c: e3ccc00f  bic ip, ip, #15
    eb10: e3520003  cmp r2, #3
    eb14: e28cc010  add ip, ip, #16
    eb18: e083300c  add r3, r3, ip
    eb1c: 9a00000a  bls eb4c <memset+0xcc>
    eb20: e1a04003  mov r4, r3
    eb24: e1a0c002  mov ip, r2
    eb28: e24cc004  sub ip, ip, #4
    eb2c: e484e004  str lr, [r4], #4
    eb30: e35c0003  cmp ip, #3
    eb34: 8afffffb  bhi eb28 <memset+0xa8>
    eb38: e242c004  sub ip, r2, #4
    eb3c: e2022003  and r2, r2, #3
    eb40: e3ccc003  bic ip, ip, #3
    eb44: e28cc004  add ip, ip, #4
    eb48: e083300c  add r3, r3, ip
    eb4c: e3520000  cmp r2, #0
    eb50: 08bd8010  popeq {r4, pc}
    eb54: e6ef1071  uxtb  r1, r1
    eb58: e0832002  add r2, r3, r2
    eb5c: e4c31001  strb  r1, [r3], #1
    eb60: e1530002  cmp r3, r2
    eb64: 1afffffc  bne eb5c <memset+0xdc>
    eb68: e8bd8010  pop {r4, pc}
    eb6c: e1a03000  mov r3, r0
    eb70: eaffffd2  b eac0 <memset+0x40>

0000eb74 <__malloc_lock>:
    eb74: e12fff1e  bx  lr

0000eb78 <__malloc_unlock>:
    eb78: e12fff1e  bx  lr

0000eb7c <_Balloc>:
    eb7c: e590204c  ldr r2, [r0, #76] ; 0x4c
    eb80: e92d4038  push  {r3, r4, r5, lr}
    eb84: e3520000  cmp r2, #0
    eb88: e1a05000  mov r5, r0
    eb8c: e1a04001  mov r4, r1
    eb90: 0a000009  beq ebbc <_Balloc+0x40>
    eb94: e7923104  ldr r3, [r2, r4, lsl #2]
    eb98: e3530000  cmp r3, #0
    eb9c: 0a00000f  beq ebe0 <_Balloc+0x64>
    eba0: e5931000  ldr r1, [r3]
    eba4: e7821104  str r1, [r2, r4, lsl #2]
    eba8: e3a02000  mov r2, #0
    ebac: e1a00003  mov r0, r3
    ebb0: e5832010  str r2, [r3, #16]
    ebb4: e583200c  str r2, [r3, #12]
    ebb8: e8bd8038  pop {r3, r4, r5, pc}
    ebbc: e3a02021  mov r2, #33 ; 0x21
    ebc0: e3a01004  mov r1, #4
    ebc4: eb000952  bl  11114 <_calloc_r>
    ebc8: e3500000  cmp r0, #0
    ebcc: e585004c  str r0, [r5, #76] ; 0x4c
    ebd0: 11a02000  movne r2, r0
    ebd4: 1affffee  bne eb94 <_Balloc+0x18>
    ebd8: e3a00000  mov r0, #0
    ebdc: e8bd8038  pop {r3, r4, r5, pc}
    ebe0: e3a01001  mov r1, #1
    ebe4: e1a00005  mov r0, r5
    ebe8: e1a05411  lsl r5, r1, r4
    ebec: e2852005  add r2, r5, #5
    ebf0: e1a02102  lsl r2, r2, #2
    ebf4: eb000946  bl  11114 <_calloc_r>
    ebf8: e2503000  subs  r3, r0, #0
    ebfc: 0afffff5  beq ebd8 <_Balloc+0x5c>
    ec00: e9830030  stmib r3, {r4, r5}
    ec04: eaffffe7  b eba8 <_Balloc+0x2c>

0000ec08 <_Bfree>:
    ec08: e3510000  cmp r1, #0
    ec0c: 1590304c  ldrne r3, [r0, #76] ; 0x4c
    ec10: 15912004  ldrne r2, [r1, #4]
    ec14: 17930102  ldrne r0, [r3, r2, lsl #2]
    ec18: 15810000  strne r0, [r1]
    ec1c: 17831102  strne r1, [r3, r2, lsl #2]
    ec20: e12fff1e  bx  lr

0000ec24 <__multadd>:
    ec24: e92d40f0  push  {r4, r5, r6, r7, lr}
    ec28: e2817014  add r7, r1, #20
    ec2c: e5914010  ldr r4, [r1, #16]
    ec30: e24dd00c  sub sp, sp, #12
    ec34: e1a06000  mov r6, r0
    ec38: e1a05001  mov r5, r1
    ec3c: e3a00000  mov r0, #0
    ec40: e597e000  ldr lr, [r7]
    ec44: e2800001  add r0, r0, #1
    ec48: e1540000  cmp r4, r0
    ec4c: e6ffc07e  uxth  ip, lr
    ec50: e1a0e82e  lsr lr, lr, #16
    ec54: e0233c92  mla r3, r2, ip, r3
    ec58: e00c0e92  mul ip, r2, lr
    ec5c: e08cc823  add ip, ip, r3, lsr #16
    ec60: e6ff3073  uxth  r3, r3
    ec64: e083180c  add r1, r3, ip, lsl #16
    ec68: e1a0382c  lsr r3, ip, #16
    ec6c: e4871004  str r1, [r7], #4
    ec70: cafffff2  bgt ec40 <__multadd+0x1c>
    ec74: e3530000  cmp r3, #0
    ec78: 0a000006  beq ec98 <__multadd+0x74>
    ec7c: e5952008  ldr r2, [r5, #8]
    ec80: e1540002  cmp r4, r2
    ec84: aa000006  bge eca4 <__multadd+0x80>
    ec88: e0852104  add r2, r5, r4, lsl #2
    ec8c: e2844001  add r4, r4, #1
    ec90: e5823014  str r3, [r2, #20]
    ec94: e5854010  str r4, [r5, #16]
    ec98: e1a00005  mov r0, r5
    ec9c: e28dd00c  add sp, sp, #12
    eca0: e8bd80f0  pop {r4, r5, r6, r7, pc}
    eca4: e5951004  ldr r1, [r5, #4]
    eca8: e1a00006  mov r0, r6
    ecac: e58d3004  str r3, [sp, #4]
    ecb0: e2811001  add r1, r1, #1
    ecb4: ebffffb0  bl  eb7c <_Balloc>
    ecb8: e5952010  ldr r2, [r5, #16]
    ecbc: e285100c  add r1, r5, #12
    ecc0: e2822002  add r2, r2, #2
    ecc4: e1a02102  lsl r2, r2, #2
    ecc8: e1a07000  mov r7, r0
    eccc: e280000c  add r0, r0, #12
    ecd0: ebffeaea  bl  9880 <memcpy>
    ecd4: e596204c  ldr r2, [r6, #76] ; 0x4c
    ecd8: e5951004  ldr r1, [r5, #4]
    ecdc: e59d3004  ldr r3, [sp, #4]
    ece0: e7920101  ldr r0, [r2, r1, lsl #2]
    ece4: e5850000  str r0, [r5]
    ece8: e7825101  str r5, [r2, r1, lsl #2]
    ecec: e1a05007  mov r5, r7
    ecf0: eaffffe4  b ec88 <__multadd+0x64>

0000ecf4 <__s2b>:
    ecf4: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
    ecf8: e308ce39  movw  ip, #36409  ; 0x8e39
    ecfc: e1a06003  mov r6, r3
    ed00: e2833008  add r3, r3, #8
    ed04: e343c8e3  movt  ip, #14563  ; 0x38e3
    ed08: e1a05000  mov r5, r0
    ed0c: e1a04001  mov r4, r1
    ed10: e1a07002  mov r7, r2
    ed14: e0c10c93  smull r0, r1, r3, ip
    ed18: e1a03fc3  asr r3, r3, #31
    ed1c: e59d8020  ldr r8, [sp, #32]
    ed20: e06330c1  rsb r3, r3, r1, asr #1
    ed24: e3530001  cmp r3, #1
    ed28: da000028  ble edd0 <__s2b+0xdc>
    ed2c: e3a0c001  mov ip, #1
    ed30: e3a01000  mov r1, #0
    ed34: e1a0c08c  lsl ip, ip, #1
    ed38: e2811001  add r1, r1, #1
    ed3c: e153000c  cmp r3, ip
    ed40: cafffffb  bgt ed34 <__s2b+0x40>
    ed44: e1a00005  mov r0, r5
    ed48: ebffff8b  bl  eb7c <_Balloc>
    ed4c: e3570009  cmp r7, #9
    ed50: e3a03001  mov r3, #1
    ed54: d284400a  addle r4, r4, #10
    ed58: d3a07009  movle r7, #9
    ed5c: e5808014  str r8, [r0, #20]
    ed60: e5803010  str r3, [r0, #16]
    ed64: da00000c  ble ed9c <__s2b+0xa8>
    ed68: e2849009  add r9, r4, #9
    ed6c: e0844007  add r4, r4, r7
    ed70: e1a08009  mov r8, r9
    ed74: e4d83001  ldrb  r3, [r8], #1
    ed78: e1a01000  mov r1, r0
    ed7c: e3a0200a  mov r2, #10
    ed80: e1a00005  mov r0, r5
    ed84: e2433030  sub r3, r3, #48 ; 0x30
    ed88: ebffffa5  bl  ec24 <__multadd>
    ed8c: e1580004  cmp r8, r4
    ed90: 1afffff7  bne ed74 <__s2b+0x80>
    ed94: e0894007  add r4, r9, r7
    ed98: e2444008  sub r4, r4, #8
    ed9c: e1560007  cmp r6, r7
    eda0: d8bd83f8  pople {r3, r4, r5, r6, r7, r8, r9, pc}
    eda4: e0676006  rsb r6, r7, r6
    eda8: e0846006  add r6, r4, r6
    edac: e4d43001  ldrb  r3, [r4], #1
    edb0: e1a01000  mov r1, r0
    edb4: e3a0200a  mov r2, #10
    edb8: e1a00005  mov r0, r5
    edbc: e2433030  sub r3, r3, #48 ; 0x30
    edc0: ebffff97  bl  ec24 <__multadd>
    edc4: e1540006  cmp r4, r6
    edc8: 1afffff7  bne edac <__s2b+0xb8>
    edcc: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
    edd0: e3a01000  mov r1, #0
    edd4: eaffffda  b ed44 <__s2b+0x50>

0000edd8 <__hi0bits>:
    edd8: e1a03820  lsr r3, r0, #16
    eddc: e1a03803  lsl r3, r3, #16
    ede0: e3530000  cmp r3, #0
    ede4: 01a00800  lsleq r0, r0, #16
    ede8: 03a03010  moveq r3, #16
    edec: 13a03000  movne r3, #0
    edf0: e31004ff  tst r0, #-16777216  ; 0xff000000
    edf4: 01a00400  lsleq r0, r0, #8
    edf8: 02833008  addeq r3, r3, #8
    edfc: e310020f  tst r0, #-268435456 ; 0xf0000000
    ee00: 01a00200  lsleq r0, r0, #4
    ee04: 02833004  addeq r3, r3, #4
    ee08: e3100103  tst r0, #-1073741824  ; 0xc0000000
    ee0c: 01a00100  lsleq r0, r0, #2
    ee10: 02833002  addeq r3, r3, #2
    ee14: e3500000  cmp r0, #0
    ee18: ba000005  blt ee34 <__hi0bits+0x5c>
    ee1c: e3100101  tst r0, #1073741824 ; 0x40000000
    ee20: 1a000001  bne ee2c <__hi0bits+0x54>
    ee24: e3a00020  mov r0, #32
    ee28: e12fff1e  bx  lr
    ee2c: e2830001  add r0, r3, #1
    ee30: e12fff1e  bx  lr
    ee34: e1a00003  mov r0, r3
    ee38: e12fff1e  bx  lr

0000ee3c <__lo0bits>:
    ee3c: e5903000  ldr r3, [r0]
    ee40: e2132007  ands  r2, r3, #7
    ee44: 0a00000a  beq ee74 <__lo0bits+0x38>
    ee48: e3130001  tst r3, #1
    ee4c: 13a02000  movne r2, #0
    ee50: 1a000005  bne ee6c <__lo0bits+0x30>
    ee54: e3130002  tst r3, #2
    ee58: 11a030a3  lsrne r3, r3, #1
    ee5c: 01a03123  lsreq r3, r3, #2
    ee60: 13a02001  movne r2, #1
    ee64: 03a02002  moveq r2, #2
    ee68: e5803000  str r3, [r0]
    ee6c: e1a00002  mov r0, r2
    ee70: e12fff1e  bx  lr
    ee74: e6ff1073  uxth  r1, r3
    ee78: e3510000  cmp r1, #0
    ee7c: 01a03823  lsreq r3, r3, #16
    ee80: 03a02010  moveq r2, #16
    ee84: e31300ff  tst r3, #255  ; 0xff
    ee88: 01a03423  lsreq r3, r3, #8
    ee8c: 02822008  addeq r2, r2, #8
    ee90: e313000f  tst r3, #15
    ee94: 01a03223  lsreq r3, r3, #4
    ee98: 02822004  addeq r2, r2, #4
    ee9c: e3130003  tst r3, #3
    eea0: 01a03123  lsreq r3, r3, #2
    eea4: 02822002  addeq r2, r2, #2
    eea8: e3130001  tst r3, #1
    eeac: 1a000003  bne eec0 <__lo0bits+0x84>
    eeb0: e1b030a3  lsrs  r3, r3, #1
    eeb4: 03a02020  moveq r2, #32
    eeb8: 0affffeb  beq ee6c <__lo0bits+0x30>
    eebc: e2822001  add r2, r2, #1
    eec0: e5803000  str r3, [r0]
    eec4: e1a00002  mov r0, r2
    eec8: e12fff1e  bx  lr

0000eecc <__i2b>:
    eecc: e92d4010  push  {r4, lr}
    eed0: e1a04001  mov r4, r1
    eed4: e3a01001  mov r1, #1
    eed8: ebffff27  bl  eb7c <_Balloc>
    eedc: e3a02001  mov r2, #1
    eee0: e5804014  str r4, [r0, #20]
    eee4: e5802010  str r2, [r0, #16]
    eee8: e8bd8010  pop {r4, pc}

0000eeec <__multiply>:
    eeec: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    eef0: e1a04001  mov r4, r1
    eef4: e5915010  ldr r5, [r1, #16]
    eef8: e1a06002  mov r6, r2
    eefc: e5929010  ldr r9, [r2, #16]
    ef00: e24dd014  sub sp, sp, #20
    ef04: e1550009  cmp r5, r9
    ef08: a1a03009  movge r3, r9
    ef0c: b1a03001  movlt r3, r1
    ef10: b1a04002  movlt r4, r2
    ef14: a1a09005  movge r9, r5
    ef18: b1a06003  movlt r6, r3
    ef1c: a1a05003  movge r5, r3
    ef20: e5943008  ldr r3, [r4, #8]
    ef24: e0898005  add r8, r9, r5
    ef28: e5941004  ldr r1, [r4, #4]
    ef2c: e1580003  cmp r8, r3
    ef30: c2811001  addgt r1, r1, #1
    ef34: ebffff10  bl  eb7c <_Balloc>
    ef38: e280a014  add sl, r0, #20
    ef3c: e1a03000  mov r3, r0
    ef40: e08ab108  add fp, sl, r8, lsl #2
    ef44: e58d0004  str r0, [sp, #4]
    ef48: e15a000b  cmp sl, fp
    ef4c: 31a0300a  movcc r3, sl
    ef50: 33a00000  movcc r0, #0
    ef54: 2a000002  bcs ef64 <__multiply+0x78>
    ef58: e4830004  str r0, [r3], #4
    ef5c: e15b0003  cmp fp, r3
    ef60: 8afffffc  bhi ef58 <__multiply+0x6c>
    ef64: e2862014  add r2, r6, #20
    ef68: e2843014  add r3, r4, #20
    ef6c: e0821105  add r1, r2, r5, lsl #2
    ef70: e0839109  add r9, r3, r9, lsl #2
    ef74: e1520001  cmp r2, r1
    ef78: 358db008  strcc fp, [sp, #8]
    ef7c: 358d800c  strcc r8, [sp, #12]
    ef80: 31a0b001  movcc fp, r1
    ef84: 31a08003  movcc r8, r3
    ef88: 2a00003d  bcs f084 <__multiply+0x198>
    ef8c: e4925004  ldr r5, [r2], #4
    ef90: e6ff7075  uxth  r7, r5
    ef94: e3570000  cmp r7, #0
    ef98: 0a000018  beq f000 <__multiply+0x114>
    ef9c: e3a01000  mov r1, #0
    efa0: e1a06008  mov r6, r8
    efa4: e1a0500a  mov r5, sl
    efa8: e1a04001  mov r4, r1
    efac: ea000000  b efb4 <__multiply+0xc8>
    efb0: e1a0500c  mov r5, ip
    efb4: e496e004  ldr lr, [r6], #4
    efb8: e1a0c005  mov ip, r5
    efbc: e5951000  ldr r1, [r5]
    efc0: e1590006  cmp r9, r6
    efc4: e6ff007e  uxth  r0, lr
    efc8: e1a0e82e  lsr lr, lr, #16
    efcc: e6ff3071  uxth  r3, r1
    efd0: e1a01821  lsr r1, r1, #16
    efd4: e0203097  mla r0, r7, r0, r3
    efd8: e02e1e97  mla lr, r7, lr, r1
    efdc: e0803004  add r3, r0, r4
    efe0: e08e1823  add r1, lr, r3, lsr #16
    efe4: e6ff0073  uxth  r0, r3
    efe8: e1800801  orr r0, r0, r1, lsl #16
    efec: e1a04821  lsr r4, r1, #16
    eff0: e48c0004  str r0, [ip], #4
    eff4: 8affffed  bhi efb0 <__multiply+0xc4>
    eff8: e5854004  str r4, [r5, #4]
    effc: e5125004  ldr r5, [r2, #-4]
    f000: e1b05825  lsrs  r5, r5, #16
    f004: 0a000019  beq f070 <__multiply+0x184>
    f008: e59a3000  ldr r3, [sl]
    f00c: e3a06000  mov r6, #0
    f010: e1a0400a  mov r4, sl
    f014: e1a0c008  mov ip, r8
    f018: e1a07006  mov r7, r6
    f01c: e1a01003  mov r1, r3
    f020: ea000000  b f028 <__multiply+0x13c>
    f024: e1a0400e  mov r4, lr
    f028: e1dc60b0  ldrh  r6, [ip]
    f02c: e1a01821  lsr r1, r1, #16
    f030: e6ff0073  uxth  r0, r3
    f034: e1a0e004  mov lr, r4
    f038: e0211695  mla r1, r5, r6, r1
    f03c: e0816007  add r6, r1, r7
    f040: e1803806  orr r3, r0, r6, lsl #16
    f044: e48e3004  str r3, [lr], #4
    f048: e49c0004  ldr r0, [ip], #4
    f04c: e5941004  ldr r1, [r4, #4]
    f050: e159000c  cmp r9, ip
    f054: e1a00820  lsr r0, r0, #16
    f058: e6ff3071  uxth  r3, r1
    f05c: e0203095  mla r0, r5, r0, r3
    f060: e0803826  add r3, r0, r6, lsr #16
    f064: e1a07823  lsr r7, r3, #16
    f068: 8affffed  bhi f024 <__multiply+0x138>
    f06c: e5843004  str r3, [r4, #4]
    f070: e15b0002  cmp fp, r2
    f074: e28aa004  add sl, sl, #4
    f078: 8affffc3  bhi ef8c <__multiply+0xa0>
    f07c: e59db008  ldr fp, [sp, #8]
    f080: e59d800c  ldr r8, [sp, #12]
    f084: e3580000  cmp r8, #0
    f088: da000009  ble f0b4 <__multiply+0x1c8>
    f08c: e51b3004  ldr r3, [fp, #-4]
    f090: e24bb004  sub fp, fp, #4
    f094: e3530000  cmp r3, #0
    f098: 0a000003  beq f0ac <__multiply+0x1c0>
    f09c: ea000004  b f0b4 <__multiply+0x1c8>
    f0a0: e53b3004  ldr r3, [fp, #-4]!
    f0a4: e3530000  cmp r3, #0
    f0a8: 1a000001  bne f0b4 <__multiply+0x1c8>
    f0ac: e2588001  subs  r8, r8, #1
    f0b0: 1afffffa  bne f0a0 <__multiply+0x1b4>
    f0b4: e59d3004  ldr r3, [sp, #4]
    f0b8: e1a00003  mov r0, r3
    f0bc: e5838010  str r8, [r3, #16]
    f0c0: e28dd014  add sp, sp, #20
    f0c4: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0000f0c8 <__pow5mult>:
    f0c8: e2123003  ands  r3, r2, #3
    f0cc: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    f0d0: e1a04002  mov r4, r2
    f0d4: e1a07000  mov r7, r0
    f0d8: e1a06001  mov r6, r1
    f0dc: 1a000024  bne f174 <__pow5mult+0xac>
    f0e0: e1b04144  asrs  r4, r4, #2
    f0e4: 0a000019  beq f150 <__pow5mult+0x88>
    f0e8: e5975048  ldr r5, [r7, #72] ; 0x48
    f0ec: e3550000  cmp r5, #0
    f0f0: 0a000027  beq f194 <__pow5mult+0xcc>
    f0f4: e3a08000  mov r8, #0
    f0f8: ea000005  b f114 <__pow5mult+0x4c>
    f0fc: e1b040c4  asrs  r4, r4, #1
    f100: 0a000012  beq f150 <__pow5mult+0x88>
    f104: e5950000  ldr r0, [r5]
    f108: e3500000  cmp r0, #0
    f10c: 0a000011  beq f158 <__pow5mult+0x90>
    f110: e1a05000  mov r5, r0
    f114: e3140001  tst r4, #1
    f118: 0afffff7  beq f0fc <__pow5mult+0x34>
    f11c: e1a02005  mov r2, r5
    f120: e1a01006  mov r1, r6
    f124: e1a00007  mov r0, r7
    f128: ebffff6f  bl  eeec <__multiply>
    f12c: e3560000  cmp r6, #0
    f130: 1596c004  ldrne ip, [r6, #4]
    f134: 1597304c  ldrne r3, [r7, #76] ; 0x4c
    f138: 1793210c  ldrne r2, [r3, ip, lsl #2]
    f13c: 15862000  strne r2, [r6]
    f140: 1783610c  strne r6, [r3, ip, lsl #2]
    f144: e1b040c4  asrs  r4, r4, #1
    f148: e1a06000  mov r6, r0
    f14c: 1affffec  bne f104 <__pow5mult+0x3c>
    f150: e1a00006  mov r0, r6
    f154: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    f158: e1a00007  mov r0, r7
    f15c: e1a01005  mov r1, r5
    f160: e1a02005  mov r2, r5
    f164: ebffff60  bl  eeec <__multiply>
    f168: e5850000  str r0, [r5]
    f16c: e5808000  str r8, [r0]
    f170: eaffffe6  b f110 <__pow5mult+0x48>
    f174: e2432001  sub r2, r3, #1
    f178: e308c5a0  movw  ip, #34208  ; 0x85a0
    f17c: e340c001  movt  ip, #1
    f180: e3a03000  mov r3, #0
    f184: e79c2102  ldr r2, [ip, r2, lsl #2]
    f188: ebfffea5  bl  ec24 <__multadd>
    f18c: e1a06000  mov r6, r0
    f190: eaffffd2  b f0e0 <__pow5mult+0x18>
    f194: e1a00007  mov r0, r7
    f198: e3a01001  mov r1, #1
    f19c: ebfffe76  bl  eb7c <_Balloc>
    f1a0: e3003271  movw  r3, #625  ; 0x271
    f1a4: e3a02001  mov r2, #1
    f1a8: e5803014  str r3, [r0, #20]
    f1ac: e1a05000  mov r5, r0
    f1b0: e3a03000  mov r3, #0
    f1b4: e5802010  str r2, [r0, #16]
    f1b8: e5870048  str r0, [r7, #72] ; 0x48
    f1bc: e5803000  str r3, [r0]
    f1c0: eaffffcb  b f0f4 <__pow5mult+0x2c>

0000f1c4 <__lshift>:
    f1c4: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
    f1c8: e1a082c2  asr r8, r2, #5
    f1cc: e5916010  ldr r6, [r1, #16]
    f1d0: e1a05001  mov r5, r1
    f1d4: e5913008  ldr r3, [r1, #8]
    f1d8: e1a09002  mov r9, r2
    f1dc: e0886006  add r6, r8, r6
    f1e0: e1a07000  mov r7, r0
    f1e4: e2864001  add r4, r6, #1
    f1e8: e5911004  ldr r1, [r1, #4]
    f1ec: e1540003  cmp r4, r3
    f1f0: da000003  ble f204 <__lshift+0x40>
    f1f4: e1a03083  lsl r3, r3, #1
    f1f8: e2811001  add r1, r1, #1
    f1fc: e1540003  cmp r4, r3
    f200: cafffffb  bgt f1f4 <__lshift+0x30>
    f204: e1a00007  mov r0, r7
    f208: ebfffe5b  bl  eb7c <_Balloc>
    f20c: e3580000  cmp r8, #0
    f210: e1a01000  mov r1, r0
    f214: e280e014  add lr, r0, #20
    f218: da000007  ble f23c <__lshift+0x78>
    f21c: e3a03000  mov r3, #0
    f220: e1a0200e  mov r2, lr
    f224: e1a00003  mov r0, r3
    f228: e2833001  add r3, r3, #1
    f22c: e4820004  str r0, [r2], #4
    f230: e1530008  cmp r3, r8
    f234: 1afffffb  bne f228 <__lshift+0x64>
    f238: e08ee103  add lr, lr, r3, lsl #2
    f23c: e5950010  ldr r0, [r5, #16]
    f240: e219901f  ands  r9, r9, #31
    f244: e2853014  add r3, r5, #20
    f248: e0830100  add r0, r3, r0, lsl #2
    f24c: 0a000015  beq f2a8 <__lshift+0xe4>
    f250: e2692020  rsb r2, r9, #32
    f254: e3a0c000  mov ip, #0
    f258: e593a000  ldr sl, [r3]
    f25c: e1a0800e  mov r8, lr
    f260: e18cc91a  orr ip, ip, sl, lsl r9
    f264: e48ec004  str ip, [lr], #4
    f268: e493c004  ldr ip, [r3], #4
    f26c: e1500003  cmp r0, r3
    f270: e1a0c23c  lsr ip, ip, r2
    f274: 8afffff7  bhi f258 <__lshift+0x94>
    f278: e35c0000  cmp ip, #0
    f27c: e588c004  str ip, [r8, #4]
    f280: 12864002  addne r4, r6, #2
    f284: e597304c  ldr r3, [r7, #76] ; 0x4c
    f288: e2444001  sub r4, r4, #1
    f28c: e5952004  ldr r2, [r5, #4]
    f290: e1a00001  mov r0, r1
    f294: e5814010  str r4, [r1, #16]
    f298: e7931102  ldr r1, [r3, r2, lsl #2]
    f29c: e5851000  str r1, [r5]
    f2a0: e7835102  str r5, [r3, r2, lsl #2]
    f2a4: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
    f2a8: e24ee004  sub lr, lr, #4
    f2ac: e4932004  ldr r2, [r3], #4
    f2b0: e1500003  cmp r0, r3
    f2b4: e5ae2004  str r2, [lr, #4]!
    f2b8: 8afffffb  bhi f2ac <__lshift+0xe8>
    f2bc: eafffff0  b f284 <__lshift+0xc0>

0000f2c0 <__mcmp>:
    f2c0: e5903010  ldr r3, [r0, #16]
    f2c4: e5912010  ldr r2, [r1, #16]
    f2c8: e0533002  subs  r3, r3, r2
    f2cc: 1a00000e  bne f30c <__mcmp+0x4c>
    f2d0: e1a02102  lsl r2, r2, #2
    f2d4: e2800014  add r0, r0, #20
    f2d8: e2811014  add r1, r1, #20
    f2dc: e0803002  add r3, r0, r2
    f2e0: e0811002  add r1, r1, r2
    f2e4: ea000001  b f2f0 <__mcmp+0x30>
    f2e8: e1500003  cmp r0, r3
    f2ec: 2a000008  bcs f314 <__mcmp+0x54>
    f2f0: e533c004  ldr ip, [r3, #-4]!
    f2f4: e5312004  ldr r2, [r1, #-4]!
    f2f8: e15c0002  cmp ip, r2
    f2fc: 0afffff9  beq f2e8 <__mcmp+0x28>
    f300: 3a000005  bcc f31c <__mcmp+0x5c>
    f304: e3a00001  mov r0, #1
    f308: e12fff1e  bx  lr
    f30c: e1a00003  mov r0, r3
    f310: e12fff1e  bx  lr
    f314: e3a00000  mov r0, #0
    f318: e12fff1e  bx  lr
    f31c: e3e00000  mvn r0, #0
    f320: e12fff1e  bx  lr

0000f324 <__mdiff>:
    f324: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    f328: e1a05001  mov r5, r1
    f32c: e1a04000  mov r4, r0
    f330: e1a01002  mov r1, r2
    f334: e1a00005  mov r0, r5
    f338: e1a08002  mov r8, r2
    f33c: ebffffdf  bl  f2c0 <__mcmp>
    f340: e2506000  subs  r6, r0, #0
    f344: 0a00003e  beq f444 <__mdiff+0x120>
    f348: b1a03005  movlt r3, r5
    f34c: b1a05008  movlt r5, r8
    f350: e5951004  ldr r1, [r5, #4]
    f354: e1a00004  mov r0, r4
    f358: b1a08003  movlt r8, r3
    f35c: b3a07001  movlt r7, #1
    f360: a3a07000  movge r7, #0
    f364: ebfffe04  bl  eb7c <_Balloc>
    f368: e5954010  ldr r4, [r5, #16]
    f36c: e2855014  add r5, r5, #20
    f370: e5982010  ldr r2, [r8, #16]
    f374: e2888014  add r8, r8, #20
    f378: e1a0e005  mov lr, r5
    f37c: e3a03000  mov r3, #0
    f380: e0855104  add r5, r5, r4, lsl #2
    f384: e0882102  add r2, r8, r2, lsl #2
    f388: e1a06000  mov r6, r0
    f38c: e280c014  add ip, r0, #20
    f390: e1a00008  mov r0, r8
    f394: e586700c  str r7, [r6, #12]
    f398: e49e8004  ldr r8, [lr], #4
    f39c: e4901004  ldr r1, [r0], #4
    f3a0: e6f37078  uxtah r7, r3, r8
    f3a4: e1520000  cmp r2, r0
    f3a8: e6ff3071  uxth  r3, r1
    f3ac: e1a01821  lsr r1, r1, #16
    f3b0: e0637007  rsb r7, r3, r7
    f3b4: e0613828  rsb r3, r1, r8, lsr #16
    f3b8: e1a0100e  mov r1, lr
    f3bc: e0833847  add r3, r3, r7, asr #16
    f3c0: e6ff7077  uxth  r7, r7
    f3c4: e1877803  orr r7, r7, r3, lsl #16
    f3c8: e1a03843  asr r3, r3, #16
    f3cc: e48c7004  str r7, [ip], #4
    f3d0: 8afffff0  bhi f398 <__mdiff+0x74>
    f3d4: e155000e  cmp r5, lr
    f3d8: e1a0000c  mov r0, ip
    f3dc: 9a00000e  bls f41c <__mdiff+0xf8>
    f3e0: e4912004  ldr r2, [r1], #4
    f3e4: e1550001  cmp r5, r1
    f3e8: e6f33072  uxtah r3, r3, r2
    f3ec: e1a02822  lsr r2, r2, #16
    f3f0: e0822843  add r2, r2, r3, asr #16
    f3f4: e6ff3073  uxth  r3, r3
    f3f8: e1837802  orr r7, r3, r2, lsl #16
    f3fc: e1a03842  asr r3, r2, #16
    f400: e48c7004  str r7, [ip], #4
    f404: 8afffff5  bhi f3e0 <__mdiff+0xbc>
    f408: e1e0c00e  mvn ip, lr
    f40c: e08cc005  add ip, ip, r5
    f410: e3ccc003  bic ip, ip, #3
    f414: e28cc004  add ip, ip, #4
    f418: e080c00c  add ip, r0, ip
    f41c: e3570000  cmp r7, #0
    f420: e24cc004  sub ip, ip, #4
    f424: 1a000003  bne f438 <__mdiff+0x114>
    f428: e53c3004  ldr r3, [ip, #-4]!
    f42c: e2444001  sub r4, r4, #1
    f430: e3530000  cmp r3, #0
    f434: 0afffffb  beq f428 <__mdiff+0x104>
    f438: e1a00006  mov r0, r6
    f43c: e5864010  str r4, [r6, #16]
    f440: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
    f444: e1a00004  mov r0, r4
    f448: e1a01006  mov r1, r6
    f44c: ebfffdca  bl  eb7c <_Balloc>
    f450: e3a02001  mov r2, #1
    f454: e1a03000  mov r3, r0
    f458: e5806014  str r6, [r0, #20]
    f45c: e5832010  str r2, [r3, #16]
    f460: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

0000f464 <__ulp>:
    f464: e3a03000  mov r3, #0
    f468: e3473ff0  movt  r3, #32752  ; 0x7ff0
    f46c: e0033001  and r3, r3, r1
    f470: e243350d  sub r3, r3, #54525952 ; 0x3400000
    f474: e3530000  cmp r3, #0
    f478: da000002  ble f488 <__ulp+0x24>
    f47c: e3a00000  mov r0, #0
    f480: e1a01003  mov r1, r3
    f484: e12fff1e  bx  lr
    f488: e2633000  rsb r3, r3, #0
    f48c: e1a03a43  asr r3, r3, #20
    f490: e3530013  cmp r3, #19
    f494: da000007  ble f4b8 <__ulp+0x54>
    f498: e3530032  cmp r3, #50 ; 0x32
    f49c: e3a01000  mov r1, #0
    f4a0: d2633033  rsble r3, r3, #51 ; 0x33
    f4a4: d3a02001  movle r2, #1
    f4a8: c3a03001  movgt r3, #1
    f4ac: d1a03312  lslle r3, r2, r3
    f4b0: e1a00003  mov r0, r3
    f4b4: e12fff1e  bx  lr
    f4b8: e3a02702  mov r2, #524288 ; 0x80000
    f4bc: e3a00000  mov r0, #0
    f4c0: e1a01352  asr r1, r2, r3
    f4c4: e12fff1e  bx  lr

0000f4c8 <__b2d>:
    f4c8: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
    f4cc: e2806014  add r6, r0, #20
    f4d0: e5904010  ldr r4, [r0, #16]
    f4d4: e0864104  add r4, r6, r4, lsl #2
    f4d8: e2445004  sub r5, r4, #4
    f4dc: e5147004  ldr r7, [r4, #-4]
    f4e0: e1a00007  mov r0, r7
    f4e4: ebfffe3b  bl  edd8 <__hi0bits>
    f4e8: e350000a  cmp r0, #10
    f4ec: e2603020  rsb r3, r0, #32
    f4f0: e5813000  str r3, [r1]
    f4f4: ca00000c  bgt f52c <__b2d+0x64>
    f4f8: e260c00b  rsb ip, r0, #11
    f4fc: e1560005  cmp r6, r5
    f500: e1a01c37  lsr r1, r7, ip
    f504: e2800015  add r0, r0, #21
    f508: e38135ff  orr r3, r1, #1069547520 ; 0x3fc00000
    f50c: 35141008  ldrcc r1, [r4, #-8]
    f510: 23a01000  movcs r1, #0
    f514: e3833603  orr r3, r3, #3145728  ; 0x300000
    f518: 31a01c31  lsrcc r1, r1, ip
    f51c: e1812017  orr r2, r1, r7, lsl r0
    f520: e1a00002  mov r0, r2
    f524: e1a01003  mov r1, r3
    f528: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    f52c: e1560005  cmp r6, r5
    f530: 2a00000e  bcs f570 <__b2d+0xa8>
    f534: e250c00b  subs  ip, r0, #11
    f538: e2445008  sub r5, r4, #8
    f53c: e5141008  ldr r1, [r4, #-8]
    f540: 0a00000d  beq f57c <__b2d+0xb4>
    f544: e260002b  rsb r0, r0, #43 ; 0x2b
    f548: e1560005  cmp r6, r5
    f54c: e1a0e031  lsr lr, r1, r0
    f550: e18e7c17  orr r7, lr, r7, lsl ip
    f554: 3514e00c  ldrcc lr, [r4, #-12]
    f558: e38735ff  orr r3, r7, #1069547520 ; 0x3fc00000
    f55c: 23a00000  movcs r0, #0
    f560: e3833603  orr r3, r3, #3145728  ; 0x300000
    f564: 31a0003e  lsrcc r0, lr, r0
    f568: e1802c11  orr r2, r0, r1, lsl ip
    f56c: eaffffeb  b f520 <__b2d+0x58>
    f570: e250c00b  subs  ip, r0, #11
    f574: 01a0100c  moveq r1, ip
    f578: 1a000003  bne f58c <__b2d+0xc4>
    f57c: e38735ff  orr r3, r7, #1069547520 ; 0x3fc00000
    f580: e1a02001  mov r2, r1
    f584: e3833603  orr r3, r3, #3145728  ; 0x300000
    f588: eaffffe4  b f520 <__b2d+0x58>
    f58c: e1a07c17  lsl r7, r7, ip
    f590: e3a00000  mov r0, #0
    f594: e38735ff  orr r3, r7, #1069547520 ; 0x3fc00000
    f598: e1a01000  mov r1, r0
    f59c: e3833603  orr r3, r3, #3145728  ; 0x300000
    f5a0: eafffff0  b f568 <__b2d+0xa0>

0000f5a4 <__d2b>:
    f5a4: e92d43f0  push  {r4, r5, r6, r7, r8, r9, lr}
    f5a8: e24dd00c  sub sp, sp, #12
    f5ac: e3a01001  mov r1, #1
    f5b0: e1a04003  mov r4, r3
    f5b4: e7ea5a53  ubfx  r5, r3, #20, #11
    f5b8: e1a08002  mov r8, r2
    f5bc: e59d6028  ldr r6, [sp, #40] ; 0x28
    f5c0: e7f34054  ubfx  r4, r4, #0, #20
    f5c4: e59d702c  ldr r7, [sp, #44] ; 0x2c
    f5c8: ebfffd6b  bl  eb7c <_Balloc>
    f5cc: e3550000  cmp r5, #0
    f5d0: 13844601  orrne r4, r4, #1048576  ; 0x100000
    f5d4: e3580000  cmp r8, #0
    f5d8: e58d4004  str r4, [sp, #4]
    f5dc: e1a09000  mov r9, r0
    f5e0: 0a00001d  beq f65c <__d2b+0xb8>
    f5e4: e28d0008  add r0, sp, #8
    f5e8: e5208008  str r8, [r0, #-8]!
    f5ec: ebfffe12  bl  ee3c <__lo0bits>
    f5f0: e3500000  cmp r0, #0
    f5f4: 12602020  rsbne r2, r0, #32
    f5f8: 159dc004  ldrne ip, [sp, #4]
    f5fc: 089d000c  ldmeq sp, {r2, r3}
    f600: 159d1000  ldrne r1, [sp]
    f604: 11a0303c  lsrne r3, ip, r0
    f608: 158d3004  strne r3, [sp, #4]
    f60c: 1181221c  orrne r2, r1, ip, lsl r2
    f610: e3530000  cmp r3, #0
    f614: e5892014  str r2, [r9, #20]
    f618: 13a02002  movne r2, #2
    f61c: 03a02001  moveq r2, #1
    f620: e3550000  cmp r5, #0
    f624: e5893018  str r3, [r9, #24]
    f628: e5892010  str r2, [r9, #16]
    f62c: 1a000013  bne f680 <__d2b+0xdc>
    f630: e0893102  add r3, r9, r2, lsl #2
    f634: e2405e43  sub r5, r0, #1072 ; 0x430
    f638: e2455002  sub r5, r5, #2
    f63c: e5865000  str r5, [r6]
    f640: e5930010  ldr r0, [r3, #16]
    f644: ebfffde3  bl  edd8 <__hi0bits>
    f648: e0600282  rsb r0, r0, r2, lsl #5
    f64c: e5870000  str r0, [r7]
    f650: e1a00009  mov r0, r9
    f654: e28dd00c  add sp, sp, #12
    f658: e8bd83f0  pop {r4, r5, r6, r7, r8, r9, pc}
    f65c: e28d0004  add r0, sp, #4
    f660: ebfffdf5  bl  ee3c <__lo0bits>
    f664: e59d3004  ldr r3, [sp, #4]
    f668: e3550000  cmp r5, #0
    f66c: e3a02001  mov r2, #1
    f670: e5892010  str r2, [r9, #16]
    f674: e5893014  str r3, [r9, #20]
    f678: e2800020  add r0, r0, #32
    f67c: 0affffeb  beq f630 <__d2b+0x8c>
    f680: e2455e43  sub r5, r5, #1072 ; 0x430
    f684: e2603035  rsb r3, r0, #53 ; 0x35
    f688: e2455003  sub r5, r5, #3
    f68c: e0855000  add r5, r5, r0
    f690: e1a00009  mov r0, r9
    f694: e5865000  str r5, [r6]
    f698: e5873000  str r3, [r7]
    f69c: e28dd00c  add sp, sp, #12
    f6a0: e8bd83f0  pop {r4, r5, r6, r7, r8, r9, pc}

0000f6a4 <__ratio>:
    f6a4: e92d40f0  push  {r4, r5, r6, r7, lr}
    f6a8: e1a06001  mov r6, r1
    f6ac: ed2d8b02  vpush {d8}
    f6b0: e1a04000  mov r4, r0
    f6b4: e24dd00c  sub sp, sp, #12
    f6b8: e1a0100d  mov r1, sp
    f6bc: ebffff81  bl  f4c8 <__b2d>
    f6c0: ec410b18  vmov  d8, r0, r1
    f6c4: e1a00006  mov r0, r6
    f6c8: e28d1004  add r1, sp, #4
    f6cc: ebffff7d  bl  f4c8 <__b2d>
    f6d0: e594c010  ldr ip, [r4, #16]
    f6d4: e89d000c  ldm sp, {r2, r3}
    f6d8: e0633002  rsb r3, r3, r2
    f6dc: ec410b30  vmov  d16, r0, r1
    f6e0: e5961010  ldr r1, [r6, #16]
    f6e4: e061100c  rsb r1, r1, ip
    f6e8: e0833281  add r3, r3, r1, lsl #5
    f6ec: e3530000  cmp r3, #0
    f6f0: cc554b18  vmovgt  r4, r5, d8
    f6f4: dc576b30  vmovle  r6, r7, d16
    f6f8: c0855a03  addgt r5, r5, r3, lsl #20
    f6fc: d0477a03  suble r7, r7, r3, lsl #20
    f700: cc454b18  vmovgt  d8, r4, r5
    f704: dc476b30  vmovle  d16, r6, r7
    f708: eec81b20  vdiv.f64  d17, d8, d16
    f70c: ec510b31  vmov  r0, r1, d17
    f710: e28dd00c  add sp, sp, #12
    f714: ecbd8b02  vpop  {d8}
    f718: e8bd80f0  pop {r4, r5, r6, r7, pc}

0000f71c <_mprec_log10>:
    f71c: e3500017  cmp r0, #23
    f720: cef70b00  vmovgt.f64  d16, #112 ; 0x70
    f724: cef21b04  vmovgt.f64  d17, #36  ; 0x24
    f728: da000004  ble f740 <_mprec_log10+0x24>
    f72c: e2500001  subs  r0, r0, #1
    f730: ee600ba1  vmul.f64  d16, d16, d17
    f734: 1afffffc  bne f72c <_mprec_log10+0x10>
    f738: ec510b30  vmov  r0, r1, d16
    f73c: e12fff1e  bx  lr
    f740: e30835a0  movw  r3, #34208  ; 0x85a0
    f744: e3403001  movt  r3, #1
    f748: e0830180  add r0, r3, r0, lsl #3
    f74c: e1c001d0  ldrd  r0, [r0, #16]
    f750: e12fff1e  bx  lr

0000f754 <__copybits>:
    f754: e592c010  ldr ip, [r2, #16]
    f758: e2411001  sub r1, r1, #1
    f75c: e2823014  add r3, r2, #20
    f760: e1a012c1  asr r1, r1, #5
    f764: e083c10c  add ip, r3, ip, lsl #2
    f768: e2811001  add r1, r1, #1
    f76c: e153000c  cmp r3, ip
    f770: e92d4010  push  {r4, lr}
    f774: e0804101  add r4, r0, r1, lsl #2
    f778: 2a000009  bcs f7a4 <__copybits+0x50>
    f77c: e2401004  sub r1, r0, #4
    f780: e493e004  ldr lr, [r3], #4
    f784: e15c0003  cmp ip, r3
    f788: e5a1e004  str lr, [r1, #4]!
    f78c: 8afffffb  bhi f780 <__copybits+0x2c>
    f790: e062300c  rsb r3, r2, ip
    f794: e2433015  sub r3, r3, #21
    f798: e3c33003  bic r3, r3, #3
    f79c: e2833004  add r3, r3, #4
    f7a0: e0800003  add r0, r0, r3
    f7a4: e1540000  cmp r4, r0
    f7a8: 98bd8010  popls {r4, pc}
    f7ac: e3a03000  mov r3, #0
    f7b0: e4803004  str r3, [r0], #4
    f7b4: e1540000  cmp r4, r0
    f7b8: 8afffffc  bhi f7b0 <__copybits+0x5c>
    f7bc: e8bd8010  pop {r4, pc}

0000f7c0 <__any_on>:
    f7c0: e5903010  ldr r3, [r0, #16]
    f7c4: e1a022c1  asr r2, r1, #5
    f7c8: e280c014  add ip, r0, #20
    f7cc: e1530002  cmp r3, r2
    f7d0: b08c3103  addlt r3, ip, r3, lsl #2
    f7d4: ba00000a  blt f804 <__any_on+0x44>
    f7d8: da000008  ble f800 <__any_on+0x40>
    f7dc: e211101f  ands  r1, r1, #31
    f7e0: 0a000006  beq f800 <__any_on+0x40>
    f7e4: e79c0102  ldr r0, [ip, r2, lsl #2]
    f7e8: e08c3102  add r3, ip, r2, lsl #2
    f7ec: e1a02130  lsr r2, r0, r1
    f7f0: e1500112  cmp r0, r2, lsl r1
    f7f4: 0a000002  beq f804 <__any_on+0x44>
    f7f8: e3a00001  mov r0, #1
    f7fc: e12fff1e  bx  lr
    f800: e08c3102  add r3, ip, r2, lsl #2
    f804: e15c0003  cmp ip, r3
    f808: 2a00000a  bcs f838 <__any_on+0x78>
    f80c: e5130004  ldr r0, [r3, #-4]
    f810: e2433004  sub r3, r3, #4
    f814: e3500000  cmp r0, #0
    f818: 0a000003  beq f82c <__any_on+0x6c>
    f81c: eafffff5  b f7f8 <__any_on+0x38>
    f820: e5332004  ldr r2, [r3, #-4]!
    f824: e3520000  cmp r2, #0
    f828: 1afffff2  bne f7f8 <__any_on+0x38>
    f82c: e15c0003  cmp ip, r3
    f830: 3afffffa  bcc f820 <__any_on+0x60>
    f834: e12fff1e  bx  lr
    f838: e3a00000  mov r0, #0
    f83c: e12fff1e  bx  lr

0000f840 <__fpclassifyd>:
    f840: e1a03000  mov r3, r0
    f844: e1932001  orrs  r2, r3, r1
    f848: 1a000001  bne f854 <__fpclassifyd+0x14>
    f84c: e3a00002  mov r0, #2
    f850: e12fff1e  bx  lr
    f854: e3510102  cmp r1, #-2147483648  ; 0x80000000
    f858: 03530000  cmpeq r3, #0
    f85c: e16f3f13  clz r3, r3
    f860: e1a032a3  lsr r3, r3, #5
    f864: 0afffff8  beq f84c <__fpclassifyd+0xc>
    f868: e3c10102  bic r0, r1, #-2147483648  ; 0x80000000
    f86c: e30f2fff  movw  r2, #65535  ; 0xffff
    f870: e2401601  sub r1, r0, #1048576  ; 0x100000
    f874: e3472fdf  movt  r2, #32735  ; 0x7fdf
    f878: e1510002  cmp r1, r2
    f87c: 8a000001  bhi f888 <__fpclassifyd+0x48>
    f880: e3a00004  mov r0, #4
    f884: e12fff1e  bx  lr
    f888: e3500601  cmp r0, #1048576  ; 0x100000
    f88c: 2a000001  bcs f898 <__fpclassifyd+0x58>
    f890: e3a00003  mov r0, #3
    f894: e12fff1e  bx  lr
    f898: e3a02000  mov r2, #0
    f89c: e3472ff0  movt  r2, #32752  ; 0x7ff0
    f8a0: e1500002  cmp r0, r2
    f8a4: 13a00000  movne r0, #0
    f8a8: 02030001  andeq r0, r3, #1
    f8ac: e12fff1e  bx  lr

0000f8b0 <_sbrk_r>:
    f8b0: e92d4038  push  {r3, r4, r5, lr}
    f8b4: e3024aec  movw  r4, #10988  ; 0x2aec
    f8b8: e1a05000  mov r5, r0
    f8bc: e3404002  movt  r4, #2
    f8c0: e1a00001  mov r0, r1
    f8c4: e3a03000  mov r3, #0
    f8c8: e5843000  str r3, [r4]
    f8cc: eb000aee  bl  1248c <_sbrk>
    f8d0: e3700001  cmn r0, #1
    f8d4: 18bd8038  popne {r3, r4, r5, pc}
    f8d8: e5943000  ldr r3, [r4]
    f8dc: e3530000  cmp r3, #0
    f8e0: 15853000  strne r3, [r5]
    f8e4: e8bd8038  pop {r3, r4, r5, pc}

0000f8e8 <__sread>:
    f8e8: e92d4010  push  {r4, lr}
    f8ec: e1a04001  mov r4, r1
    f8f0: e1d110fe  ldrsh r1, [r1, #14]
    f8f4: eb00087f  bl  11af8 <_read_r>
    f8f8: e3500000  cmp r0, #0
    f8fc: a5943050  ldrge r3, [r4, #80] ; 0x50
    f900: b1d430bc  ldrhlt  r3, [r4, #12]
    f904: a0833000  addge r3, r3, r0
    f908: b3c33a01  biclt r3, r3, #4096 ; 0x1000
    f90c: a5843050  strge r3, [r4, #80] ; 0x50
    f910: b1c430bc  strhlt  r3, [r4, #12]
    f914: e8bd8010  pop {r4, pc}

0000f918 <__seofread>:
    f918: e3a00000  mov r0, #0
    f91c: e12fff1e  bx  lr

0000f920 <__swrite>:
    f920: e1d1c0bc  ldrh  ip, [r1, #12]
    f924: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
    f928: e31c0c01  tst ip, #256  ; 0x100
    f92c: e1a04001  mov r4, r1
    f930: e1a06002  mov r6, r2
    f934: e1a05003  mov r5, r3
    f938: e1a07000  mov r7, r0
    f93c: 0a000004  beq f954 <__swrite+0x34>
    f940: e1d110fe  ldrsh r1, [r1, #14]
    f944: e3a02000  mov r2, #0
    f948: e3a03002  mov r3, #2
    f94c: eb00080e  bl  1198c <_lseek_r>
    f950: e1d4c0bc  ldrh  ip, [r4, #12]
    f954: e3ccca01  bic ip, ip, #4096 ; 0x1000
    f958: e1a00007  mov r0, r7
    f95c: e1c4c0bc  strh  ip, [r4, #12]
    f960: e1a02006  mov r2, r6
    f964: e1d410fe  ldrsh r1, [r4, #14]
    f968: e1a03005  mov r3, r5
    f96c: e8bd41f0  pop {r4, r5, r6, r7, r8, lr}
    f970: ea0005a1  b 10ffc <_write_r>

0000f974 <__sseek>:
    f974: e92d4010  push  {r4, lr}
    f978: e1a04001  mov r4, r1
    f97c: e1d110fe  ldrsh r1, [r1, #14]
    f980: eb000801  bl  1198c <_lseek_r>
    f984: e1d430bc  ldrh  r3, [r4, #12]
    f988: e3700001  cmn r0, #1
    f98c: 15840050  strne r0, [r4, #80] ; 0x50
    f990: 03c33a01  biceq r3, r3, #4096 ; 0x1000
    f994: 13833a01  orrne r3, r3, #4096 ; 0x1000
    f998: e1c430bc  strh  r3, [r4, #12]
    f99c: e8bd8010  pop {r4, pc}

0000f9a0 <__sclose>:
    f9a0: e1d110fe  ldrsh r1, [r1, #14]
    f9a4: ea0005ff  b 111a8 <_close_r>
  ...
    f9c0: eba2 0003   sub.w r0, r2, r3
    f9c4: 4770        bx  lr
    f9c6: bf00        nop

0000f9c8 <strcmp>:
    f9c8: 7802        ldrb  r2, [r0, #0]
    f9ca: 780b        ldrb  r3, [r1, #0]
    f9cc: 2a01        cmp r2, #1
    f9ce: bf28        it  cs
    f9d0: 429a        cmpcs r2, r3
    f9d2: d1f5        bne.n f9c0 <__sclose+0x20>
    f9d4: e96d 4504   strd  r4, r5, [sp, #-16]!
    f9d8: ea40 0401   orr.w r4, r0, r1
    f9dc: e9cd 6702   strd  r6, r7, [sp, #8]
    f9e0: f06f 0c00   mvn.w ip, #0
    f9e4: ea4f 7244   mov.w r2, r4, lsl #29
    f9e8: b312        cbz r2, fa30 <strcmp+0x68>
    f9ea: ea80 0401   eor.w r4, r0, r1
    f9ee: f014 0f07   tst.w r4, #7
    f9f2: d16a        bne.n faca <strcmp+0x102>
    f9f4: f000 0407   and.w r4, r0, #7
    f9f8: f020 0007   bic.w r0, r0, #7
    f9fc: f004 0503   and.w r5, r4, #3
    fa00: f021 0107   bic.w r1, r1, #7
    fa04: ea4f 05c5   mov.w r5, r5, lsl #3
    fa08: e8f0 2304   ldrd  r2, r3, [r0], #16
    fa0c: f014 0f04   tst.w r4, #4
    fa10: e8f1 6704   ldrd  r6, r7, [r1], #16
    fa14: fa0c f405   lsl.w r4, ip, r5
    fa18: ea62 0204   orn r2, r2, r4
    fa1c: ea66 0604   orn r6, r6, r4
    fa20: d00a        beq.n fa38 <strcmp+0x70>
    fa22: ea63 0304   orn r3, r3, r4
    fa26: 4662        mov r2, ip
    fa28: ea67 0704   orn r7, r7, r4
    fa2c: 4666        mov r6, ip
    fa2e: e003        b.n fa38 <strcmp+0x70>
    fa30: e8f0 2304   ldrd  r2, r3, [r0], #16
    fa34: e8f1 6704   ldrd  r6, r7, [r1], #16
    fa38: fa82 f54c   uadd8 r5, r2, ip
    fa3c: ea82 0406   eor.w r4, r2, r6
    fa40: faa4 f48c   sel r4, r4, ip
    fa44: bb6c        cbnz  r4, faa2 <strcmp+0xda>
    fa46: fa83 f54c   uadd8 r5, r3, ip
    fa4a: ea83 0507   eor.w r5, r3, r7
    fa4e: faa5 f58c   sel r5, r5, ip
    fa52: b995        cbnz  r5, fa7a <strcmp+0xb2>
    fa54: e950 2302   ldrd  r2, r3, [r0, #-8]
    fa58: e951 6702   ldrd  r6, r7, [r1, #-8]
    fa5c: fa82 f54c   uadd8 r5, r2, ip
    fa60: ea82 0406   eor.w r4, r2, r6
    fa64: faa4 f48c   sel r4, r4, ip
    fa68: fa83 f54c   uadd8 r5, r3, ip
    fa6c: ea83 0507   eor.w r5, r3, r7
    fa70: faa5 f58c   sel r5, r5, ip
    fa74: 4325        orrs  r5, r4
    fa76: d0db        beq.n fa30 <strcmp+0x68>
    fa78: b99c        cbnz  r4, faa2 <strcmp+0xda>
    fa7a: ba2d        rev r5, r5
    fa7c: fab5 f485   clz r4, r5
    fa80: f024 0407   bic.w r4, r4, #7
    fa84: fa27 f104   lsr.w r1, r7, r4
    fa88: e9dd 6702   ldrd  r6, r7, [sp, #8]
    fa8c: fa23 f304   lsr.w r3, r3, r4
    fa90: f003 00ff   and.w r0, r3, #255  ; 0xff
    fa94: f001 01ff   and.w r1, r1, #255  ; 0xff
    fa98: e8fd 4504   ldrd  r4, r5, [sp], #16
    fa9c: eba0 0001   sub.w r0, r0, r1
    faa0: 4770        bx  lr
    faa2: ba24        rev r4, r4
    faa4: fab4 f484   clz r4, r4
    faa8: f024 0407   bic.w r4, r4, #7
    faac: fa26 f104   lsr.w r1, r6, r4
    fab0: e9dd 6702   ldrd  r6, r7, [sp, #8]
    fab4: fa22 f204   lsr.w r2, r2, r4
    fab8: f002 00ff   and.w r0, r2, #255  ; 0xff
    fabc: f001 01ff   and.w r1, r1, #255  ; 0xff
    fac0: e8fd 4504   ldrd  r4, r5, [sp], #16
    fac4: eba0 0001   sub.w r0, r0, r1
    fac8: 4770        bx  lr
    faca: f014 0f03   tst.w r4, #3
    face: d13c        bne.n fb4a <strcmp+0x182>
    fad0: f010 0403   ands.w  r4, r0, #3
    fad4: d128        bne.n fb28 <strcmp+0x160>
    fad6: f850 2b08   ldr.w r2, [r0], #8
    fada: f851 3b08   ldr.w r3, [r1], #8
    fade: fa82 f54c   uadd8 r5, r2, ip
    fae2: ea82 0503   eor.w r5, r2, r3
    fae6: faa5 f58c   sel r5, r5, ip
    faea: b95d        cbnz  r5, fb04 <strcmp+0x13c>
    faec: f850 2c04   ldr.w r2, [r0, #-4]
    faf0: f851 3c04   ldr.w r3, [r1, #-4]
    faf4: fa82 f54c   uadd8 r5, r2, ip
    faf8: ea82 0503   eor.w r5, r2, r3
    fafc: faa5 f58c   sel r5, r5, ip
    fb00: 2d00        cmp r5, #0
    fb02: d0e8        beq.n fad6 <strcmp+0x10e>
    fb04: ba2d        rev r5, r5
    fb06: fab5 f485   clz r4, r5
    fb0a: f024 0407   bic.w r4, r4, #7
    fb0e: fa23 f104   lsr.w r1, r3, r4
    fb12: fa22 f204   lsr.w r2, r2, r4
    fb16: f002 00ff   and.w r0, r2, #255  ; 0xff
    fb1a: f001 01ff   and.w r1, r1, #255  ; 0xff
    fb1e: e8fd 4504   ldrd  r4, r5, [sp], #16
    fb22: eba0 0001   sub.w r0, r0, r1
    fb26: 4770        bx  lr
    fb28: ea4f 04c4   mov.w r4, r4, lsl #3
    fb2c: f020 0003   bic.w r0, r0, #3
    fb30: f850 2b08   ldr.w r2, [r0], #8
    fb34: f021 0103   bic.w r1, r1, #3
    fb38: f851 3b08   ldr.w r3, [r1], #8
    fb3c: fa0c f404   lsl.w r4, ip, r4
    fb40: ea62 0204   orn r2, r2, r4
    fb44: ea63 0304   orn r3, r3, r4
    fb48: e7c9        b.n fade <strcmp+0x116>
    fb4a: f010 0403   ands.w  r4, r0, #3
    fb4e: d01a        beq.n fb86 <strcmp+0x1be>
    fb50: eba1 0104   sub.w r1, r1, r4
    fb54: f020 0003   bic.w r0, r0, #3
    fb58: 07e4        lsls  r4, r4, #31
    fb5a: f850 2b04   ldr.w r2, [r0], #4
    fb5e: d006        beq.n fb6e <strcmp+0x1a6>
    fb60: d20f        bcs.n fb82 <strcmp+0x1ba>
    fb62: 788b        ldrb  r3, [r1, #2]
    fb64: fa5f f4a2   uxtb.w  r4, r2, ror #16
    fb68: 1ae4        subs  r4, r4, r3
    fb6a: d106        bne.n fb7a <strcmp+0x1b2>
    fb6c: b12b        cbz r3, fb7a <strcmp+0x1b2>
    fb6e: 78cb        ldrb  r3, [r1, #3]
    fb70: fa5f f4b2   uxtb.w  r4, r2, ror #24
    fb74: 1ae4        subs  r4, r4, r3
    fb76: d100        bne.n fb7a <strcmp+0x1b2>
    fb78: b91b        cbnz  r3, fb82 <strcmp+0x1ba>
    fb7a: 4620        mov r0, r4
    fb7c: f85d 4b10   ldr.w r4, [sp], #16
    fb80: 4770        bx  lr
    fb82: f101 0104   add.w r1, r1, #4
    fb86: f850 2b04   ldr.w r2, [r0], #4
    fb8a: 07cc        lsls  r4, r1, #31
    fb8c: f021 0103   bic.w r1, r1, #3
    fb90: f851 3b04   ldr.w r3, [r1], #4
    fb94: d848        bhi.n fc28 <strcmp+0x260>
    fb96: d224        bcs.n fbe2 <strcmp+0x21a>
    fb98: f022 447f   bic.w r4, r2, #4278190080 ; 0xff000000
    fb9c: fa82 f54c   uadd8 r5, r2, ip
    fba0: ea94 2513   eors.w  r5, r4, r3, lsr #8
    fba4: faa5 f58c   sel r5, r5, ip
    fba8: d10a        bne.n fbc0 <strcmp+0x1f8>
    fbaa: b965        cbnz  r5, fbc6 <strcmp+0x1fe>
    fbac: f851 3b04   ldr.w r3, [r1], #4
    fbb0: ea84 0402   eor.w r4, r4, r2
    fbb4: ebb4 6f03   cmp.w r4, r3, lsl #24
    fbb8: d10e        bne.n fbd8 <strcmp+0x210>
    fbba: f850 2b04   ldr.w r2, [r0], #4
    fbbe: e7eb        b.n fb98 <strcmp+0x1d0>
    fbc0: ea4f 2313   mov.w r3, r3, lsr #8
    fbc4: e055        b.n fc72 <strcmp+0x2aa>
    fbc6: f035 457f   bics.w  r5, r5, #4278190080 ; 0xff000000
    fbca: d14d        bne.n fc68 <strcmp+0x2a0>
    fbcc: 7808        ldrb  r0, [r1, #0]
    fbce: e8fd 4504   ldrd  r4, r5, [sp], #16
    fbd2: f1c0 0000   rsb r0, r0, #0
    fbd6: 4770        bx  lr
    fbd8: ea4f 6212   mov.w r2, r2, lsr #24
    fbdc: f003 03ff   and.w r3, r3, #255  ; 0xff
    fbe0: e047        b.n fc72 <strcmp+0x2aa>
    fbe2: ea02 441c   and.w r4, r2, ip, lsr #16
    fbe6: fa82 f54c   uadd8 r5, r2, ip
    fbea: ea94 4513   eors.w  r5, r4, r3, lsr #16
    fbee: faa5 f58c   sel r5, r5, ip
    fbf2: d10a        bne.n fc0a <strcmp+0x242>
    fbf4: b965        cbnz  r5, fc10 <strcmp+0x248>
    fbf6: f851 3b04   ldr.w r3, [r1], #4
    fbfa: ea84 0402   eor.w r4, r4, r2
    fbfe: ebb4 4f03   cmp.w r4, r3, lsl #16
    fc02: d10c        bne.n fc1e <strcmp+0x256>
    fc04: f850 2b04   ldr.w r2, [r0], #4
    fc08: e7eb        b.n fbe2 <strcmp+0x21a>
    fc0a: ea4f 4313   mov.w r3, r3, lsr #16
    fc0e: e030        b.n fc72 <strcmp+0x2aa>
    fc10: ea15 451c   ands.w  r5, r5, ip, lsr #16
    fc14: d128        bne.n fc68 <strcmp+0x2a0>
    fc16: 880b        ldrh  r3, [r1, #0]
    fc18: ea4f 4212   mov.w r2, r2, lsr #16
    fc1c: e029        b.n fc72 <strcmp+0x2aa>
    fc1e: ea4f 4212   mov.w r2, r2, lsr #16
    fc22: ea03 431c   and.w r3, r3, ip, lsr #16
    fc26: e024        b.n fc72 <strcmp+0x2aa>
    fc28: f002 04ff   and.w r4, r2, #255  ; 0xff
    fc2c: fa82 f54c   uadd8 r5, r2, ip
    fc30: ea94 6513   eors.w  r5, r4, r3, lsr #24
    fc34: faa5 f58c   sel r5, r5, ip
    fc38: d10a        bne.n fc50 <strcmp+0x288>
    fc3a: b965        cbnz  r5, fc56 <strcmp+0x28e>
    fc3c: f851 3b04   ldr.w r3, [r1], #4
    fc40: ea84 0402   eor.w r4, r4, r2
    fc44: ebb4 2f03   cmp.w r4, r3, lsl #8
    fc48: d109        bne.n fc5e <strcmp+0x296>
    fc4a: f850 2b04   ldr.w r2, [r0], #4
    fc4e: e7eb        b.n fc28 <strcmp+0x260>
    fc50: ea4f 6313   mov.w r3, r3, lsr #24
    fc54: e00d        b.n fc72 <strcmp+0x2aa>
    fc56: f015 0fff   tst.w r5, #255  ; 0xff
    fc5a: d105        bne.n fc68 <strcmp+0x2a0>
    fc5c: 680b        ldr r3, [r1, #0]
    fc5e: ea4f 2212   mov.w r2, r2, lsr #8
    fc62: f023 437f   bic.w r3, r3, #4278190080 ; 0xff000000
    fc66: e004        b.n fc72 <strcmp+0x2aa>
    fc68: f04f 0000   mov.w r0, #0
    fc6c: e8fd 4504   ldrd  r4, r5, [sp], #16
    fc70: 4770        bx  lr
    fc72: ba12        rev r2, r2
    fc74: ba1b        rev r3, r3
    fc76: fa82 f44c   uadd8 r4, r2, ip
    fc7a: ea82 0403   eor.w r4, r2, r3
    fc7e: faa4 f58c   sel r5, r4, ip
    fc82: fab5 f485   clz r4, r5
    fc86: fa02 f204   lsl.w r2, r2, r4
    fc8a: fa03 f304   lsl.w r3, r3, r4
    fc8e: ea4f 6012   mov.w r0, r2, lsr #24
    fc92: e8fd 4504   ldrd  r4, r5, [sp], #16
    fc96: eba0 6013   sub.w r0, r0, r3, lsr #24
    fc9a: 4770        bx  lr
    fc9c: f3af 8000   nop.w

0000fca0 <__sprint_r.part.0>:
    fca0: e5913064  ldr r3, [r1, #100]  ; 0x64
    fca4: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
    fca8: e3130a02  tst r3, #8192 ; 0x2000
    fcac: e1a07001  mov r7, r1
    fcb0: e1a0a002  mov sl, r2
    fcb4: 0a000020  beq fd3c <__sprint_r.part.0+0x9c>
    fcb8: e5923008  ldr r3, [r2, #8]
    fcbc: e5929000  ldr r9, [r2]
    fcc0: e3530000  cmp r3, #0
    fcc4: 12899008  addne r9, r9, #8
    fcc8: 11a08000  movne r8, r0
    fccc: 0a000018  beq fd34 <__sprint_r.part.0+0x94>
    fcd0: e9190060  ldmdb r9, {r5, r6}
    fcd4: e1b06126  lsrs  r6, r6, #2
    fcd8: 12455004  subne r5, r5, #4
    fcdc: 13a04000  movne r4, #0
    fce0: 1a000002  bne fcf0 <__sprint_r.part.0+0x50>
    fce4: ea00000c  b fd1c <__sprint_r.part.0+0x7c>
    fce8: e1560004  cmp r6, r4
    fcec: 0a00000a  beq fd1c <__sprint_r.part.0+0x7c>
    fcf0: e1a00008  mov r0, r8
    fcf4: e5b51004  ldr r1, [r5, #4]!
    fcf8: e1a02007  mov r2, r7
    fcfc: e2844001  add r4, r4, #1
    fd00: eb000578  bl  112e8 <_fputwc_r>
    fd04: e3700001  cmn r0, #1
    fd08: 1afffff6  bne fce8 <__sprint_r.part.0+0x48>
    fd0c: e3a03000  mov r3, #0
    fd10: e58a3008  str r3, [sl, #8]
    fd14: e58a3004  str r3, [sl, #4]
    fd18: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
    fd1c: e59a3008  ldr r3, [sl, #8]
    fd20: e2899008  add r9, r9, #8
    fd24: e0436106  sub r6, r3, r6, lsl #2
    fd28: e58a6008  str r6, [sl, #8]
    fd2c: e3560000  cmp r6, #0
    fd30: 1affffe6  bne fcd0 <__sprint_r.part.0+0x30>
    fd34: e3a00000  mov r0, #0
    fd38: eafffff3  b fd0c <__sprint_r.part.0+0x6c>
    fd3c: eb0005da  bl  114ac <__sfvwrite_r>
    fd40: eafffff1  b fd0c <__sprint_r.part.0+0x6c>

0000fd44 <__sprint_r>:
    fd44: e5923008  ldr r3, [r2, #8]
    fd48: e3530000  cmp r3, #0
    fd4c: 0a000000  beq fd54 <__sprint_r+0x10>
    fd50: eaffffd2  b fca0 <__sprint_r.part.0>
    fd54: e5823004  str r3, [r2, #4]
    fd58: e1a00003  mov r0, r3
    fd5c: e12fff1e  bx  lr

0000fd60 <_vfiprintf_r>:
    fd60: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    fd64: e250c000  subs  ip, r0, #0
    fd68: e24dd0b4  sub sp, sp, #180  ; 0xb4
    fd6c: e1a04003  mov r4, r3
    fd70: e1a07002  mov r7, r2
    fd74: e58dc00c  str ip, [sp, #12]
    fd78: e58d1004  str r1, [sp, #4]
    fd7c: e58d301c  str r3, [sp, #28]
    fd80: 0a000002  beq fd90 <_vfiprintf_r+0x30>
    fd84: e59c3038  ldr r3, [ip, #56] ; 0x38
    fd88: e3530000  cmp r3, #0
    fd8c: 0a0000ba  beq 1007c <_vfiprintf_r+0x31c>
    fd90: e59d3004  ldr r3, [sp, #4]
    fd94: e1d310bc  ldrh  r1, [r3, #12]
    fd98: e6ff2071  uxth  r2, r1
    fd9c: e3120a02  tst r2, #8192 ; 0x2000
    fda0: 1a000006  bne fdc0 <_vfiprintf_r+0x60>
    fda4: e3812a02  orr r2, r1, #8192 ; 0x2000
    fda8: e1a01003  mov r1, r3
    fdac: e5933064  ldr r3, [r3, #100]  ; 0x64
    fdb0: e1c120bc  strh  r2, [r1, #12]
    fdb4: e6ff2072  uxth  r2, r2
    fdb8: e3c33a02  bic r3, r3, #8192 ; 0x2000
    fdbc: e5813064  str r3, [r1, #100]  ; 0x64
    fdc0: e3120008  tst r2, #8
    fdc4: 0a000094  beq 1001c <_vfiprintf_r+0x2bc>
    fdc8: e59d3004  ldr r3, [sp, #4]
    fdcc: e5933010  ldr r3, [r3, #16]
    fdd0: e3530000  cmp r3, #0
    fdd4: 0a000090  beq 1001c <_vfiprintf_r+0x2bc>
    fdd8: e202201a  and r2, r2, #26
    fddc: e352000a  cmp r2, #10
    fde0: 0a000097  beq 10044 <_vfiprintf_r+0x2e4>
    fde4: e28db070  add fp, sp, #112  ; 0x70
    fde8: e3a03000  mov r3, #0
    fdec: e58db03c  str fp, [sp, #60] ; 0x3c
    fdf0: e1a0a00b  mov sl, fp
    fdf4: e58d3028  str r3, [sp, #40] ; 0x28
    fdf8: e58d3044  str r3, [sp, #68] ; 0x44
    fdfc: e58d3010  str r3, [sp, #16]
    fe00: e58d3040  str r3, [sp, #64] ; 0x40
    fe04: e5d73000  ldrb  r3, [r7]
    fe08: e1a04007  mov r4, r7
    fe0c: e3530025  cmp r3, #37 ; 0x25
    fe10: 13530000  cmpne r3, #0
    fe14: 0a000013  beq fe68 <_vfiprintf_r+0x108>
    fe18: e5f43001  ldrb  r3, [r4, #1]!
    fe1c: e3530025  cmp r3, #37 ; 0x25
    fe20: 13530000  cmpne r3, #0
    fe24: 1afffffb  bne fe18 <_vfiprintf_r+0xb8>
    fe28: e0545007  subs  r5, r4, r7
    fe2c: 0a00000d  beq fe68 <_vfiprintf_r+0x108>
    fe30: e59d3040  ldr r3, [sp, #64] ; 0x40
    fe34: e59d2044  ldr r2, [sp, #68] ; 0x44
    fe38: e2833001  add r3, r3, #1
    fe3c: e58a7000  str r7, [sl]
    fe40: e3530007  cmp r3, #7
    fe44: e58a5004  str r5, [sl, #4]
    fe48: e58d3040  str r3, [sp, #64] ; 0x40
    fe4c: d28aa008  addle sl, sl, #8
    fe50: e0853002  add r3, r5, r2
    fe54: e58d3044  str r3, [sp, #68] ; 0x44
    fe58: ca00006a  bgt 10008 <_vfiprintf_r+0x2a8>
    fe5c: e59d3010  ldr r3, [sp, #16]
    fe60: e0833005  add r3, r3, r5
    fe64: e58d3010  str r3, [sp, #16]
    fe68: e5d43000  ldrb  r3, [r4]
    fe6c: e3530000  cmp r3, #0
    fe70: 0a0003eb  beq 10e24 <_vfiprintf_r+0x10c4>
    fe74: e5d43001  ldrb  r3, [r4, #1]
    fe78: e3a01000  mov r1, #0
    fe7c: e2840001  add r0, r4, #1
    fe80: e1a0c001  mov ip, r1
    fe84: e1a08001  mov r8, r1
    fe88: e5cd1037  strb  r1, [sp, #55] ; 0x37
    fe8c: e3e06000  mvn r6, #0
    fe90: e2807001  add r7, r0, #1
    fe94: e2432020  sub r2, r3, #32
    fe98: e3520058  cmp r2, #88 ; 0x58
    fe9c: 979ff102  ldrls pc, [pc, r2, lsl #2]
    fea0: ea0001f3  b 10674 <_vfiprintf_r+0x914>
    fea4: 00010494  .word 0x00010494
    fea8: 00010674  .word 0x00010674
    feac: 00010674  .word 0x00010674
    feb0: 000104a8  .word 0x000104a8
    feb4: 00010674  .word 0x00010674
    feb8: 00010674  .word 0x00010674
    febc: 00010674  .word 0x00010674
    fec0: 00010674  .word 0x00010674
    fec4: 00010674  .word 0x00010674
    fec8: 00010674  .word 0x00010674
    fecc: 000104b8  .word 0x000104b8
    fed0: 000104dc  .word 0x000104dc
    fed4: 00010674  .word 0x00010674
    fed8: 00010264  .word 0x00010264
    fedc: 00010308  .word 0x00010308
    fee0: 00010674  .word 0x00010674
    fee4: 0001053c  .word 0x0001053c
    fee8: 0001054c  .word 0x0001054c
    feec: 0001054c  .word 0x0001054c
    fef0: 0001054c  .word 0x0001054c
    fef4: 0001054c  .word 0x0001054c
    fef8: 0001054c  .word 0x0001054c
    fefc: 0001054c  .word 0x0001054c
    ff00: 0001054c  .word 0x0001054c
    ff04: 0001054c  .word 0x0001054c
    ff08: 0001054c  .word 0x0001054c
    ff0c: 00010674  .word 0x00010674
    ff10: 00010674  .word 0x00010674
    ff14: 00010674  .word 0x00010674
    ff18: 00010674  .word 0x00010674
    ff1c: 00010674  .word 0x00010674
    ff20: 00010674  .word 0x00010674
    ff24: 00010674  .word 0x00010674
    ff28: 00010674  .word 0x00010674
    ff2c: 00010674  .word 0x00010674
    ff30: 00010674  .word 0x00010674
    ff34: 00010570  .word 0x00010570
    ff38: 00010674  .word 0x00010674
    ff3c: 00010674  .word 0x00010674
    ff40: 00010674  .word 0x00010674
    ff44: 00010674  .word 0x00010674
    ff48: 00010674  .word 0x00010674
    ff4c: 00010674  .word 0x00010674
    ff50: 00010674  .word 0x00010674
    ff54: 00010674  .word 0x00010674
    ff58: 00010674  .word 0x00010674
    ff5c: 00010674  .word 0x00010674
    ff60: 000105b8  .word 0x000105b8
    ff64: 00010674  .word 0x00010674
    ff68: 00010674  .word 0x00010674
    ff6c: 00010674  .word 0x00010674
    ff70: 00010674  .word 0x00010674
    ff74: 00010674  .word 0x00010674
    ff78: 000105f4  .word 0x000105f4
    ff7c: 00010674  .word 0x00010674
    ff80: 00010674  .word 0x00010674
    ff84: 00010630  .word 0x00010630
    ff88: 00010674  .word 0x00010674
    ff8c: 00010674  .word 0x00010674
    ff90: 00010674  .word 0x00010674
    ff94: 00010674  .word 0x00010674
    ff98: 00010674  .word 0x00010674
    ff9c: 00010674  .word 0x00010674
    ffa0: 00010674  .word 0x00010674
    ffa4: 00010674  .word 0x00010674
    ffa8: 00010674  .word 0x00010674
    ffac: 00010674  .word 0x00010674
    ffb0: 00010408  .word 0x00010408
    ffb4: 00010448  .word 0x00010448
    ffb8: 00010674  .word 0x00010674
    ffbc: 00010674  .word 0x00010674
    ffc0: 00010674  .word 0x00010674
    ffc4: 000103f8  .word 0x000103f8
    ffc8: 00010448  .word 0x00010448
    ffcc: 00010674  .word 0x00010674
    ffd0: 00010674  .word 0x00010674
    ffd4: 000103a8  .word 0x000103a8
    ffd8: 00010674  .word 0x00010674
    ffdc: 000103c8  .word 0x000103c8
    ffe0: 00010274  .word 0x00010274
    ffe4: 000104ec  .word 0x000104ec
    ffe8: 0001052c  .word 0x0001052c
    ffec: 00010674  .word 0x00010674
    fff0: 000102a0  .word 0x000102a0
    fff4: 00010674  .word 0x00010674
    fff8: 00010084  .word 0x00010084
    fffc: 00010674  .word 0x00010674
   10000: 00010674  .word 0x00010674
   10004: 0001034c  .word 0x0001034c
   10008: e3530000  cmp r3, #0
   1000c: 1a000317  bne 10c70 <_vfiprintf_r+0xf10>
   10010: e58d3040  str r3, [sp, #64] ; 0x40
   10014: e1a0a00b  mov sl, fp
   10018: eaffff8f  b fe5c <_vfiprintf_r+0xfc>
   1001c: e59d000c  ldr r0, [sp, #12]
   10020: e59d1004  ldr r1, [sp, #4]
   10024: ebffef9b  bl  be98 <__swsetup_r>
   10028: e3500000  cmp r0, #0
   1002c: 1a00000f  bne 10070 <_vfiprintf_r+0x310>
   10030: e59d3004  ldr r3, [sp, #4]
   10034: e1d320bc  ldrh  r2, [r3, #12]
   10038: e202201a  and r2, r2, #26
   1003c: e352000a  cmp r2, #10
   10040: 1affff67  bne fde4 <_vfiprintf_r+0x84>
   10044: e59d3004  ldr r3, [sp, #4]
   10048: e1d330fe  ldrsh r3, [r3, #14]
   1004c: e3530000  cmp r3, #0
   10050: baffff63  blt fde4 <_vfiprintf_r+0x84>
   10054: e59d000c  ldr r0, [sp, #12]
   10058: e1a02007  mov r2, r7
   1005c: e59d1004  ldr r1, [sp, #4]
   10060: e1a03004  mov r3, r4
   10064: eb0003ba  bl  10f54 <__sbprintf>
   10068: e28dd0b4  add sp, sp, #180  ; 0xb4
   1006c: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10070: e3e00000  mvn r0, #0
   10074: e28dd0b4  add sp, sp, #180  ; 0xb4
   10078: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1007c: ebfff6a5  bl  db18 <__sinit>
   10080: eaffff42  b fd90 <_vfiprintf_r+0x30>
   10084: e3180020  tst r8, #32
   10088: e58dc018  str ip, [sp, #24]
   1008c: e59d301c  ldr r3, [sp, #28]
   10090: 0a00015c  beq 10608 <_vfiprintf_r+0x8a8>
   10094: e2835007  add r5, r3, #7
   10098: e3a02001  mov r2, #1
   1009c: e3c53007  bic r3, r5, #7
   100a0: e2831008  add r1, r3, #8
   100a4: e58d101c  str r1, [sp, #28]
   100a8: e1c340d0  ldrd  r4, [r3]
   100ac: e3a09000  mov r9, #0
   100b0: e58d6014  str r6, [sp, #20]
   100b4: e5cd9037  strb  r9, [sp, #55] ; 0x37
   100b8: e3560000  cmp r6, #0
   100bc: a3c88080  bicge r8, r8, #128  ; 0x80
   100c0: e1943005  orrs  r3, r4, r5
   100c4: 13a03001  movne r3, #1
   100c8: 03a03000  moveq r3, #0
   100cc: e3560000  cmp r6, #0
   100d0: 01a06003  moveq r6, r3
   100d4: 13836001  orrne r6, r3, #1
   100d8: e3560000  cmp r6, #0
   100dc: 0a000246  beq 109fc <_vfiprintf_r+0xc9c>
   100e0: e3520001  cmp r2, #1
   100e4: 0a0002b7  beq 10bc8 <_vfiprintf_r+0xe68>
   100e8: e3520002  cmp r2, #2
   100ec: 1a000294  bne 10b44 <_vfiprintf_r+0xde4>
   100f0: e59d1028  ldr r1, [sp, #40] ; 0x28
   100f4: e1a0300b  mov r3, fp
   100f8: e204200f  and r2, r4, #15
   100fc: e1a04224  lsr r4, r4, #4
   10100: e1844e05  orr r4, r4, r5, lsl #28
   10104: e1a05225  lsr r5, r5, #4
   10108: e7d12002  ldrb  r2, [r1, r2]
   1010c: e1940005  orrs  r0, r4, r5
   10110: e5632001  strb  r2, [r3, #-1]!
   10114: 1afffff7  bne 100f8 <_vfiprintf_r+0x398>
   10118: e58d3024  str r3, [sp, #36] ; 0x24
   1011c: e063600b  rsb r6, r3, fp
   10120: e59d3014  ldr r3, [sp, #20]
   10124: e1560003  cmp r6, r3
   10128: a1a03006  movge r3, r6
   1012c: e3590000  cmp r9, #0
   10130: e58d3008  str r3, [sp, #8]
   10134: 12833001  addne r3, r3, #1
   10138: 158d3008  strne r3, [sp, #8]
   1013c: e2183002  ands  r3, r8, #2
   10140: 159d2008  ldrne r2, [sp, #8]
   10144: 12822002  addne r2, r2, #2
   10148: 158d2008  strne r2, [sp, #8]
   1014c: e2182084  ands  r2, r8, #132  ; 0x84
   10150: e58d2020  str r2, [sp, #32]
   10154: 1a000153  bne 106a8 <_vfiprintf_r+0x948>
   10158: e59d2018  ldr r2, [sp, #24]
   1015c: e59d1008  ldr r1, [sp, #8]
   10160: e0614002  rsb r4, r1, r2
   10164: e3540000  cmp r4, #0
   10168: da00014e  ble 106a8 <_vfiprintf_r+0x948>
   1016c: e3540010  cmp r4, #16
   10170: da00034a  ble 10ea0 <_vfiprintf_r+0x1140>
   10174: e30856c8  movw  r5, #34504  ; 0x86c8
   10178: e59d2044  ldr r2, [sp, #68] ; 0x44
   1017c: e59dc040  ldr ip, [sp, #64] ; 0x40
   10180: e3405001  movt  r5, #1
   10184: e3a09010  mov r9, #16
   10188: e58d302c  str r3, [sp, #44] ; 0x2c
   1018c: ea000002  b 1019c <_vfiprintf_r+0x43c>
   10190: e2444010  sub r4, r4, #16
   10194: e3540010  cmp r4, #16
   10198: da00001b  ble 1020c <_vfiprintf_r+0x4ac>
   1019c: e28c0001  add r0, ip, #1
   101a0: e2822010  add r2, r2, #16
   101a4: e3500007  cmp r0, #7
   101a8: e58a5000  str r5, [sl]
   101ac: e28c1002  add r1, ip, #2
   101b0: e58a9004  str r9, [sl, #4]
   101b4: e58d2044  str r2, [sp, #68] ; 0x44
   101b8: e1a0c000  mov ip, r0
   101bc: e58d0040  str r0, [sp, #64] ; 0x40
   101c0: d28aa008  addle sl, sl, #8
   101c4: dafffff1  ble 10190 <_vfiprintf_r+0x430>
   101c8: e3520000  cmp r2, #0
   101cc: e1a0c002  mov ip, r2
   101d0: e3a01001  mov r1, #1
   101d4: e1a0a00b  mov sl, fp
   101d8: 0affffec  beq 10190 <_vfiprintf_r+0x430>
   101dc: e59d000c  ldr r0, [sp, #12]
   101e0: e28d203c  add r2, sp, #60 ; 0x3c
   101e4: e59d1004  ldr r1, [sp, #4]
   101e8: ebfffeac  bl  fca0 <__sprint_r.part.0>
   101ec: e3500000  cmp r0, #0
   101f0: 1a0001d8  bne 10958 <_vfiprintf_r+0xbf8>
   101f4: e2444010  sub r4, r4, #16
   101f8: e59dc040  ldr ip, [sp, #64] ; 0x40
   101fc: e3540010  cmp r4, #16
   10200: e59d2044  ldr r2, [sp, #68] ; 0x44
   10204: e28c1001  add r1, ip, #1
   10208: caffffe3  bgt 1019c <_vfiprintf_r+0x43c>
   1020c: e59d302c  ldr r3, [sp, #44] ; 0x2c
   10210: e3510007  cmp r1, #7
   10214: e0842002  add r2, r4, r2
   10218: e58a5000  str r5, [sl]
   1021c: d2810001  addle r0, r1, #1
   10220: e58a4004  str r4, [sl, #4]
   10224: d28aa008  addle sl, sl, #8
   10228: e58d2044  str r2, [sp, #68] ; 0x44
   1022c: e58d1040  str r1, [sp, #64] ; 0x40
   10230: da00011f  ble 106b4 <_vfiprintf_r+0x954>
   10234: e3520000  cmp r2, #0
   10238: 1a0002ec  bne 10df0 <_vfiprintf_r+0x1090>
   1023c: e5dd1037  ldrb  r1, [sp, #55] ; 0x37
   10240: e3510000  cmp r1, #0
   10244: 0a0002cd  beq 10d80 <_vfiprintf_r+0x1020>
   10248: e3a02001  mov r2, #1
   1024c: e28d1037  add r1, sp, #55 ; 0x37
   10250: e1a00002  mov r0, r2
   10254: e58d2074  str r2, [sp, #116]  ; 0x74
   10258: e58d1070  str r1, [sp, #112]  ; 0x70
   1025c: e1a0a00b  mov sl, fp
   10260: ea00011f  b 106e4 <_vfiprintf_r+0x984>
   10264: e1a00007  mov r0, r7
   10268: e3888004  orr r8, r8, #4
   1026c: e5d73000  ldrb  r3, [r7]
   10270: eaffff06  b fe90 <_vfiprintf_r+0x130>
   10274: e2182020  ands  r2, r8, #32
   10278: e58dc018  str ip, [sp, #24]
   1027c: 0a0000d1  beq 105c8 <_vfiprintf_r+0x868>
   10280: e59d301c  ldr r3, [sp, #28]
   10284: e3a02000  mov r2, #0
   10288: e2835007  add r5, r3, #7
   1028c: e3c53007  bic r3, r5, #7
   10290: e2831008  add r1, r3, #8
   10294: e58d101c  str r1, [sp, #28]
   10298: e1c340d0  ldrd  r4, [r3]
   1029c: eaffff82  b 100ac <_vfiprintf_r+0x34c>
   102a0: e59d301c  ldr r3, [sp, #28]
   102a4: e58dc018  str ip, [sp, #24]
   102a8: e2835004  add r5, r3, #4
   102ac: e5932000  ldr r2, [r3]
   102b0: e3a03000  mov r3, #0
   102b4: e5cd3037  strb  r3, [sp, #55] ; 0x37
   102b8: e1520003  cmp r2, r3
   102bc: e58d2024  str r2, [sp, #36] ; 0x24
   102c0: 0a0002fc  beq 10eb8 <_vfiprintf_r+0x1158>
   102c4: e3560000  cmp r6, #0
   102c8: ba0002e1  blt 10e54 <_vfiprintf_r+0x10f4>
   102cc: e59d4024  ldr r4, [sp, #36] ; 0x24
   102d0: e3a01000  mov r1, #0
   102d4: e1a02006  mov r2, r6
   102d8: e1a00004  mov r0, r4
   102dc: fafff9bf  blx e9e0 <memchr>
   102e0: e3500000  cmp r0, #0
   102e4: 0a000303  beq 10ef8 <_vfiprintf_r+0x1198>
   102e8: e0643000  rsb r3, r4, r0
   102ec: e3a02000  mov r2, #0
   102f0: e1530006  cmp r3, r6
   102f4: e58d501c  str r5, [sp, #28]
   102f8: e5dd9037  ldrb  r9, [sp, #55] ; 0x37
   102fc: e58d2014  str r2, [sp, #20]
   10300: b1a06003  movlt r6, r3
   10304: eaffff85  b 10120 <_vfiprintf_r+0x3c0>
   10308: e5d73000  ldrb  r3, [r7]
   1030c: e2870001  add r0, r7, #1
   10310: e353002a  cmp r3, #42 ; 0x2a
   10314: 0a0002fb  beq 10f08 <_vfiprintf_r+0x11a8>
   10318: e2432030  sub r2, r3, #48 ; 0x30
   1031c: e1a07000  mov r7, r0
   10320: e3520009  cmp r2, #9
   10324: e3a06000  mov r6, #0
   10328: 8afffed9  bhi fe94 <_vfiprintf_r+0x134>
   1032c: e0866106  add r6, r6, r6, lsl #2
   10330: e4d73001  ldrb  r3, [r7], #1
   10334: e0826086  add r6, r2, r6, lsl #1
   10338: e2432030  sub r2, r3, #48 ; 0x30
   1033c: e3520009  cmp r2, #9
   10340: 9afffff9  bls 1032c <_vfiprintf_r+0x5cc>
   10344: e1866fc6  orr r6, r6, r6, asr #31
   10348: eafffed1  b fe94 <_vfiprintf_r+0x134>
   1034c: e3180020  tst r8, #32
   10350: e308274c  movw  r2, #34636  ; 0x874c
   10354: e3402001  movt  r2, #1
   10358: e58dc018  str ip, [sp, #24]
   1035c: e58d2028  str r2, [sp, #40] ; 0x28
   10360: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10364: e59d201c  ldr r2, [sp, #28]
   10368: 0a0000b8  beq 10650 <_vfiprintf_r+0x8f0>
   1036c: e2825007  add r5, r2, #7
   10370: e3c52007  bic r2, r5, #7
   10374: e2821008  add r1, r2, #8
   10378: e58d101c  str r1, [sp, #28]
   1037c: e1c240d0  ldrd  r4, [r2]
   10380: e3180001  tst r8, #1
   10384: 0a000206  beq 10ba4 <_vfiprintf_r+0xe44>
   10388: e1942005  orrs  r2, r4, r5
   1038c: 0a000204  beq 10ba4 <_vfiprintf_r+0xe44>
   10390: e5cd3039  strb  r3, [sp, #57] ; 0x39
   10394: e3888002  orr r8, r8, #2
   10398: e3a03030  mov r3, #48 ; 0x30
   1039c: e3a02002  mov r2, #2
   103a0: e5cd3038  strb  r3, [sp, #56] ; 0x38
   103a4: eaffff40  b 100ac <_vfiprintf_r+0x34c>
   103a8: e5d73000  ldrb  r3, [r7]
   103ac: e353006c  cmp r3, #108  ; 0x6c
   103b0: 03888020  orreq r8, r8, #32
   103b4: 02870001  addeq r0, r7, #1
   103b8: 05d73001  ldrbeq  r3, [r7, #1]
   103bc: 13888010  orrne r8, r8, #16
   103c0: 11a00007  movne r0, r7
   103c4: eafffeb1  b fe90 <_vfiprintf_r+0x130>
   103c8: e3180020  tst r8, #32
   103cc: e5cd1037  strb  r1, [sp, #55] ; 0x37
   103d0: 0a000274  beq 10da8 <_vfiprintf_r+0x1048>
   103d4: e59d1010  ldr r1, [sp, #16]
   103d8: e59d201c  ldr r2, [sp, #28]
   103dc: ee801b90  vdup.32 d16, r1
   103e0: e2822004  add r2, r2, #4
   103e4: e5123004  ldr r3, [r2, #-4]
   103e8: f2e000b0  vshr.s64  d16, d16, #32
   103ec: e58d201c  str r2, [sp, #28]
   103f0: edc30b00  vstr  d16, [r3]
   103f4: eafffe82  b fe04 <_vfiprintf_r+0xa4>
   103f8: e3888040  orr r8, r8, #64 ; 0x40
   103fc: e5d73000  ldrb  r3, [r7]
   10400: e1a00007  mov r0, r7
   10404: eafffea1  b fe90 <_vfiprintf_r+0x130>
   10408: e59d101c  ldr r1, [sp, #28]
   1040c: e3a02001  mov r2, #1
   10410: e1a06002  mov r6, r2
   10414: e58d2008  str r2, [sp, #8]
   10418: e2811004  add r1, r1, #4
   1041c: e28d2048  add r2, sp, #72 ; 0x48
   10420: e5113004  ldr r3, [r1, #-4]
   10424: e58dc018  str ip, [sp, #24]
   10428: e58d101c  str r1, [sp, #28]
   1042c: e3a01000  mov r1, #0
   10430: e58d2024  str r2, [sp, #36] ; 0x24
   10434: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10438: e5cd3048  strb  r3, [sp, #72] ; 0x48
   1043c: e3a03000  mov r3, #0
   10440: e58d3014  str r3, [sp, #20]
   10444: eaffff3c  b 1013c <_vfiprintf_r+0x3dc>
   10448: e3180020  tst r8, #32
   1044c: e58dc018  str ip, [sp, #24]
   10450: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10454: e59d301c  ldr r3, [sp, #28]
   10458: 0a00004a  beq 10588 <_vfiprintf_r+0x828>
   1045c: e2835007  add r5, r3, #7
   10460: e3c53007  bic r3, r5, #7
   10464: e2832008  add r2, r3, #8
   10468: e58d201c  str r2, [sp, #28]
   1046c: e1c320d0  ldrd  r2, [r3]
   10470: e1a04002  mov r4, r2
   10474: e1a05003  mov r5, r3
   10478: e3520000  cmp r2, #0
   1047c: e2d33000  sbcs  r3, r3, #0
   10480: ba000237  blt 10d64 <_vfiprintf_r+0x1004>
   10484: e5dd9037  ldrb  r9, [sp, #55] ; 0x37
   10488: e3a02001  mov r2, #1
   1048c: e58d6014  str r6, [sp, #20]
   10490: eaffff08  b 100b8 <_vfiprintf_r+0x358>
   10494: e3510000  cmp r1, #0
   10498: e5d73000  ldrb  r3, [r7]
   1049c: e1a00007  mov r0, r7
   104a0: 03a01020  moveq r1, #32
   104a4: eafffe79  b fe90 <_vfiprintf_r+0x130>
   104a8: e3888001  orr r8, r8, #1
   104ac: e5d73000  ldrb  r3, [r7]
   104b0: e1a00007  mov r0, r7
   104b4: eafffe75  b fe90 <_vfiprintf_r+0x130>
   104b8: e59d301c  ldr r3, [sp, #28]
   104bc: e2833004  add r3, r3, #4
   104c0: e513c004  ldr ip, [r3, #-4]
   104c4: e35c0000  cmp ip, #0
   104c8: ba00025d  blt 10e44 <_vfiprintf_r+0x10e4>
   104cc: e58d301c  str r3, [sp, #28]
   104d0: e1a00007  mov r0, r7
   104d4: e5d73000  ldrb  r3, [r7]
   104d8: eafffe6c  b fe90 <_vfiprintf_r+0x130>
   104dc: e5d73000  ldrb  r3, [r7]
   104e0: e1a00007  mov r0, r7
   104e4: e3a0102b  mov r1, #43 ; 0x2b
   104e8: eafffe68  b fe90 <_vfiprintf_r+0x130>
   104ec: e59d101c  ldr r1, [sp, #28]
   104f0: e308274c  movw  r2, #34636  ; 0x874c
   104f4: e3402001  movt  r2, #1
   104f8: e58dc018  str ip, [sp, #24]
   104fc: e2813004  add r3, r1, #4
   10500: e58d2028  str r2, [sp, #40] ; 0x28
   10504: e58d301c  str r3, [sp, #28]
   10508: e3888002  orr r8, r8, #2
   1050c: e3a03030  mov r3, #48 ; 0x30
   10510: e5914000  ldr r4, [r1]
   10514: e5cd3038  strb  r3, [sp, #56] ; 0x38
   10518: e3a05000  mov r5, #0
   1051c: e3a03078  mov r3, #120  ; 0x78
   10520: e3a02002  mov r2, #2
   10524: e5cd3039  strb  r3, [sp, #57] ; 0x39
   10528: eafffedf  b 100ac <_vfiprintf_r+0x34c>
   1052c: e3888020  orr r8, r8, #32
   10530: e5d73000  ldrb  r3, [r7]
   10534: e1a00007  mov r0, r7
   10538: eafffe54  b fe90 <_vfiprintf_r+0x130>
   1053c: e3888080  orr r8, r8, #128  ; 0x80
   10540: e5d73000  ldrb  r3, [r7]
   10544: e1a00007  mov r0, r7
   10548: eafffe50  b fe90 <_vfiprintf_r+0x130>
   1054c: e2432030  sub r2, r3, #48 ; 0x30
   10550: e3a0c000  mov ip, #0
   10554: e08cc10c  add ip, ip, ip, lsl #2
   10558: e4d73001  ldrb  r3, [r7], #1
   1055c: e082c08c  add ip, r2, ip, lsl #1
   10560: e2432030  sub r2, r3, #48 ; 0x30
   10564: e3520009  cmp r2, #9
   10568: 9afffff9  bls 10554 <_vfiprintf_r+0x7f4>
   1056c: eafffe48  b fe94 <_vfiprintf_r+0x134>
   10570: e3888010  orr r8, r8, #16
   10574: e58dc018  str ip, [sp, #24]
   10578: e3180020  tst r8, #32
   1057c: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10580: e59d301c  ldr r3, [sp, #28]
   10584: 1affffb4  bne 1045c <_vfiprintf_r+0x6fc>
   10588: e3180010  tst r8, #16
   1058c: 1a0001aa  bne 10c3c <_vfiprintf_r+0xedc>
   10590: e3180040  tst r8, #64 ; 0x40
   10594: 0a0001a8  beq 10c3c <_vfiprintf_r+0xedc>
   10598: e1d340b0  ldrh  r4, [r3]
   1059c: e2833004  add r3, r3, #4
   105a0: e58d301c  str r3, [sp, #28]
   105a4: e6bf4074  sxth  r4, r4
   105a8: e1a05fc4  asr r5, r4, #31
   105ac: e1a02004  mov r2, r4
   105b0: e1a03005  mov r3, r5
   105b4: eaffffaf  b 10478 <_vfiprintf_r+0x718>
   105b8: e3888010  orr r8, r8, #16
   105bc: e58dc018  str ip, [sp, #24]
   105c0: e2182020  ands  r2, r8, #32
   105c4: 1affff2d  bne 10280 <_vfiprintf_r+0x520>
   105c8: e2183010  ands  r3, r8, #16
   105cc: 1a000194  bne 10c24 <_vfiprintf_r+0xec4>
   105d0: e2182040  ands  r2, r8, #64 ; 0x40
   105d4: 0a000192  beq 10c24 <_vfiprintf_r+0xec4>
   105d8: e1a02003  mov r2, r3
   105dc: e59d301c  ldr r3, [sp, #28]
   105e0: e3a05000  mov r5, #0
   105e4: e2833004  add r3, r3, #4
   105e8: e15340b4  ldrh  r4, [r3, #-4]
   105ec: e58d301c  str r3, [sp, #28]
   105f0: eafffead  b 100ac <_vfiprintf_r+0x34c>
   105f4: e3888010  orr r8, r8, #16
   105f8: e58dc018  str ip, [sp, #24]
   105fc: e3180020  tst r8, #32
   10600: e59d301c  ldr r3, [sp, #28]
   10604: 1afffea2  bne 10094 <_vfiprintf_r+0x334>
   10608: e3180010  tst r8, #16
   1060c: 1a000191  bne 10c58 <_vfiprintf_r+0xef8>
   10610: e3180040  tst r8, #64 ; 0x40
   10614: 0a00018f  beq 10c58 <_vfiprintf_r+0xef8>
   10618: e1d340b0  ldrh  r4, [r3]
   1061c: e3a05000  mov r5, #0
   10620: e2833004  add r3, r3, #4
   10624: e3a02001  mov r2, #1
   10628: e58d301c  str r3, [sp, #28]
   1062c: eafffe9e  b 100ac <_vfiprintf_r+0x34c>
   10630: e3180020  tst r8, #32
   10634: e30826e8  movw  r2, #34536  ; 0x86e8
   10638: e3402001  movt  r2, #1
   1063c: e58dc018  str ip, [sp, #24]
   10640: e58d2028  str r2, [sp, #40] ; 0x28
   10644: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10648: e59d201c  ldr r2, [sp, #28]
   1064c: 1affff46  bne 1036c <_vfiprintf_r+0x60c>
   10650: e3180010  tst r8, #16
   10654: 1a00016d  bne 10c10 <_vfiprintf_r+0xeb0>
   10658: e3180040  tst r8, #64 ; 0x40
   1065c: 0a00016b  beq 10c10 <_vfiprintf_r+0xeb0>
   10660: e1d240b0  ldrh  r4, [r2]
   10664: e3a05000  mov r5, #0
   10668: e2822004  add r2, r2, #4
   1066c: e58d201c  str r2, [sp, #28]
   10670: eaffff42  b 10380 <_vfiprintf_r+0x620>
   10674: e3530000  cmp r3, #0
   10678: e58dc018  str ip, [sp, #24]
   1067c: e5cd1037  strb  r1, [sp, #55] ; 0x37
   10680: 0a0001e7  beq 10e24 <_vfiprintf_r+0x10c4>
   10684: e3a02001  mov r2, #1
   10688: e5cd3048  strb  r3, [sp, #72] ; 0x48
   1068c: e58d2008  str r2, [sp, #8]
   10690: e3a03000  mov r3, #0
   10694: e1a06002  mov r6, r2
   10698: e5cd3037  strb  r3, [sp, #55] ; 0x37
   1069c: e28d3048  add r3, sp, #72 ; 0x48
   106a0: e58d3024  str r3, [sp, #36] ; 0x24
   106a4: eaffff64  b 1043c <_vfiprintf_r+0x6dc>
   106a8: e59d1040  ldr r1, [sp, #64] ; 0x40
   106ac: e59d2044  ldr r2, [sp, #68] ; 0x44
   106b0: e2810001  add r0, r1, #1
   106b4: e5ddc037  ldrb  ip, [sp, #55] ; 0x37
   106b8: e35c0000  cmp ip, #0
   106bc: 0a00000b  beq 106f0 <_vfiprintf_r+0x990>
   106c0: e3500007  cmp r0, #7
   106c4: e2822001  add r2, r2, #1
   106c8: e28dc037  add ip, sp, #55 ; 0x37
   106cc: e3a01001  mov r1, #1
   106d0: e58d0040  str r0, [sp, #64] ; 0x40
   106d4: e58d2044  str r2, [sp, #68] ; 0x44
   106d8: e58ac000  str ip, [sl]
   106dc: e58a1004  str r1, [sl, #4]
   106e0: ca000106  bgt 10b00 <_vfiprintf_r+0xda0>
   106e4: e1a01000  mov r1, r0
   106e8: e28aa008  add sl, sl, #8
   106ec: e2800001  add r0, r0, #1
   106f0: e3530000  cmp r3, #0
   106f4: 0a00000a  beq 10724 <_vfiprintf_r+0x9c4>
   106f8: e3500007  cmp r0, #7
   106fc: e2822002  add r2, r2, #2
   10700: e28d1038  add r1, sp, #56 ; 0x38
   10704: e3a03002  mov r3, #2
   10708: e58d0040  str r0, [sp, #64] ; 0x40
   1070c: e58d2044  str r2, [sp, #68] ; 0x44
   10710: e88a000a  stm sl, {r1, r3}
   10714: ca000104  bgt 10b2c <_vfiprintf_r+0xdcc>
   10718: e1a01000  mov r1, r0
   1071c: e28aa008  add sl, sl, #8
   10720: e2800001  add r0, r0, #1
   10724: e59d3020  ldr r3, [sp, #32]
   10728: e3530080  cmp r3, #128  ; 0x80
   1072c: 0a0000bf  beq 10a30 <_vfiprintf_r+0xcd0>
   10730: e59d3014  ldr r3, [sp, #20]
   10734: e0664003  rsb r4, r6, r3
   10738: e3540000  cmp r4, #0
   1073c: da000096  ble 1099c <_vfiprintf_r+0xc3c>
   10740: e3540010  cmp r4, #16
   10744: e59f57dc  ldr r5, [pc, #2012] ; 10f28 <_vfiprintf_r+0x11c8>
   10748: c3a09010  movgt r9, #16
   1074c: ca000003  bgt 10760 <_vfiprintf_r+0xa00>
   10750: ea00001e  b 107d0 <_vfiprintf_r+0xa70>
   10754: e2444010  sub r4, r4, #16
   10758: e3540010  cmp r4, #16
   1075c: da00001b  ble 107d0 <_vfiprintf_r+0xa70>
   10760: e281c001  add ip, r1, #1
   10764: e2822010  add r2, r2, #16
   10768: e35c0007  cmp ip, #7
   1076c: e58a5000  str r5, [sl]
   10770: e2810002  add r0, r1, #2
   10774: e58a9004  str r9, [sl, #4]
   10778: e58d2044  str r2, [sp, #68] ; 0x44
   1077c: e1a0100c  mov r1, ip
   10780: e58dc040  str ip, [sp, #64] ; 0x40
   10784: d28aa008  addle sl, sl, #8
   10788: dafffff1  ble 10754 <_vfiprintf_r+0x9f4>
   1078c: e3520000  cmp r2, #0
   10790: e3a00001  mov r0, #1
   10794: e1a01002  mov r1, r2
   10798: e1a0a00b  mov sl, fp
   1079c: 0affffec  beq 10754 <_vfiprintf_r+0x9f4>
   107a0: e59d000c  ldr r0, [sp, #12]
   107a4: e28d203c  add r2, sp, #60 ; 0x3c
   107a8: e59d1004  ldr r1, [sp, #4]
   107ac: ebfffd3b  bl  fca0 <__sprint_r.part.0>
   107b0: e3500000  cmp r0, #0
   107b4: 1a000067  bne 10958 <_vfiprintf_r+0xbf8>
   107b8: e2444010  sub r4, r4, #16
   107bc: e59d1040  ldr r1, [sp, #64] ; 0x40
   107c0: e3540010  cmp r4, #16
   107c4: e59d2044  ldr r2, [sp, #68] ; 0x44
   107c8: e2810001  add r0, r1, #1
   107cc: caffffe3  bgt 10760 <_vfiprintf_r+0xa00>
   107d0: e3500007  cmp r0, #7
   107d4: e0822004  add r2, r2, r4
   107d8: e58a5000  str r5, [sl]
   107dc: e58a4004  str r4, [sl, #4]
   107e0: d28aa008  addle sl, sl, #8
   107e4: e58d0040  str r0, [sp, #64] ; 0x40
   107e8: d2800001  addle r0, r0, #1
   107ec: e58d2044  str r2, [sp, #68] ; 0x44
   107f0: da000069  ble 1099c <_vfiprintf_r+0xc3c>
   107f4: e3520000  cmp r2, #0
   107f8: 1a00005d  bne 10974 <_vfiprintf_r+0xc14>
   107fc: e59d3024  ldr r3, [sp, #36] ; 0x24
   10800: e1a02006  mov r2, r6
   10804: e1a0a00b  mov sl, fp
   10808: e58d6074  str r6, [sp, #116]  ; 0x74
   1080c: e58d6044  str r6, [sp, #68] ; 0x44
   10810: e58d3070  str r3, [sp, #112]  ; 0x70
   10814: e3a03001  mov r3, #1
   10818: e58d3040  str r3, [sp, #64] ; 0x40
   1081c: e28aa008  add sl, sl, #8
   10820: e3180004  tst r8, #4
   10824: 0a00003c  beq 1091c <_vfiprintf_r+0xbbc>
   10828: e59d3018  ldr r3, [sp, #24]
   1082c: e59d1008  ldr r1, [sp, #8]
   10830: e0614003  rsb r4, r1, r3
   10834: e3540000  cmp r4, #0
   10838: da000037  ble 1091c <_vfiprintf_r+0xbbc>
   1083c: e3540010  cmp r4, #16
   10840: da0001a5  ble 10edc <_vfiprintf_r+0x117c>
   10844: e30856c8  movw  r5, #34504  ; 0x86c8
   10848: e59d1040  ldr r1, [sp, #64] ; 0x40
   1084c: e3405001  movt  r5, #1
   10850: e3a06010  mov r6, #16
   10854: e59d800c  ldr r8, [sp, #12]
   10858: e59d9004  ldr r9, [sp, #4]
   1085c: ea000002  b 1086c <_vfiprintf_r+0xb0c>
   10860: e2444010  sub r4, r4, #16
   10864: e3540010  cmp r4, #16
   10868: da00001b  ble 108dc <_vfiprintf_r+0xb7c>
   1086c: e2813001  add r3, r1, #1
   10870: e2822010  add r2, r2, #16
   10874: e3530007  cmp r3, #7
   10878: e58a5000  str r5, [sl]
   1087c: e2810002  add r0, r1, #2
   10880: e58a6004  str r6, [sl, #4]
   10884: e58d2044  str r2, [sp, #68] ; 0x44
   10888: e1a01003  mov r1, r3
   1088c: e58d3040  str r3, [sp, #64] ; 0x40
   10890: d28aa008  addle sl, sl, #8
   10894: dafffff1  ble 10860 <_vfiprintf_r+0xb00>
   10898: e3520000  cmp r2, #0
   1089c: e3a00001  mov r0, #1
   108a0: e1a01002  mov r1, r2
   108a4: e1a0a00b  mov sl, fp
   108a8: 0affffec  beq 10860 <_vfiprintf_r+0xb00>
   108ac: e1a00008  mov r0, r8
   108b0: e1a01009  mov r1, r9
   108b4: e28d203c  add r2, sp, #60 ; 0x3c
   108b8: ebfffcf8  bl  fca0 <__sprint_r.part.0>
   108bc: e3500000  cmp r0, #0
   108c0: 1a000024  bne 10958 <_vfiprintf_r+0xbf8>
   108c4: e2444010  sub r4, r4, #16
   108c8: e59d1040  ldr r1, [sp, #64] ; 0x40
   108cc: e3540010  cmp r4, #16
   108d0: e59d2044  ldr r2, [sp, #68] ; 0x44
   108d4: e2810001  add r0, r1, #1
   108d8: caffffe3  bgt 1086c <_vfiprintf_r+0xb0c>
   108dc: e3500007  cmp r0, #7
   108e0: e0822004  add r2, r2, r4
   108e4: e58a5000  str r5, [sl]
   108e8: e58d2044  str r2, [sp, #68] ; 0x44
   108ec: e58a4004  str r4, [sl, #4]
   108f0: e58d0040  str r0, [sp, #64] ; 0x40
   108f4: da000008  ble 1091c <_vfiprintf_r+0xbbc>
   108f8: e3520000  cmp r2, #0
   108fc: 0a000033  beq 109d0 <_vfiprintf_r+0xc70>
   10900: e59d000c  ldr r0, [sp, #12]
   10904: e28d203c  add r2, sp, #60 ; 0x3c
   10908: e59d1004  ldr r1, [sp, #4]
   1090c: ebfffce3  bl  fca0 <__sprint_r.part.0>
   10910: e3500000  cmp r0, #0
   10914: 1a00000f  bne 10958 <_vfiprintf_r+0xbf8>
   10918: e59d2044  ldr r2, [sp, #68] ; 0x44
   1091c: e59d3010  ldr r3, [sp, #16]
   10920: e59d1008  ldr r1, [sp, #8]
   10924: e59d0018  ldr r0, [sp, #24]
   10928: e1510000  cmp r1, r0
   1092c: a0833001  addge r3, r3, r1
   10930: b0833000  addlt r3, r3, r0
   10934: e3520000  cmp r2, #0
   10938: e58d3010  str r3, [sp, #16]
   1093c: 0a00002a  beq 109ec <_vfiprintf_r+0xc8c>
   10940: e59d000c  ldr r0, [sp, #12]
   10944: e28d203c  add r2, sp, #60 ; 0x3c
   10948: e59d1004  ldr r1, [sp, #4]
   1094c: ebfffcd3  bl  fca0 <__sprint_r.part.0>
   10950: e3500000  cmp r0, #0
   10954: 0a000024  beq 109ec <_vfiprintf_r+0xc8c>
   10958: e59d3004  ldr r3, [sp, #4]
   1095c: e1d330bc  ldrh  r3, [r3, #12]
   10960: e3130040  tst r3, #64 ; 0x40
   10964: 1afffdc1  bne 10070 <_vfiprintf_r+0x310>
   10968: e59d0010  ldr r0, [sp, #16]
   1096c: e28dd0b4  add sp, sp, #180  ; 0xb4
   10970: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   10974: e59d000c  ldr r0, [sp, #12]
   10978: e28d203c  add r2, sp, #60 ; 0x3c
   1097c: e59d1004  ldr r1, [sp, #4]
   10980: ebfffcc6  bl  fca0 <__sprint_r.part.0>
   10984: e3500000  cmp r0, #0
   10988: 1afffff2  bne 10958 <_vfiprintf_r+0xbf8>
   1098c: e59d0040  ldr r0, [sp, #64] ; 0x40
   10990: e1a0a00b  mov sl, fp
   10994: e59d2044  ldr r2, [sp, #68] ; 0x44
   10998: e2800001  add r0, r0, #1
   1099c: e59d3024  ldr r3, [sp, #36] ; 0x24
   109a0: e3500007  cmp r0, #7
   109a4: e0822006  add r2, r2, r6
   109a8: e58a6004  str r6, [sl, #4]
   109ac: e58d2044  str r2, [sp, #68] ; 0x44
   109b0: e58a3000  str r3, [sl]
   109b4: e58d0040  str r0, [sp, #64] ; 0x40
   109b8: daffff97  ble 1081c <_vfiprintf_r+0xabc>
   109bc: e3520000  cmp r2, #0
   109c0: 1a000089  bne 10bec <_vfiprintf_r+0xe8c>
   109c4: e3180004  tst r8, #4
   109c8: e58d2040  str r2, [sp, #64] ; 0x40
   109cc: 1a000076  bne 10bac <_vfiprintf_r+0xe4c>
   109d0: e59d3010  ldr r3, [sp, #16]
   109d4: e59d2008  ldr r2, [sp, #8]
   109d8: e59d1018  ldr r1, [sp, #24]
   109dc: e1520001  cmp r2, r1
   109e0: a0833002  addge r3, r3, r2
   109e4: b0833001  addlt r3, r3, r1
   109e8: e58d3010  str r3, [sp, #16]
   109ec: e3a03000  mov r3, #0
   109f0: e1a0a00b  mov sl, fp
   109f4: e58d3040  str r3, [sp, #64] ; 0x40
   109f8: eafffd01  b fe04 <_vfiprintf_r+0xa4>
   109fc: e3520000  cmp r2, #0
   10a00: 1a000008  bne 10a28 <_vfiprintf_r+0xcc8>
   10a04: e3180001  tst r8, #1
   10a08: 0a000005  beq 10a24 <_vfiprintf_r+0xcc4>
   10a0c: e28d30b0  add r3, sp, #176  ; 0xb0
   10a10: e3a02030  mov r2, #48 ; 0x30
   10a14: e5632041  strb  r2, [r3, #-65]! ; 0xffffffbf
   10a18: e063600b  rsb r6, r3, fp
   10a1c: e58d3024  str r3, [sp, #36] ; 0x24
   10a20: eafffdbe  b 10120 <_vfiprintf_r+0x3c0>
   10a24: e1a06002  mov r6, r2
   10a28: e58db024  str fp, [sp, #36] ; 0x24
   10a2c: eafffdbb  b 10120 <_vfiprintf_r+0x3c0>
   10a30: e59d3018  ldr r3, [sp, #24]
   10a34: e59dc008  ldr ip, [sp, #8]
   10a38: e06c4003  rsb r4, ip, r3
   10a3c: e3540000  cmp r4, #0
   10a40: daffff3a  ble 10730 <_vfiprintf_r+0x9d0>
   10a44: e3540010  cmp r4, #16
   10a48: e59f54d8  ldr r5, [pc, #1240] ; 10f28 <_vfiprintf_r+0x11c8>
   10a4c: da000127  ble 10ef0 <_vfiprintf_r+0x1190>
   10a50: e3a09010  mov r9, #16
   10a54: ea000002  b 10a64 <_vfiprintf_r+0xd04>
   10a58: e2444010  sub r4, r4, #16
   10a5c: e3540010  cmp r4, #16
   10a60: da00001b  ble 10ad4 <_vfiprintf_r+0xd74>
   10a64: e2810001  add r0, r1, #1
   10a68: e2822010  add r2, r2, #16
   10a6c: e3500007  cmp r0, #7
   10a70: e58a5000  str r5, [sl]
   10a74: e281c002  add ip, r1, #2
   10a78: e58a9004  str r9, [sl, #4]
   10a7c: e58d2044  str r2, [sp, #68] ; 0x44
   10a80: e1a01000  mov r1, r0
   10a84: e58d0040  str r0, [sp, #64] ; 0x40
   10a88: d28aa008  addle sl, sl, #8
   10a8c: dafffff1  ble 10a58 <_vfiprintf_r+0xcf8>
   10a90: e3520000  cmp r2, #0
   10a94: e3a0c001  mov ip, #1
   10a98: e1a01002  mov r1, r2
   10a9c: e1a0a00b  mov sl, fp
   10aa0: 0affffec  beq 10a58 <_vfiprintf_r+0xcf8>
   10aa4: e59d000c  ldr r0, [sp, #12]
   10aa8: e28d203c  add r2, sp, #60 ; 0x3c
   10aac: e59d1004  ldr r1, [sp, #4]
   10ab0: ebfffc7a  bl  fca0 <__sprint_r.part.0>
   10ab4: e3500000  cmp r0, #0
   10ab8: 1affffa6  bne 10958 <_vfiprintf_r+0xbf8>
   10abc: e2444010  sub r4, r4, #16
   10ac0: e59d1040  ldr r1, [sp, #64] ; 0x40
   10ac4: e3540010  cmp r4, #16
   10ac8: e59d2044  ldr r2, [sp, #68] ; 0x44
   10acc: e281c001  add ip, r1, #1
   10ad0: caffffe3  bgt 10a64 <_vfiprintf_r+0xd04>
   10ad4: e35c0007  cmp ip, #7
   10ad8: e0822004  add r2, r2, r4
   10adc: e58a5000  str r5, [sl]
   10ae0: e58d2044  str r2, [sp, #68] ; 0x44
   10ae4: e58a4004  str r4, [sl, #4]
   10ae8: e58dc040  str ip, [sp, #64] ; 0x40
   10aec: ca000083  bgt 10d00 <_vfiprintf_r+0xfa0>
   10af0: e28aa008  add sl, sl, #8
   10af4: e28c0001  add r0, ip, #1
   10af8: e1a0100c  mov r1, ip
   10afc: eaffff0b  b 10730 <_vfiprintf_r+0x9d0>
   10b00: e3520000  cmp r2, #0
   10b04: 1a000065  bne 10ca0 <_vfiprintf_r+0xf40>
   10b08: e3530000  cmp r3, #0
   10b0c: 0a00005f  beq 10c90 <_vfiprintf_r+0xf30>
   10b10: e3a02002  mov r2, #2
   10b14: e28d3038  add r3, sp, #56 ; 0x38
   10b18: e1a00001  mov r0, r1
   10b1c: e58d2074  str r2, [sp, #116]  ; 0x74
   10b20: e58d3070  str r3, [sp, #112]  ; 0x70
   10b24: e1a0a00b  mov sl, fp
   10b28: eafffefa  b 10718 <_vfiprintf_r+0x9b8>
   10b2c: e3520000  cmp r2, #0
   10b30: 1a000067  bne 10cd4 <_vfiprintf_r+0xf74>
   10b34: e3a00001  mov r0, #1
   10b38: e1a01002  mov r1, r2
   10b3c: e1a0a00b  mov sl, fp
   10b40: eafffef7  b 10724 <_vfiprintf_r+0x9c4>
   10b44: e1a0200b  mov r2, fp
   10b48: e2043007  and r3, r4, #7
   10b4c: e1a041a4  lsr r4, r4, #3
   10b50: e1844e85  orr r4, r4, r5, lsl #29
   10b54: e1a051a5  lsr r5, r5, #3
   10b58: e1941005  orrs  r1, r4, r5
   10b5c: e2833030  add r3, r3, #48 ; 0x30
   10b60: e5623001  strb  r3, [r2, #-1]!
   10b64: 1afffff7  bne 10b48 <_vfiprintf_r+0xde8>
   10b68: e3180001  tst r8, #1
   10b6c: e58d2024  str r2, [sp, #36] ; 0x24
   10b70: 01a03002  moveq r3, r2
   10b74: 0063600b  rsbeq r6, r3, fp
   10b78: 0afffd68  beq 10120 <_vfiprintf_r+0x3c0>
   10b7c: e3530030  cmp r3, #48 ; 0x30
   10b80: e59d3024  ldr r3, [sp, #36] ; 0x24
   10b84: 0afffd64  beq 1011c <_vfiprintf_r+0x3bc>
   10b88: e2433001  sub r3, r3, #1
   10b8c: e58d3024  str r3, [sp, #36] ; 0x24
   10b90: e1a01003  mov r1, r3
   10b94: e3a03030  mov r3, #48 ; 0x30
   10b98: e061600b  rsb r6, r1, fp
   10b9c: e5423001  strb  r3, [r2, #-1]
   10ba0: eafffd5e  b 10120 <_vfiprintf_r+0x3c0>
   10ba4: e3a02002  mov r2, #2
   10ba8: eafffd3f  b 100ac <_vfiprintf_r+0x34c>
   10bac: e59d3018  ldr r3, [sp, #24]
   10bb0: e1a0a00b  mov sl, fp
   10bb4: e59d1008  ldr r1, [sp, #8]
   10bb8: e0614003  rsb r4, r1, r3
   10bbc: e3540000  cmp r4, #0
   10bc0: caffff1d  bgt 1083c <_vfiprintf_r+0xadc>
   10bc4: eaffff81  b 109d0 <_vfiprintf_r+0xc70>
   10bc8: e3550000  cmp r5, #0
   10bcc: 03540009  cmpeq r4, #9
   10bd0: 8a000050  bhi 10d18 <_vfiprintf_r+0xfb8>
   10bd4: e28d30b0  add r3, sp, #176  ; 0xb0
   10bd8: e2844030  add r4, r4, #48 ; 0x30
   10bdc: e5634041  strb  r4, [r3, #-65]! ; 0xffffffbf
   10be0: e063600b  rsb r6, r3, fp
   10be4: e58d3024  str r3, [sp, #36] ; 0x24
   10be8: eafffd4c  b 10120 <_vfiprintf_r+0x3c0>
   10bec: e59d000c  ldr r0, [sp, #12]
   10bf0: e28d203c  add r2, sp, #60 ; 0x3c
   10bf4: e59d1004  ldr r1, [sp, #4]
   10bf8: ebfffc28  bl  fca0 <__sprint_r.part.0>
   10bfc: e3500000  cmp r0, #0
   10c00: 1affff54  bne 10958 <_vfiprintf_r+0xbf8>
   10c04: e59d2044  ldr r2, [sp, #68] ; 0x44
   10c08: e1a0a00b  mov sl, fp
   10c0c: eaffff03  b 10820 <_vfiprintf_r+0xac0>
   10c10: e5924000  ldr r4, [r2]
   10c14: e3a05000  mov r5, #0
   10c18: e2822004  add r2, r2, #4
   10c1c: e58d201c  str r2, [sp, #28]
   10c20: eafffdd6  b 10380 <_vfiprintf_r+0x620>
   10c24: e59d301c  ldr r3, [sp, #28]
   10c28: e3a05000  mov r5, #0
   10c2c: e2833004  add r3, r3, #4
   10c30: e5134004  ldr r4, [r3, #-4]
   10c34: e58d301c  str r3, [sp, #28]
   10c38: eafffd1b  b 100ac <_vfiprintf_r+0x34c>
   10c3c: e5934000  ldr r4, [r3]
   10c40: e2833004  add r3, r3, #4
   10c44: e58d301c  str r3, [sp, #28]
   10c48: e1a05fc4  asr r5, r4, #31
   10c4c: e1a02004  mov r2, r4
   10c50: e1a03005  mov r3, r5
   10c54: eafffe07  b 10478 <_vfiprintf_r+0x718>
   10c58: e5934000  ldr r4, [r3]
   10c5c: e3a02001  mov r2, #1
   10c60: e2833004  add r3, r3, #4
   10c64: e3a05000  mov r5, #0
   10c68: e58d301c  str r3, [sp, #28]
   10c6c: eafffd0e  b 100ac <_vfiprintf_r+0x34c>
   10c70: e59d000c  ldr r0, [sp, #12]
   10c74: e28d203c  add r2, sp, #60 ; 0x3c
   10c78: e59d1004  ldr r1, [sp, #4]
   10c7c: ebfffc07  bl  fca0 <__sprint_r.part.0>
   10c80: e3500000  cmp r0, #0
   10c84: 1affff33  bne 10958 <_vfiprintf_r+0xbf8>
   10c88: e1a0a00b  mov sl, fp
   10c8c: eafffc72  b fe5c <_vfiprintf_r+0xfc>
   10c90: e1a00001  mov r0, r1
   10c94: e1a0a00b  mov sl, fp
   10c98: e1a01002  mov r1, r2
   10c9c: eafffea0  b 10724 <_vfiprintf_r+0x9c4>
   10ca0: e59d000c  ldr r0, [sp, #12]
   10ca4: e28d203c  add r2, sp, #60 ; 0x3c
   10ca8: e59d1004  ldr r1, [sp, #4]
   10cac: e58d302c  str r3, [sp, #44] ; 0x2c
   10cb0: ebfffbfa  bl  fca0 <__sprint_r.part.0>
   10cb4: e3500000  cmp r0, #0
   10cb8: 1affff26  bne 10958 <_vfiprintf_r+0xbf8>
   10cbc: e59d1040  ldr r1, [sp, #64] ; 0x40
   10cc0: e1a0a00b  mov sl, fp
   10cc4: e59d2044  ldr r2, [sp, #68] ; 0x44
   10cc8: e2810001  add r0, r1, #1
   10ccc: e59d302c  ldr r3, [sp, #44] ; 0x2c
   10cd0: eafffe86  b 106f0 <_vfiprintf_r+0x990>
   10cd4: e59d000c  ldr r0, [sp, #12]
   10cd8: e28d203c  add r2, sp, #60 ; 0x3c
   10cdc: e59d1004  ldr r1, [sp, #4]
   10ce0: ebfffbee  bl  fca0 <__sprint_r.part.0>
   10ce4: e3500000  cmp r0, #0
   10ce8: 1affff1a  bne 10958 <_vfiprintf_r+0xbf8>
   10cec: e59d1040  ldr r1, [sp, #64] ; 0x40
   10cf0: e1a0a00b  mov sl, fp
   10cf4: e59d2044  ldr r2, [sp, #68] ; 0x44
   10cf8: e2810001  add r0, r1, #1
   10cfc: eafffe88  b 10724 <_vfiprintf_r+0x9c4>
   10d00: e3520000  cmp r2, #0
   10d04: 1a00005a  bne 10e74 <_vfiprintf_r+0x1114>
   10d08: e3a00001  mov r0, #1
   10d0c: e1a01002  mov r1, r2
   10d10: e1a0a00b  mov sl, fp
   10d14: eafffe85  b 10730 <_vfiprintf_r+0x9d0>
   10d18: e1a0600b  mov r6, fp
   10d1c: e1a00004  mov r0, r4
   10d20: e1a01005  mov r1, r5
   10d24: e3a0200a  mov r2, #10
   10d28: e3a03000  mov r3, #0
   10d2c: eb0006ee  bl  128ec <__aeabi_uldivmod>
   10d30: e1a00004  mov r0, r4
   10d34: e1a01005  mov r1, r5
   10d38: e3a03000  mov r3, #0
   10d3c: e2822030  add r2, r2, #48 ; 0x30
   10d40: e5662001  strb  r2, [r6, #-1]!
   10d44: e3a0200a  mov r2, #10
   10d48: eb0006e7  bl  128ec <__aeabi_uldivmod>
   10d4c: e1a04000  mov r4, r0
   10d50: e1a05001  mov r5, r1
   10d54: e1943005  orrs  r3, r4, r5
   10d58: 1affffef  bne 10d1c <_vfiprintf_r+0xfbc>
   10d5c: e1a03006  mov r3, r6
   10d60: eafffcec  b 10118 <_vfiprintf_r+0x3b8>
   10d64: e2744000  rsbs  r4, r4, #0
   10d68: e3a0902d  mov r9, #45 ; 0x2d
   10d6c: e2e55000  rsc r5, r5, #0
   10d70: e5cd9037  strb  r9, [sp, #55] ; 0x37
   10d74: e58d6014  str r6, [sp, #20]
   10d78: e3a02001  mov r2, #1
   10d7c: eafffccd  b 100b8 <_vfiprintf_r+0x358>
   10d80: e3530000  cmp r3, #0
   10d84: e1a01002  mov r1, r2
   10d88: e3a00001  mov r0, #1
   10d8c: e1a0a00b  mov sl, fp
   10d90: 0afffe66  beq 10730 <_vfiprintf_r+0x9d0>
   10d94: e3a02002  mov r2, #2
   10d98: e28d3038  add r3, sp, #56 ; 0x38
   10d9c: e58b2004  str r2, [fp, #4]
   10da0: e58b3000  str r3, [fp]
   10da4: eafffe5b  b 10718 <_vfiprintf_r+0x9b8>
   10da8: e3180010  tst r8, #16
   10dac: 1a000008  bne 10dd4 <_vfiprintf_r+0x1074>
   10db0: e3180040  tst r8, #64 ; 0x40
   10db4: 0a000006  beq 10dd4 <_vfiprintf_r+0x1074>
   10db8: e59d201c  ldr r2, [sp, #28]
   10dbc: e2822004  add r2, r2, #4
   10dc0: e5123004  ldr r3, [r2, #-4]
   10dc4: e58d201c  str r2, [sp, #28]
   10dc8: e1dd21b0  ldrh  r2, [sp, #16]
   10dcc: e1c320b0  strh  r2, [r3]
   10dd0: eafffc0b  b fe04 <_vfiprintf_r+0xa4>
   10dd4: e59d201c  ldr r2, [sp, #28]
   10dd8: e2822004  add r2, r2, #4
   10ddc: e5123004  ldr r3, [r2, #-4]
   10de0: e58d201c  str r2, [sp, #28]
   10de4: e59d2010  ldr r2, [sp, #16]
   10de8: e5832000  str r2, [r3]
   10dec: eafffc04  b fe04 <_vfiprintf_r+0xa4>
   10df0: e59d000c  ldr r0, [sp, #12]
   10df4: e28d203c  add r2, sp, #60 ; 0x3c
   10df8: e59d1004  ldr r1, [sp, #4]
   10dfc: e58d302c  str r3, [sp, #44] ; 0x2c
   10e00: ebfffba6  bl  fca0 <__sprint_r.part.0>
   10e04: e3500000  cmp r0, #0
   10e08: 1afffed2  bne 10958 <_vfiprintf_r+0xbf8>
   10e0c: e59d1040  ldr r1, [sp, #64] ; 0x40
   10e10: e1a0a00b  mov sl, fp
   10e14: e59d2044  ldr r2, [sp, #68] ; 0x44
   10e18: e2810001  add r0, r1, #1
   10e1c: e59d302c  ldr r3, [sp, #44] ; 0x2c
   10e20: eafffe23  b 106b4 <_vfiprintf_r+0x954>
   10e24: e59d3044  ldr r3, [sp, #68] ; 0x44
   10e28: e3530000  cmp r3, #0
   10e2c: 0afffec9  beq 10958 <_vfiprintf_r+0xbf8>
   10e30: e59d000c  ldr r0, [sp, #12]
   10e34: e28d203c  add r2, sp, #60 ; 0x3c
   10e38: e59d1004  ldr r1, [sp, #4]
   10e3c: ebfffb97  bl  fca0 <__sprint_r.part.0>
   10e40: eafffec4  b 10958 <_vfiprintf_r+0xbf8>
   10e44: e26cc000  rsb ip, ip, #0
   10e48: e58d301c  str r3, [sp, #28]
   10e4c: e1a00007  mov r0, r7
   10e50: eafffd04  b 10268 <_vfiprintf_r+0x508>
   10e54: e59d0024  ldr r0, [sp, #36] ; 0x24
   10e58: e58d501c  str r5, [sp, #28]
   10e5c: faffe3e7  blx 9e00 <strlen>
   10e60: e3a03000  mov r3, #0
   10e64: e5dd9037  ldrb  r9, [sp, #55] ; 0x37
   10e68: e58d3014  str r3, [sp, #20]
   10e6c: e1a06000  mov r6, r0
   10e70: eafffcaa  b 10120 <_vfiprintf_r+0x3c0>
   10e74: e59d000c  ldr r0, [sp, #12]
   10e78: e28d203c  add r2, sp, #60 ; 0x3c
   10e7c: e59d1004  ldr r1, [sp, #4]
   10e80: ebfffb86  bl  fca0 <__sprint_r.part.0>
   10e84: e3500000  cmp r0, #0
   10e88: 1afffeb2  bne 10958 <_vfiprintf_r+0xbf8>
   10e8c: e59d1040  ldr r1, [sp, #64] ; 0x40
   10e90: e1a0a00b  mov sl, fp
   10e94: e59d2044  ldr r2, [sp, #68] ; 0x44
   10e98: e2810001  add r0, r1, #1
   10e9c: eafffe23  b 10730 <_vfiprintf_r+0x9d0>
   10ea0: e59d1040  ldr r1, [sp, #64] ; 0x40
   10ea4: e30856c8  movw  r5, #34504  ; 0x86c8
   10ea8: e3405001  movt  r5, #1
   10eac: e59d2044  ldr r2, [sp, #68] ; 0x44
   10eb0: e2811001  add r1, r1, #1
   10eb4: eafffcd5  b 10210 <_vfiprintf_r+0x4b0>
   10eb8: e3560006  cmp r6, #6
   10ebc: e3083760  movw  r3, #34656  ; 0x8760
   10ec0: e3403001  movt  r3, #1
   10ec4: e58d501c  str r5, [sp, #28]
   10ec8: 23a06006  movcs r6, #6
   10ecc: e58d3024  str r3, [sp, #36] ; 0x24
   10ed0: e1c63fc6  bic r3, r6, r6, asr #31
   10ed4: e58d3008  str r3, [sp, #8]
   10ed8: eafffd57  b 1043c <_vfiprintf_r+0x6dc>
   10edc: e59d0040  ldr r0, [sp, #64] ; 0x40
   10ee0: e30856c8  movw  r5, #34504  ; 0x86c8
   10ee4: e3405001  movt  r5, #1
   10ee8: e2800001  add r0, r0, #1
   10eec: eafffe7a  b 108dc <_vfiprintf_r+0xb7c>
   10ef0: e1a0c000  mov ip, r0
   10ef4: eafffef6  b 10ad4 <_vfiprintf_r+0xd74>
   10ef8: e5dd9037  ldrb  r9, [sp, #55] ; 0x37
   10efc: e58d501c  str r5, [sp, #28]
   10f00: e58d0014  str r0, [sp, #20]
   10f04: eafffc85  b 10120 <_vfiprintf_r+0x3c0>
   10f08: e59d301c  ldr r3, [sp, #28]
   10f0c: e2832004  add r2, r3, #4
   10f10: e58d201c  str r2, [sp, #28]
   10f14: e5936000  ldr r6, [r3]
   10f18: e5d73001  ldrb  r3, [r7, #1]
   10f1c: e3560000  cmp r6, #0
   10f20: aafffbda  bge fe90 <_vfiprintf_r+0x130>
   10f24: eafffbd8  b fe8c <_vfiprintf_r+0x12c>
   10f28: 000186d8  .word 0x000186d8

00010f2c <vfiprintf>:
   10f2c: e30bc390  movw  ip, #45968  ; 0xb390
   10f30: e1a03002  mov r3, r2
   10f34: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
   10f38: e340c001  movt  ip, #1
   10f3c: e1a0e001  mov lr, r1
   10f40: e1a01000  mov r1, r0
   10f44: e1a0200e  mov r2, lr
   10f48: e59c0000  ldr r0, [ip]
   10f4c: e49de004  pop {lr}    ; (ldr lr, [sp], #4)
   10f50: eafffb82  b fd60 <_vfiprintf_r>

00010f54 <__sbprintf>:
   10f54: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
   10f58: e1a04001  mov r4, r1
   10f5c: e24dde46  sub sp, sp, #1120 ; 0x460
   10f60: e1d470be  ldrh  r7, [r4, #14]
   10f64: e24dd008  sub sp, sp, #8
   10f68: e5949064  ldr r9, [r4, #100]  ; 0x64
   10f6c: e594a01c  ldr sl, [r4, #28]
   10f70: e28d6068  add r6, sp, #104  ; 0x68
   10f74: e5948024  ldr r8, [r4, #36] ; 0x24
   10f78: e1a0100d  mov r1, sp
   10f7c: e1d4c0bc  ldrh  ip, [r4, #12]
   10f80: e3a0eb01  mov lr, #1024 ; 0x400
   10f84: e1cd70be  strh  r7, [sp, #14]
   10f88: e3a07000  mov r7, #0
   10f8c: e3ccc002  bic ip, ip, #2
   10f90: e58d9064  str r9, [sp, #100]  ; 0x64
   10f94: e58d6000  str r6, [sp]
   10f98: e1a09000  mov r9, r0
   10f9c: e58d6010  str r6, [sp, #16]
   10fa0: e1cdc0bc  strh  ip, [sp, #12]
   10fa4: e58da01c  str sl, [sp, #28]
   10fa8: e58d8024  str r8, [sp, #36] ; 0x24
   10fac: e58de008  str lr, [sp, #8]
   10fb0: e58de014  str lr, [sp, #20]
   10fb4: e58d7018  str r7, [sp, #24]
   10fb8: ebfffb68  bl  fd60 <_vfiprintf_r>
   10fbc: e2506000  subs  r6, r0, #0
   10fc0: ba000004  blt 10fd8 <__sbprintf+0x84>
   10fc4: e1a00009  mov r0, r9
   10fc8: e1a0100d  mov r1, sp
   10fcc: ebfff200  bl  d7d4 <_fflush_r>
   10fd0: e1500007  cmp r0, r7
   10fd4: 13e06000  mvnne r6, #0
   10fd8: e1dd30bc  ldrh  r3, [sp, #12]
   10fdc: e1a00006  mov r0, r6
   10fe0: e3130040  tst r3, #64 ; 0x40
   10fe4: 11d430bc  ldrhne  r3, [r4, #12]
   10fe8: 13833040  orrne r3, r3, #64 ; 0x40
   10fec: 11c430bc  strhne  r3, [r4, #12]
   10ff0: e28dde46  add sp, sp, #1120 ; 0x460
   10ff4: e28dd008  add sp, sp, #8
   10ff8: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}

00010ffc <_write_r>:
   10ffc: e92d4038  push  {r3, r4, r5, lr}
   11000: e3024aec  movw  r4, #10988  ; 0x2aec
   11004: e1a05000  mov r5, r0
   11008: e3404002  movt  r4, #2
   1100c: e1a00001  mov r0, r1
   11010: e1a01002  mov r1, r2
   11014: e1a02003  mov r2, r3
   11018: e3a03000  mov r3, #0
   1101c: e5843000  str r3, [r4]
   11020: eb000582  bl  12630 <_write>
   11024: e3700001  cmn r0, #1
   11028: 18bd8038  popne {r3, r4, r5, pc}
   1102c: e5943000  ldr r3, [r4]
   11030: e3530000  cmp r3, #0
   11034: 15853000  strne r3, [r5]
   11038: e8bd8038  pop {r3, r4, r5, pc}

0001103c <__register_exitproc>:
   1103c: e308c57c  movw  ip, #34172  ; 0x857c
   11040: e340c001  movt  ip, #1
   11044: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   11048: e1a07003  mov r7, r3
   1104c: e59c4000  ldr r4, [ip]
   11050: e1a05000  mov r5, r0
   11054: e1a06001  mov r6, r1
   11058: e1a08002  mov r8, r2
   1105c: e594c148  ldr ip, [r4, #328]  ; 0x148
   11060: e35c0000  cmp ip, #0
   11064: 0284cf53  addeq ip, r4, #332  ; 0x14c
   11068: 0584c148  streq ip, [r4, #328]  ; 0x148
   1106c: e59ce004  ldr lr, [ip, #4]
   11070: e35e001f  cmp lr, #31
   11074: d28e3001  addle r3, lr, #1
   11078: da000010  ble 110c0 <__register_exitproc+0x84>
   1107c: e3003000  movw  r3, #0
   11080: e3403000  movt  r3, #0
   11084: e3530000  cmp r3, #0
   11088: 0a00001f  beq 1110c <__register_exitproc+0xd0>
   1108c: e3a00e19  mov r0, #400  ; 0x190
   11090: e320f000  nop {0}
   11094: e250c000  subs  ip, r0, #0
   11098: 0a00001b  beq 1110c <__register_exitproc+0xd0>
   1109c: e5942148  ldr r2, [r4, #328]  ; 0x148
   110a0: e3a01000  mov r1, #0
   110a4: e1a0e001  mov lr, r1
   110a8: e3a03001  mov r3, #1
   110ac: e58c1004  str r1, [ip, #4]
   110b0: e58c2000  str r2, [ip]
   110b4: e584c148  str ip, [r4, #328]  ; 0x148
   110b8: e58c1188  str r1, [ip, #392]  ; 0x188
   110bc: e58c118c  str r1, [ip, #396]  ; 0x18c
   110c0: e3550000  cmp r5, #0
   110c4: 0a00000b  beq 110f8 <__register_exitproc+0xbc>
   110c8: e08c010e  add r0, ip, lr, lsl #2
   110cc: e3550002  cmp r5, #2
   110d0: e3a02001  mov r2, #1
   110d4: e5808088  str r8, [r0, #136]  ; 0x88
   110d8: e1a02e12  lsl r2, r2, lr
   110dc: e59c1188  ldr r1, [ip, #392]  ; 0x188
   110e0: e1811002  orr r1, r1, r2
   110e4: e58c1188  str r1, [ip, #392]  ; 0x188
   110e8: e5807108  str r7, [r0, #264]  ; 0x108
   110ec: 059c118c  ldreq r1, [ip, #396]  ; 0x18c
   110f0: 01812002  orreq r2, r1, r2
   110f4: 058c218c  streq r2, [ip, #396]  ; 0x18c
   110f8: e28ee002  add lr, lr, #2
   110fc: e58c3004  str r3, [ip, #4]
   11100: e3a00000  mov r0, #0
   11104: e78c610e  str r6, [ip, lr, lsl #2]
   11108: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   1110c: e3e00000  mvn r0, #0
   11110: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

00011114 <_calloc_r>:
   11114: e92d4010  push  {r4, lr}
   11118: e0010192  mul r1, r2, r1
   1111c: ebfff44e  bl  e25c <_malloc_r>
   11120: e2504000  subs  r4, r0, #0
   11124: 0a00000b  beq 11158 <_calloc_r+0x44>
   11128: e5142004  ldr r2, [r4, #-4]
   1112c: e3c22003  bic r2, r2, #3
   11130: e2422004  sub r2, r2, #4
   11134: e3520024  cmp r2, #36 ; 0x24
   11138: 8a000016  bhi 11198 <_calloc_r+0x84>
   1113c: e3520013  cmp r2, #19
   11140: 91a03004  movls r3, r4
   11144: 8a000005  bhi 11160 <_calloc_r+0x4c>
   11148: e3a02000  mov r2, #0
   1114c: e5832000  str r2, [r3]
   11150: e5832004  str r2, [r3, #4]
   11154: e5832008  str r2, [r3, #8]
   11158: e1a00004  mov r0, r4
   1115c: e8bd8010  pop {r4, pc}
   11160: e352001b  cmp r2, #27
   11164: e3a01000  mov r1, #0
   11168: 92843008  addls r3, r4, #8
   1116c: e5841000  str r1, [r4]
   11170: e5841004  str r1, [r4, #4]
   11174: 9afffff3  bls 11148 <_calloc_r+0x34>
   11178: e3520024  cmp r2, #36 ; 0x24
   1117c: e5841008  str r1, [r4, #8]
   11180: e584100c  str r1, [r4, #12]
   11184: 12843010  addne r3, r4, #16
   11188: 05841010  streq r1, [r4, #16]
   1118c: 02843018  addeq r3, r4, #24
   11190: 05841014  streq r1, [r4, #20]
   11194: eaffffeb  b 11148 <_calloc_r+0x34>
   11198: e3a01000  mov r1, #0
   1119c: ebfff637  bl  ea80 <memset>
   111a0: e1a00004  mov r0, r4
   111a4: e8bd8010  pop {r4, pc}

000111a8 <_close_r>:
   111a8: e92d4038  push  {r3, r4, r5, lr}
   111ac: e3024aec  movw  r4, #10988  ; 0x2aec
   111b0: e1a05000  mov r5, r0
   111b4: e3404002  movt  r4, #2
   111b8: e1a00001  mov r0, r1
   111bc: e3a03000  mov r3, #0
   111c0: e5843000  str r3, [r4]
   111c4: eb0004bf  bl  124c8 <_close>
   111c8: e3700001  cmn r0, #1
   111cc: 18bd8038  popne {r3, r4, r5, pc}
   111d0: e5943000  ldr r3, [r4]
   111d4: e3530000  cmp r3, #0
   111d8: 15853000  strne r3, [r5]
   111dc: e8bd8038  pop {r3, r4, r5, pc}

000111e0 <_fclose_r>:
   111e0: e3510000  cmp r1, #0
   111e4: 0a000038  beq 112cc <_fclose_r+0xec>
   111e8: e3500000  cmp r0, #0
   111ec: e92d4070  push  {r4, r5, r6, lr}
   111f0: e1a06000  mov r6, r0
   111f4: e1a04001  mov r4, r1
   111f8: 0a000002  beq 11208 <_fclose_r+0x28>
   111fc: e5903038  ldr r3, [r0, #56] ; 0x38
   11200: e3530000  cmp r3, #0
   11204: 0a00002a  beq 112b4 <_fclose_r+0xd4>
   11208: e1d430fc  ldrsh r3, [r4, #12]
   1120c: e3530000  cmp r3, #0
   11210: 1a000001  bne 1121c <_fclose_r+0x3c>
   11214: e3a00000  mov r0, #0
   11218: e8bd8070  pop {r4, r5, r6, pc}
   1121c: e1a00006  mov r0, r6
   11220: e1a01004  mov r1, r4
   11224: ebfff0db  bl  d598 <__sflush_r>
   11228: e594302c  ldr r3, [r4, #44] ; 0x2c
   1122c: e3530000  cmp r3, #0
   11230: e1a05000  mov r5, r0
   11234: 0a000004  beq 1124c <_fclose_r+0x6c>
   11238: e1a00006  mov r0, r6
   1123c: e594101c  ldr r1, [r4, #28]
   11240: e12fff33  blx r3
   11244: e3500000  cmp r0, #0
   11248: b3e05000  mvnlt r5, #0
   1124c: e1d430bc  ldrh  r3, [r4, #12]
   11250: e3130080  tst r3, #128  ; 0x80
   11254: 1a000018  bne 112bc <_fclose_r+0xdc>
   11258: e5941030  ldr r1, [r4, #48] ; 0x30
   1125c: e3510000  cmp r1, #0
   11260: 0a000006  beq 11280 <_fclose_r+0xa0>
   11264: e2843040  add r3, r4, #64 ; 0x40
   11268: e1510003  cmp r1, r3
   1126c: 0a000001  beq 11278 <_fclose_r+0x98>
   11270: e1a00006  mov r0, r6
   11274: ebfff27a  bl  dc64 <_free_r>
   11278: e3a03000  mov r3, #0
   1127c: e5843030  str r3, [r4, #48] ; 0x30
   11280: e5941044  ldr r1, [r4, #68] ; 0x44
   11284: e3510000  cmp r1, #0
   11288: 0a000003  beq 1129c <_fclose_r+0xbc>
   1128c: e1a00006  mov r0, r6
   11290: ebfff273  bl  dc64 <_free_r>
   11294: e3a03000  mov r3, #0
   11298: e5843044  str r3, [r4, #68] ; 0x44
   1129c: ebfff221  bl  db28 <__sfp_lock_acquire>
   112a0: e3a03000  mov r3, #0
   112a4: e1c430bc  strh  r3, [r4, #12]
   112a8: ebfff21f  bl  db2c <__sfp_lock_release>
   112ac: e1a00005  mov r0, r5
   112b0: e8bd8070  pop {r4, r5, r6, pc}
   112b4: ebfff217  bl  db18 <__sinit>
   112b8: eaffffd2  b 11208 <_fclose_r+0x28>
   112bc: e1a00006  mov r0, r6
   112c0: e5941010  ldr r1, [r4, #16]
   112c4: ebfff266  bl  dc64 <_free_r>
   112c8: eaffffe2  b 11258 <_fclose_r+0x78>
   112cc: e3a00000  mov r0, #0
   112d0: e12fff1e  bx  lr

000112d4 <fclose>:
   112d4: e30b3390  movw  r3, #45968  ; 0xb390
   112d8: e1a01000  mov r1, r0
   112dc: e3403001  movt  r3, #1
   112e0: e5930000  ldr r0, [r3]
   112e4: eaffffbd  b 111e0 <_fclose_r>

000112e8 <_fputwc_r>:
   112e8: e1d230bc  ldrh  r3, [r2, #12]
   112ec: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   112f0: e3130a02  tst r3, #8192 ; 0x2000
   112f4: e1a04002  mov r4, r2
   112f8: 03833a02  orreq r3, r3, #8192 ; 0x2000
   112fc: 05922064  ldreq r2, [r2, #100]  ; 0x64
   11300: e24dd008  sub sp, sp, #8
   11304: 01c430bc  strheq  r3, [r4, #12]
   11308: e1a07000  mov r7, r0
   1130c: 03823a02  orreq r3, r2, #8192 ; 0x2000
   11310: 05843064  streq r3, [r4, #100]  ; 0x64
   11314: e1a06001  mov r6, r1
   11318: ebfff35e  bl  e098 <__locale_mb_cur_max>
   1131c: e3500001  cmp r0, #1
   11320: 0a000036  beq 11400 <_fputwc_r+0x118>
   11324: e1a00007  mov r0, r7
   11328: e28d1004  add r1, sp, #4
   1132c: e1a02006  mov r2, r6
   11330: e284305c  add r3, r4, #92 ; 0x5c
   11334: eb0003ef  bl  122f8 <_wcrtomb_r>
   11338: e3700001  cmn r0, #1
   1133c: e1a08000  mov r8, r0
   11340: 0a000029  beq 113ec <_fputwc_r+0x104>
   11344: e3500000  cmp r0, #0
   11348: 15dd1004  ldrbne  r1, [sp, #4]
   1134c: 0a000032  beq 1141c <_fputwc_r+0x134>
   11350: e3a05000  mov r5, #0
   11354: ea000009  b 11380 <_fputwc_r+0x98>
   11358: e5943000  ldr r3, [r4]
   1135c: e5c31000  strb  r1, [r3]
   11360: e5943000  ldr r3, [r4]
   11364: e2833001  add r3, r3, #1
   11368: e5843000  str r3, [r4]
   1136c: e2855001  add r5, r5, #1
   11370: e1580005  cmp r8, r5
   11374: 9a000028  bls 1141c <_fputwc_r+0x134>
   11378: e28d3004  add r3, sp, #4
   1137c: e7d31005  ldrb  r1, [r3, r5]
   11380: e5943008  ldr r3, [r4, #8]
   11384: e2433001  sub r3, r3, #1
   11388: e5843008  str r3, [r4, #8]
   1138c: e3530000  cmp r3, #0
   11390: aafffff0  bge 11358 <_fputwc_r+0x70>
   11394: e5942018  ldr r2, [r4, #24]
   11398: e1530002  cmp r3, r2
   1139c: ba000007  blt 113c0 <_fputwc_r+0xd8>
   113a0: e5943000  ldr r3, [r4]
   113a4: e5c31000  strb  r1, [r3]
   113a8: e5943000  ldr r3, [r4]
   113ac: e2832001  add r2, r3, #1
   113b0: e5d31000  ldrb  r1, [r3]
   113b4: e351000a  cmp r1, #10
   113b8: 15842000  strne r2, [r4]
   113bc: 1affffea  bne 1136c <_fputwc_r+0x84>
   113c0: e1a00007  mov r0, r7
   113c4: e1a02004  mov r2, r4
   113c8: eb00037b  bl  121bc <__swbuf_r>
   113cc: e3700001  cmn r0, #1
   113d0: 13a00000  movne r0, #0
   113d4: 03a00001  moveq r0, #1
   113d8: e3500000  cmp r0, #0
   113dc: 0affffe2  beq 1136c <_fputwc_r+0x84>
   113e0: e3e00000  mvn r0, #0
   113e4: e28dd008  add sp, sp, #8
   113e8: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   113ec: e1d430bc  ldrh  r3, [r4, #12]
   113f0: e3833040  orr r3, r3, #64 ; 0x40
   113f4: e1c430bc  strh  r3, [r4, #12]
   113f8: e28dd008  add sp, sp, #8
   113fc: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   11400: e2463001  sub r3, r6, #1
   11404: e35300fe  cmp r3, #254  ; 0xfe
   11408: 8affffc5  bhi 11324 <_fputwc_r+0x3c>
   1140c: e6ef1076  uxtb  r1, r6
   11410: e1a08000  mov r8, r0
   11414: e5cd1004  strb  r1, [sp, #4]
   11418: eaffffcc  b 11350 <_fputwc_r+0x68>
   1141c: e1a00006  mov r0, r6
   11420: e28dd008  add sp, sp, #8
   11424: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

00011428 <fputwc>:
   11428: e30b3390  movw  r3, #45968  ; 0xb390
   1142c: e3403001  movt  r3, #1
   11430: e92d4070  push  {r4, r5, r6, lr}
   11434: e1a06000  mov r6, r0
   11438: e5934000  ldr r4, [r3]
   1143c: e1a05001  mov r5, r1
   11440: e3540000  cmp r4, #0
   11444: 0a000004  beq 1145c <fputwc+0x34>
   11448: e5943038  ldr r3, [r4, #56] ; 0x38
   1144c: e3530000  cmp r3, #0
   11450: 1a000001  bne 1145c <fputwc+0x34>
   11454: e1a00004  mov r0, r4
   11458: ebfff1ae  bl  db18 <__sinit>
   1145c: e1a00004  mov r0, r4
   11460: e1a01006  mov r1, r6
   11464: e1a02005  mov r2, r5
   11468: e8bd4070  pop {r4, r5, r6, lr}
   1146c: eaffff9d  b 112e8 <_fputwc_r>

00011470 <_fstat_r>:
   11470: e92d4038  push  {r3, r4, r5, lr}
   11474: e3024aec  movw  r4, #10988  ; 0x2aec
   11478: e1a05000  mov r5, r0
   1147c: e3404002  movt  r4, #2
   11480: e1a00001  mov r0, r1
   11484: e1a01002  mov r1, r2
   11488: e3a03000  mov r3, #0
   1148c: e5843000  str r3, [r4]
   11490: eb00040e  bl  124d0 <_fstat>
   11494: e3700001  cmn r0, #1
   11498: 18bd8038  popne {r3, r4, r5, pc}
   1149c: e5943000  ldr r3, [r4]
   114a0: e3530000  cmp r3, #0
   114a4: 15853000  strne r3, [r5]
   114a8: e8bd8038  pop {r3, r4, r5, pc}

000114ac <__sfvwrite_r>:
   114ac: e5923008  ldr r3, [r2, #8]
   114b0: e3530000  cmp r3, #0
   114b4: 0a000034  beq 1158c <__sfvwrite_r+0xe0>
   114b8: e1d130bc  ldrh  r3, [r1, #12]
   114bc: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   114c0: e3130008  tst r3, #8
   114c4: e24dd00c  sub sp, sp, #12
   114c8: e1a04001  mov r4, r1
   114cc: e1a07002  mov r7, r2
   114d0: e58d0000  str r0, [sp]
   114d4: 0a000021  beq 11560 <__sfvwrite_r+0xb4>
   114d8: e5912010  ldr r2, [r1, #16]
   114dc: e3520000  cmp r2, #0
   114e0: 0a00001e  beq 11560 <__sfvwrite_r+0xb4>
   114e4: e2038002  and r8, r3, #2
   114e8: e5975000  ldr r5, [r7]
   114ec: e6ff0078  uxth  r0, r8
   114f0: e3500000  cmp r0, #0
   114f4: 0a000026  beq 11594 <__sfvwrite_r+0xe8>
   114f8: e3a08000  mov r8, #0
   114fc: e3a09b3f  mov r9, #64512  ; 0xfc00
   11500: e1a06008  mov r6, r8
   11504: e3479fff  movt  r9, #32767  ; 0x7fff
   11508: e3560000  cmp r6, #0
   1150c: e1a02008  mov r2, r8
   11510: e59d0000  ldr r0, [sp]
   11514: 0a000018  beq 1157c <__sfvwrite_r+0xd0>
   11518: e1560009  cmp r6, r9
   1151c: e594a024  ldr sl, [r4, #36] ; 0x24
   11520: e594101c  ldr r1, [r4, #28]
   11524: 31a03006  movcc r3, r6
   11528: 21a03009  movcs r3, r9
   1152c: e12fff3a  blx sl
   11530: e3500000  cmp r0, #0
   11534: e0888000  add r8, r8, r0
   11538: e0606006  rsb r6, r0, r6
   1153c: da00003f  ble 11640 <__sfvwrite_r+0x194>
   11540: e5973008  ldr r3, [r7, #8]
   11544: e0600003  rsb r0, r0, r3
   11548: e5870008  str r0, [r7, #8]
   1154c: e3500000  cmp r0, #0
   11550: 1affffec  bne 11508 <__sfvwrite_r+0x5c>
   11554: e3a00000  mov r0, #0
   11558: e28dd00c  add sp, sp, #12
   1155c: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11560: e59d0000  ldr r0, [sp]
   11564: e1a01004  mov r1, r4
   11568: ebffea4a  bl  be98 <__swsetup_r>
   1156c: e3500000  cmp r0, #0
   11570: 1a0000f0  bne 11938 <__sfvwrite_r+0x48c>
   11574: e1d430bc  ldrh  r3, [r4, #12]
   11578: eaffffd9  b 114e4 <__sfvwrite_r+0x38>
   1157c: e5958000  ldr r8, [r5]
   11580: e2855008  add r5, r5, #8
   11584: e5156004  ldr r6, [r5, #-4]
   11588: eaffffde  b 11508 <__sfvwrite_r+0x5c>
   1158c: e3a00000  mov r0, #0
   11590: e12fff1e  bx  lr
   11594: e2138001  ands  r8, r3, #1
   11598: 1a00002e  bne 11658 <__sfvwrite_r+0x1ac>
   1159c: e1a06008  mov r6, r8
   115a0: e3560000  cmp r6, #0
   115a4: 0a00001c  beq 1161c <__sfvwrite_r+0x170>
   115a8: e3130c02  tst r3, #512  ; 0x200
   115ac: e5949008  ldr r9, [r4, #8]
   115b0: 0a00005a  beq 11720 <__sfvwrite_r+0x274>
   115b4: e1560009  cmp r6, r9
   115b8: e1a0a009  mov sl, r9
   115bc: 3a00007e  bcc 117bc <__sfvwrite_r+0x310>
   115c0: e3130d12  tst r3, #1152 ; 0x480
   115c4: 1a00008b  bne 117f8 <__sfvwrite_r+0x34c>
   115c8: e5940000  ldr r0, [r4]
   115cc: e1a0200a  mov r2, sl
   115d0: e1a01008  mov r1, r8
   115d4: eb0000fc  bl  119cc <memmove>
   115d8: e5943008  ldr r3, [r4, #8]
   115dc: e5942000  ldr r2, [r4]
   115e0: e1a00006  mov r0, r6
   115e4: e0699003  rsb r9, r9, r3
   115e8: e5849008  str r9, [r4, #8]
   115ec: e082200a  add r2, r2, sl
   115f0: e5842000  str r2, [r4]
   115f4: e5973008  ldr r3, [r7, #8]
   115f8: e0888000  add r8, r8, r0
   115fc: e0606006  rsb r6, r0, r6
   11600: e0600003  rsb r0, r0, r3
   11604: e5870008  str r0, [r7, #8]
   11608: e3500000  cmp r0, #0
   1160c: 0affffd0  beq 11554 <__sfvwrite_r+0xa8>
   11610: e3560000  cmp r6, #0
   11614: e1d430bc  ldrh  r3, [r4, #12]
   11618: 1affffe2  bne 115a8 <__sfvwrite_r+0xfc>
   1161c: e5958000  ldr r8, [r5]
   11620: e2855008  add r5, r5, #8
   11624: e5156004  ldr r6, [r5, #-4]
   11628: eaffffdc  b 115a0 <__sfvwrite_r+0xf4>
   1162c: e59d0000  ldr r0, [sp]
   11630: e1a01004  mov r1, r4
   11634: ebfff066  bl  d7d4 <_fflush_r>
   11638: e3500000  cmp r0, #0
   1163c: 0a00004b  beq 11770 <__sfvwrite_r+0x2c4>
   11640: e1d430bc  ldrh  r3, [r4, #12]
   11644: e3833040  orr r3, r3, #64 ; 0x40
   11648: e3e00000  mvn r0, #0
   1164c: e1c430bc  strh  r3, [r4, #12]
   11650: e28dd00c  add sp, sp, #12
   11654: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11658: e1a08000  mov r8, r0
   1165c: e1a0b000  mov fp, r0
   11660: e1a0a000  mov sl, r0
   11664: e1a09000  mov r9, r0
   11668: e3590000  cmp r9, #0
   1166c: 0a000026  beq 1170c <__sfvwrite_r+0x260>
   11670: e35b0000  cmp fp, #0
   11674: 0a000054  beq 117cc <__sfvwrite_r+0x320>
   11678: e5941014  ldr r1, [r4, #20]
   1167c: e1580009  cmp r8, r9
   11680: e5943008  ldr r3, [r4, #8]
   11684: 31a02008  movcc r2, r8
   11688: 21a02009  movcs r2, r9
   1168c: e0813003  add r3, r1, r3
   11690: e5940000  ldr r0, [r4]
   11694: e1520003  cmp r2, r3
   11698: e594e010  ldr lr, [r4, #16]
   1169c: e1a06002  mov r6, r2
   116a0: d3a0c000  movle ip, #0
   116a4: c3a0c001  movgt ip, #1
   116a8: e150000e  cmp r0, lr
   116ac: 93a0c000  movls ip, #0
   116b0: e35c0000  cmp ip, #0
   116b4: 1a000081  bne 118c0 <__sfvwrite_r+0x414>
   116b8: e1520001  cmp r2, r1
   116bc: ba00002d  blt 11778 <__sfvwrite_r+0x2cc>
   116c0: e1a03001  mov r3, r1
   116c4: e5946024  ldr r6, [r4, #36] ; 0x24
   116c8: e59d0000  ldr r0, [sp]
   116cc: e1a0200a  mov r2, sl
   116d0: e594101c  ldr r1, [r4, #28]
   116d4: e12fff36  blx r6
   116d8: e2506000  subs  r6, r0, #0
   116dc: daffffd7  ble 11640 <__sfvwrite_r+0x194>
   116e0: e0588006  subs  r8, r8, r6
   116e4: 0a00002d  beq 117a0 <__sfvwrite_r+0x2f4>
   116e8: e5973008  ldr r3, [r7, #8]
   116ec: e08aa006  add sl, sl, r6
   116f0: e0669009  rsb r9, r6, r9
   116f4: e0666003  rsb r6, r6, r3
   116f8: e5876008  str r6, [r7, #8]
   116fc: e3560000  cmp r6, #0
   11700: 0affff93  beq 11554 <__sfvwrite_r+0xa8>
   11704: e3590000  cmp r9, #0
   11708: 1affffd8  bne 11670 <__sfvwrite_r+0x1c4>
   1170c: e595a000  ldr sl, [r5]
   11710: e3a0b000  mov fp, #0
   11714: e5959004  ldr r9, [r5, #4]
   11718: e2855008  add r5, r5, #8
   1171c: eaffffd1  b 11668 <__sfvwrite_r+0x1bc>
   11720: e5940000  ldr r0, [r4]
   11724: e5943010  ldr r3, [r4, #16]
   11728: e1500003  cmp r0, r3
   1172c: 8a000002  bhi 1173c <__sfvwrite_r+0x290>
   11730: e594a014  ldr sl, [r4, #20]
   11734: e156000a  cmp r6, sl
   11738: 2a000052  bcs 11888 <__sfvwrite_r+0x3dc>
   1173c: e1560009  cmp r6, r9
   11740: e1a01008  mov r1, r8
   11744: 31a09006  movcc r9, r6
   11748: e1a02009  mov r2, r9
   1174c: eb00009e  bl  119cc <memmove>
   11750: e5943008  ldr r3, [r4, #8]
   11754: e5942000  ldr r2, [r4]
   11758: e0693003  rsb r3, r9, r3
   1175c: e5843008  str r3, [r4, #8]
   11760: e3530000  cmp r3, #0
   11764: e0823009  add r3, r2, r9
   11768: e5843000  str r3, [r4]
   1176c: 0affffae  beq 1162c <__sfvwrite_r+0x180>
   11770: e1a00009  mov r0, r9
   11774: eaffff9e  b 115f4 <__sfvwrite_r+0x148>
   11778: e1a0100a  mov r1, sl
   1177c: eb000092  bl  119cc <memmove>
   11780: e5942008  ldr r2, [r4, #8]
   11784: e5943000  ldr r3, [r4]
   11788: e0588006  subs  r8, r8, r6
   1178c: e0662002  rsb r2, r6, r2
   11790: e5842008  str r2, [r4, #8]
   11794: e0833006  add r3, r3, r6
   11798: e5843000  str r3, [r4]
   1179c: 1affffd1  bne 116e8 <__sfvwrite_r+0x23c>
   117a0: e59d0000  ldr r0, [sp]
   117a4: e1a01004  mov r1, r4
   117a8: ebfff009  bl  d7d4 <_fflush_r>
   117ac: e3500000  cmp r0, #0
   117b0: 1affffa2  bne 11640 <__sfvwrite_r+0x194>
   117b4: e1a0b008  mov fp, r8
   117b8: eaffffca  b 116e8 <__sfvwrite_r+0x23c>
   117bc: e5940000  ldr r0, [r4]
   117c0: e1a09006  mov r9, r6
   117c4: e1a0a006  mov sl, r6
   117c8: eaffff7f  b 115cc <__sfvwrite_r+0x120>
   117cc: e1a0000a  mov r0, sl
   117d0: e3a0100a  mov r1, #10
   117d4: e1a02009  mov r2, r9
   117d8: fafff480  blx e9e0 <memchr>
   117dc: e3500000  cmp r0, #0
   117e0: 12800001  addne r0, r0, #1
   117e4: 02898001  addeq r8, r9, #1
   117e8: 13a0b001  movne fp, #1
   117ec: 106a8000  rsbne r8, sl, r0
   117f0: 03a0b001  moveq fp, #1
   117f4: eaffff9f  b 11678 <__sfvwrite_r+0x1cc>
   117f8: e594a014  ldr sl, [r4, #20]
   117fc: e5941010  ldr r1, [r4, #16]
   11800: e5949000  ldr r9, [r4]
   11804: e08aa08a  add sl, sl, sl, lsl #1
   11808: e0619009  rsb r9, r1, r9
   1180c: e08aafaa  add sl, sl, sl, lsr #31
   11810: e2890001  add r0, r9, #1
   11814: e0800006  add r0, r0, r6
   11818: e1a0a0ca  asr sl, sl, #1
   1181c: e15a0000  cmp sl, r0
   11820: e1a0200a  mov r2, sl
   11824: 31a0a000  movcc sl, r0
   11828: 31a0200a  movcc r2, sl
   1182c: e3130b01  tst r3, #1024 ; 0x400
   11830: 0a000032  beq 11900 <__sfvwrite_r+0x454>
   11834: e1a01002  mov r1, r2
   11838: e59d0000  ldr r0, [sp]
   1183c: ebfff286  bl  e25c <_malloc_r>
   11840: e250b000  subs  fp, r0, #0
   11844: 0a00003d  beq 11940 <__sfvwrite_r+0x494>
   11848: e5941010  ldr r1, [r4, #16]
   1184c: e1a02009  mov r2, r9
   11850: ebffe00a  bl  9880 <memcpy>
   11854: e1d430bc  ldrh  r3, [r4, #12]
   11858: e3c33d12  bic r3, r3, #1152 ; 0x480
   1185c: e3833080  orr r3, r3, #128  ; 0x80
   11860: e1c430bc  strh  r3, [r4, #12]
   11864: e08b0009  add r0, fp, r9
   11868: e584a014  str sl, [r4, #20]
   1186c: e069900a  rsb r9, r9, sl
   11870: e584b010  str fp, [r4, #16]
   11874: e5849008  str r9, [r4, #8]
   11878: e1a0a006  mov sl, r6
   1187c: e5840000  str r0, [r4]
   11880: e1a09006  mov r9, r6
   11884: eaffff50  b 115cc <__sfvwrite_r+0x120>
   11888: e3760106  cmn r6, #-2147483647  ; 0x80000001
   1188c: e1a0100a  mov r1, sl
   11890: 31a00006  movcc r0, r6
   11894: 23e00102  mvncs r0, #-2147483648  ; 0x80000000
   11898: eb000383  bl  126ac <__aeabi_idiv>
   1189c: e5949024  ldr r9, [r4, #36] ; 0x24
   118a0: e594101c  ldr r1, [r4, #28]
   118a4: e1a02008  mov r2, r8
   118a8: e0030a90  mul r3, r0, sl
   118ac: e59d0000  ldr r0, [sp]
   118b0: e12fff39  blx r9
   118b4: e3500000  cmp r0, #0
   118b8: caffff4d  bgt 115f4 <__sfvwrite_r+0x148>
   118bc: eaffff5f  b 11640 <__sfvwrite_r+0x194>
   118c0: e1a02003  mov r2, r3
   118c4: e1a0100a  mov r1, sl
   118c8: e58d3004  str r3, [sp, #4]
   118cc: eb00003e  bl  119cc <memmove>
   118d0: e5942000  ldr r2, [r4]
   118d4: e1a01004  mov r1, r4
   118d8: e59d3004  ldr r3, [sp, #4]
   118dc: e59d0000  ldr r0, [sp]
   118e0: e0822003  add r2, r2, r3
   118e4: e5842000  str r2, [r4]
   118e8: ebffefb9  bl  d7d4 <_fflush_r>
   118ec: e59d3004  ldr r3, [sp, #4]
   118f0: e3500000  cmp r0, #0
   118f4: 1affff51  bne 11640 <__sfvwrite_r+0x194>
   118f8: e1a06003  mov r6, r3
   118fc: eaffff77  b 116e0 <__sfvwrite_r+0x234>
   11900: e59d0000  ldr r0, [sp]
   11904: eb00008b  bl  11b38 <_realloc_r>
   11908: e250b000  subs  fp, r0, #0
   1190c: 1affffd4  bne 11864 <__sfvwrite_r+0x3b8>
   11910: e59d5000  ldr r5, [sp]
   11914: e5941010  ldr r1, [r4, #16]
   11918: e1a00005  mov r0, r5
   1191c: ebfff0d0  bl  dc64 <_free_r>
   11920: e1d430bc  ldrh  r3, [r4, #12]
   11924: e3a0200c  mov r2, #12
   11928: e5852000  str r2, [r5]
   1192c: e3c33080  bic r3, r3, #128  ; 0x80
   11930: e6ff3073  uxth  r3, r3
   11934: eaffff42  b 11644 <__sfvwrite_r+0x198>
   11938: e3e00000  mvn r0, #0
   1193c: eaffff05  b 11558 <__sfvwrite_r+0xac>
   11940: e59d1000  ldr r1, [sp]
   11944: e3a0200c  mov r2, #12
   11948: e1d430bc  ldrh  r3, [r4, #12]
   1194c: e5812000  str r2, [r1]
   11950: eaffff3b  b 11644 <__sfvwrite_r+0x198>

00011954 <_isatty_r>:
   11954: e92d4038  push  {r3, r4, r5, lr}
   11958: e3024aec  movw  r4, #10988  ; 0x2aec
   1195c: e1a05000  mov r5, r0
   11960: e3404002  movt  r4, #2
   11964: e1a00001  mov r0, r1
   11968: e3a03000  mov r3, #0
   1196c: e5843000  str r3, [r4]
   11970: eb0002dc  bl  124e8 <_isatty>
   11974: e3700001  cmn r0, #1
   11978: 18bd8038  popne {r3, r4, r5, pc}
   1197c: e5943000  ldr r3, [r4]
   11980: e3530000  cmp r3, #0
   11984: 15853000  strne r3, [r5]
   11988: e8bd8038  pop {r3, r4, r5, pc}

0001198c <_lseek_r>:
   1198c: e92d4038  push  {r3, r4, r5, lr}
   11990: e3024aec  movw  r4, #10988  ; 0x2aec
   11994: e1a05000  mov r5, r0
   11998: e3404002  movt  r4, #2
   1199c: e1a00001  mov r0, r1
   119a0: e1a01002  mov r1, r2
   119a4: e1a02003  mov r2, r3
   119a8: e3a03000  mov r3, #0
   119ac: e5843000  str r3, [r4]
   119b0: eb0002d4  bl  12508 <_lseek>
   119b4: e3700001  cmn r0, #1
   119b8: 18bd8038  popne {r3, r4, r5, pc}
   119bc: e5943000  ldr r3, [r4]
   119c0: e3530000  cmp r3, #0
   119c4: 15853000  strne r3, [r5]
   119c8: e8bd8038  pop {r3, r4, r5, pc}

000119cc <memmove>:
   119cc: e1500001  cmp r0, r1
   119d0: e92d4070  push  {r4, r5, r6, lr}
   119d4: 9a00000b  bls 11a08 <memmove+0x3c>
   119d8: e0813002  add r3, r1, r2
   119dc: e1500003  cmp r0, r3
   119e0: 2a000008  bcs 11a08 <memmove+0x3c>
   119e4: e3520000  cmp r2, #0
   119e8: e0801002  add r1, r0, r2
   119ec: 08bd8070  popeq {r4, r5, r6, pc}
   119f0: e0622003  rsb r2, r2, r3
   119f4: e573c001  ldrb  ip, [r3, #-1]!
   119f8: e1530002  cmp r3, r2
   119fc: e561c001  strb  ip, [r1, #-1]!
   11a00: 1afffffb  bne 119f4 <memmove+0x28>
   11a04: e8bd8070  pop {r4, r5, r6, pc}
   11a08: e352000f  cmp r2, #15
   11a0c: 8a000009  bhi 11a38 <memmove+0x6c>
   11a10: e1a03000  mov r3, r0
   11a14: e3520000  cmp r2, #0
   11a18: 08bd8070  popeq {r4, r5, r6, pc}
   11a1c: e2433001  sub r3, r3, #1
   11a20: e0812002  add r2, r1, r2
   11a24: e4d1c001  ldrb  ip, [r1], #1
   11a28: e1510002  cmp r1, r2
   11a2c: e5e3c001  strb  ip, [r3, #1]!
   11a30: 1afffffb  bne 11a24 <memmove+0x58>
   11a34: e8bd8070  pop {r4, r5, r6, pc}
   11a38: e1803001  orr r3, r0, r1
   11a3c: e3130003  tst r3, #3
   11a40: 1a000028  bne 11ae8 <memmove+0x11c>
   11a44: e280c010  add ip, r0, #16
   11a48: e2813010  add r3, r1, #16
   11a4c: e1a0e002  mov lr, r2
   11a50: e5134010  ldr r4, [r3, #-16]
   11a54: e24ee010  sub lr, lr, #16
   11a58: e35e000f  cmp lr, #15
   11a5c: e2833010  add r3, r3, #16
   11a60: e28cc010  add ip, ip, #16
   11a64: e50c4020  str r4, [ip, #-32]  ; 0xffffffe0
   11a68: e513401c  ldr r4, [r3, #-28]  ; 0xffffffe4
   11a6c: e50c401c  str r4, [ip, #-28]  ; 0xffffffe4
   11a70: e5134018  ldr r4, [r3, #-24]  ; 0xffffffe8
   11a74: e50c4018  str r4, [ip, #-24]  ; 0xffffffe8
   11a78: e5134014  ldr r4, [r3, #-20]  ; 0xffffffec
   11a7c: e50c4014  str r4, [ip, #-20]  ; 0xffffffec
   11a80: 8afffff2  bhi 11a50 <memmove+0x84>
   11a84: e2423010  sub r3, r2, #16
   11a88: e202600f  and r6, r2, #15
   11a8c: e3c3300f  bic r3, r3, #15
   11a90: e3560003  cmp r6, #3
   11a94: e2833010  add r3, r3, #16
   11a98: e0811003  add r1, r1, r3
   11a9c: e0803003  add r3, r0, r3
   11aa0: 9a000012  bls 11af0 <memmove+0x124>
   11aa4: e2434004  sub r4, r3, #4
   11aa8: e1a0e001  mov lr, r1
   11aac: e1a0c006  mov ip, r6
   11ab0: e24cc004  sub ip, ip, #4
   11ab4: e49e5004  ldr r5, [lr], #4
   11ab8: e35c0003  cmp ip, #3
   11abc: e5a45004  str r5, [r4, #4]!
   11ac0: 8afffffa  bhi 11ab0 <memmove+0xe4>
   11ac4: e246c004  sub ip, r6, #4
   11ac8: e2022003  and r2, r2, #3
   11acc: e3ccc003  bic ip, ip, #3
   11ad0: e3520000  cmp r2, #0
   11ad4: e28cc004  add ip, ip, #4
   11ad8: e083300c  add r3, r3, ip
   11adc: e081100c  add r1, r1, ip
   11ae0: 1affffcd  bne 11a1c <memmove+0x50>
   11ae4: e8bd8070  pop {r4, r5, r6, pc}
   11ae8: e1a03000  mov r3, r0
   11aec: eaffffca  b 11a1c <memmove+0x50>
   11af0: e1a02006  mov r2, r6
   11af4: eaffffc6  b 11a14 <memmove+0x48>

00011af8 <_read_r>:
   11af8: e92d4038  push  {r3, r4, r5, lr}
   11afc: e3024aec  movw  r4, #10988  ; 0x2aec
   11b00: e1a05000  mov r5, r0
   11b04: e3404002  movt  r4, #2
   11b08: e1a00001  mov r0, r1
   11b0c: e1a01002  mov r1, r2
   11b10: e1a02003  mov r2, r3
   11b14: e3a03000  mov r3, #0
   11b18: e5843000  str r3, [r4]
   11b1c: eb000295  bl  12578 <_read>
   11b20: e3700001  cmn r0, #1
   11b24: 18bd8038  popne {r3, r4, r5, pc}
   11b28: e5943000  ldr r3, [r4]
   11b2c: e3530000  cmp r3, #0
   11b30: 15853000  strne r3, [r5]
   11b34: e8bd8038  pop {r3, r4, r5, pc}

00011b38 <_realloc_r>:
   11b38: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11b3c: e2516000  subs  r6, r1, #0
   11b40: e24dd00c  sub sp, sp, #12
   11b44: e1a07002  mov r7, r2
   11b48: 0a0000de  beq 11ec8 <_realloc_r+0x390>
   11b4c: e1a08000  mov r8, r0
   11b50: ebfff407  bl  eb74 <__malloc_lock>
   11b54: e287400b  add r4, r7, #11
   11b58: e5163004  ldr r3, [r6, #-4]
   11b5c: e3540016  cmp r4, #22
   11b60: e2469008  sub r9, r6, #8
   11b64: 83c44007  bichi r4, r4, #7
   11b68: e3c35003  bic r5, r3, #3
   11b6c: 93a02010  movls r2, #16
   11b70: 93a00000  movls r0, #0
   11b74: 81a00fa4  lsrhi r0, r4, #31
   11b78: 81a02004  movhi r2, r4
   11b7c: 91a04002  movls r4, r2
   11b80: e1540007  cmp r4, r7
   11b84: 33800001  orrcc r0, r0, #1
   11b88: e3500000  cmp r0, #0
   11b8c: 13a0300c  movne r3, #12
   11b90: 13a00000  movne r0, #0
   11b94: 15883000  strne r3, [r8]
   11b98: 1a00000f  bne 11bdc <_realloc_r+0xa4>
   11b9c: e1550002  cmp r5, r2
   11ba0: ba00000f  blt 11be4 <_realloc_r+0xac>
   11ba4: e1a07006  mov r7, r6
   11ba8: e0642005  rsb r2, r4, r5
   11bac: e352000f  cmp r2, #15
   11bb0: 8a000085  bhi 11dcc <_realloc_r+0x294>
   11bb4: e0892005  add r2, r9, r5
   11bb8: e2033001  and r3, r3, #1
   11bbc: e1835005  orr r5, r3, r5
   11bc0: e5895004  str r5, [r9, #4]
   11bc4: e5923004  ldr r3, [r2, #4]
   11bc8: e3833001  orr r3, r3, #1
   11bcc: e5823004  str r3, [r2, #4]
   11bd0: e1a00008  mov r0, r8
   11bd4: ebfff3e7  bl  eb78 <__malloc_unlock>
   11bd8: e1a00007  mov r0, r7
   11bdc: e28dd00c  add sp, sp, #12
   11be0: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   11be4: e30bb83c  movw  fp, #47164  ; 0xb83c
   11be8: e0891005  add r1, r9, r5
   11bec: e340b001  movt  fp, #1
   11bf0: e59b0008  ldr r0, [fp, #8]
   11bf4: e1500001  cmp r0, r1
   11bf8: 0a0000bd  beq 11ef4 <_realloc_r+0x3bc>
   11bfc: e591c004  ldr ip, [r1, #4]
   11c00: e3cc0001  bic r0, ip, #1
   11c04: e0810000  add r0, r1, r0
   11c08: e5900004  ldr r0, [r0, #4]
   11c0c: e3100001  tst r0, #1
   11c10: 1a00003a  bne 11d00 <_realloc_r+0x1c8>
   11c14: e3ccc003  bic ip, ip, #3
   11c18: e08cc005  add ip, ip, r5
   11c1c: e15c0002  cmp ip, r2
   11c20: aa0000ac  bge 11ed8 <_realloc_r+0x3a0>
   11c24: e3130001  tst r3, #1
   11c28: 1a000075  bne 11e04 <_realloc_r+0x2cc>
   11c2c: e516a008  ldr sl, [r6, #-8]
   11c30: e06aa009  rsb sl, sl, r9
   11c34: e59a0004  ldr r0, [sl, #4]
   11c38: e3c00003  bic r0, r0, #3
   11c3c: e08cc000  add ip, ip, r0
   11c40: e15c0002  cmp ip, r2
   11c44: ba000033  blt 11d18 <_realloc_r+0x1e0>
   11c48: e591000c  ldr r0, [r1, #12]
   11c4c: e1a0700a  mov r7, sl
   11c50: e5911008  ldr r1, [r1, #8]
   11c54: e2452004  sub r2, r5, #4
   11c58: e3520024  cmp r2, #36 ; 0x24
   11c5c: e581000c  str r0, [r1, #12]
   11c60: e5801008  str r1, [r0, #8]
   11c64: e59a100c  ldr r1, [sl, #12]
   11c68: e5b70008  ldr r0, [r7, #8]!
   11c6c: e580100c  str r1, [r0, #12]
   11c70: e5810008  str r0, [r1, #8]
   11c74: 8a0000fc  bhi 1206c <_realloc_r+0x534>
   11c78: e3520013  cmp r2, #19
   11c7c: 91a02007  movls r2, r7
   11c80: 9a000014  bls 11cd8 <_realloc_r+0x1a0>
   11c84: e5961000  ldr r1, [r6]
   11c88: e352001b  cmp r2, #27
   11c8c: 928a2010  addls r2, sl, #16
   11c90: e58a1008  str r1, [sl, #8]
   11c94: e5961004  ldr r1, [r6, #4]
   11c98: 92866008  addls r6, r6, #8
   11c9c: e58a100c  str r1, [sl, #12]
   11ca0: 9a00000c  bls 11cd8 <_realloc_r+0x1a0>
   11ca4: e5963008  ldr r3, [r6, #8]
   11ca8: e3520024  cmp r2, #36 ; 0x24
   11cac: 128a2018  addne r2, sl, #24
   11cb0: 028a2020  addeq r2, sl, #32
   11cb4: e58a3010  str r3, [sl, #16]
   11cb8: e596300c  ldr r3, [r6, #12]
   11cbc: 12866010  addne r6, r6, #16
   11cc0: e58a3014  str r3, [sl, #20]
   11cc4: 05963010  ldreq r3, [r6, #16]
   11cc8: 058a3018  streq r3, [sl, #24]
   11ccc: 05963014  ldreq r3, [r6, #20]
   11cd0: 02866018  addeq r6, r6, #24
   11cd4: 058a301c  streq r3, [sl, #28]
   11cd8: e5963000  ldr r3, [r6]
   11cdc: e1a0500c  mov r5, ip
   11ce0: e1a0900a  mov r9, sl
   11ce4: e5823000  str r3, [r2]
   11ce8: e5963004  ldr r3, [r6, #4]
   11cec: e5823004  str r3, [r2, #4]
   11cf0: e5963008  ldr r3, [r6, #8]
   11cf4: e5823008  str r3, [r2, #8]
   11cf8: e59a3004  ldr r3, [sl, #4]
   11cfc: eaffffa9  b 11ba8 <_realloc_r+0x70>
   11d00: e3130001  tst r3, #1
   11d04: 1a00003e  bne 11e04 <_realloc_r+0x2cc>
   11d08: e516a008  ldr sl, [r6, #-8]
   11d0c: e06aa009  rsb sl, sl, r9
   11d10: e59a0004  ldr r0, [sl, #4]
   11d14: e3c00003  bic r0, r0, #3
   11d18: e0803005  add r3, r0, r5
   11d1c: e1530002  cmp r3, r2
   11d20: ba000037  blt 11e04 <_realloc_r+0x2cc>
   11d24: e1a0700a  mov r7, sl
   11d28: e59a100c  ldr r1, [sl, #12]
   11d2c: e5b70008  ldr r0, [r7, #8]!
   11d30: e2452004  sub r2, r5, #4
   11d34: e3520024  cmp r2, #36 ; 0x24
   11d38: e580100c  str r1, [r0, #12]
   11d3c: e5810008  str r0, [r1, #8]
   11d40: 8a0000ad  bhi 11ffc <_realloc_r+0x4c4>
   11d44: e3520013  cmp r2, #19
   11d48: 91a01007  movls r1, r7
   11d4c: 9a000014  bls 11da4 <_realloc_r+0x26c>
   11d50: e5961000  ldr r1, [r6]
   11d54: e352001b  cmp r2, #27
   11d58: e58a1008  str r1, [sl, #8]
   11d5c: e5961004  ldr r1, [r6, #4]
   11d60: 92866008  addls r6, r6, #8
   11d64: e58a100c  str r1, [sl, #12]
   11d68: 928a1010  addls r1, sl, #16
   11d6c: 9a00000c  bls 11da4 <_realloc_r+0x26c>
   11d70: e5961008  ldr r1, [r6, #8]
   11d74: e3520024  cmp r2, #36 ; 0x24
   11d78: e58a1010  str r1, [sl, #16]
   11d7c: 128a1018  addne r1, sl, #24
   11d80: e596200c  ldr r2, [r6, #12]
   11d84: 028a1020  addeq r1, sl, #32
   11d88: 12866010  addne r6, r6, #16
   11d8c: e58a2014  str r2, [sl, #20]
   11d90: 05962010  ldreq r2, [r6, #16]
   11d94: 058a2018  streq r2, [sl, #24]
   11d98: 05962014  ldreq r2, [r6, #20]
   11d9c: 02866018  addeq r6, r6, #24
   11da0: 058a201c  streq r2, [sl, #28]
   11da4: e5962000  ldr r2, [r6]
   11da8: e1a05003  mov r5, r3
   11dac: e1a0900a  mov r9, sl
   11db0: e5812000  str r2, [r1]
   11db4: e5963004  ldr r3, [r6, #4]
   11db8: e5813004  str r3, [r1, #4]
   11dbc: e5963008  ldr r3, [r6, #8]
   11dc0: e5813008  str r3, [r1, #8]
   11dc4: e59a3004  ldr r3, [sl, #4]
   11dc8: eaffff76  b 11ba8 <_realloc_r+0x70>
   11dcc: e0891004  add r1, r9, r4
   11dd0: e2033001  and r3, r3, #1
   11dd4: e081c002  add ip, r1, r2
   11dd8: e1834004  orr r4, r3, r4
   11ddc: e3822001  orr r2, r2, #1
   11de0: e5894004  str r4, [r9, #4]
   11de4: e5812004  str r2, [r1, #4]
   11de8: e1a00008  mov r0, r8
   11dec: e59c3004  ldr r3, [ip, #4]
   11df0: e2811008  add r1, r1, #8
   11df4: e3833001  orr r3, r3, #1
   11df8: e58c3004  str r3, [ip, #4]
   11dfc: ebffef98  bl  dc64 <_free_r>
   11e00: eaffff72  b 11bd0 <_realloc_r+0x98>
   11e04: e1a01007  mov r1, r7
   11e08: e1a00008  mov r0, r8
   11e0c: ebfff112  bl  e25c <_malloc_r>
   11e10: e2507000  subs  r7, r0, #0
   11e14: 0affff6d  beq 11bd0 <_realloc_r+0x98>
   11e18: e5163004  ldr r3, [r6, #-4]
   11e1c: e2471008  sub r1, r7, #8
   11e20: e3c32001  bic r2, r3, #1
   11e24: e0892002  add r2, r9, r2
   11e28: e1510002  cmp r1, r2
   11e2c: 0a000089  beq 12058 <_realloc_r+0x520>
   11e30: e2452004  sub r2, r5, #4
   11e34: e3520024  cmp r2, #36 ; 0x24
   11e38: 8a000083  bhi 1204c <_realloc_r+0x514>
   11e3c: e3520013  cmp r2, #19
   11e40: 91a03007  movls r3, r7
   11e44: 91a02006  movls r2, r6
   11e48: 9a000014  bls 11ea0 <_realloc_r+0x368>
   11e4c: e5963000  ldr r3, [r6]
   11e50: e352001b  cmp r2, #27
   11e54: 92862008  addls r2, r6, #8
   11e58: e5873000  str r3, [r7]
   11e5c: e5963004  ldr r3, [r6, #4]
   11e60: e5873004  str r3, [r7, #4]
   11e64: 92873008  addls r3, r7, #8
   11e68: 9a00000c  bls 11ea0 <_realloc_r+0x368>
   11e6c: e5963008  ldr r3, [r6, #8]
   11e70: e3520024  cmp r2, #36 ; 0x24
   11e74: 12862010  addne r2, r6, #16
   11e78: 02862018  addeq r2, r6, #24
   11e7c: e5873008  str r3, [r7, #8]
   11e80: e596300c  ldr r3, [r6, #12]
   11e84: e587300c  str r3, [r7, #12]
   11e88: 12873010  addne r3, r7, #16
   11e8c: 05961010  ldreq r1, [r6, #16]
   11e90: 02873018  addeq r3, r7, #24
   11e94: 05871010  streq r1, [r7, #16]
   11e98: 05961014  ldreq r1, [r6, #20]
   11e9c: 05871014  streq r1, [r7, #20]
   11ea0: e5921000  ldr r1, [r2]
   11ea4: e5831000  str r1, [r3]
   11ea8: e5921004  ldr r1, [r2, #4]
   11eac: e5831004  str r1, [r3, #4]
   11eb0: e5922008  ldr r2, [r2, #8]
   11eb4: e5832008  str r2, [r3, #8]
   11eb8: e1a01006  mov r1, r6
   11ebc: e1a00008  mov r0, r8
   11ec0: ebffef67  bl  dc64 <_free_r>
   11ec4: eaffff41  b 11bd0 <_realloc_r+0x98>
   11ec8: e1a01002  mov r1, r2
   11ecc: e28dd00c  add sp, sp, #12
   11ed0: e8bd4ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   11ed4: eafff0e0  b e25c <_malloc_r>
   11ed8: e591200c  ldr r2, [r1, #12]
   11edc: e1a07006  mov r7, r6
   11ee0: e5911008  ldr r1, [r1, #8]
   11ee4: e1a0500c  mov r5, ip
   11ee8: e581200c  str r2, [r1, #12]
   11eec: e5821008  str r1, [r2, #8]
   11ef0: eaffff2c  b 11ba8 <_realloc_r+0x70>
   11ef4: e5901004  ldr r1, [r0, #4]
   11ef8: e284c010  add ip, r4, #16
   11efc: e3c11003  bic r1, r1, #3
   11f00: e0811005  add r1, r1, r5
   11f04: e151000c  cmp r1, ip
   11f08: aa000042  bge 12018 <_realloc_r+0x4e0>
   11f0c: e3130001  tst r3, #1
   11f10: 1affffbb  bne 11e04 <_realloc_r+0x2cc>
   11f14: e516a008  ldr sl, [r6, #-8]
   11f18: e06aa009  rsb sl, sl, r9
   11f1c: e59a0004  ldr r0, [sl, #4]
   11f20: e3c00003  bic r0, r0, #3
   11f24: e0813000  add r3, r1, r0
   11f28: e15c0003  cmp ip, r3
   11f2c: caffff79  bgt 11d18 <_realloc_r+0x1e0>
   11f30: e1a0700a  mov r7, sl
   11f34: e59a100c  ldr r1, [sl, #12]
   11f38: e5b70008  ldr r0, [r7, #8]!
   11f3c: e2452004  sub r2, r5, #4
   11f40: e3520024  cmp r2, #36 ; 0x24
   11f44: e580100c  str r1, [r0, #12]
   11f48: e5810008  str r0, [r1, #8]
   11f4c: 8a00004d  bhi 12088 <_realloc_r+0x550>
   11f50: e3520013  cmp r2, #19
   11f54: 91a02007  movls r2, r7
   11f58: 9a000014  bls 11fb0 <_realloc_r+0x478>
   11f5c: e5961000  ldr r1, [r6]
   11f60: e352001b  cmp r2, #27
   11f64: 928a2010  addls r2, sl, #16
   11f68: e58a1008  str r1, [sl, #8]
   11f6c: e5961004  ldr r1, [r6, #4]
   11f70: 92866008  addls r6, r6, #8
   11f74: e58a100c  str r1, [sl, #12]
   11f78: 9a00000c  bls 11fb0 <_realloc_r+0x478>
   11f7c: e5961008  ldr r1, [r6, #8]
   11f80: e3520024  cmp r2, #36 ; 0x24
   11f84: e58a1010  str r1, [sl, #16]
   11f88: e596200c  ldr r2, [r6, #12]
   11f8c: 12866010  addne r6, r6, #16
   11f90: e58a2014  str r2, [sl, #20]
   11f94: 128a2018  addne r2, sl, #24
   11f98: 05961010  ldreq r1, [r6, #16]
   11f9c: 028a2020  addeq r2, sl, #32
   11fa0: 058a1018  streq r1, [sl, #24]
   11fa4: 05961014  ldreq r1, [r6, #20]
   11fa8: 02866018  addeq r6, r6, #24
   11fac: 058a101c  streq r1, [sl, #28]
   11fb0: e5961000  ldr r1, [r6]
   11fb4: e5821000  str r1, [r2]
   11fb8: e5961004  ldr r1, [r6, #4]
   11fbc: e5821004  str r1, [r2, #4]
   11fc0: e5961008  ldr r1, [r6, #8]
   11fc4: e5821008  str r1, [r2, #8]
   11fc8: e08a2004  add r2, sl, r4
   11fcc: e0643003  rsb r3, r4, r3
   11fd0: e58b2008  str r2, [fp, #8]
   11fd4: e3833001  orr r3, r3, #1
   11fd8: e5823004  str r3, [r2, #4]
   11fdc: e1a00008  mov r0, r8
   11fe0: e59a3004  ldr r3, [sl, #4]
   11fe4: e2033001  and r3, r3, #1
   11fe8: e1844003  orr r4, r4, r3
   11fec: e58a4004  str r4, [sl, #4]
   11ff0: ebfff2e0  bl  eb78 <__malloc_unlock>
   11ff4: e1a00007  mov r0, r7
   11ff8: eafffef7  b 11bdc <_realloc_r+0xa4>
   11ffc: e1a01006  mov r1, r6
   12000: e1a00007  mov r0, r7
   12004: e1a05003  mov r5, r3
   12008: e1a0900a  mov r9, sl
   1200c: ebfffe6e  bl  119cc <memmove>
   12010: e59a3004  ldr r3, [sl, #4]
   12014: eafffee3  b 11ba8 <_realloc_r+0x70>
   12018: e0899004  add r9, r9, r4
   1201c: e0643001  rsb r3, r4, r1
   12020: e58b9008  str r9, [fp, #8]
   12024: e3833001  orr r3, r3, #1
   12028: e5893004  str r3, [r9, #4]
   1202c: e1a00008  mov r0, r8
   12030: e5163004  ldr r3, [r6, #-4]
   12034: e2033001  and r3, r3, #1
   12038: e1844003  orr r4, r4, r3
   1203c: e5064004  str r4, [r6, #-4]
   12040: ebfff2cc  bl  eb78 <__malloc_unlock>
   12044: e1a00006  mov r0, r6
   12048: eafffee3  b 11bdc <_realloc_r+0xa4>
   1204c: e1a01006  mov r1, r6
   12050: ebfffe5d  bl  119cc <memmove>
   12054: eaffff97  b 11eb8 <_realloc_r+0x380>
   12058: e5172004  ldr r2, [r7, #-4]
   1205c: e1a07006  mov r7, r6
   12060: e3c22003  bic r2, r2, #3
   12064: e0855002  add r5, r5, r2
   12068: eafffece  b 11ba8 <_realloc_r+0x70>
   1206c: e1a01006  mov r1, r6
   12070: e1a00007  mov r0, r7
   12074: e1a0500c  mov r5, ip
   12078: e1a0900a  mov r9, sl
   1207c: ebfffe52  bl  119cc <memmove>
   12080: e59a3004  ldr r3, [sl, #4]
   12084: eafffec7  b 11ba8 <_realloc_r+0x70>
   12088: e1a01006  mov r1, r6
   1208c: e1a00007  mov r0, r7
   12090: e58d3004  str r3, [sp, #4]
   12094: ebfffe4c  bl  119cc <memmove>
   12098: e59d3004  ldr r3, [sp, #4]
   1209c: eaffffc9  b 11fc8 <_realloc_r+0x490>

000120a0 <cleanup_glue>:
   120a0: e92d4038  push  {r3, r4, r5, lr}
   120a4: e1a04001  mov r4, r1
   120a8: e5911000  ldr r1, [r1]
   120ac: e1a05000  mov r5, r0
   120b0: e3510000  cmp r1, #0
   120b4: 0a000000  beq 120bc <cleanup_glue+0x1c>
   120b8: ebfffff8  bl  120a0 <cleanup_glue>
   120bc: e1a00005  mov r0, r5
   120c0: e1a01004  mov r1, r4
   120c4: e8bd4038  pop {r3, r4, r5, lr}
   120c8: eaffeee5  b dc64 <_free_r>

000120cc <_reclaim_reent>:
   120cc: e30b3390  movw  r3, #45968  ; 0xb390
   120d0: e3403001  movt  r3, #1
   120d4: e5933000  ldr r3, [r3]
   120d8: e1500003  cmp r0, r3
   120dc: 012fff1e  bxeq  lr
   120e0: e590304c  ldr r3, [r0, #76] ; 0x4c
   120e4: e92d4070  push  {r4, r5, r6, lr}
   120e8: e3530000  cmp r3, #0
   120ec: e1a05000  mov r5, r0
   120f0: 0a00000f  beq 12134 <_reclaim_reent+0x68>
   120f4: e3a06000  mov r6, #0
   120f8: e7931006  ldr r1, [r3, r6]
   120fc: e3510000  cmp r1, #0
   12100: 0a000005  beq 1211c <_reclaim_reent+0x50>
   12104: e5914000  ldr r4, [r1]
   12108: e1a00005  mov r0, r5
   1210c: ebffeed4  bl  dc64 <_free_r>
   12110: e2541000  subs  r1, r4, #0
   12114: 1afffffa  bne 12104 <_reclaim_reent+0x38>
   12118: e595304c  ldr r3, [r5, #76] ; 0x4c
   1211c: e2866004  add r6, r6, #4
   12120: e3560080  cmp r6, #128  ; 0x80
   12124: 1afffff3  bne 120f8 <_reclaim_reent+0x2c>
   12128: e1a01003  mov r1, r3
   1212c: e1a00005  mov r0, r5
   12130: ebffeecb  bl  dc64 <_free_r>
   12134: e5951040  ldr r1, [r5, #64] ; 0x40
   12138: e3510000  cmp r1, #0
   1213c: 0a000001  beq 12148 <_reclaim_reent+0x7c>
   12140: e1a00005  mov r0, r5
   12144: ebffeec6  bl  dc64 <_free_r>
   12148: e5951148  ldr r1, [r5, #328]  ; 0x148
   1214c: e3510000  cmp r1, #0
   12150: 0a000008  beq 12178 <_reclaim_reent+0xac>
   12154: e2856f53  add r6, r5, #332  ; 0x14c
   12158: e1510006  cmp r1, r6
   1215c: 0a000005  beq 12178 <_reclaim_reent+0xac>
   12160: e5914000  ldr r4, [r1]
   12164: e1a00005  mov r0, r5
   12168: ebffeebd  bl  dc64 <_free_r>
   1216c: e1560004  cmp r6, r4
   12170: e1a01004  mov r1, r4
   12174: 1afffff9  bne 12160 <_reclaim_reent+0x94>
   12178: e5951054  ldr r1, [r5, #84] ; 0x54
   1217c: e3510000  cmp r1, #0
   12180: 0a000001  beq 1218c <_reclaim_reent+0xc0>
   12184: e1a00005  mov r0, r5
   12188: ebffeeb5  bl  dc64 <_free_r>
   1218c: e5953038  ldr r3, [r5, #56] ; 0x38
   12190: e3530000  cmp r3, #0
   12194: 08bd8070  popeq {r4, r5, r6, pc}
   12198: e595303c  ldr r3, [r5, #60] ; 0x3c
   1219c: e1a00005  mov r0, r5
   121a0: e12fff33  blx r3
   121a4: e59512e0  ldr r1, [r5, #736]  ; 0x2e0
   121a8: e3510000  cmp r1, #0
   121ac: 08bd8070  popeq {r4, r5, r6, pc}
   121b0: e1a00005  mov r0, r5
   121b4: e8bd4070  pop {r4, r5, r6, lr}
   121b8: eaffffb8  b 120a0 <cleanup_glue>

000121bc <__swbuf_r>:
   121bc: e92d4070  push  {r4, r5, r6, lr}
   121c0: e2506000  subs  r6, r0, #0
   121c4: e1a05001  mov r5, r1
   121c8: e1a04002  mov r4, r2
   121cc: 0a000002  beq 121dc <__swbuf_r+0x20>
   121d0: e5963038  ldr r3, [r6, #56] ; 0x38
   121d4: e3530000  cmp r3, #0
   121d8: 0a00003e  beq 122d8 <__swbuf_r+0x11c>
   121dc: e1d420bc  ldrh  r2, [r4, #12]
   121e0: e5943018  ldr r3, [r4, #24]
   121e4: e6ffc072  uxth  ip, r2
   121e8: e31c0008  tst ip, #8
   121ec: e5843008  str r3, [r4, #8]
   121f0: 0a000020  beq 12278 <__swbuf_r+0xbc>
   121f4: e5943010  ldr r3, [r4, #16]
   121f8: e3530000  cmp r3, #0
   121fc: 0a00001d  beq 12278 <__swbuf_r+0xbc>
   12200: e31c0a02  tst ip, #8192 ; 0x2000
   12204: e6ef5075  uxtb  r5, r5
   12208: 03822a02  orreq r2, r2, #8192 ; 0x2000
   1220c: 01c420bc  strheq  r2, [r4, #12]
   12210: 05941064  ldreq r1, [r4, #100]  ; 0x64
   12214: 03c12a02  biceq r2, r1, #8192 ; 0x2000
   12218: 05842064  streq r2, [r4, #100]  ; 0x64
   1221c: e5942000  ldr r2, [r4]
   12220: e5941014  ldr r1, [r4, #20]
   12224: e0633002  rsb r3, r3, r2
   12228: e1530001  cmp r3, r1
   1222c: b2833001  addlt r3, r3, #1
   12230: aa000019  bge 1229c <__swbuf_r+0xe0>
   12234: e5941008  ldr r1, [r4, #8]
   12238: e2820001  add r0, r2, #1
   1223c: e5840000  str r0, [r4]
   12240: e2411001  sub r1, r1, #1
   12244: e5841008  str r1, [r4, #8]
   12248: e5c25000  strb  r5, [r2]
   1224c: e5942014  ldr r2, [r4, #20]
   12250: e1520003  cmp r2, r3
   12254: 0a000018  beq 122bc <__swbuf_r+0x100>
   12258: e1d430bc  ldrh  r3, [r4, #12]
   1225c: e355000a  cmp r5, #10
   12260: 13a03000  movne r3, #0
   12264: 02033001  andeq r3, r3, #1
   12268: e3530000  cmp r3, #0
   1226c: 1a000012  bne 122bc <__swbuf_r+0x100>
   12270: e1a00005  mov r0, r5
   12274: e8bd8070  pop {r4, r5, r6, pc}
   12278: e1a00006  mov r0, r6
   1227c: e1a01004  mov r1, r4
   12280: ebffe704  bl  be98 <__swsetup_r>
   12284: e3500000  cmp r0, #0
   12288: 1a000010  bne 122d0 <__swbuf_r+0x114>
   1228c: e1d420bc  ldrh  r2, [r4, #12]
   12290: e5943010  ldr r3, [r4, #16]
   12294: e6ffc072  uxth  ip, r2
   12298: eaffffd8  b 12200 <__swbuf_r+0x44>
   1229c: e1a00006  mov r0, r6
   122a0: e1a01004  mov r1, r4
   122a4: ebffed4a  bl  d7d4 <_fflush_r>
   122a8: e3500000  cmp r0, #0
   122ac: 1a000007  bne 122d0 <__swbuf_r+0x114>
   122b0: e5942000  ldr r2, [r4]
   122b4: e3a03001  mov r3, #1
   122b8: eaffffdd  b 12234 <__swbuf_r+0x78>
   122bc: e1a00006  mov r0, r6
   122c0: e1a01004  mov r1, r4
   122c4: ebffed42  bl  d7d4 <_fflush_r>
   122c8: e3500000  cmp r0, #0
   122cc: 0affffe7  beq 12270 <__swbuf_r+0xb4>
   122d0: e3e00000  mvn r0, #0
   122d4: e8bd8070  pop {r4, r5, r6, pc}
   122d8: ebffee0e  bl  db18 <__sinit>
   122dc: eaffffbe  b 121dc <__swbuf_r+0x20>

000122e0 <__swbuf>:
   122e0: e30b3390  movw  r3, #45968  ; 0xb390
   122e4: e1a02001  mov r2, r1
   122e8: e3403001  movt  r3, #1
   122ec: e1a01000  mov r1, r0
   122f0: e5930000  ldr r0, [r3]
   122f4: eaffffb0  b 121bc <__swbuf_r>

000122f8 <_wcrtomb_r>:
   122f8: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   122fc: e2516000  subs  r6, r1, #0
   12300: e24dd018  sub sp, sp, #24
   12304: e1a04000  mov r4, r0
   12308: e1a05003  mov r5, r3
   1230c: 0a000011  beq 12358 <_wcrtomb_r+0x60>
   12310: e30bcc4c  movw  ip, #48204  ; 0xbc4c
   12314: e1a07002  mov r7, r2
   12318: e340c001  movt  ip, #1
   1231c: e59c8000  ldr r8, [ip]
   12320: ebffef59  bl  e08c <__locale_charset>
   12324: e58d5000  str r5, [sp]
   12328: e1a01006  mov r1, r6
   1232c: e1a02007  mov r2, r7
   12330: e1a03000  mov r3, r0
   12334: e1a00004  mov r0, r4
   12338: e12fff38  blx r8
   1233c: e3700001  cmn r0, #1
   12340: 03a02000  moveq r2, #0
   12344: 03a0308a  moveq r3, #138  ; 0x8a
   12348: 05852000  streq r2, [r5]
   1234c: 05843000  streq r3, [r4]
   12350: e28dd018  add sp, sp, #24
   12354: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   12358: e30b3c4c  movw  r3, #48204  ; 0xbc4c
   1235c: e3403001  movt  r3, #1
   12360: e5937000  ldr r7, [r3]
   12364: ebffef48  bl  e08c <__locale_charset>
   12368: e58d5000  str r5, [sp]
   1236c: e1a02006  mov r2, r6
   12370: e28d100c  add r1, sp, #12
   12374: e1a03000  mov r3, r0
   12378: e1a00004  mov r0, r4
   1237c: e12fff37  blx r7
   12380: eaffffed  b 1233c <_wcrtomb_r+0x44>

00012384 <wcrtomb>:
   12384: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   12388: e30b3390  movw  r3, #45968  ; 0xb390
   1238c: e2506000  subs  r6, r0, #0
   12390: e3403001  movt  r3, #1
   12394: e24dd018  sub sp, sp, #24
   12398: e1a05002  mov r5, r2
   1239c: e5934000  ldr r4, [r3]
   123a0: 0a000011  beq 123ec <wcrtomb+0x68>
   123a4: e30b3c4c  movw  r3, #48204  ; 0xbc4c
   123a8: e1a07001  mov r7, r1
   123ac: e3403001  movt  r3, #1
   123b0: e5938000  ldr r8, [r3]
   123b4: ebffef34  bl  e08c <__locale_charset>
   123b8: e58d5000  str r5, [sp]
   123bc: e1a01006  mov r1, r6
   123c0: e1a02007  mov r2, r7
   123c4: e1a03000  mov r3, r0
   123c8: e1a00004  mov r0, r4
   123cc: e12fff38  blx r8
   123d0: e3700001  cmn r0, #1
   123d4: 03a02000  moveq r2, #0
   123d8: 03a0308a  moveq r3, #138  ; 0x8a
   123dc: 05852000  streq r2, [r5]
   123e0: 05843000  streq r3, [r4]
   123e4: e28dd018  add sp, sp, #24
   123e8: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   123ec: e30b3c4c  movw  r3, #48204  ; 0xbc4c
   123f0: e3403001  movt  r3, #1
   123f4: e5937000  ldr r7, [r3]
   123f8: ebffef23  bl  e08c <__locale_charset>
   123fc: e58d5000  str r5, [sp]
   12400: e1a02006  mov r2, r6
   12404: e28d100c  add r1, sp, #12
   12408: e1a03000  mov r3, r0
   1240c: e1a00004  mov r0, r4
   12410: e12fff37  blx r7
   12414: eaffffed  b 123d0 <wcrtomb+0x4c>

00012418 <__ascii_wctomb>:
   12418: e3510000  cmp r1, #0
   1241c: 0a000005  beq 12438 <__ascii_wctomb+0x20>
   12420: e35200ff  cmp r2, #255  ; 0xff
   12424: 95c12000  strbls  r2, [r1]
   12428: 83e01000  mvnhi r1, #0
   1242c: 93a01001  movls r1, #1
   12430: 83a0308a  movhi r3, #138  ; 0x8a
   12434: 85803000  strhi r3, [r0]
   12438: e1a00001  mov r0, r1
   1243c: e12fff1e  bx  lr

00012440 <_wctomb_r>:
   12440: e30bcc4c  movw  ip, #48204  ; 0xbc4c
   12444: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   12448: e340c001  movt  ip, #1
   1244c: e24dd008  sub sp, sp, #8
   12450: e1a07003  mov r7, r3
   12454: e1a08000  mov r8, r0
   12458: e1a06001  mov r6, r1
   1245c: e1a05002  mov r5, r2
   12460: e59c4000  ldr r4, [ip]
   12464: ebffef08  bl  e08c <__locale_charset>
   12468: e58d7000  str r7, [sp]
   1246c: e1a01006  mov r1, r6
   12470: e1a02005  mov r2, r5
   12474: e1a03000  mov r3, r0
   12478: e1a00008  mov r0, r8
   1247c: e12fff34  blx r4
   12480: e28dd008  add sp, sp, #8
   12484: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

00012488 <_exit>:
__attribute__((weak)) void _exit (sint32 status)
{
  (void)status;
  while (1) {
  ;
  }
   12488: eafffffe  b 12488 <_exit>

0001248c <_sbrk>:
  static u8 *heap = NULL;
  u8 *prev_heap;
  static u8 *HeapEndPtr = (u8 *)&_heap_end;
  caddr_t Status;

  if (heap == NULL) {
   1248c: e3012564  movw  r2, #5476 ; 0x1564
   12490: e302caf0  movw  ip, #10992  ; 0x2af0
   12494: e3402002  movt  r2, #2
   12498: e340c002  movt  ip, #2
   1249c: e5923000  ldr r3, [r2]
  heap += incr;

  if (heap > HeapEndPtr){
    Status = (caddr_t) -1;
  }
  else if (prev_heap != NULL) {
   124a0: e3041af0  movw  r1, #19184  ; 0x4af0
   124a4: e3401002  movt  r1, #2
  static u8 *heap = NULL;
  u8 *prev_heap;
  static u8 *HeapEndPtr = (u8 *)&_heap_end;
  caddr_t Status;

  if (heap == NULL) {
   124a8: e3530000  cmp r3, #0
   124ac: 01a0300c  moveq r3, ip
    heap = (u8 *)&_heap_start;
  }
  prev_heap = heap;

  heap += incr;
   124b0: e0830000  add r0, r3, r0

  if (heap > HeapEndPtr){
    Status = (caddr_t) -1;
  }
  else if (prev_heap != NULL) {
   124b4: e1500001  cmp r0, r1
  if (heap == NULL) {
    heap = (u8 *)&_heap_start;
  }
  prev_heap = heap;

  heap += incr;
   124b8: e5820000  str r0, [r2]
  else {
    Status = (caddr_t) -1;
  }

  return Status;
}
   124bc: 91a00003  movls r0, r3
   124c0: 83e00000  mvnhi r0, #0
   124c4: e12fff1e  bx  lr

000124c8 <_close>:

__attribute__((weak)) s32 _close(s32 fd)
{
  (void)fd;
  return (0);
}
   124c8: e3a00000  mov r0, #0
   124cc: e12fff1e  bx  lr

000124d0 <_fstat>:
 * fstat -- Since we have no file system, we just return an error.
 */
__attribute__((weak)) s32 _fstat(s32 fd, struct stat *buf)
{
  (void)fd;
  buf->st_mode = S_IFCHR; /* Always pretend to be a tty */
   124d0: e3a03a02  mov r3, #8192 ; 0x2000

  return (0);
}
   124d4: e3a00000  mov r0, #0
 * fstat -- Since we have no file system, we just return an error.
 */
__attribute__((weak)) s32 _fstat(s32 fd, struct stat *buf)
{
  (void)fd;
  buf->st_mode = S_IFCHR; /* Always pretend to be a tty */
   124d8: e5813004  str r3, [r1, #4]

  return (0);
}
   124dc: e12fff1e  bx  lr

000124e0 <isatty>:
 */
__attribute__((weak)) sint32 isatty(sint32 fd)
{
  (void)fd;
  return (1);
}
   124e0: e3a00001  mov r0, #1
   124e4: e12fff1e  bx  lr

000124e8 <_isatty>:

__attribute__((weak)) sint32 _isatty(sint32 fd)
{
  (void)fd;
  return (1);
}
   124e8: e3a00001  mov r0, #1
   124ec: e12fff1e  bx  lr

000124f0 <lseek>:
#endif
/*
 * lseek --  Since a serial port is non-seekable, we return an error.
 */
__attribute__((weak)) off_t lseek(s32 fd, off_t offset, s32 whence)
{
   124f0: e92d4008  push  {r3, lr}
  (void)fd;
  (void)offset;
  (void)whence;
  errno = ESPIPE;
   124f4: eb000065  bl  12690 <__errno>
   124f8: e3a0301d  mov r3, #29
   124fc: e5803000  str r3, [r0]
  return ((off_t)-1);
}
   12500: e3e00000  mvn r0, #0
   12504: e8bd8008  pop {r3, pc}

00012508 <_lseek>:

__attribute__((weak)) off_t _lseek(s32 fd, off_t offset, s32 whence)
{
   12508: e92d4008  push  {r3, lr}
  (void)fd;
  (void)offset;
  (void)whence;
  errno = ESPIPE;
   1250c: eb00005f  bl  12690 <__errno>
   12510: e3a0301d  mov r3, #29
   12514: e5803000  str r3, [r0]
  return ((off_t)-1);
}
   12518: e3e00000  mvn r0, #0
   1251c: e8bd8008  pop {r3, pc}

00012520 <read>:
 * read  -- read bytes from the serial port. Ignore fd, since
 *          we only have stdin.
 */
__attribute__((weak)) s32
read (s32 fd, char8* buf, s32 nbytes)
{
   12520: e92d4070  push  {r4, r5, r6, lr}
#ifdef STDIN_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   12524: e2526000  subs  r6, r2, #0
   12528: da000010  ble 12570 <read+0x50>
   1252c: e1a04001  mov r4, r1
   12530: e3a05000  mov r5, #0
  if(LocalBuf != NULL) {
   12534: e3540000  cmp r4, #0
   12538: 0a000007  beq 1255c <read+0x3c>
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
   1253c: e0944005  adds  r4, r4, r5
   12540: 0a000005  beq 1255c <read+0x3c>
      *LocalBuf = inbyte();
   12544: eb000055  bl  126a0 <inbyte>
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
   12548: e350000a  cmp r0, #10
   1254c: 1350000d  cmpne r0, #13
  for (i = 0; i < nbytes; i++) {
  if(LocalBuf != NULL) {
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
      *LocalBuf = inbyte();
   12550: e5c40000  strb  r0, [r4]
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
          break;
    }
  }
  if(LocalBuf != NULL) {
  LocalBuf -= i;
   12554: e0654004  rsb r4, r5, r4
  if(LocalBuf != NULL) {
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
      *LocalBuf = inbyte();
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
   12558: 0a000002  beq 12568 <read+0x48>
#ifdef STDIN_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   1255c: e2855001  add r5, r5, #1
   12560: e1550006  cmp r5, r6
   12564: 1afffff2  bne 12534 <read+0x14>
   12568: e2850001  add r0, r5, #1
   1256c: e8bd8070  pop {r4, r5, r6, pc}
   12570: e3a00001  mov r0, #1
  (void)fd;
  (void)buf;
  (void)nbytes;
  return 0;
#endif
}
   12574: e8bd8070  pop {r4, r5, r6, pc}

00012578 <_read>:

__attribute__((weak)) s32
_read (s32 fd, char8* buf, s32 nbytes)
{
   12578: e92d4070  push  {r4, r5, r6, lr}
#ifdef STDIN_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   1257c: e2526000  subs  r6, r2, #0
   12580: da000010  ble 125c8 <_read+0x50>
   12584: e1a04001  mov r4, r1
   12588: e3a05000  mov r5, #0
  if(LocalBuf != NULL) {
   1258c: e3540000  cmp r4, #0
   12590: 0a000007  beq 125b4 <_read+0x3c>
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
   12594: e0944005  adds  r4, r4, r5
   12598: 0a000005  beq 125b4 <_read+0x3c>
      *LocalBuf = inbyte();
   1259c: eb00003f  bl  126a0 <inbyte>
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
   125a0: e350000a  cmp r0, #10
   125a4: 1350000d  cmpne r0, #13
  for (i = 0; i < nbytes; i++) {
  if(LocalBuf != NULL) {
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
      *LocalBuf = inbyte();
   125a8: e5c40000  strb  r0, [r4]
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
          break;
    }
  }
  if(LocalBuf != NULL) {
  LocalBuf -= i;
   125ac: e0654004  rsb r4, r5, r4
  if(LocalBuf != NULL) {
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
      *LocalBuf = inbyte();
      if ((*LocalBuf == '\n' )|| (*LocalBuf == '\r')) {
   125b0: 0a000002  beq 125c0 <_read+0x48>
#ifdef STDIN_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   125b4: e2855001  add r5, r5, #1
   125b8: e1550006  cmp r5, r6
   125bc: 1afffff2  bne 1258c <_read+0x14>
   125c0: e2850001  add r0, r5, #1
   125c4: e8bd8070  pop {r4, r5, r6, pc}
   125c8: e3a00001  mov r0, #1
  (void)fd;
  (void)buf;
  (void)nbytes;
  return 0;
#endif
}
   125cc: e8bd8070  pop {r4, r5, r6, pc}

000125d0 <write>:
 *          open will only return an error.
 */
__attribute__((weak)) sint32
write (sint32 fd, char8* buf, sint32 nbytes)

{
   125d0: e92d4070  push  {r4, r5, r6, lr}
#ifdef STDOUT_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   125d4: e2526000  subs  r6, r2, #0
   125d8: da000012  ble 12628 <write+0x58>
   125dc: e1a04001  mov r4, r1
   125e0: e3a05000  mov r5, #0
   125e4: ea000004  b 125fc <write+0x2c>
        outbyte ('\r');
      }
      outbyte (*LocalBuf);
  }
  if(LocalBuf != NULL) {
    LocalBuf -= i;
   125e8: e0654004  rsb r4, r5, r4
  }
  if(LocalBuf != NULL) {
      if (*LocalBuf == '\n') {
        outbyte ('\r');
      }
      outbyte (*LocalBuf);
   125ec: ebffdaa3  bl  9080 <outbyte>
#ifdef STDOUT_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   125f0: e2855001  add r5, r5, #1
   125f4: e1550006  cmp r5, r6
   125f8: 0a00000a  beq 12628 <write+0x58>
  if(LocalBuf != NULL) {
   125fc: e3540000  cmp r4, #0
   12600: 0afffffa  beq 125f0 <write+0x20>
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
   12604: e0944005  adds  r4, r4, r5
   12608: 0afffff8  beq 125f0 <write+0x20>
      if (*LocalBuf == '\n') {
   1260c: e5d40000  ldrb  r0, [r4]
   12610: e350000a  cmp r0, #10
   12614: 1afffff3  bne 125e8 <write+0x18>
        outbyte ('\r');
   12618: e3a0000d  mov r0, #13
   1261c: ebffda97  bl  9080 <outbyte>
   12620: e5d40000  ldrb  r0, [r4]
   12624: eaffffef  b 125e8 <write+0x18>
  (void)fd;
  (void)buf;
  (void)nbytes;
  return 0;
#endif
}
   12628: e1a00006  mov r0, r6
   1262c: e8bd8070  pop {r4, r5, r6, pc}

00012630 <_write>:

__attribute__((weak)) sint32
_write (sint32 fd, char8* buf, sint32 nbytes)
{
   12630: e92d4070  push  {r4, r5, r6, lr}
#ifdef STDOUT_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   12634: e2526000  subs  r6, r2, #0
   12638: da000012  ble 12688 <_write+0x58>
   1263c: e1a04001  mov r4, r1
   12640: e3a05000  mov r5, #0
   12644: ea000004  b 1265c <_write+0x2c>
        outbyte ('\r');
      }
      outbyte (*LocalBuf);
  }
  if(LocalBuf != NULL) {
    LocalBuf -= i;
   12648: e0654004  rsb r4, r5, r4
  }
  if(LocalBuf != NULL) {
      if (*LocalBuf == '\n') {
        outbyte ('\r');
      }
      outbyte (*LocalBuf);
   1264c: ebffda8b  bl  9080 <outbyte>
#ifdef STDOUT_BASEADDRESS
  s32 i;
  char8* LocalBuf = buf;

  (void)fd;
  for (i = 0; i < nbytes; i++) {
   12650: e2855001  add r5, r5, #1
   12654: e1550006  cmp r5, r6
   12658: 0a00000a  beq 12688 <_write+0x58>
  if(LocalBuf != NULL) {
   1265c: e3540000  cmp r4, #0
   12660: 0afffffa  beq 12650 <_write+0x20>
    LocalBuf += i;
  }
  if(LocalBuf != NULL) {
   12664: e0944005  adds  r4, r4, r5
   12668: 0afffff8  beq 12650 <_write+0x20>
      if (*LocalBuf == '\n') {
   1266c: e5d40000  ldrb  r0, [r4]
   12670: e350000a  cmp r0, #10
   12674: 1afffff3  bne 12648 <_write+0x18>
        outbyte ('\r');
   12678: e3a0000d  mov r0, #13
   1267c: ebffda7f  bl  9080 <outbyte>
   12680: e5d40000  ldrb  r0, [r4]
   12684: eaffffef  b 12648 <_write+0x18>
  (void)fd;
  (void)buf;
  (void)nbytes;
  return 0;
#endif
}
   12688: e1a00006  mov r0, r6
   1268c: e8bd8070  pop {r4, r5, r6, pc}

00012690 <__errno>:
#endif

__attribute__((weak)) sint32 *
__errno (void)
{
  return &_REENT->_errno;
   12690: e30b3390  movw  r3, #45968  ; 0xb390
   12694: e3403001  movt  r3, #1
}
   12698: e5930000  ldr r0, [r3]
   1269c: e12fff1e  bx  lr

000126a0 <inbyte>:
#ifdef __cplusplus
}
#endif 

char inbyte(void) {
   return XUartPs_RecvByte(STDIN_BASEADDRESS);
   126a0: e3a00a01  mov r0, #4096 ; 0x1000
   126a4: e34e0000  movt  r0, #57344  ; 0xe000
   126a8: eaffda91  b 90f4 <XUartPs_RecvByte>

000126ac <__aeabi_idiv>:
   126ac: e3510000  cmp r1, #0
   126b0: 0a000081  beq 128bc <.divsi3_skip_div0_test+0x208>

000126b4 <.divsi3_skip_div0_test>:
   126b4: e020c001  eor ip, r0, r1
   126b8: 42611000  rsbmi r1, r1, #0
   126bc: e2512001  subs  r2, r1, #1
   126c0: 0a000070  beq 12888 <.divsi3_skip_div0_test+0x1d4>
   126c4: e1b03000  movs  r3, r0
   126c8: 42603000  rsbmi r3, r0, #0
   126cc: e1530001  cmp r3, r1
   126d0: 9a00006f  bls 12894 <.divsi3_skip_div0_test+0x1e0>
   126d4: e1110002  tst r1, r2
   126d8: 0a000071  beq 128a4 <.divsi3_skip_div0_test+0x1f0>
   126dc: e16f2f13  clz r2, r3
   126e0: e16f0f11  clz r0, r1
   126e4: e0402002  sub r2, r0, r2
   126e8: e272201f  rsbs  r2, r2, #31
   126ec: 10822082  addne r2, r2, r2, lsl #1
   126f0: e3a00000  mov r0, #0
   126f4: 108ff102  addne pc, pc, r2, lsl #2
   126f8: e320f000  nop {0}
   126fc: e1530f81  cmp r3, r1, lsl #31
   12700: e0a00000  adc r0, r0, r0
   12704: 20433f81  subcs r3, r3, r1, lsl #31
   12708: e1530f01  cmp r3, r1, lsl #30
   1270c: e0a00000  adc r0, r0, r0
   12710: 20433f01  subcs r3, r3, r1, lsl #30
   12714: e1530e81  cmp r3, r1, lsl #29
   12718: e0a00000  adc r0, r0, r0
   1271c: 20433e81  subcs r3, r3, r1, lsl #29
   12720: e1530e01  cmp r3, r1, lsl #28
   12724: e0a00000  adc r0, r0, r0
   12728: 20433e01  subcs r3, r3, r1, lsl #28
   1272c: e1530d81  cmp r3, r1, lsl #27
   12730: e0a00000  adc r0, r0, r0
   12734: 20433d81  subcs r3, r3, r1, lsl #27
   12738: e1530d01  cmp r3, r1, lsl #26
   1273c: e0a00000  adc r0, r0, r0
   12740: 20433d01  subcs r3, r3, r1, lsl #26
   12744: e1530c81  cmp r3, r1, lsl #25
   12748: e0a00000  adc r0, r0, r0
   1274c: 20433c81  subcs r3, r3, r1, lsl #25
   12750: e1530c01  cmp r3, r1, lsl #24
   12754: e0a00000  adc r0, r0, r0
   12758: 20433c01  subcs r3, r3, r1, lsl #24
   1275c: e1530b81  cmp r3, r1, lsl #23
   12760: e0a00000  adc r0, r0, r0
   12764: 20433b81  subcs r3, r3, r1, lsl #23
   12768: e1530b01  cmp r3, r1, lsl #22
   1276c: e0a00000  adc r0, r0, r0
   12770: 20433b01  subcs r3, r3, r1, lsl #22
   12774: e1530a81  cmp r3, r1, lsl #21
   12778: e0a00000  adc r0, r0, r0
   1277c: 20433a81  subcs r3, r3, r1, lsl #21
   12780: e1530a01  cmp r3, r1, lsl #20
   12784: e0a00000  adc r0, r0, r0
   12788: 20433a01  subcs r3, r3, r1, lsl #20
   1278c: e1530981  cmp r3, r1, lsl #19
   12790: e0a00000  adc r0, r0, r0
   12794: 20433981  subcs r3, r3, r1, lsl #19
   12798: e1530901  cmp r3, r1, lsl #18
   1279c: e0a00000  adc r0, r0, r0
   127a0: 20433901  subcs r3, r3, r1, lsl #18
   127a4: e1530881  cmp r3, r1, lsl #17
   127a8: e0a00000  adc r0, r0, r0
   127ac: 20433881  subcs r3, r3, r1, lsl #17
   127b0: e1530801  cmp r3, r1, lsl #16
   127b4: e0a00000  adc r0, r0, r0
   127b8: 20433801  subcs r3, r3, r1, lsl #16
   127bc: e1530781  cmp r3, r1, lsl #15
   127c0: e0a00000  adc r0, r0, r0
   127c4: 20433781  subcs r3, r3, r1, lsl #15
   127c8: e1530701  cmp r3, r1, lsl #14
   127cc: e0a00000  adc r0, r0, r0
   127d0: 20433701  subcs r3, r3, r1, lsl #14
   127d4: e1530681  cmp r3, r1, lsl #13
   127d8: e0a00000  adc r0, r0, r0
   127dc: 20433681  subcs r3, r3, r1, lsl #13
   127e0: e1530601  cmp r3, r1, lsl #12
   127e4: e0a00000  adc r0, r0, r0
   127e8: 20433601  subcs r3, r3, r1, lsl #12
   127ec: e1530581  cmp r3, r1, lsl #11
   127f0: e0a00000  adc r0, r0, r0
   127f4: 20433581  subcs r3, r3, r1, lsl #11
   127f8: e1530501  cmp r3, r1, lsl #10
   127fc: e0a00000  adc r0, r0, r0
   12800: 20433501  subcs r3, r3, r1, lsl #10
   12804: e1530481  cmp r3, r1, lsl #9
   12808: e0a00000  adc r0, r0, r0
   1280c: 20433481  subcs r3, r3, r1, lsl #9
   12810: e1530401  cmp r3, r1, lsl #8
   12814: e0a00000  adc r0, r0, r0
   12818: 20433401  subcs r3, r3, r1, lsl #8
   1281c: e1530381  cmp r3, r1, lsl #7
   12820: e0a00000  adc r0, r0, r0
   12824: 20433381  subcs r3, r3, r1, lsl #7
   12828: e1530301  cmp r3, r1, lsl #6
   1282c: e0a00000  adc r0, r0, r0
   12830: 20433301  subcs r3, r3, r1, lsl #6
   12834: e1530281  cmp r3, r1, lsl #5
   12838: e0a00000  adc r0, r0, r0
   1283c: 20433281  subcs r3, r3, r1, lsl #5
   12840: e1530201  cmp r3, r1, lsl #4
   12844: e0a00000  adc r0, r0, r0
   12848: 20433201  subcs r3, r3, r1, lsl #4
   1284c: e1530181  cmp r3, r1, lsl #3
   12850: e0a00000  adc r0, r0, r0
   12854: 20433181  subcs r3, r3, r1, lsl #3
   12858: e1530101  cmp r3, r1, lsl #2
   1285c: e0a00000  adc r0, r0, r0
   12860: 20433101  subcs r3, r3, r1, lsl #2
   12864: e1530081  cmp r3, r1, lsl #1
   12868: e0a00000  adc r0, r0, r0
   1286c: 20433081  subcs r3, r3, r1, lsl #1
   12870: e1530001  cmp r3, r1
   12874: e0a00000  adc r0, r0, r0
   12878: 20433001  subcs r3, r3, r1
   1287c: e35c0000  cmp ip, #0
   12880: 42600000  rsbmi r0, r0, #0
   12884: e12fff1e  bx  lr
   12888: e13c0000  teq ip, r0
   1288c: 42600000  rsbmi r0, r0, #0
   12890: e12fff1e  bx  lr
   12894: 33a00000  movcc r0, #0
   12898: 01a00fcc  asreq r0, ip, #31
   1289c: 03800001  orreq r0, r0, #1
   128a0: e12fff1e  bx  lr
   128a4: e16f2f11  clz r2, r1
   128a8: e262201f  rsb r2, r2, #31
   128ac: e35c0000  cmp ip, #0
   128b0: e1a00233  lsr r0, r3, r2
   128b4: 42600000  rsbmi r0, r0, #0
   128b8: e12fff1e  bx  lr
   128bc: e3500000  cmp r0, #0
   128c0: c3e00102  mvngt r0, #-2147483648  ; 0x80000000
   128c4: b3a00102  movlt r0, #-2147483648  ; 0x80000000
   128c8: eaffdabb  b 93bc <__aeabi_idiv0>

000128cc <__aeabi_idivmod>:
   128cc: e3510000  cmp r1, #0
   128d0: 0afffff9  beq 128bc <.divsi3_skip_div0_test+0x208>
   128d4: e92d4003  push  {r0, r1, lr}
   128d8: ebffff75  bl  126b4 <.divsi3_skip_div0_test>
   128dc: e8bd4006  pop {r1, r2, lr}
   128e0: e0030092  mul r3, r2, r0
   128e4: e0411003  sub r1, r1, r3
   128e8: e12fff1e  bx  lr

000128ec <__aeabi_uldivmod>:
   128ec: e3530000  cmp r3, #0
   128f0: 03520000  cmpeq r2, #0
   128f4: 1a000004  bne 1290c <__aeabi_uldivmod+0x20>
   128f8: e3510000  cmp r1, #0
   128fc: 03500000  cmpeq r0, #0
   12900: 13e01000  mvnne r1, #0
   12904: 13e00000  mvnne r0, #0
   12908: eaffdaab  b 93bc <__aeabi_idiv0>
   1290c: e24dd008  sub sp, sp, #8
   12910: e92d6000  push  {sp, lr}
   12914: eb000012  bl  12964 <__gnu_uldivmod_helper>
   12918: e59de004  ldr lr, [sp, #4]
   1291c: e28dd008  add sp, sp, #8
   12920: e8bd000c  pop {r2, r3}
   12924: e12fff1e  bx  lr

00012928 <__gnu_ldivmod_helper>:
   12928: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   1292c: e1a08003  mov r8, r3
   12930: e1a04002  mov r4, r2
   12934: e59d5018  ldr r5, [sp, #24]
   12938: e1a06000  mov r6, r0
   1293c: e1a07001  mov r7, r1
   12940: eb000016  bl  129a0 <__divdi3>
   12944: e0832094  umull r2, r3, r4, r0
   12948: e0040194  mul r4, r4, r1
   1294c: e0244890  mla r4, r0, r8, r4
   12950: e0843003  add r3, r4, r3
   12954: e0566002  subs  r6, r6, r2
   12958: e0c77003  sbc r7, r7, r3
   1295c: e1c560f0  strd  r6, [r5]
   12960: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

00012964 <__gnu_uldivmod_helper>:
   12964: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
   12968: e1a06002  mov r6, r2
   1296c: e1a08000  mov r8, r0
   12970: e1a09001  mov r9, r1
   12974: e1a05003  mov r5, r3
   12978: e59d7020  ldr r7, [sp, #32]
   1297c: eb000071  bl  12b48 <__udivdi3>
   12980: e0030590  mul r3, r0, r5
   12984: e0854690  umull r4, r5, r0, r6
   12988: e0263196  mla r6, r6, r1, r3
   1298c: e0865005  add r5, r6, r5
   12990: e0584004  subs  r4, r8, r4
   12994: e0c95005  sbc r5, r9, r5
   12998: e1c740f0  strd  r4, [r7]
   1299c: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

000129a0 <__divdi3>:
   129a0: e3510000  cmp r1, #0
   129a4: e92d43f0  push  {r4, r5, r6, r7, r8, r9, lr}
   129a8: a3a0c000  movge ip, #0
   129ac: a1a08000  movge r8, r0
   129b0: a1a09001  movge r9, r1
   129b4: ba00005c  blt 12b2c <__divdi3+0x18c>
   129b8: e3530000  cmp r3, #0
   129bc: a1a00002  movge r0, r2
   129c0: a1a01003  movge r1, r3
   129c4: ba000054  blt 12b1c <__divdi3+0x17c>
   129c8: e1590001  cmp r9, r1
   129cc: e1a04008  mov r4, r8
   129d0: 01580000  cmpeq r8, r0
   129d4: e1a05009  mov r5, r9
   129d8: 33a04000  movcc r4, #0
   129dc: 33a05000  movcc r5, #0
   129e0: 3a00003b  bcc 12ad4 <__divdi3+0x134>
   129e4: e3510000  cmp r1, #0
   129e8: 016f3f10  clzeq r3, r0
   129ec: 116f2f11  clzne r2, r1
   129f0: 02832020  addeq r2, r3, #32
   129f4: e3590000  cmp r9, #0
   129f8: 016f3f18  clzeq r3, r8
   129fc: 116f3f19  clzne r3, r9
   12a00: 02833020  addeq r3, r3, #32
   12a04: e0633002  rsb r3, r3, r2
   12a08: e2432020  sub r2, r3, #32
   12a0c: e1a07311  lsl r7, r1, r3
   12a10: e1877210  orr r7, r7, r0, lsl r2
   12a14: e263e020  rsb lr, r3, #32
   12a18: e1877e30  orr r7, r7, r0, lsr lr
   12a1c: e1a06310  lsl r6, r0, r3
   12a20: e1590007  cmp r9, r7
   12a24: e1a02003  mov r2, r3
   12a28: 01580006  cmpeq r8, r6
   12a2c: 2a000032  bcs 12afc <__divdi3+0x15c>
   12a30: f2c00010  vmov.i32  d16, #0 ; 0x00000000
   12a34: e3530000  cmp r3, #0
   12a38: 0c554b30  vmoveq  r4, r5, d16
   12a3c: 0a000024  beq 12ad4 <__divdi3+0x134>
   12a40: e1b010a7  lsrs  r1, r7, #1
   12a44: e1a00066  rrx r0, r6
   12a48: ea000007  b 12a6c <__divdi3+0xcc>
   12a4c: e0544000  subs  r4, r4, r0
   12a50: e0c55001  sbc r5, r5, r1
   12a54: e0944004  adds  r4, r4, r4
   12a58: e0a55005  adc r5, r5, r5
   12a5c: e2944001  adds  r4, r4, #1
   12a60: e2a55000  adc r5, r5, #0
   12a64: e2533001  subs  r3, r3, #1
   12a68: 0a000006  beq 12a88 <__divdi3+0xe8>
   12a6c: e1510005  cmp r1, r5
   12a70: 01500004  cmpeq r0, r4
   12a74: 9afffff4  bls 12a4c <__divdi3+0xac>
   12a78: e0944004  adds  r4, r4, r4
   12a7c: e0a55005  adc r5, r5, r5
   12a80: e2533001  subs  r3, r3, #1
   12a84: 1afffff8  bne 12a6c <__divdi3+0xcc>
   12a88: e1a00234  lsr r0, r4, r2
   12a8c: e2623020  rsb r3, r2, #32
   12a90: e1800315  orr r0, r0, r5, lsl r3
   12a94: e242e020  sub lr, r2, #32
   12a98: e1a01235  lsr r1, r5, r2
   12a9c: e1800e35  orr r0, r0, r5, lsr lr
   12aa0: ee022b90  vmov.32 d18[0], r2
   12aa4: ec410b31  vmov  d17, r0, r1
   12aa8: ec510b30  vmov  r0, r1, d16
   12aac: f37204a1  vshl.u64  d16, d17, d18
   12ab0: ec532b30  vmov  r2, r3, d16
   12ab4: e0900004  adds  r0, r0, r4
   12ab8: e0a11005  adc r1, r1, r5
   12abc: e1a04000  mov r4, r0
   12ac0: e1a05001  mov r5, r1
   12ac4: e0542002  subs  r2, r4, r2
   12ac8: e0c53003  sbc r3, r5, r3
   12acc: e1a04002  mov r4, r2
   12ad0: e1a05003  mov r5, r3
   12ad4: e29c0000  adds  r0, ip, #0
   12ad8: e3a01000  mov r1, #0
   12adc: 13a00001  movne r0, #1
   12ae0: e2702000  rsbs  r2, r0, #0
   12ae4: e2e13000  rsc r3, r1, #0
   12ae8: e0244002  eor r4, r4, r2
   12aec: e0255003  eor r5, r5, r3
   12af0: e0900004  adds  r0, r0, r4
   12af4: e0a11005  adc r1, r1, r5
   12af8: e8bd83f0  pop {r4, r5, r6, r7, r8, r9, pc}
   12afc: eddf0b0f  vldr  d16, [pc, #60]  ; 12b40 <__divdi3+0x1a0>
   12b00: e1a04008  mov r4, r8
   12b04: e1a05009  mov r5, r9
   12b08: e0544006  subs  r4, r4, r6
   12b0c: e0c55007  sbc r5, r5, r7
   12b10: ee013b90  vmov.32 d17[0], r3
   12b14: f37104a0  vshl.u64  d16, d16, d17
   12b18: eaffffc5  b 12a34 <__divdi3+0x94>
   12b1c: e2720000  rsbs  r0, r2, #0
   12b20: e1e0c00c  mvn ip, ip
   12b24: e2e31000  rsc r1, r3, #0
   12b28: eaffffa6  b 129c8 <__divdi3+0x28>
   12b2c: e2708000  rsbs  r8, r0, #0
   12b30: e3e0c000  mvn ip, #0
   12b34: e2e19000  rsc r9, r1, #0
   12b38: eaffff9e  b 129b8 <__divdi3+0x18>
   12b3c: e320f000  nop {0}
   12b40: 00000001  .word 0x00000001
   12b44: 00000000  .word 0x00000000

00012b48 <__udivdi3>:
   12b48: e1510003  cmp r1, r3
   12b4c: 01500002  cmpeq r0, r2
   12b50: e92d0030  push  {r4, r5}
   12b54: e1a04002  mov r4, r2
   12b58: e1a05003  mov r5, r3
   12b5c: 3a00003a  bcc 12c4c <__udivdi3+0x104>
   12b60: e3530000  cmp r3, #0
   12b64: ec454b30  vmov  d16, r4, r5
   12b68: 016f3f12  clzeq r3, r2
   12b6c: 116fcf13  clzne ip, r3
   12b70: 0283c020  addeq ip, r3, #32
   12b74: e3510000  cmp r1, #0
   12b78: 016f3f10  clzeq r3, r0
   12b7c: 116f3f11  clzne r3, r1
   12b80: 02833020  addeq r3, r3, #32
   12b84: e063300c  rsb r3, r3, ip
   12b88: ee013b90  vmov.32 d17[0], r3
   12b8c: e1a02003  mov r2, r3
   12b90: f37104a0  vshl.u64  d16, d16, d17
   12b94: ec554b30  vmov  r4, r5, d16
   12b98: e1510005  cmp r1, r5
   12b9c: 01500004  cmpeq r0, r4
   12ba0: 2a000023  bcs 12c34 <__udivdi3+0xec>
   12ba4: f2c00010  vmov.i32  d16, #0 ; 0x00000000
   12ba8: e3530000  cmp r3, #0
   12bac: 0a00001d  beq 12c28 <__udivdi3+0xe0>
   12bb0: e1b050a5  lsrs  r5, r5, #1
   12bb4: e1a04064  rrx r4, r4
   12bb8: ea000007  b 12bdc <__udivdi3+0x94>
   12bbc: e0500004  subs  r0, r0, r4
   12bc0: e0c11005  sbc r1, r1, r5
   12bc4: e0900000  adds  r0, r0, r0
   12bc8: e0a11001  adc r1, r1, r1
   12bcc: e2900001  adds  r0, r0, #1
   12bd0: e2a11000  adc r1, r1, #0
   12bd4: e2533001  subs  r3, r3, #1
   12bd8: 0a000006  beq 12bf8 <__udivdi3+0xb0>
   12bdc: e1550001  cmp r5, r1
   12be0: 01540000  cmpeq r4, r0
   12be4: 9afffff4  bls 12bbc <__udivdi3+0x74>
   12be8: e0900000  adds  r0, r0, r0
   12bec: e0a11001  adc r1, r1, r1
   12bf0: e2533001  subs  r3, r3, #1
   12bf4: 1afffff8  bne 12bdc <__udivdi3+0x94>
   12bf8: ec410b32  vmov  d18, r0, r1
   12bfc: e2623020  rsb r3, r2, #32
   12c00: e1a00230  lsr r0, r0, r2
   12c04: e242c020  sub ip, r2, #32
   12c08: e1800311  orr r0, r0, r1, lsl r3
   12c0c: f27218a0  vadd.i64  d17, d18, d16
   12c10: e1800c31  orr r0, r0, r1, lsr ip
   12c14: e1a01231  lsr r1, r1, r2
   12c18: ee022b90  vmov.32 d18[0], r2
   12c1c: ec410b30  vmov  d16, r0, r1
   12c20: f37204a0  vshl.u64  d16, d16, d18
   12c24: f37108a0  vsub.i64  d16, d17, d16
   12c28: ec510b30  vmov  r0, r1, d16
   12c2c: e8bd0030  pop {r4, r5}
   12c30: e12fff1e  bx  lr
   12c34: eddf0b09  vldr  d16, [pc, #36]  ; 12c60 <__udivdi3+0x118>
   12c38: e0500004  subs  r0, r0, r4
   12c3c: e0c11005  sbc r1, r1, r5
   12c40: ee013b90  vmov.32 d17[0], r3
   12c44: f37104a0  vshl.u64  d16, d16, d17
   12c48: eaffffd6  b 12ba8 <__udivdi3+0x60>
   12c4c: f2c00010  vmov.i32  d16, #0 ; 0x00000000
   12c50: e8bd0030  pop {r4, r5}
   12c54: ec510b30  vmov  r0, r1, d16
   12c58: e12fff1e  bx  lr
   12c5c: e320f000  nop {0}
   12c60: 00000001  .word 0x00000001
   12c64: 00000000  .word 0x00000000

00012c68 <get_ldnumber>:
  const TCHAR *tp, *tt;
  UINT i;
  s32 vol = -1;


  if ((*path)!=NULL) {  /* If the pointer is not a null */
   12c68: e5901000  ldr r1, [r0]
   12c6c: e3510000  cmp r1, #0
   12c70: 0a000019  beq 12cdc <get_ldnumber+0x74>
    tt = *path;
    for (; (*tt >= '!') && (*tt != ':'); ) {tt += 1U;}  /* Find ':' in the path */
   12c74: e5d1c000  ldrb  ip, [r1]
   12c78: e35c003a  cmp ip, #58 ; 0x3a
   12c7c: 135c0020  cmpne ip, #32
   12c80: 9a000012  bls 12cd0 <get_ldnumber+0x68>
   12c84: e1a02001  mov r2, r1
   12c88: e5f23001  ldrb  r3, [r2, #1]!
   12c8c: e353003a  cmp r3, #58 ; 0x3a
   12c90: 13530020  cmpne r3, #32
   12c94: 8afffffb  bhi 12c88 <get_ldnumber+0x20>
    if (*tt == ':') { /* If a ':' is exist in the path name */
   12c98: e353003a  cmp r3, #58 ; 0x3a
    }
    else {
#if _FS_RPATH && _VOLUMES >= 2
      vol = CurrVol;  /* Current drive */
#else
      vol = 0;    /* Drive 0 */
   12c9c: 13a03000  movne r3, #0


  if ((*path)!=NULL) {  /* If the pointer is not a null */
    tt = *path;
    for (; (*tt >= '!') && (*tt != ':'); ) {tt += 1U;}  /* Find ':' in the path */
    if (*tt == ':') { /* If a ':' is exist in the path name */
   12ca0: 0a000001  beq 12cac <get_ldnumber+0x44>
      vol = 0;    /* Drive 0 */
#endif
    }
  }
  return vol;
}
   12ca4: e1a00003  mov r0, r3
   12ca8: e12fff1e  bx  lr
    tt = *path;
    for (; (*tt >= '!') && (*tt != ':'); ) {tt += 1U;}  /* Find ':' in the path */
    if (*tt == ':') { /* If a ':' is exist in the path name */
      tp = *path;
      i = (*tp - '0');
      tp += 1U;
   12cac: e2811001  add r1, r1, #1
      if ((i < 10U) && (tp == tt)) {  /* Is there a numeric drive id? */
        if (i < _VOLUMES) { /* If a drive id is found, get the value and strip it */
   12cb0: e1520001  cmp r2, r1
   12cb4: 035c0030  cmpeq ip, #48 ; 0x30
   12cb8: 1a000007  bne 12cdc <get_ldnumber+0x74>
          vol = (s32)i;
          tt += 1U;
          *path = ((TCHAR *)tt);
   12cbc: e3a03000  mov r3, #0
      i = (*tp - '0');
      tp += 1U;
      if ((i < 10U) && (tp == tt)) {  /* Is there a numeric drive id? */
        if (i < _VOLUMES) { /* If a drive id is found, get the value and strip it */
          vol = (s32)i;
          tt += 1U;
   12cc0: e2822001  add r2, r2, #1
          *path = ((TCHAR *)tt);
   12cc4: e5802000  str r2, [r0]
      vol = 0;    /* Drive 0 */
#endif
    }
  }
  return vol;
}
   12cc8: e1a00003  mov r0, r3
   12ccc: e12fff1e  bx  lr
  s32 vol = -1;


  if ((*path)!=NULL) {  /* If the pointer is not a null */
    tt = *path;
    for (; (*tt >= '!') && (*tt != ':'); ) {tt += 1U;}  /* Find ':' in the path */
   12cd0: e1a0300c  mov r3, ip
   12cd4: e1a02001  mov r2, r1
   12cd8: eaffffee  b 12c98 <get_ldnumber+0x30>
  const TCHAR** path  /* Pointer to pointer to the path name */
)
{
  const TCHAR *tp, *tt;
  UINT i;
  s32 vol = -1;
   12cdc: e3e03000  mvn r3, #0
   12ce0: eaffffef  b 12ca4 <get_ldnumber+0x3c>

00012ce4 <validate>:
)
{
  FIL *fil = (FIL *)(void *)obj;  /* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
  FRESULT res;

  if (((!fil) != 0U) || ((!fil->fs) != 0U) || ((!fil->fs->fs_type) != 0U) || (fil->fs->id != fil->id)) {
   12ce4: e3500000  cmp r0, #0
   12ce8: 0a000008  beq 12d10 <validate+0x2c>

static
FRESULT validate (  /* FR_OK(0): The object is valid, !=0: Invalid */
  void* obj   /* Pointer to the object FIL/DIR to check validity */
)
{
   12cec: e92d4008  push  {r3, lr}
  FIL *fil = (FIL *)(void *)obj;  /* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
  FRESULT res;

  if (((!fil) != 0U) || ((!fil->fs) != 0U) || ((!fil->fs->fs_type) != 0U) || (fil->fs->id != fil->id)) {
   12cf0: e5903000  ldr r3, [r0]
   12cf4: e3530000  cmp r3, #0
   12cf8: 0a000002  beq 12d08 <validate+0x24>
   12cfc: e5d32000  ldrb  r2, [r3]
   12d00: e3520000  cmp r2, #0
   12d04: 1a000003  bne 12d18 <validate+0x34>
    res = FR_INVALID_OBJECT;
   12d08: e3a00009  mov r0, #9
    else {
      res = FR_OK;
    }
  }
  return res;
}
   12d0c: e8bd8008  pop {r3, pc}
{
  FIL *fil = (FIL *)(void *)obj;  /* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
  FRESULT res;

  if (((!fil) != 0U) || ((!fil->fs) != 0U) || ((!fil->fs->fs_type) != 0U) || (fil->fs->id != fil->id)) {
    res = FR_INVALID_OBJECT;
   12d10: e3a00009  mov r0, #9
    else {
      res = FR_OK;
    }
  }
  return res;
}
   12d14: e12fff1e  bx  lr
)
{
  FIL *fil = (FIL *)(void *)obj;  /* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
  FRESULT res;

  if (((!fil) != 0U) || ((!fil->fs) != 0U) || ((!fil->fs->fs_type) != 0U) || (fil->fs->id != fil->id)) {
   12d18: e1d020b4  ldrh  r2, [r0, #4]
   12d1c: e1d310b6  ldrh  r1, [r3, #6]
   12d20: e1510002  cmp r1, r2
   12d24: 1afffff7  bne 12d08 <validate+0x24>
    res = FR_INVALID_OBJECT;
  }
  else {
    ENTER_FF(fil->fs);    /* Lock file system */

    if ((disk_status(fil->fs->drv) & STA_NOINIT) != (BYTE)0U) {
   12d28: e5d30001  ldrb  r0, [r3, #1]
   12d2c: eb000bf4  bl  15d04 <disk_status>
   12d30: e3100001  tst r0, #1
      res = FR_NOT_READY;
    }
    else {
      res = FR_OK;
   12d34: 13a00003  movne r0, #3
   12d38: 03a00000  moveq r0, #0
   12d3c: e8bd8008  pop {r3, pc}

00012d40 <get_fileinfo.isra.1>:
  UINT i;
  TCHAR *p, c;


  p = fno->fname;
  if (dp->sect!=((DWORD)0U)) {    /* Get SFN */
   12d40: e3500000  cmp r0, #0
{
  UINT i;
  TCHAR *p, c;


  p = fno->fname;
   12d44: e282c009  add ip, r2, #9
    fno->fattrib = (*(dir+DIR_Attr));       /* Attribute */
    fno->fsize = LD_DWORD(dir+DIR_FileSize);  /* Size */
    fno->fdate = LD_WORD(dir+DIR_WrtDate);    /* Date */
    fno->ftime = LD_WORD(dir+DIR_WrtTime);    /* Time */
  }
  *p = 0;   /* Terminate SFN string by a \0 */
   12d48: 03a03000  moveq r3, #0
   12d4c: 05cc3000  strbeq  r3, [ip]
  UINT i;
  TCHAR *p, c;


  p = fno->fname;
  if (dp->sect!=((DWORD)0U)) {    /* Get SFN */
   12d50: 012fff1e  bxeq  lr
/*-----------------------------------------------------------------------*/
/* Get file information from directory entry                             */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
static
void get_fileinfo (   /* No return code */
   12d54: e92d4010  push  {r4, lr}
      }
      if (c == (BYTE)NDDE) {
        c = (TCHAR)DDE; /* Restore replaced DDE character */
      }
      if (i == (UINT)9) {
        *p = '.';     /* Insert a . if extension is exist */
   12d58: e3a0402e  mov r4, #46 ; 0x2e
  TCHAR *p, c;


  p = fno->fname;
  if (dp->sect!=((DWORD)0U)) {    /* Get SFN */
    BYTE *dir = dp->dir;
   12d5c: e591e000  ldr lr, [r1]

    i = 0U;
   12d60: e3a01000  mov r1, #0
   12d64: e24e0001  sub r0, lr, #1
    while (i < 11U) {   /* Copy name body and extension */
      c = (TCHAR)(*(dir+i));
   12d68: e5f03001  ldrb  r3, [r0, #1]!
      i += (UINT)1;
   12d6c: e2811001  add r1, r1, #1
      if (c == ' ') {
   12d70: e3530020  cmp r3, #32
   12d74: 0a000004  beq 12d8c <get_fileinfo.isra.1+0x4c>
        continue;     /* Skip padding spaces */
      }
      if (c == (BYTE)NDDE) {
        c = (TCHAR)DDE; /* Restore replaced DDE character */
   12d78: e3530005  cmp r3, #5
   12d7c: 03a030e5  moveq r3, #229  ; 0xe5
      }
      if (i == (UINT)9) {
   12d80: e3510009  cmp r1, #9
        *p = '.';     /* Insert a . if extension is exist */
   12d84: 04cc4001  strbeq  r4, [ip], #1
      if (c == ((TCHAR)0U)) {
        c = '?';
      }
#endif
#endif
      *p = c;
   12d88: e4cc3001  strb  r3, [ip], #1
  p = fno->fname;
  if (dp->sect!=((DWORD)0U)) {    /* Get SFN */
    BYTE *dir = dp->dir;

    i = 0U;
    while (i < 11U) {   /* Copy name body and extension */
   12d8c: e351000b  cmp r1, #11
   12d90: 1afffff4  bne 12d68 <get_fileinfo.isra.1+0x28>
#endif
#endif
      *p = c;
      p += 1U;
    }
    fno->fattrib = (*(dir+DIR_Attr));       /* Attribute */
   12d94: e5de300b  ldrb  r3, [lr, #11]
   12d98: e5c23008  strb  r3, [r2, #8]
    fno->fsize = LD_DWORD(dir+DIR_FileSize);  /* Size */
   12d9c: e5de001e  ldrb  r0, [lr, #30]
   12da0: e5de301f  ldrb  r3, [lr, #31]
   12da4: e5de101c  ldrb  r1, [lr, #28]
   12da8: e5de401d  ldrb  r4, [lr, #29]
   12dac: e1a00800  lsl r0, r0, #16
   12db0: e1803c03  orr r3, r0, r3, lsl #24
   12db4: e1833001  orr r3, r3, r1
   12db8: e1833404  orr r3, r3, r4, lsl #8
   12dbc: e5823000  str r3, [r2]
    fno->fdate = LD_WORD(dir+DIR_WrtDate);    /* Date */
   12dc0: e5de1019  ldrb  r1, [lr, #25]
   12dc4: e5de3018  ldrb  r3, [lr, #24]
   12dc8: e1833401  orr r3, r3, r1, lsl #8
   12dcc: e1c230b4  strh  r3, [r2, #4]
    fno->ftime = LD_WORD(dir+DIR_WrtTime);    /* Time */
   12dd0: e5de1017  ldrb  r1, [lr, #23]
   12dd4: e5de3016  ldrb  r3, [lr, #22]
   12dd8: e1833401  orr r3, r3, r1, lsl #8
   12ddc: e1c230b6  strh  r3, [r2, #6]
  }
  *p = 0;   /* Terminate SFN string by a \0 */
   12de0: e3a03000  mov r3, #0
   12de4: e5cc3000  strb  r3, [ip]
   12de8: e8bd8010  pop {r4, pc}

00012dec <sync_window.part.3>:
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
   12dec: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
    wsect = fs->winsect;  /* Current sector number */
    if (disk_write(fs->drv, fs->win, wsect, 1U) != RES_OK) {
   12df0: e2807040  add r7, r0, #64 ; 0x40
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
    wsect = fs->winsect;  /* Current sector number */
   12df4: e590402c  ldr r4, [r0, #44] ; 0x2c
/*-----------------------------------------------------------------------*/
/* Move/Flush disk access window in the file system object               */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT sync_window (
   12df8: e1a05000  mov r5, r0
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
    wsect = fs->winsect;  /* Current sector number */
    if (disk_write(fs->drv, fs->win, wsect, 1U) != RES_OK) {
   12dfc: e3a03001  mov r3, #1
   12e00: e1a01007  mov r1, r7
   12e04: e5d00001  ldrb  r0, [r0, #1]
   12e08: e1a02004  mov r2, r4
   12e0c: eb000c59  bl  15f78 <disk_write>
   12e10: e3500000  cmp r0, #0
   12e14: 1a000015  bne 12e70 <sync_window.part.3+0x84>
      return FR_DISK_ERR;
    }
    fs->wflag = 0U;
    if ((wsect - fs->fatbase) < fs->fsize) {    /* Is it in the FAT area? */
   12e18: e5952020  ldr r2, [r5, #32]
   12e1c: e5953018  ldr r3, [r5, #24]
   12e20: e0622004  rsb r2, r2, r4
  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
    wsect = fs->winsect;  /* Current sector number */
    if (disk_write(fs->drv, fs->win, wsect, 1U) != RES_OK) {
      return FR_DISK_ERR;
    }
    fs->wflag = 0U;
   12e24: e5c50004  strb  r0, [r5, #4]
    if ((wsect - fs->fatbase) < fs->fsize) {    /* Is it in the FAT area? */
   12e28: e1520003  cmp r2, r3
   12e2c: 2a00000d  bcs 12e68 <sync_window.part.3+0x7c>
      nf = (UINT)fs->n_fats;
   12e30: e5d56003  ldrb  r6, [r5, #3]
      for (; nf >= 2U; nf--) {  /* Reflect the change to all FAT copies */
   12e34: e3560001  cmp r6, #1
   12e38: 8a000001  bhi 12e44 <sync_window.part.3+0x58>
   12e3c: ea000009  b 12e68 <sync_window.part.3+0x7c>
   12e40: e5953018  ldr r3, [r5, #24]
        wsect += fs->fsize;
   12e44: e0844003  add r4, r4, r3
      return FR_DISK_ERR;
    }
    fs->wflag = 0U;
    if ((wsect - fs->fatbase) < fs->fsize) {    /* Is it in the FAT area? */
      nf = (UINT)fs->n_fats;
      for (; nf >= 2U; nf--) {  /* Reflect the change to all FAT copies */
   12e48: e2466001  sub r6, r6, #1
        wsect += fs->fsize;
        (void)disk_write(fs->drv, fs->win, wsect, 1U);
   12e4c: e5d50001  ldrb  r0, [r5, #1]
   12e50: e1a01007  mov r1, r7
   12e54: e1a02004  mov r2, r4
   12e58: e3a03001  mov r3, #1
   12e5c: eb000c45  bl  15f78 <disk_write>
      return FR_DISK_ERR;
    }
    fs->wflag = 0U;
    if ((wsect - fs->fatbase) < fs->fsize) {    /* Is it in the FAT area? */
      nf = (UINT)fs->n_fats;
      for (; nf >= 2U; nf--) {  /* Reflect the change to all FAT copies */
   12e60: e3560001  cmp r6, #1
   12e64: 1afffff5  bne 12e40 <sync_window.part.3+0x54>
        wsect += fs->fsize;
        (void)disk_write(fs->drv, fs->win, wsect, 1U);
      }
    }
  }
  return FR_OK;
   12e68: e3a00000  mov r0, #0
   12e6c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
    wsect = fs->winsect;  /* Current sector number */
    if (disk_write(fs->drv, fs->win, wsect, 1U) != RES_OK) {
      return FR_DISK_ERR;
   12e70: e3a00001  mov r0, #1
        (void)disk_write(fs->drv, fs->win, wsect, 1U);
      }
    }
  }
  return FR_OK;
}
   12e74: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

00012e78 <sync_fs>:
#if !_FS_READONLY
static
FRESULT sync_fs ( /* FR_OK: successful, FR_DISK_ERR: failed */
  FATFS* fs   /* File system object */
)
{
   12e78: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   12e7c: e1a05000  mov r5, r0
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   12e80: e5d03004  ldrb  r3, [r0, #4]
   12e84: e3530000  cmp r3, #0
   12e88: 1a000009  bne 12eb4 <sync_fs+0x3c>

  BYTE *lp;
  res = sync_window(fs);
  if (res == FR_OK) {
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
   12e8c: e5d53000  ldrb  r3, [r5]
   12e90: e3530003  cmp r3, #3
   12e94: 0a00000a  beq 12ec4 <sync_fs+0x4c>
      fs->winsect = fs->volbase + 1U;
      (void)disk_write(fs->drv, fs->win, fs->winsect, 1U);
      fs->fsi_flag = 0U;
    }
    /* Make sure that no pending write process in the physical drive */
    if (disk_ioctl(fs->drv, CTRL_SYNC, (void*)NULL) != RES_OK) {
   12e98: e3a01000  mov r1, #0
   12e9c: e5d50001  ldrb  r0, [r5, #1]
   12ea0: e1a02001  mov r2, r1
   12ea4: eb000c1c  bl  15f1c <disk_ioctl>
   12ea8: e2900000  adds  r0, r0, #0
   12eac: 13a00001  movne r0, #1
   12eb0: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
   12eb4: ebffffcc  bl  12dec <sync_window.part.3>
{
  FRESULT res;

  BYTE *lp;
  res = sync_window(fs);
  if (res == FR_OK) {
   12eb8: e3500000  cmp r0, #0
   12ebc: 18bd81f0  popne {r4, r5, r6, r7, r8, pc}
   12ec0: eafffff1  b 12e8c <sync_fs+0x14>
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
   12ec4: e5d53005  ldrb  r3, [r5, #5]
   12ec8: e3530001  cmp r3, #1
   12ecc: 1afffff1  bne 12e98 <sync_fs+0x20>
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
   12ed0: e2851040  add r1, r5, #64 ; 0x40
   12ed4: e285cd09  add ip, r5, #576  ; 0x240
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   12ed8: e3a02000  mov r2, #0
}

/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;
   12edc: e1a03001  mov r3, r1

  while ((cnt) > 0U){
    *d = (BYTE)val;
   12ee0: e4c32001  strb  r2, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   12ee4: e153000c  cmp r3, ip
    *d = (BYTE)val;
   12ee8: e3a04000  mov r4, #0
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   12eec: 1afffffb  bne 12ee0 <sync_fs+0x68>
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
   12ef0: e595c01c  ldr ip, [r5, #28]
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12ef4: e300823e  movw  r8, #574  ; 0x23e
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12ef8: e595000c  ldr r0, [r5, #12]
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12efc: e30a6a55  movw  r6, #43605  ; 0xaa55
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
   12f00: e5953010  ldr r3, [r5, #16]
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
   12f04: e28cc001  add ip, ip, #1
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f08: e3052252  movw  r2, #21074  ; 0x5252
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f0c: e307e272  movw  lr, #29298  ; 0x7272
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12f10: e300723f  movw  r7, #575  ; 0x23f
   12f14: e34f6fff  movt  r6, #65535  ; 0xffff
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f18: e3442161  movt  r2, #16737  ; 0x4161
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12f1c: e18560b8  strh  r6, [r5, r8]
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f20: e346e141  movt  lr, #24897  ; 0x6141
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f24: e5852040  str r2, [r5, #64] ; 0x40
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f28: e585e224  str lr, [r5, #548]  ; 0x224
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
      (void)disk_write(fs->drv, fs->win, fs->winsect, 1U);
   12f2c: e1a0200c  mov r2, ip
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
   12f30: e5853228  str r3, [r5, #552]  ; 0x228
   12f34: e1a0e423  lsr lr, r3, #8
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f38: e585022c  str r0, [r5, #556]  ; 0x22c
   12f3c: e1a08420  lsr r8, r0, #8
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
   12f40: e585c02c  str ip, [r5, #44] ; 0x2c
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f44: e1a06c20  lsr r6, r0, #24
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
   12f48: e1a0c823  lsr ip, r3, #16
   12f4c: e5c5e229  strb  lr, [r5, #553]  ; 0x229
   12f50: e5c5c22a  strb  ip, [r5, #554]  ; 0x22a
   12f54: e1a03c23  lsr r3, r3, #24
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f58: e1a0c820  lsr ip, r0, #16
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
   12f5c: e5c5322b  strb  r3, [r5, #555]  ; 0x22b
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f60: e5c5c22e  strb  ip, [r5, #558]  ; 0x22e
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f64: e3a00041  mov r0, #65 ; 0x41
   12f68: e3a0c061  mov ip, #97 ; 0x61
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12f6c: e3a0e0aa  mov lr, #170  ; 0xaa
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f70: e5c5822d  strb  r8, [r5, #557]  ; 0x22d
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f74: e3a03052  mov r3, #82 ; 0x52
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
      lp = fs->win+FSI_Free_Count;
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
   12f78: e5c5622f  strb  r6, [r5, #559]  ; 0x22f
    /* Update FSINFO sector if needed */
    if (((fs->fs_type == FS_FAT32) != 0U) && ((fs->fsi_flag == 1U) != 0U)) {
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
   12f7c: e185e0b7  strh  lr, [r5, r7]
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f80: e3a0e072  mov lr, #114  ; 0x72
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f84: e5c53041  strb  r3, [r5, #65] ; 0x41
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
      (void)disk_write(fs->drv, fs->win, fs->winsect, 1U);
   12f88: e3a03001  mov r3, #1
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f8c: e5c50043  strb  r0, [r5, #67] ; 0x43
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f90: e5c50226  strb  r0, [r5, #550]  ; 0x226
      /* Create FSINFO structure */
      mem_set(fs->win, 0, SS(fs));
      lp = fs->win+BS_55AA;
      ST_WORD(lp, 0xAA55U);
      lp = fs->win+FSI_LeadSig;
      ST_DWORD(lp, 0x41615252);
   12f94: e5c5c042  strb  ip, [r5, #66] ; 0x42
      lp = fs->win+FSI_StrucSig;
      ST_DWORD(lp, 0x61417272);
   12f98: e5c5c227  strb  ip, [r5, #551]  ; 0x227
   12f9c: e5c5e225  strb  lr, [r5, #549]  ; 0x225
      ST_DWORD(lp, fs->free_clust);
      lp = fs->win+FSI_Nxt_Free;
      ST_DWORD(lp, fs->last_clust);
      /* Write it into the FSINFO sector */
      fs->winsect = fs->volbase + 1U;
      (void)disk_write(fs->drv, fs->win, fs->winsect, 1U);
   12fa0: e5d50001  ldrb  r0, [r5, #1]
   12fa4: eb000bf3  bl  15f78 <disk_write>
      fs->fsi_flag = 0U;
   12fa8: e5c54005  strb  r4, [r5, #5]
   12fac: eaffffb9  b 12e98 <sync_fs+0x20>

00012fb0 <move_window>:
static
FRESULT move_window (
  FATFS* fs,    /* File system object */
  DWORD sector  /* Sector number to make appearance in the fs->win[] */
)
{
   12fb0: e92d4038  push  {r3, r4, r5, lr}
   12fb4: e1a04000  mov r4, r0
  if (sector != fs->winsect) {  /* Changed current window */
   12fb8: e590302c  ldr r3, [r0, #44] ; 0x2c
   12fbc: e1530001  cmp r3, r1
   12fc0: 0a000011  beq 1300c <move_window+0x5c>
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   12fc4: e5d03004  ldrb  r3, [r0, #4]
   12fc8: e1a05001  mov r5, r1
   12fcc: e3530000  cmp r3, #0
   12fd0: 1a000008  bne 12ff8 <move_window+0x48>
#if !_FS_READONLY
    if (sync_window(fs) != FR_OK) {
      return FR_DISK_ERR;
    }
#endif
    if (disk_read(fs->drv, fs->win, sector, 1U) != RES_OK) {
   12fd4: e5d40001  ldrb  r0, [r4, #1]
   12fd8: e2841040  add r1, r4, #64 ; 0x40
   12fdc: e1a02005  mov r2, r5
   12fe0: e3a03001  mov r3, #1
   12fe4: eb000bb1  bl  15eb0 <disk_read>
   12fe8: e3500000  cmp r0, #0
   12fec: 1a000004  bne 13004 <move_window+0x54>
      return FR_DISK_ERR;
    }
      fs->winsect = sector;
   12ff0: e584502c  str r5, [r4, #44] ; 0x2c
   12ff4: e8bd8038  pop {r3, r4, r5, pc}
   12ff8: ebffff7b  bl  12dec <sync_window.part.3>
  DWORD sector  /* Sector number to make appearance in the fs->win[] */
)
{
  if (sector != fs->winsect) {  /* Changed current window */
#if !_FS_READONLY
    if (sync_window(fs) != FR_OK) {
   12ffc: e3500000  cmp r0, #0
   13000: 0afffff3  beq 12fd4 <move_window+0x24>
      return FR_DISK_ERR;
   13004: e3a00001  mov r0, #1
   13008: e8bd8038  pop {r3, r4, r5, pc}
      return FR_DISK_ERR;
    }
      fs->winsect = sector;
  }

  return FR_OK;
   1300c: e3a00000  mov r0, #0
}
   13010: e8bd8038  pop {r3, r4, r5, pc}

00013014 <check_fs>:
static
BYTE check_fs ( /* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
  FATFS* fs,  /* File system object */
  DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
   13014: e92d4010  push  {r4, lr}
  fs->wflag = 0U; fs->winsect = 0xFFFFFFFFU;  /* Invaidate window */
   13018: e3a02000  mov r2, #0
   1301c: e3e03000  mvn r3, #0
   13020: e5c02004  strb  r2, [r0, #4]
   13024: e580302c  str r3, [r0, #44] ; 0x2c
static
BYTE check_fs ( /* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
  FATFS* fs,  /* File system object */
  DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
   13028: e1a04000  mov r4, r0
  fs->wflag = 0U; fs->winsect = 0xFFFFFFFFU;  /* Invaidate window */
  if (move_window(fs, sect) != FR_OK) {   /* Load boot record */
   1302c: ebffffdf  bl  12fb0 <move_window>
   13030: e3500000  cmp r0, #0
   13034: 0a000001  beq 13040 <check_fs+0x2c>
    return (BYTE)3;
   13038: e3a00003  mov r0, #3
   1303c: e8bd8010  pop {r4, pc}
  }

  if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55U) {  /* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   13040: e5d4123f  ldrb  r1, [r4, #575]  ; 0x23f
   13044: e30a2a55  movw  r2, #43605  ; 0xaa55
   13048: e5d4323e  ldrb  r3, [r4, #574]  ; 0x23e
   1304c: e1833401  orr r3, r3, r1, lsl #8
   13050: e1530002  cmp r3, r2
   13054: 0a000001  beq 13060 <check_fs+0x4c>
    return (BYTE)2;
   13058: e3a00002  mov r0, #2
  if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFFU) == 0x544146U) { /* Check "FAT" string */
    return (BYTE)0;
  }

  return (BYTE)1;
}
   1305c: e8bd8010  pop {r4, pc}

  if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55U) {  /* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
    return (BYTE)2;
  }

  if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFFU) == 0x544146U) {   /* Check "FAT" string */
   13060: e5d41078  ldrb  r1, [r4, #120]  ; 0x78
   13064: e304c146  movw  ip, #16710  ; 0x4146
   13068: e5d43079  ldrb  r3, [r4, #121]  ; 0x79
   1306c: e340c054  movt  ip, #84 ; 0x54
   13070: e5d42076  ldrb  r2, [r4, #118]  ; 0x76
   13074: e1a01801  lsl r1, r1, #16
   13078: e5d4e077  ldrb  lr, [r4, #119]  ; 0x77
   1307c: e1813c03  orr r3, r1, r3, lsl #24
   13080: e1833002  orr r3, r3, r2
   13084: e183340e  orr r3, r3, lr, lsl #8
   13088: e3c334ff  bic r3, r3, #-16777216  ; 0xff000000
   1308c: e153000c  cmp r3, ip
   13090: 08bd8010  popeq {r4, pc}
    return (BYTE)0;
  }
  if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFFU) == 0x544146U) { /* Check "FAT" string */
   13094: e5d41094  ldrb  r1, [r4, #148]  ; 0x94
   13098: e5d43095  ldrb  r3, [r4, #149]  ; 0x95
   1309c: e5d40093  ldrb  r0, [r4, #147]  ; 0x93
   130a0: e5d42092  ldrb  r2, [r4, #146]  ; 0x92
   130a4: e1a01801  lsl r1, r1, #16
   130a8: e1813c03  orr r3, r1, r3, lsl #24
   130ac: e1833002  orr r3, r3, r2
   130b0: e1833400  orr r3, r3, r0, lsl #8
   130b4: e3c334ff  bic r3, r3, #-16777216  ; 0xff000000
  DWORD sect  /* Sector# (lba) to check if it is an FAT boot record or not */
)
{
  fs->wflag = 0U; fs->winsect = 0xFFFFFFFFU;  /* Invaidate window */
  if (move_window(fs, sect) != FR_OK) {   /* Load boot record */
    return (BYTE)3;
   130b8: e053000c  subs  r0, r3, ip
   130bc: 13a00001  movne r0, #1
   130c0: e8bd8010  pop {r4, pc}

000130c4 <find_volume>:
FRESULT find_volume ( /* FR_OK(0): successful, !=0: any error occurred */
  FATFS** rfs,    /* Pointer to pointer to the found file system object */
  const TCHAR** path, /* Pointer to pointer to the path name (drive number) */
  BYTE wmode      /* !=0: Check write protection for write access */
)
{
   130c4: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   130c8: e1a07000  mov r7, r0
  WORD nrsv;
  FATFS *fs;


  /* Get logical drive number from the path name */
  (*rfs) = 0;
   130cc: e3a03000  mov r3, #0
FRESULT find_volume ( /* FR_OK(0): successful, !=0: any error occurred */
  FATFS** rfs,    /* Pointer to pointer to the found file system object */
  const TCHAR** path, /* Pointer to pointer to the path name (drive number) */
  BYTE wmode      /* !=0: Check write protection for write access */
)
{
   130d0: e24dd014  sub sp, sp, #20
  FATFS *fs;


  /* Get logical drive number from the path name */
  (*rfs) = 0;
  vol = get_ldnumber(path);
   130d4: e1a00001  mov r0, r1
  WORD nrsv;
  FATFS *fs;


  /* Get logical drive number from the path name */
  (*rfs) = 0;
   130d8: e5873000  str r3, [r7]
FRESULT find_volume ( /* FR_OK(0): successful, !=0: any error occurred */
  FATFS** rfs,    /* Pointer to pointer to the found file system object */
  const TCHAR** path, /* Pointer to pointer to the path name (drive number) */
  BYTE wmode      /* !=0: Check write protection for write access */
)
{
   130dc: e1a04002  mov r4, r2
  FATFS *fs;


  /* Get logical drive number from the path name */
  (*rfs) = 0;
  vol = get_ldnumber(path);
   130e0: ebfffee0  bl  12c68 <get_ldnumber>
  if (vol < 0) {return FR_INVALID_DRIVE;}
   130e4: e2506000  subs  r6, r0, #0
   130e8: b3a0000b  movlt r0, #11
   130ec: ba000012  blt 1313c <find_volume+0x78>

  /* Check if the file system object is valid or not */
  fs = FatFs[vol];          /* Get pointer to the file system object */
   130f0: e3018568  movw  r8, #5480 ; 0x1568
   130f4: e3408002  movt  r8, #2
   130f8: e7985106  ldr r5, [r8, r6, lsl #2]
  if ((!fs) != 0U) {
   130fc: e3550000  cmp r5, #0
   13100: 0a00001d  beq 1317c <find_volume+0xb8>
    return FR_NOT_ENABLED;    /* Is the file system object available? */
  }

  ENTER_FF(fs);           /* Lock the volume */
  *rfs = fs;              /* Return pointer to the file system object */
   13104: e5875000  str r5, [r7]

  if (fs->fs_type != 0U) {          /* If the volume has been mounted */
   13108: e5d53000  ldrb  r3, [r5]
   1310c: e3530000  cmp r3, #0
   13110: 0a00000b  beq 13144 <find_volume+0x80>
    stat = disk_status(fs->drv);
   13114: e5d50001  ldrb  r0, [r5, #1]
   13118: eb000af9  bl  15d04 <disk_status>
    if ((!(stat & STA_NOINIT)) != 0U) {   /* and the physical drive is kept initialized */
   1311c: e3100001  tst r0, #1
   13120: 1a000007  bne 13144 <find_volume+0x80>
      if (!_FS_READONLY && (wmode != (BYTE)0U) && ((stat & STA_PROTECT) != (BYTE)0U)) {/* Check write protection if needed */
   13124: e3540000  cmp r4, #0
        return FR_WRITE_PROTECTED;
      }
      return FR_OK;       /* The file system object is valid */
   13128: 01a00004  moveq r0, r4
  *rfs = fs;              /* Return pointer to the file system object */

  if (fs->fs_type != 0U) {          /* If the volume has been mounted */
    stat = disk_status(fs->drv);
    if ((!(stat & STA_NOINIT)) != 0U) {   /* and the physical drive is kept initialized */
      if (!_FS_READONLY && (wmode != (BYTE)0U) && ((stat & STA_PROTECT) != (BYTE)0U)) {/* Check write protection if needed */
   1312c: 0a000002  beq 1313c <find_volume+0x78>
   13130: e2000004  and r0, r0, #4
   13134: e21000ff  ands  r0, r0, #255  ; 0xff
   13138: 1a00000d  bne 13174 <find_volume+0xb0>
#if _FS_LOCK      /* Clear file lock semaphores */
  clear_lock(fs);
#endif

  return FR_OK;
}
   1313c: e28dd014  add sp, sp, #20
   13140: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}

  /* The file system object is not valid. */
  /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

  fs->fs_type = 0U;         /* Clear the file system object */
  fs->drv = LD2PD(vol);       /* Bind the logical drive and a physical drive */
   13144: e6ef0076  uxtb  r0, r6
  }

  /* The file system object is not valid. */
  /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

  fs->fs_type = 0U;         /* Clear the file system object */
   13148: e3a03000  mov r3, #0
  fs->drv = LD2PD(vol);       /* Bind the logical drive and a physical drive */
   1314c: e5c50001  strb  r0, [r5, #1]
  }

  /* The file system object is not valid. */
  /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

  fs->fs_type = 0U;         /* Clear the file system object */
   13150: e5c53000  strb  r3, [r5]
  fs->drv = LD2PD(vol);       /* Bind the logical drive and a physical drive */
  stat = disk_initialize(fs->drv);  /* Initialize the physical drive */
   13154: eb000afc  bl  15d4c <disk_initialize>
  if ((stat & STA_NOINIT) != (BYTE)0U) {        /* Check if the initialization succeeded */
   13158: e3100001  tst r0, #1
    return FR_NOT_READY;      /* Failed to initialize due to no medium or hard error */
   1315c: 13a00003  movne r0, #3
  /* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

  fs->fs_type = 0U;         /* Clear the file system object */
  fs->drv = LD2PD(vol);       /* Bind the logical drive and a physical drive */
  stat = disk_initialize(fs->drv);  /* Initialize the physical drive */
  if ((stat & STA_NOINIT) != (BYTE)0U) {        /* Check if the initialization succeeded */
   13160: 1afffff5  bne 1313c <find_volume+0x78>
    return FR_NOT_READY;      /* Failed to initialize due to no medium or hard error */
  }
  if (!_FS_READONLY && (wmode != (BYTE)0U)&& ((stat & STA_PROTECT) != (BYTE)0U)) {  /* Check disk write protection if needed */
   13164: e3540000  cmp r4, #0
   13168: 0a000005  beq 13184 <find_volume+0xc0>
   1316c: e3100004  tst r0, #4
   13170: 0a000003  beq 13184 <find_volume+0xc0>

  if (fs->fs_type != 0U) {          /* If the volume has been mounted */
    stat = disk_status(fs->drv);
    if ((!(stat & STA_NOINIT)) != 0U) {   /* and the physical drive is kept initialized */
      if (!_FS_READONLY && (wmode != (BYTE)0U) && ((stat & STA_PROTECT) != (BYTE)0U)) {/* Check write protection if needed */
        return FR_WRITE_PROTECTED;
   13174: e3a0000a  mov r0, #10
   13178: eaffffef  b 1313c <find_volume+0x78>
  if (vol < 0) {return FR_INVALID_DRIVE;}

  /* Check if the file system object is valid or not */
  fs = FatFs[vol];          /* Get pointer to the file system object */
  if ((!fs) != 0U) {
    return FR_NOT_ENABLED;    /* Is the file system object available? */
   1317c: e3a0000c  mov r0, #12
   13180: eaffffed  b 1313c <find_volume+0x78>
     return FR_DISK_ERR;
  }
#endif
  /* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
  bsect = 0U;
  fmt = check_fs(fs, bsect);          /* Load sector 0 and check if it is an FAT boot sector as SFD */
   13184: e1a00005  mov r0, r5
   13188: e3a01000  mov r1, #0
   1318c: ebffffa0  bl  13014 <check_fs>
  if ((fmt == 1U) || (((!fmt) != (BYTE)0U) && ((LD2PT(vol)) != 0U))) {  /* Not an FAT boot sector or forced partition number */
   13190: e3500001  cmp r0, #1
    || SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) {
     return FR_DISK_ERR;
  }
#endif
  /* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
  bsect = 0U;
   13194: 13a06000  movne r6, #0
  fmt = check_fs(fs, bsect);          /* Load sector 0 and check if it is an FAT boot sector as SFD */
  if ((fmt == 1U) || (((!fmt) != (BYTE)0U) && ((LD2PT(vol)) != 0U))) {  /* Not an FAT boot sector or forced partition number */
   13198: 0a000006  beq 131b8 <find_volume+0xf4>
      bsect = br[i];
      fmt = (bsect!=(DWORD)0U) ? check_fs(fs, bsect) : 2U;  /* Check the partition */
      i += (UINT)1;
    } while ((!LD2PT(vol)) && (fmt != (BYTE)0U)&& (i < 4U));
  }
  if (fmt == 3U) {
   1319c: e3500003  cmp r0, #3
    return FR_DISK_ERR;   /* An error occured in the disk I/O layer */
   131a0: 03a00001  moveq r0, #1
      bsect = br[i];
      fmt = (bsect!=(DWORD)0U) ? check_fs(fs, bsect) : 2U;  /* Check the partition */
      i += (UINT)1;
    } while ((!LD2PT(vol)) && (fmt != (BYTE)0U)&& (i < 4U));
  }
  if (fmt == 3U) {
   131a4: 0affffe4  beq 1313c <find_volume+0x78>
    return FR_DISK_ERR;   /* An error occured in the disk I/O layer */
  }
  if (fmt != 0U) {
   131a8: e3500000  cmp r0, #0
   131ac: 0a000026  beq 1324c <find_volume+0x188>
    return FR_NO_FILESYSTEM;    /* No FAT volume is found */
   131b0: e3a0000d  mov r0, #13
   131b4: eaffffe0  b 1313c <find_volume+0x78>
   131b8: e285e040  add lr, r5, #64 ; 0x40
   131bc: e1a01005  mov r1, r5
   131c0: e1a0c00d  mov ip, sp
    UINT i;
    DWORD br[4];

    for (i = 0U; i < 4U; i++) {     /* Get partition offset */
      BYTE *pt = fs->win+MBR_Table + ((WORD)i * (WORD)SZ_PTE);
      br[i] = ((*(pt+4)) != (BYTE)0U) ? LD_DWORD((pt+8U)) : 0U;
   131c4: e5d13202  ldrb  r3, [r1, #514]  ; 0x202
   131c8: e3530000  cmp r3, #0
   131cc: 0a000007  beq 131f0 <find_volume+0x12c>
   131d0: e5d10208  ldrb  r0, [r1, #520]  ; 0x208
   131d4: e5d13209  ldrb  r3, [r1, #521]  ; 0x209
   131d8: e5d12206  ldrb  r2, [r1, #518]  ; 0x206
   131dc: e1a00800  lsl r0, r0, #16
   131e0: e5d14207  ldrb  r4, [r1, #519]  ; 0x207
   131e4: e1803c03  orr r3, r0, r3, lsl #24
   131e8: e1833002  orr r3, r3, r2
   131ec: e1833404  orr r3, r3, r4, lsl #8
   131f0: e2811010  add r1, r1, #16
   131f4: e48c3004  str r3, [ip], #4
  fmt = check_fs(fs, bsect);          /* Load sector 0 and check if it is an FAT boot sector as SFD */
  if ((fmt == 1U) || (((!fmt) != (BYTE)0U) && ((LD2PT(vol)) != 0U))) {  /* Not an FAT boot sector or forced partition number */
    UINT i;
    DWORD br[4];

    for (i = 0U; i < 4U; i++) {     /* Get partition offset */
   131f8: e151000e  cmp r1, lr
   131fc: 1afffff0  bne 131c4 <find_volume+0x100>
   13200: e3a04000  mov r4, #0
    i = LD2PT(vol);           /* Partition number: 0:auto, 1-4:forced */
    if (i != 0U) {
      i--;
    }
    do {                /* Find an FAT volume */
      bsect = br[i];
   13204: e79d6104  ldr r6, [sp, r4, lsl #2]
   13208: e3a03001  mov r3, #1
      fmt = (bsect!=(DWORD)0U) ? check_fs(fs, bsect) : 2U;  /* Check the partition */
   1320c: e3a00002  mov r0, #2
   13210: e3560000  cmp r6, #0
   13214: 1a000006  bne 13234 <find_volume+0x170>
      i += (UINT)1;
   13218: e2844001  add r4, r4, #1
    } while ((!LD2PT(vol)) && (fmt != (BYTE)0U)&& (i < 4U));
   1321c: e3540003  cmp r4, #3
   13220: 83a03000  movhi r3, #0
   13224: 92033001  andls r3, r3, #1
   13228: e3530000  cmp r3, #0
   1322c: 1afffff4  bne 13204 <find_volume+0x140>
   13230: eaffffd9  b 1319c <find_volume+0xd8>
    if (i != 0U) {
      i--;
    }
    do {                /* Find an FAT volume */
      bsect = br[i];
      fmt = (bsect!=(DWORD)0U) ? check_fs(fs, bsect) : 2U;  /* Check the partition */
   13234: e1a00005  mov r0, r5
   13238: e1a01006  mov r1, r6
   1323c: ebffff74  bl  13014 <check_fs>
   13240: e2903000  adds  r3, r0, #0
   13244: 13a03001  movne r3, #1
   13248: eafffff2  b 13218 <find_volume+0x154>
    return FR_NO_FILESYSTEM;    /* No FAT volume is found */
  }

  /* An FAT volume is found. Following code initializes the file system object */

  if (LD_WORD(fs->win+BPB_BytsPerSec) != (WORD)SS(fs)) {  /* (BPB_BytsPerSec must be equal to the physical sector size) */
   1324c: e5d5204c  ldrb  r2, [r5, #76] ; 0x4c
   13250: e5d5304b  ldrb  r3, [r5, #75] ; 0x4b
   13254: e1833402  orr r3, r3, r2, lsl #8
   13258: e3530c02  cmp r3, #512  ; 0x200
   1325c: 1affffd3  bne 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }

  fasize = ((DWORD)LD_WORD(fs->win+BPB_FATSz16));       /* Number of sectors per FAT */
   13260: e5d57057  ldrb  r7, [r5, #87] ; 0x57
   13264: e5d53056  ldrb  r3, [r5, #86] ; 0x56
  if ((!fasize) != 0U) {
   13268: e1933407  orrs  r3, r3, r7, lsl #8
   1326c: 0a00005c  beq 133e4 <find_volume+0x320>

  if (LD_WORD(fs->win+BPB_BytsPerSec) != (WORD)SS(fs)) {  /* (BPB_BytsPerSec must be equal to the physical sector size) */
    return FR_NO_FILESYSTEM;
  }

  fasize = ((DWORD)LD_WORD(fs->win+BPB_FATSz16));       /* Number of sectors per FAT */
   13270: e1a07003  mov r7, r3
  if ((!fasize) != 0U) {
    fasize = (DWORD)LD_DWORD(fs->win+BPB_FATSz32);
  }
  fs->fsize = fasize;

  fs->n_fats = fs->win[BPB_NumFATs];          /* Number of FAT copies */
   13274: e5d5a050  ldrb  sl, [r5, #80] ; 0x50

  fasize = ((DWORD)LD_WORD(fs->win+BPB_FATSz16));       /* Number of sectors per FAT */
  if ((!fasize) != 0U) {
    fasize = (DWORD)LD_DWORD(fs->win+BPB_FATSz32);
  }
  fs->fsize = fasize;
   13278: e5857018  str r7, [r5, #24]

  fs->n_fats = fs->win[BPB_NumFATs];          /* Number of FAT copies */
  if ((fs->n_fats != 1U) && (fs->n_fats != 2U)) {     /* (Must be 1 or 2) */
   1327c: e24a3001  sub r3, sl, #1
   13280: e3530001  cmp r3, #1
  if ((!fasize) != 0U) {
    fasize = (DWORD)LD_DWORD(fs->win+BPB_FATSz32);
  }
  fs->fsize = fasize;

  fs->n_fats = fs->win[BPB_NumFATs];          /* Number of FAT copies */
   13284: e5c5a003  strb  sl, [r5, #3]
  if ((fs->n_fats != 1U) && (fs->n_fats != 2U)) {     /* (Must be 1 or 2) */
   13288: 8affffc8  bhi 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }
  fasize *= (DWORD)fs->n_fats;                /* Number of sectors for FAT area */

  fs->csize = fs->win[BPB_SecPerClus];        /* Number of sectors per cluster */
   1328c: e5d5104d  ldrb  r1, [r5, #77] ; 0x4d
  if (((!fs->csize) != 0U) || ((fs->csize & (fs->csize - 1U)) != 0U)) { /* (Must be power of 2) */
   13290: e3510000  cmp r1, #0
  if ((fs->n_fats != 1U) && (fs->n_fats != 2U)) {     /* (Must be 1 or 2) */
    return FR_NO_FILESYSTEM;
  }
  fasize *= (DWORD)fs->n_fats;                /* Number of sectors for FAT area */

  fs->csize = fs->win[BPB_SecPerClus];        /* Number of sectors per cluster */
   13294: e5c51002  strb  r1, [r5, #2]
  if (((!fs->csize) != 0U) || ((fs->csize & (fs->csize - 1U)) != 0U)) { /* (Must be power of 2) */
   13298: 0affffc4  beq 131b0 <find_volume+0xec>
   1329c: e2413001  sub r3, r1, #1
   132a0: e1130001  tst r3, r1
   132a4: 1affffc1  bne 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }

  fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);  /* Number of root directory entries */
   132a8: e5d5b052  ldrb  fp, [r5, #82] ; 0x52
   132ac: e5d53051  ldrb  r3, [r5, #81] ; 0x51
   132b0: e183b40b  orr fp, r3, fp, lsl #8
   132b4: e1c5b0b8  strh  fp, [r5, #8]
  if ((fs->n_rootdir % (SS(fs) / SZ_DIR)) != 0U) {        /* (Must be sector aligned) */
   132b8: e31b000f  tst fp, #15
   132bc: 1affffbb  bne 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }

  tsect = ((DWORD)LD_WORD(fs->win+BPB_TotSec16));       /* Number of sectors on the volume */
   132c0: e5d50054  ldrb  r0, [r5, #84] ; 0x54
   132c4: e5d53053  ldrb  r3, [r5, #83] ; 0x53
  if ((!tsect) != 0U) {
   132c8: e1930400  orrs  r0, r3, r0, lsl #8
   132cc: 1a000007  bne 132f0 <find_volume+0x22c>
    tsect = (DWORD)LD_DWORD(fs->win+BPB_TotSec32);
   132d0: e5d52062  ldrb  r2, [r5, #98] ; 0x62
   132d4: e5d5c063  ldrb  ip, [r5, #99] ; 0x63
   132d8: e5d53060  ldrb  r3, [r5, #96] ; 0x60
   132dc: e1a02802  lsl r2, r2, #16
   132e0: e5d50061  ldrb  r0, [r5, #97] ; 0x61
   132e4: e1822c0c  orr r2, r2, ip, lsl #24
   132e8: e1823003  orr r3, r2, r3
   132ec: e1830400  orr r0, r3, r0, lsl #8
  }

  nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);       /* Number of reserved sectors */
   132f0: e5d5404f  ldrb  r4, [r5, #79] ; 0x4f
   132f4: e5d5304e  ldrb  r3, [r5, #78] ; 0x4e
  if ((!nrsv) != 0U) {
   132f8: e1934404  orrs  r4, r3, r4, lsl #8
   132fc: 0affffab  beq 131b0 <find_volume+0xec>

  fs->n_fats = fs->win[BPB_NumFATs];          /* Number of FAT copies */
  if ((fs->n_fats != 1U) && (fs->n_fats != 2U)) {     /* (Must be 1 or 2) */
    return FR_NO_FILESYSTEM;
  }
  fasize *= (DWORD)fs->n_fats;                /* Number of sectors for FAT area */
   13300: e00a079a  mul sl, sl, r7
   13304: e084922b  add r9, r4, fp, lsr #4
  if ((!nrsv) != 0U) {
    return FR_NO_FILESYSTEM;          /* (Must not be 0) */
  }

  /* Determine the FAT sub type */
  sysect = (DWORD)nrsv + fasize + (fs->n_rootdir / (SS(fs) / SZ_DIR));  /* RSV+FAT+DIR */
   13308: e089900a  add r9, r9, sl
  if (tsect < sysect) {
   1330c: e1500009  cmp r0, r9
   13310: 3affffa6  bcc 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;    /* (Invalid volume size) */
  }
  nclst = (tsect - sysect) / ((DWORD)fs->csize);        /* Number of clusters */
   13314: e0690000  rsb r0, r9, r0
   13318: ebffd7a4  bl  91b0 <__aeabi_uidiv>
  if ((!nclst) != 0U) {
   1331c: e3500000  cmp r0, #0
   13320: 0affffa2  beq 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;        /* (Invalid volume size) */
  }
  fmt = FS_FAT12;
  if (nclst >= MIN_FAT16) {
   13324: e3003ff5  movw  r3, #4085 ; 0xff5
   13328: e1500003  cmp r0, r3
   1332c: 9a000084  bls 13544 <find_volume+0x480>
    fmt = FS_FAT16;
  }
  if (nclst >= MIN_FAT32) {
   13330: e30f3ff5  movw  r3, #65525  ; 0xfff5
   13334: e1500003  cmp r0, r3
   13338: 9a00006a  bls 134e8 <find_volume+0x424>
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
  fs->database = bsect + sysect;            /* Data start sector */
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
   1333c: e35b0000  cmp fp, #0
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   13340: e2800002  add r0, r0, #2
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   13344: e0864004  add r4, r6, r4
  fs->database = bsect + sysect;            /* Data start sector */
   13348: e0899006  add r9, r9, r6
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   1334c: e5850014  str r0, [r5, #20]
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   13350: e5854020  str r4, [r5, #32]
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
  fs->volbase = bsect;                /* Volume start sector */
   13354: e585601c  str r6, [r5, #28]
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
  fs->database = bsect + sysect;            /* Data start sector */
   13358: e5859028  str r9, [r5, #40] ; 0x28
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
   1335c: 1affff93  bne 131b0 <find_volume+0xec>
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
   13360: e1a00100  lsl r0, r0, #2
  fs->database = bsect + sysect;            /* Data start sector */
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
   13364: e5d5106e  ldrb  r1, [r5, #110]  ; 0x6e
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13368: e2803f7f  add r3, r0, #508  ; 0x1fc
  fs->database = bsect + sysect;            /* Data start sector */
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
   1336c: e5d5c06f  ldrb  ip, [r5, #111]  ; 0x6f
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13370: e2833003  add r3, r3, #3
  fs->database = bsect + sysect;            /* Data start sector */
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
   13374: e5d5206c  ldrb  r2, [r5, #108]  ; 0x6c
   13378: e1a01801  lsl r1, r1, #16
   1337c: e5d5006d  ldrb  r0, [r5, #109]  ; 0x6d
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13380: e15704a3  cmp r7, r3, lsr #9
  fs->database = bsect + sysect;            /* Data start sector */
  if (fmt == FS_FAT32) {
    if (fs->n_rootdir != 0U) {
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
   13384: e1813c0c  orr r3, r1, ip, lsl #24
   13388: e1833002  orr r3, r3, r2
   1338c: e1833400  orr r3, r3, r0, lsl #8
   13390: e5853024  str r3, [r5, #36] ; 0x24
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13394: 3affff85  bcc 131b0 <find_volume+0xec>

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
   13398: e5d50071  ldrb  r0, [r5, #113]  ; 0x71
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   1339c: e3e02000  mvn r2, #0

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
   133a0: e5d53070  ldrb  r3, [r5, #112]  ; 0x70
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
  fs->free_clust = 0xFFFFFFFFU;

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   133a4: e3e0107f  mvn r1, #127  ; 0x7f
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   133a8: e585200c  str r2, [r5, #12]

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
   133ac: e1833400  orr r3, r3, r0, lsl #8
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
  fs->free_clust = 0xFFFFFFFFU;
   133b0: e5852010  str r2, [r5, #16]

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
   133b4: e3530001  cmp r3, #1
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
  fs->free_clust = 0xFFFFFFFFU;

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   133b8: e5c51005  strb  r1, [r5, #5]
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
   133bc: 0a000011  beq 13408 <find_volume+0x344>
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   133c0: e3a0c003  mov ip, #3
    }
  }
#endif
#endif
  fs->fs_type = fmt;  /* FAT sub-type */
  Fsid += (WORD)1;
   133c4: e1d830b4  ldrh  r3, [r8, #4]
#endif
#if _FS_LOCK      /* Clear file lock semaphores */
  clear_lock(fs);
#endif

  return FR_OK;
   133c8: e3a00000  mov r0, #0
#endif
    }
  }
#endif
#endif
  fs->fs_type = fmt;  /* FAT sub-type */
   133cc: e5c5c000  strb  ip, [r5]
  Fsid += (WORD)1;
   133d0: e2833001  add r3, r3, #1
   133d4: e6ff3073  uxth  r3, r3
   133d8: e1c830b4  strh  r3, [r8, #4]
  fs->id = Fsid;  /* File system mount ID */
   133dc: e1c530b6  strh  r3, [r5, #6]
#endif
#if _FS_LOCK      /* Clear file lock semaphores */
  clear_lock(fs);
#endif

  return FR_OK;
   133e0: eaffff55  b 1313c <find_volume+0x78>
    return FR_NO_FILESYSTEM;
  }

  fasize = ((DWORD)LD_WORD(fs->win+BPB_FATSz16));       /* Number of sectors per FAT */
  if ((!fasize) != 0U) {
    fasize = (DWORD)LD_DWORD(fs->win+BPB_FATSz32);
   133e4: e5d53066  ldrb  r3, [r5, #102]  ; 0x66
   133e8: e5d51067  ldrb  r1, [r5, #103]  ; 0x67
   133ec: e5d52064  ldrb  r2, [r5, #100]  ; 0x64
   133f0: e1a03803  lsl r3, r3, #16
   133f4: e5d57065  ldrb  r7, [r5, #101]  ; 0x65
   133f8: e1833c01  orr r3, r3, r1, lsl #24
   133fc: e1833002  orr r3, r3, r2
   13400: e1837407  orr r7, r3, r7, lsl #8
   13404: eaffff9a  b 13274 <find_volume+0x1b0>
  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
    && (move_window(fs, bsect + 1U) == FR_OK))
   13408: e2861001  add r1, r6, #1
   1340c: e1a00005  mov r0, r5
   13410: ebfffee6  bl  12fb0 <move_window>
   13414: e3500000  cmp r0, #0
   13418: 1affffe8  bne 133c0 <find_volume+0x2fc>
  {
    fs->fsi_flag = 0U;
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
   1341c: e5d5123f  ldrb  r1, [r5, #575]  ; 0x23f
   13420: e30a2a55  movw  r2, #43605  ; 0xaa55
   13424: e5d5323e  ldrb  r3, [r5, #574]  ; 0x23e
#if (_FS_NOFSINFO & 3) != 3U
  if ((fmt == FS_FAT32)       /* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
    && (LD_WORD(fs->win+BPB_FSInfo) == 1U)
    && (move_window(fs, bsect + 1U) == FR_OK))
  {
    fs->fsi_flag = 0U;
   13428: e5c5b005  strb  fp, [r5, #5]
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
   1342c: e1833401  orr r3, r3, r1, lsl #8
   13430: e1530002  cmp r3, r2
   13434: 1affffe1  bne 133c0 <find_volume+0x2fc>
      && (LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252U)
   13438: e5d51042  ldrb  r1, [r5, #66] ; 0x42
   1343c: e3050252  movw  r0, #21074  ; 0x5252
   13440: e5d53043  ldrb  r3, [r5, #67] ; 0x43
   13444: e3440161  movt  r0, #16737  ; 0x4161
   13448: e5d52040  ldrb  r2, [r5, #64] ; 0x40
   1344c: e1a01801  lsl r1, r1, #16
   13450: e5d5c041  ldrb  ip, [r5, #65] ; 0x41
   13454: e1813c03  orr r3, r1, r3, lsl #24
   13458: e1833002  orr r3, r3, r2
   1345c: e183340c  orr r3, r3, ip, lsl #8
   13460: e1530000  cmp r3, r0
   13464: 1affffd5  bne 133c0 <find_volume+0x2fc>
      && (LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272U))
   13468: e5d51226  ldrb  r1, [r5, #550]  ; 0x226
   1346c: e3070272  movw  r0, #29298  ; 0x7272
   13470: e5d53227  ldrb  r3, [r5, #551]  ; 0x227
   13474: e3460141  movt  r0, #24897  ; 0x6141
   13478: e5d52224  ldrb  r2, [r5, #548]  ; 0x224
   1347c: e1a01801  lsl r1, r1, #16
   13480: e5d5c225  ldrb  ip, [r5, #549]  ; 0x225
   13484: e1813c03  orr r3, r1, r3, lsl #24
   13488: e1833002  orr r3, r3, r2
   1348c: e183340c  orr r3, r3, ip, lsl #8
   13490: e1530000  cmp r3, r0
   13494: 1affffc9  bne 133c0 <find_volume+0x2fc>
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   13498: e5d5022a  ldrb  r0, [r5, #554]  ; 0x22a
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   1349c: e3a0c003  mov ip, #3
   134a0: e5d5322e  ldrb  r3, [r5, #558]  ; 0x22e
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
      && (LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252U)
      && (LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272U))
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   134a4: e5d5222b  ldrb  r2, [r5, #555]  ; 0x22b
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   134a8: e5d5e22f  ldrb  lr, [r5, #559]  ; 0x22f
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
      && (LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252U)
      && (LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272U))
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   134ac: e1a00800  lsl r0, r0, #16
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   134b0: e1a03803  lsl r3, r3, #16
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
      && (LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252U)
      && (LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272U))
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   134b4: e5d51228  ldrb  r1, [r5, #552]  ; 0x228
   134b8: e1800c02  orr r0, r0, r2, lsl #24
   134bc: e5d54229  ldrb  r4, [r5, #553]  ; 0x229
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   134c0: e5d5222c  ldrb  r2, [r5, #556]  ; 0x22c
   134c4: e1833c0e  orr r3, r3, lr, lsl #24
   134c8: e5d5e22d  ldrb  lr, [r5, #557]  ; 0x22d
   134cc: e1801001  orr r1, r0, r1
   134d0: e1833002  orr r3, r3, r2
    if ((LD_WORD(fs->win+BS_55AA) == 0xAA55U) /* Load FSINFO data if available */
      && (LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252U)
      && (LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272U))
    {
#if (_FS_NOFSINFO & 1) == 0
      fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
   134d4: e1812404  orr r2, r1, r4, lsl #8
   134d8: e5852010  str r2, [r5, #16]
#endif
#if (_FS_NOFSINFO & 2) == 0
      fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
   134dc: e183340e  orr r3, r3, lr, lsl #8
   134e0: e585300c  str r3, [r5, #12]
   134e4: eaffffb6  b 133c4 <find_volume+0x300>
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
   134e8: e35b0000  cmp fp, #0
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   134ec: e2800002  add r0, r0, #2
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   134f0: e0864004  add r4, r6, r4
  fs->database = bsect + sysect;            /* Data start sector */
   134f4: e0899006  add r9, r9, r6
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   134f8: e5850014  str r0, [r5, #20]
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   134fc: e5854020  str r4, [r5, #32]
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
  fs->volbase = bsect;                /* Volume start sector */
   13500: e585601c  str r6, [r5, #28]
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
  fs->database = bsect + sysect;            /* Data start sector */
   13504: e5859028  str r9, [r5, #40] ; 0x28
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
   13508: 0affff28  beq 131b0 <find_volume+0xec>
      return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
   1350c: e1a00080  lsl r0, r0, #1
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
      return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
   13510: e08a4004  add r4, sl, r4
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13514: e2803f7f  add r3, r0, #508  ; 0x1fc
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
      return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
   13518: e5854024  str r4, [r5, #36] ; 0x24
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   1351c: e2833003  add r3, r3, #3
   13520: e15704a3  cmp r7, r3, lsr #9
   13524: 3affff21  bcc 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   13528: e3e03000  mvn r3, #0
  fs->free_clust = 0xFFFFFFFFU;

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   1352c: e3e0207f  mvn r2, #127  ; 0x7f
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   13530: e585300c  str r3, [r5, #12]
  fs->free_clust = 0xFFFFFFFFU;

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   13534: e3a0c002  mov ip, #2
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
  fs->free_clust = 0xFFFFFFFFU;
   13538: e5853010  str r3, [r5, #16]

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   1353c: e5c52005  strb  r2, [r5, #5]
   13540: eaffff9f  b 133c4 <find_volume+0x300>
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
   13544: e35b0000  cmp fp, #0
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   13548: e2800002  add r0, r0, #2
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   1354c: e0864004  add r4, r6, r4
  fs->database = bsect + sysect;            /* Data start sector */
   13550: e0899006  add r9, r9, r6
  if (nclst >= MIN_FAT32) {
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
   13554: e5850014  str r0, [r5, #20]
  fs->volbase = bsect;                /* Volume start sector */
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
   13558: e5854020  str r4, [r5, #32]
    fmt = FS_FAT32;
  }

  /* Boundaries and Limits */
  fs->n_fatent = nclst + 2U;              /* Number of FAT entries */
  fs->volbase = bsect;                /* Volume start sector */
   1355c: e585601c  str r6, [r5, #28]
  fs->fatbase = bsect + nrsv;             /* FAT start sector */
  fs->database = bsect + sysect;            /* Data start sector */
   13560: e5859028  str r9, [r5, #40] ; 0x28
      return FR_NO_FILESYSTEM;    /* (BPB_RootEntCnt must be 0) */
    }
    fs->dirbase = LD_DWORD(fs->win+BPB_RootClus); /* Root directory start cluster */
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
   13564: 0affff11  beq 131b0 <find_volume+0xec>
      return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
   13568: e2003001  and r3, r0, #1
   1356c: e0800080  add r0, r0, r0, lsl #1
   13570: e2833f7f  add r3, r3, #508  ; 0x1fc
    szbfat = fs->n_fatent * 4U;           /* (Needed FAT size) */
  } else {
    if ((!fs->n_rootdir) != 0U) {
      return FR_NO_FILESYSTEM;  /* (BPB_RootEntCnt must not be 0) */
    }
    fs->dirbase = fs->fatbase + fasize;       /* Root directory start sector */
   13574: e08a4004  add r4, sl, r4
   13578: e2833003  add r3, r3, #3
   1357c: e5854024  str r4, [r5, #36] ; 0x24
    szbfat = (((DWORD)fmt) == FS_FAT16) ?         /* (Needed FAT size) */
      (fs->n_fatent * ((DWORD)2U)) : (((fs->n_fatent * (DWORD)3U) / (DWORD)2U) + (fs->n_fatent & (DWORD)1U));
  }
  if (fs->fsize < ((szbfat + (SS(fs) - 1)) / SS(fs))) { /* (BPB_FATSz must not be less than needed) */
   13580: e08300a0  add r0, r3, r0, lsr #1
   13584: e15704a0  cmp r7, r0, lsr #9
   13588: 3affff08  bcc 131b0 <find_volume+0xec>
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   1358c: e3e03000  mvn r3, #0
  fs->free_clust = 0xFFFFFFFFU;

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   13590: e3e0207f  mvn r2, #127  ; 0x7f
    return FR_NO_FILESYSTEM;
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
   13594: e585300c  str r3, [r5, #12]
  }
  nclst = (tsect - sysect) / ((DWORD)fs->csize);        /* Number of clusters */
  if ((!nclst) != 0U) {
    return FR_NO_FILESYSTEM;        /* (Invalid volume size) */
  }
  fmt = FS_FAT12;
   13598: e3a0c001  mov ip, #1
  }

#if !_FS_READONLY
  /* Initialize cluster allocation information */
  fs->last_clust = 0xFFFFFFFFU;
  fs->free_clust = 0xFFFFFFFFU;
   1359c: e5853010  str r3, [r5, #16]

  /* Get fsinfo if available */
  fs->fsi_flag = 0x80U;
   135a0: e5c52005  strb  r2, [r5, #5]
   135a4: eaffff86  b 133c4 <find_volume+0x300>

000135a8 <get_fat.part.6>:
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat ( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
   135a8: e92d4070  push  {r4, r5, r6, lr}
   135ac: e1a04000  mov r4, r0

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
    Status = (DWORD)1;
  }
  else{
  switch (fs->fs_type) {
   135b0: e5d03000  ldrb  r3, [r0]
/*-----------------------------------------------------------------------*/
/* FAT access - Read value of a FAT entry                                */
/*-----------------------------------------------------------------------*/


DWORD get_fat ( /* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
   135b4: e1a05001  mov r5, r1

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
    Status = (DWORD)1;
  }
  else{
  switch (fs->fs_type) {
   135b8: e3530002  cmp r3, #2
   135bc: 0a00002d  beq 13678 <get_fat.part.6+0xd0>
   135c0: e3530003  cmp r3, #3
   135c4: 0a000017  beq 13628 <get_fat.part.6+0x80>
   135c8: e3530001  cmp r3, #1
   135cc: 0a000001  beq 135d8 <get_fat.part.6+0x30>
  DWORD clst  /* Cluster# to get the link information */
)
{
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;
   135d0: e3e00000  mvn r0, #0
    /* This is added for Misrac Compliance */
    break;
  }
  }
  return Status;  /* An error occurred at the disk I/O layer */
}
   135d4: e8bd8070  pop {r4, r5, r6, pc}
    Status = (DWORD)1;
  }
  else{
  switch (fs->fs_type) {
  case FS_FAT12 :
    bc = (UINT)clst; bc += bc / 2;
   135d8: e08160a1  add r6, r1, r1, lsr #1
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
   135dc: e5901020  ldr r1, [r0, #32]
   135e0: e08114a6  add r1, r1, r6, lsr #9
   135e4: ebfffe71  bl  12fb0 <move_window>
   135e8: e3500000  cmp r0, #0
   135ec: 1afffff7  bne 135d0 <get_fat.part.6+0x28>
      break;
    }
    wc = (UINT)fs->win[bc % (UINT)SS(fs)]; bc++;
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
   135f0: e5941020  ldr r1, [r4, #32]
  case FS_FAT12 :
    bc = (UINT)clst; bc += bc / 2;
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
      break;
    }
    wc = (UINT)fs->win[bc % (UINT)SS(fs)]; bc++;
   135f4: e7e83056  ubfx  r3, r6, #0, #9
   135f8: e2866001  add r6, r6, #1
   135fc: e0843003  add r3, r4, r3
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
   13600: e1a00004  mov r0, r4
   13604: e08114a6  add r1, r1, r6, lsr #9
  case FS_FAT12 :
    bc = (UINT)clst; bc += bc / 2;
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
      break;
    }
    wc = (UINT)fs->win[bc % (UINT)SS(fs)]; bc++;
   13608: e5d34040  ldrb  r4, [r3, #64] ; 0x40
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
   1360c: ebfffe67  bl  12fb0 <move_window>
   13610: e3500000  cmp r0, #0
   13614: 1affffed  bne 135d0 <get_fat.part.6+0x28>
      break;
    }
    temp = fs->win[bc % (UINT)SS(fs)] << 4;
    temp = temp << 4;
    wc |= temp;
    Status = (DWORD)(((clst & (DWORD)1) == (DWORD)(1U)) ? (DWORD)((DWORD)wc >> 4) : (DWORD)((DWORD)wc & (DWORD)0xFFFU));
   13618: e3150001  tst r5, #1
  case FS_FAT12 :
    bc = (UINT)clst; bc += bc / 2;
    if (move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs))) > 0){
      break;
    }
    wc = (UINT)fs->win[bc % (UINT)SS(fs)]; bc++;
   1361c: e1a00004  mov r0, r4
      break;
    }
    temp = fs->win[bc % (UINT)SS(fs)] << 4;
    temp = temp << 4;
    wc |= temp;
    Status = (DWORD)(((clst & (DWORD)1) == (DWORD)(1U)) ? (DWORD)((DWORD)wc >> 4) : (DWORD)((DWORD)wc & (DWORD)0xFFFU));
   13620: 11a00224  lsrne r0, r4, #4
   13624: e8bd8070  pop {r4, r5, r6, pc}
    p = &fs->win[(clst * 2) % SS(fs)];
    Status = (DWORD)LD_WORD(p);
    break;

  case FS_FAT32 :
    if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) > 0){
   13628: e5901020  ldr r1, [r0, #32]
   1362c: e08113a5  add r1, r1, r5, lsr #7
   13630: ebfffe5e  bl  12fb0 <move_window>
   13634: e3500000  cmp r0, #0
   13638: 1affffe4  bne 135d0 <get_fat.part.6+0x28>
      break;
    }
    p = &fs->win[(clst * 4) % SS(fs)];
   1363c: e1a05105  lsl r5, r5, #2
   13640: e2055f7f  and r5, r5, #508  ; 0x1fc
   13644: e2853040  add r3, r5, #64 ; 0x40
    Status = (LD_DWORD(p) & (DWORD)0x0FFFFFFFU);
   13648: e0845005  add r5, r4, r5

  case FS_FAT32 :
    if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) > 0){
      break;
    }
    p = &fs->win[(clst * 4) % SS(fs)];
   1364c: e0844003  add r4, r4, r3
    Status = (LD_DWORD(p) & (DWORD)0x0FFFFFFFU);
   13650: e5d53040  ldrb  r3, [r5, #64] ; 0x40
   13654: e5d42003  ldrb  r2, [r4, #3]
   13658: e5d41002  ldrb  r1, [r4, #2]
   1365c: e5d40001  ldrb  r0, [r4, #1]
   13660: e1a02c02  lsl r2, r2, #24
   13664: e1822801  orr r2, r2, r1, lsl #16
   13668: e1820400  orr r0, r2, r0, lsl #8
   1366c: e1800003  orr r0, r0, r3
   13670: e3c0020f  bic r0, r0, #-268435456 ; 0xf0000000
   13674: e8bd8070  pop {r4, r5, r6, pc}
    wc |= temp;
    Status = (DWORD)(((clst & (DWORD)1) == (DWORD)(1U)) ? (DWORD)((DWORD)wc >> 4) : (DWORD)((DWORD)wc & (DWORD)0xFFFU));
    break;

  case FS_FAT16 :
    if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) > 0){
   13678: e5901020  ldr r1, [r0, #32]
   1367c: e0811425  add r1, r1, r5, lsr #8
   13680: ebfffe4a  bl  12fb0 <move_window>
   13684: e3500000  cmp r0, #0
   13688: 1affffd0  bne 135d0 <get_fat.part.6+0x28>
      break;
    }
    p = &fs->win[(clst * 2) % SS(fs)];
   1368c: e1a05085  lsl r5, r5, #1
   13690: e30031fe  movw  r3, #510  ; 0x1fe
   13694: e0033005  and r3, r3, r5
    Status = (DWORD)LD_WORD(p);
   13698: e0842003  add r2, r4, r3
   1369c: e5d20041  ldrb  r0, [r2, #65] ; 0x41
   136a0: e1a04002  mov r4, r2
   136a4: e5d23040  ldrb  r3, [r2, #64] ; 0x40
   136a8: e1830400  orr r0, r3, r0, lsl #8
   136ac: e8bd8070  pop {r4, r5, r6, pc}

000136b0 <dir_sdi>:
static
FRESULT dir_sdi (
  DIR* dp,    /* Pointer to directory object */
  UINT idx    /* Index of directory table */
)
{
   136b0: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  WORD LocalDirectory = (WORD)idx;
   136b4: e6ff2071  uxth  r2, r1
  DWORD clst, sect;
  UINT ic;


  dp->index = (WORD)LocalDirectory; /* Current index */
  clst = dp->sclust;    /* Table start cluster (0:root) */
   136b8: e5903008  ldr r3, [r0, #8]
static
FRESULT dir_sdi (
  DIR* dp,    /* Pointer to directory object */
  UINT idx    /* Index of directory table */
)
{
   136bc: e1a04000  mov r4, r0
   136c0: e1a06001  mov r6, r1
  WORD LocalDirectory = (WORD)idx;
  DWORD clst, sect;
  UINT ic;


  dp->index = (WORD)LocalDirectory; /* Current index */
   136c4: e1c020b6  strh  r2, [r0, #6]
  clst = dp->sclust;    /* Table start cluster (0:root) */
  if (((clst == 1U) !=0) || ((clst >= dp->fs->n_fatent) !=0)) { /* Check start cluster range */
   136c8: e3530001  cmp r3, #1
   136cc: 0a000003  beq 136e0 <dir_sdi+0x30>
   136d0: e5900000  ldr r0, [r0]
   136d4: e590c014  ldr ip, [r0, #20]
   136d8: e153000c  cmp r3, ip
   136dc: 3a000001  bcc 136e8 <dir_sdi+0x38>
    return FR_INT_ERR;
   136e0: e3a00002  mov r0, #2
   136e4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  }
  if ((clst == ((DWORD)0U)) && ((dp->fs->fs_type == FS_FAT32) != 0U)) { /* Replace cluster# 0 with root cluster# if in FAT32 */
   136e8: e3530000  cmp r3, #0
   136ec: e1a05002  mov r5, r2
   136f0: 1a000017  bne 13754 <dir_sdi+0xa4>
   136f4: e5d01000  ldrb  r1, [r0]
   136f8: e3510003  cmp r1, #3
   136fc: 0a000010  beq 13744 <dir_sdi+0x94>
    clst = dp->fs->dirbase;
  }

  if (clst == 0U) { /* Static table (root-directory in FAT12/16) */
    if (LocalDirectory >= dp->fs->n_rootdir) {  /* Is index out of range? */
   13700: e1d010b8  ldrh  r1, [r0, #8]
   13704: e1510002  cmp r1, r2
      return FR_INT_ERR;
    }
    sect = dp->fs->dirbase;
   13708: 85902024  ldrhi r2, [r0, #36] ; 0x24
  if ((clst == ((DWORD)0U)) && ((dp->fs->fs_type == FS_FAT32) != 0U)) { /* Replace cluster# 0 with root cluster# if in FAT32 */
    clst = dp->fs->dirbase;
  }

  if (clst == 0U) { /* Static table (root-directory in FAT12/16) */
    if (LocalDirectory >= dp->fs->n_rootdir) {  /* Is index out of range? */
   1370c: 9afffff3  bls 136e0 <dir_sdi+0x30>
      LocalDirectory -= (WORD)ic;
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
   13710: e3520000  cmp r2, #0
      }
      LocalDirectory -= (WORD)ic;
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
   13714: e584300c  str r3, [r4, #12]
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
   13718: 0afffff0  beq 136e0 <dir_sdi+0x30>
  dp->sect = sect + ((DWORD)idx / ((DWORD)SS(dp->fs) / (DWORD)SZ_DIR));         /* Sector# of the directory entry */
  dp->dir = dp->fs->win + ((idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Ptr to the entry in the sector */
   1371c: e206300f  and r3, r6, #15
   13720: e5941000  ldr r1, [r4]
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
  dp->sect = sect + ((DWORD)idx / ((DWORD)SS(dp->fs) / (DWORD)SZ_DIR));         /* Sector# of the directory entry */
   13724: e0826226  add r6, r2, r6, lsr #4
  dp->dir = dp->fs->win + ((idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Ptr to the entry in the sector */

  return FR_OK;
   13728: e3a00000  mov r0, #0
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
  dp->sect = sect + ((DWORD)idx / ((DWORD)SS(dp->fs) / (DWORD)SZ_DIR));         /* Sector# of the directory entry */
  dp->dir = dp->fs->win + ((idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Ptr to the entry in the sector */
   1372c: e1a03283  lsl r3, r3, #5
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
  dp->sect = sect + ((DWORD)idx / ((DWORD)SS(dp->fs) / (DWORD)SZ_DIR));         /* Sector# of the directory entry */
   13730: e5846010  str r6, [r4, #16]
  dp->dir = dp->fs->win + ((idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Ptr to the entry in the sector */
   13734: e2833040  add r3, r3, #64 ; 0x40
   13738: e0813003  add r3, r1, r3
   1373c: e5843014  str r3, [r4, #20]

  return FR_OK;
   13740: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  clst = dp->sclust;    /* Table start cluster (0:root) */
  if (((clst == 1U) !=0) || ((clst >= dp->fs->n_fatent) !=0)) { /* Check start cluster range */
    return FR_INT_ERR;
  }
  if ((clst == ((DWORD)0U)) && ((dp->fs->fs_type == FS_FAT32) != 0U)) { /* Replace cluster# 0 with root cluster# if in FAT32 */
    clst = dp->fs->dirbase;
   13744: e5901024  ldr r1, [r0, #36] ; 0x24
  }

  if (clst == 0U) { /* Static table (root-directory in FAT12/16) */
   13748: e3510000  cmp r1, #0
   1374c: 11a03001  movne r3, r1
   13750: 0affffea  beq 13700 <dir_sdi+0x50>
      return FR_INT_ERR;
    }
    sect = dp->fs->dirbase;
  }
  else {        /* Dynamic table (root-directory in FAT32 or sub-directory) */
    ic = (UINT)((UINT)(SS(dp->fs) / SZ_DIR) * (UINT)dp->fs->csize); /* Entries per cluster */
   13754: e5d07002  ldrb  r7, [r0, #2]
   13758: e1a07207  lsl r7, r7, #4
    while (LocalDirectory >= ic) {  /* Follow cluster chain */
   1375c: e1570002  cmp r7, r2
   13760: 9a00000f  bls 137a4 <dir_sdi+0xf4>
   13764: ea000015  b 137c0 <dir_sdi+0x110>
   13768: e1a01003  mov r1, r3
   1376c: e0675005  rsb r5, r7, r5
   13770: ebffff8c  bl  135a8 <get_fat.part.6>
   13774: e6ff5075  uxth  r5, r5
      clst = get_fat(dp->fs, clst);       /* Get next cluster */
      if (clst == 0xFFFFFFFFU) {
   13778: e3700001  cmn r0, #1
   1377c: e1a03000  mov r3, r0
   13780: 0a000016  beq 137e0 <dir_sdi+0x130>
         return FR_DISK_ERR;  /* Disk error */
      }
      if (((clst < 2U) != 0U) || ((clst >= dp->fs->n_fatent) != 0U)) {  /* Reached to end of table or internal error */
   13784: e3500001  cmp r0, #1
   13788: 9affffd4  bls 136e0 <dir_sdi+0x30>
   1378c: e5940000  ldr r0, [r4]
   13790: e590c014  ldr ip, [r0, #20]
   13794: e15c0003  cmp ip, r3
   13798: 9affffd0  bls 136e0 <dir_sdi+0x30>
    }
    sect = dp->fs->dirbase;
  }
  else {        /* Dynamic table (root-directory in FAT32 or sub-directory) */
    ic = (UINT)((UINT)(SS(dp->fs) / SZ_DIR) * (UINT)dp->fs->csize); /* Entries per cluster */
    while (LocalDirectory >= ic) {  /* Follow cluster chain */
   1379c: e1570005  cmp r7, r5
   137a0: 8a000006  bhi 137c0 <dir_sdi+0x110>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   137a4: e3530001  cmp r3, #1
   137a8: 9affffcc  bls 136e0 <dir_sdi+0x30>
   137ac: e5902014  ldr r2, [r0, #20]
   137b0: e1520003  cmp r2, r3
   137b4: 8affffeb  bhi 13768 <dir_sdi+0xb8>


  dp->index = (WORD)LocalDirectory; /* Current index */
  clst = dp->sclust;    /* Table start cluster (0:root) */
  if (((clst == 1U) !=0) || ((clst >= dp->fs->n_fatent) !=0)) { /* Check start cluster range */
    return FR_INT_ERR;
   137b8: e3a00002  mov r0, #2
   137bc: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   137c0: e24cc002  sub ip, ip, #2
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   137c4: e2431002  sub r1, r3, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   137c8: e151000c  cmp r1, ip
   137cc: 2a000005  bcs 137e8 <dir_sdi+0x138>
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   137d0: e5d0c002  ldrb  ip, [r0, #2]
   137d4: e5902028  ldr r2, [r0, #40] ; 0x28
   137d8: e022219c  mla r2, ip, r1, r2
   137dc: eaffffcb  b 13710 <dir_sdi+0x60>
  else {        /* Dynamic table (root-directory in FAT32 or sub-directory) */
    ic = (UINT)((UINT)(SS(dp->fs) / SZ_DIR) * (UINT)dp->fs->csize); /* Entries per cluster */
    while (LocalDirectory >= ic) {  /* Follow cluster chain */
      clst = get_fat(dp->fs, clst);       /* Get next cluster */
      if (clst == 0xFFFFFFFFU) {
         return FR_DISK_ERR;  /* Disk error */
   137e0: e3a00001  mov r0, #1
   137e4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
      LocalDirectory -= (WORD)ic;
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
   137e8: e3a00002  mov r0, #2
      }
      LocalDirectory -= (WORD)ic;
    }
    sect = clust2sect(dp->fs, clst);
  }
  dp->clust = clst; /* Current cluster# */
   137ec: e584300c  str r3, [r4, #12]
  if (sect == ((DWORD)0U)) {return FR_INT_ERR;}
  dp->sect = sect + ((DWORD)idx / ((DWORD)SS(dp->fs) / (DWORD)SZ_DIR));         /* Sector# of the directory entry */
  dp->dir = dp->fs->win + ((idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Ptr to the entry in the sector */

  return FR_OK;
}
   137f0: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

000137f4 <dir_remove>:
#if !_FS_READONLY && !_FS_MINIMIZE
static
FRESULT dir_remove (  /* FR_OK: Successful, FR_DISK_ERR: A disk error */
  DIR* dp       /* Directory object pointing the entry to be removed */
)
{
   137f4: e92d4010  push  {r4, lr}
   137f8: e1a04000  mov r4, r0
    }
  }

#else     /* Non LFN configuration */
  temp = dp->index;
  res = dir_sdi(dp, temp);
   137fc: e1d010b6  ldrh  r1, [r0, #6]
   13800: ebffffaa  bl  136b0 <dir_sdi>
  if (res == FR_OK) {
   13804: e3500000  cmp r0, #0
   13808: 18bd8010  popne {r4, pc}
    res = move_window(dp->fs, dp->sect);
   1380c: e5940000  ldr r0, [r4]
   13810: e5941010  ldr r1, [r4, #16]
   13814: ebfffde5  bl  12fb0 <move_window>
    if (res == FR_OK) {
   13818: e3500000  cmp r0, #0
   1381c: 18bd8010  popne {r4, pc}
      mem_set(dp->dir, 0, SZ_DIR);  /* Clear and mark the entry "deleted" */
   13820: e5943014  ldr r3, [r4, #20]
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   13824: e1a01000  mov r1, r0
   13828: e2832020  add r2, r3, #32
   1382c: e4c31001  strb  r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   13830: e1530002  cmp r3, r2
   13834: 1afffffc  bne 1382c <dir_remove+0x38>
  res = dir_sdi(dp, temp);
  if (res == FR_OK) {
    res = move_window(dp->fs, dp->sect);
    if (res == FR_OK) {
      mem_set(dp->dir, 0, SZ_DIR);  /* Clear and mark the entry "deleted" */
      *dp->dir = DDE;
   13838: e5943014  ldr r3, [r4, #20]
   1383c: e3e0101a  mvn r1, #26
      dp->fs->wflag = 1U;
   13840: e3a02001  mov r2, #1
  res = dir_sdi(dp, temp);
  if (res == FR_OK) {
    res = move_window(dp->fs, dp->sect);
    if (res == FR_OK) {
      mem_set(dp->dir, 0, SZ_DIR);  /* Clear and mark the entry "deleted" */
      *dp->dir = DDE;
   13844: e5c31000  strb  r1, [r3]
      dp->fs->wflag = 1U;
   13848: e5943000  ldr r3, [r4]
   1384c: e5c32004  strb  r2, [r3, #4]
    }
  }
#endif

  return res;
}
   13850: e8bd8010  pop {r4, pc}

00013854 <put_fat.part.8>:
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
   13854: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
   13858: e1a04000  mov r4, r0

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
    res = FR_INT_ERR;

  } else {
    switch (fs->fs_type) {
   1385c: e5d06000  ldrb  r6, [r0]
/*-----------------------------------------------------------------------*/
/* FAT access - Change value of a FAT entry                              */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY

FRESULT put_fat (
   13860: e1a05001  mov r5, r1
   13864: e1a08002  mov r8, r2

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
    res = FR_INT_ERR;

  } else {
    switch (fs->fs_type) {
   13868: e3560002  cmp r6, #2
   1386c: 0a000035  beq 13948 <put_fat.part.8+0xf4>
   13870: e3560003  cmp r6, #3
   13874: 0a00001e  beq 138f4 <put_fat.part.8+0xa0>
   13878: e3560001  cmp r6, #1
      LocVal |= LD_DWORD(p) & 0xF0000000U;
      ST_DWORD(p, LocVal);
      break;

    default :
      res = FR_INT_ERR;
   1387c: 13a07002  movne r7, #2

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
    res = FR_INT_ERR;

  } else {
    switch (fs->fs_type) {
   13880: 0a000003  beq 13894 <put_fat.part.8+0x40>

    default :
      res = FR_INT_ERR;
      break;
    }
    fs->wflag = 1U;
   13884: e3a03001  mov r3, #1
  }

  return res;
}
   13888: e1a00007  mov r0, r7

    default :
      res = FR_INT_ERR;
      break;
    }
    fs->wflag = 1U;
   1388c: e5c43004  strb  r3, [r4, #4]
  }

  return res;
}
   13890: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
    res = FR_INT_ERR;

  } else {
    switch (fs->fs_type) {
    case FS_FAT12 :
      bc = (UINT)clst; bc += bc / 2;
   13894: e08190a1  add r9, r1, r1, lsr #1
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   13898: e5901020  ldr r1, [r0, #32]
   1389c: e08114a9  add r1, r1, r9, lsr #9
   138a0: ebfffdc2  bl  12fb0 <move_window>
      if (res != FR_OK){
   138a4: e2507000  subs  r7, r0, #0
   138a8: 1afffff5  bne 13884 <put_fat.part.8+0x30>
        break;
      }
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
   138ac: e3150001  tst r5, #1
      bc = (UINT)clst; bc += bc / 2;
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[bc % SS(fs)];
   138b0: e7e83059  ubfx  r3, r9, #0, #9
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
   138b4: e0843003  add r3, r4, r3
      bc++;
   138b8: e2899001  add r9, r9, #1
      fs->wflag = 1U;
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   138bc: e5941020  ldr r1, [r4, #32]
   138c0: e1a00004  mov r0, r4
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
   138c4: 0a00002e  beq 13984 <put_fat.part.8+0x130>
   138c8: e5d32040  ldrb  r2, [r3, #64] ; 0x40
      bc++;
      fs->wflag = 1U;
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   138cc: e08114a9  add r1, r1, r9, lsr #9
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
   138d0: e202200f  and r2, r2, #15
   138d4: e1822208  orr r2, r2, r8, lsl #4
   138d8: e5c32040  strb  r2, [r3, #64] ; 0x40
      bc++;
      fs->wflag = 1U;
   138dc: e5c46004  strb  r6, [r4, #4]
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   138e0: ebfffdb2  bl  12fb0 <move_window>
      if (res != FR_OK){
   138e4: e3500000  cmp r0, #0
   138e8: 0a000033  beq 139bc <put_fat.part.8+0x168>
   138ec: e1a07000  mov r7, r0
   138f0: eaffffe3  b 13884 <put_fat.part.8+0x30>
      p = &fs->win[(clst * 2) % SS(fs)];
      ST_WORD(p, (WORD)LocVal);
      break;

    case FS_FAT32 :
      res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   138f4: e5901020  ldr r1, [r0, #32]
   138f8: e08113a5  add r1, r1, r5, lsr #7
   138fc: ebfffdab  bl  12fb0 <move_window>
      if (res != FR_OK){
   13900: e2507000  subs  r7, r0, #0
   13904: 1affffde  bne 13884 <put_fat.part.8+0x30>
        break;
      }
      p = &fs->win[(clst * 4) % SS(fs)];
   13908: e1a05105  lsl r5, r5, #2
   1390c: e2055f7f  and r5, r5, #508  ; 0x1fc
   13910: e2855040  add r5, r5, #64 ; 0x40
   13914: e0843005  add r3, r4, r5
      LocVal |= LD_DWORD(p) & 0xF0000000U;
   13918: e5d32003  ldrb  r2, [r3, #3]
   1391c: e1a02c02  lsl r2, r2, #24
   13920: e202220f  and r2, r2, #-268435456 ; 0xf0000000
   13924: e1828008  orr r8, r2, r8
      ST_DWORD(p, LocVal);
   13928: e7848005  str r8, [r4, r5]
   1392c: e1a01428  lsr r1, r8, #8
   13930: e1a02828  lsr r2, r8, #16
   13934: e5c31001  strb  r1, [r3, #1]
   13938: e1a08c28  lsr r8, r8, #24
   1393c: e5c32002  strb  r2, [r3, #2]
   13940: e5c38003  strb  r8, [r3, #3]
   13944: eaffffce  b 13884 <put_fat.part.8+0x30>
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? (BYTE)(LocVal >> 4) : ((*p & 0xF0U) | ((BYTE)(LocVal >> 8) & 0x0FU)));
      break;

    case FS_FAT16 :
      res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   13948: e5901020  ldr r1, [r0, #32]
   1394c: e0811425  add r1, r1, r5, lsr #8
   13950: ebfffd96  bl  12fb0 <move_window>
      if (res != FR_OK){
   13954: e2507000  subs  r7, r0, #0
   13958: 1affffc9  bne 13884 <put_fat.part.8+0x30>
        break;
      }
      p = &fs->win[(clst * 2) % SS(fs)];
   1395c: e1a05085  lsl r5, r5, #1
   13960: e30031fe  movw  r3, #510  ; 0x1fe
   13964: e0033005  and r3, r3, r5
      ST_WORD(p, (WORD)LocVal);
   13968: e6ff8078  uxth  r8, r8
    case FS_FAT16 :
      res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[(clst * 2) % SS(fs)];
   1396c: e2833040  add r3, r3, #64 ; 0x40
   13970: e0842003  add r2, r4, r3
      ST_WORD(p, (WORD)LocVal);
   13974: e1a01428  lsr r1, r8, #8
   13978: e18480b3  strh  r8, [r4, r3]
   1397c: e1c210b1  strh  r1, [r2, #1]
   13980: eaffffbf  b 13884 <put_fat.part.8+0x30>
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
   13984: e5c38040  strb  r8, [r3, #64] ; 0x40
      bc++;
      fs->wflag = 1U;
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   13988: e08114a9  add r1, r1, r9, lsr #9
        break;
      }
      p = &fs->win[bc % SS(fs)];
      *p = (((clst & 1U) == 1U) ? ((*p & 0x0FU) | ((BYTE)LocVal << 4)) : (BYTE)LocVal);
      bc++;
      fs->wflag = 1U;
   1398c: e5c46004  strb  r6, [r4, #4]
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
   13990: ebfffd86  bl  12fb0 <move_window>
      if (res != FR_OK){
   13994: e3500000  cmp r0, #0
   13998: 1affffd3  bne 138ec <put_fat.part.8+0x98>
        break;
      }
      p = &fs->win[bc % SS(fs)];
   1399c: e7e89059  ubfx  r9, r9, #0, #9
      *p = (((clst & 1U) == 1U) ? (BYTE)(LocVal >> 4) : ((*p & 0xF0U) | ((BYTE)(LocVal >> 8) & 0x0FU)));
   139a0: e7e38458  ubfx  r8, r8, #8, #4
   139a4: e0849009  add r9, r4, r9
   139a8: e5d93040  ldrb  r3, [r9, #64] ; 0x40
   139ac: e3c3300f  bic r3, r3, #15
   139b0: e1838008  orr r8, r3, r8
   139b4: e5c98040  strb  r8, [r9, #64] ; 0x40
   139b8: eaffffb1  b 13884 <put_fat.part.8+0x30>
      fs->wflag = 1U;
      res = move_window(fs, fs->fatbase + ((DWORD)bc / (DWORD)SS(fs)));
      if (res != FR_OK){
        break;
      }
      p = &fs->win[bc % SS(fs)];
   139bc: e7e89059  ubfx  r9, r9, #0, #9
      *p = (((clst & 1U) == 1U) ? (BYTE)(LocVal >> 4) : ((*p & 0xF0U) | ((BYTE)(LocVal >> 8) & 0x0FU)));
   139c0: e7e78258  ubfx  r8, r8, #4, #8
   139c4: e0849009  add r9, r4, r9
   139c8: eafffff9  b 139b4 <put_fat.part.8+0x160>

000139cc <create_chain>:
static
DWORD create_chain (  /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
  FATFS* fs,      /* File system object */
  DWORD clst      /* Cluster# to stretch. 0 means create a new chain. */
)
{
   139cc: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  DWORD cs, ncl, scl;
  FRESULT res;


  if (clst == 0U) {   /* Create a new chain */
   139d0: e2517000  subs  r7, r1, #0
static
DWORD create_chain (  /* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
  FATFS* fs,      /* File system object */
  DWORD clst      /* Cluster# to stretch. 0 means create a new chain. */
)
{
   139d4: e1a06000  mov r6, r0
  DWORD cs, ncl, scl;
  FRESULT res;


  if (clst == 0U) {   /* Create a new chain */
   139d8: 1a00001c  bne 13a50 <create_chain+0x84>
    scl = fs->last_clust;     /* Get suggested start point */
   139dc: e590500c  ldr r5, [r0, #12]
   139e0: e5903014  ldr r3, [r0, #20]
    if (((!scl) != 0U) || ((scl >= fs->n_fatent) != 0U)){
   139e4: e3550000  cmp r5, #0
      scl = 1U;
   139e8: 03a05001  moveq r5, #1
  FRESULT res;


  if (clst == 0U) {   /* Create a new chain */
    scl = fs->last_clust;     /* Get suggested start point */
    if (((!scl) != 0U) || ((scl >= fs->n_fatent) != 0U)){
   139ec: 1a000026  bne 13a8c <create_chain+0xc0>
      scl = 1U;
   139f0: e1a04005  mov r4, r5
    scl = clst;
  }

  ncl = scl;        /* Start cluster */
  for (;;) {
    ncl++;              /* Next cluster */
   139f4: e2844001  add r4, r4, #1
    if (ncl >= fs->n_fatent) {    /* Wrap around */
   139f8: e1540003  cmp r4, r3
   139fc: 3a000005  bcc 13a18 <create_chain+0x4c>
      ncl = 2U;
      if (ncl > scl) {
   13a00: e3550001  cmp r5, #1
   13a04: 9a000023  bls 13a98 <create_chain+0xcc>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   13a08: e3530002  cmp r3, #2
   13a0c: 8a00004d  bhi 13b48 <create_chain+0x17c>
    if (fs->free_clust != 0xFFFFFFFFU) {
      fs->free_clust--;
      fs->fsi_flag |= 1U;
    }
  } else {
    ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFFU : 1U;
   13a10: e3a00001  mov r0, #1
   13a14: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   13a18: e3540001  cmp r4, #1
   13a1c: 9afffffb  bls 13a10 <create_chain+0x44>
   13a20: e1a00006  mov r0, r6
   13a24: e1a01004  mov r1, r4
   13a28: ebfffede  bl  135a8 <get_fat.part.6>
      if (ncl > scl) {
        return 0; /* No free cluster */
      }
    }
    cs = get_fat(fs, ncl);      /* Get the cluster status */
    if (cs == 0U) {
   13a2c: e3500000  cmp r0, #0
   13a30: 0a00001a  beq 13aa0 <create_chain+0xd4>
      break;        /* Found a free cluster */
    }
    if ((cs == 0xFFFFFFFFU) || (cs == 1U)) {/* An error occurred */
   13a34: e3700001  cmn r0, #1
   13a38: 13500001  cmpne r0, #1
   13a3c: 0a000040  beq 13b44 <create_chain+0x178>
      return cs;
    }
    if (ncl == scl) {
   13a40: e1550004  cmp r5, r4
   13a44: 0a000013  beq 13a98 <create_chain+0xcc>
   13a48: e5963014  ldr r3, [r6, #20]
   13a4c: eaffffe8  b 139f4 <create_chain+0x28>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   13a50: e3570001  cmp r7, #1
   13a54: 9affffed  bls 13a10 <create_chain+0x44>
   13a58: e5903014  ldr r3, [r0, #20]
   13a5c: e1570003  cmp r7, r3
   13a60: 2affffea  bcs 13a10 <create_chain+0x44>
   13a64: ebfffecf  bl  135a8 <get_fat.part.6>
      scl = 1U;
    }
  }
  else {          /* Stretch the current chain */
    cs = get_fat(fs, clst);     /* Check the cluster status */
    if (cs < 2U) {
   13a68: e3500001  cmp r0, #1
   13a6c: 9affffe7  bls 13a10 <create_chain+0x44>
      return (DWORD)1;      /* Invalid value */
    }
    if (cs == (DWORD)0xFFFFFFFFU) {
   13a70: e3700001  cmn r0, #1
   13a74: 0a00002e  beq 13b34 <create_chain+0x168>
      return cs;  /* A disk error occurred */
    }
    if (cs < fs->n_fatent) {
   13a78: e5963014  ldr r3, [r6, #20]
   13a7c: e1530000  cmp r3, r0
   13a80: 88bd80f8  pophi {r3, r4, r5, r6, r7, pc}
   13a84: e1a05007  mov r5, r7
   13a88: eaffffd8  b 139f0 <create_chain+0x24>


  if (clst == 0U) {   /* Create a new chain */
    scl = fs->last_clust;     /* Get suggested start point */
    if (((!scl) != 0U) || ((scl >= fs->n_fatent) != 0U)){
      scl = 1U;
   13a8c: e1550003  cmp r5, r3
   13a90: 23a05001  movcs r5, #1
   13a94: eaffffd5  b 139f0 <create_chain+0x24>
  for (;;) {
    ncl++;              /* Next cluster */
    if (ncl >= fs->n_fatent) {    /* Wrap around */
      ncl = 2U;
      if (ncl > scl) {
        return 0; /* No free cluster */
   13a98: e3a00000  mov r0, #0
   13a9c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  UINT bc;
  BYTE *p;
  FRESULT res;
  DWORD LocVal = val;

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
   13aa0: e5963014  ldr r3, [r6, #20]
   13aa4: e1540003  cmp r4, r3
   13aa8: 2affffd8  bcs 13a10 <create_chain+0x44>
   13aac: e1a00006  mov r0, r6
   13ab0: e1a01004  mov r1, r4
   13ab4: e3e0220f  mvn r2, #-268435456 ; 0xf0000000
   13ab8: ebffff65  bl  13854 <put_fat.part.8>
      return 0;   /* No free cluster */
    }
  }

  res = put_fat(fs, ncl, 0x0FFFFFFFU);  /* Mark the new cluster "last link" */
  if ((res == FR_OK) && (clst != 0U)) {
   13abc: e3570000  cmp r7, #0
   13ac0: e16f3f10  clz r3, r0
   13ac4: e1a032a3  lsr r3, r3, #5
   13ac8: 03a03000  moveq r3, #0
   13acc: e3530000  cmp r3, #0
   13ad0: 0a000008  beq 13af8 <create_chain+0x12c>
  UINT bc;
  BYTE *p;
  FRESULT res;
  DWORD LocVal = val;

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
   13ad4: e3570001  cmp r7, #1
   13ad8: 9affffcc  bls 13a10 <create_chain+0x44>
   13adc: e5963014  ldr r3, [r6, #20]
   13ae0: e1570003  cmp r7, r3
   13ae4: 2affffc9  bcs 13a10 <create_chain+0x44>
   13ae8: e1a01007  mov r1, r7
   13aec: e1a00006  mov r0, r6
   13af0: e1a02004  mov r2, r4
   13af4: ebffff56  bl  13854 <put_fat.part.8>

  res = put_fat(fs, ncl, 0x0FFFFFFFU);  /* Mark the new cluster "last link" */
  if ((res == FR_OK) && (clst != 0U)) {
    res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
  }
  if (res == FR_OK) {
   13af8: e3500000  cmp r0, #0
   13afc: 1a00000a  bne 13b2c <create_chain+0x160>
    fs->last_clust = ncl;     /* Update FSINFO */
    if (fs->free_clust != 0xFFFFFFFFU) {
   13b00: e5963010  ldr r3, [r6, #16]
  res = put_fat(fs, ncl, 0x0FFFFFFFU);  /* Mark the new cluster "last link" */
  if ((res == FR_OK) && (clst != 0U)) {
    res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
  }
  if (res == FR_OK) {
    fs->last_clust = ncl;     /* Update FSINFO */
   13b04: e586400c  str r4, [r6, #12]
    if (fs->free_clust != 0xFFFFFFFFU) {
   13b08: e3730001  cmn r3, #1
   13b0c: 0a00000a  beq 13b3c <create_chain+0x170>
      fs->free_clust--;
      fs->fsi_flag |= 1U;
   13b10: e5d61005  ldrb  r1, [r6, #5]
    res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
  }
  if (res == FR_OK) {
    fs->last_clust = ncl;     /* Update FSINFO */
    if (fs->free_clust != 0xFFFFFFFFU) {
      fs->free_clust--;
   13b14: e2432001  sub r2, r3, #1
      fs->fsi_flag |= 1U;
   13b18: e1a00004  mov r0, r4
    res = put_fat(fs, clst, ncl); /* Link it to the previous one if needed */
  }
  if (res == FR_OK) {
    fs->last_clust = ncl;     /* Update FSINFO */
    if (fs->free_clust != 0xFFFFFFFFU) {
      fs->free_clust--;
   13b1c: e5862010  str r2, [r6, #16]
      fs->fsi_flag |= 1U;
   13b20: e3812001  orr r2, r1, #1
   13b24: e5c62005  strb  r2, [r6, #5]
   13b28: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
    }
  } else {
    ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFFU : 1U;
   13b2c: e3500001  cmp r0, #1
   13b30: 1affffb6  bne 13a10 <create_chain+0x44>
    }
  }
  else {          /* Stretch the current chain */
    cs = get_fat(fs, clst);     /* Check the cluster status */
    if (cs < 2U) {
      return (DWORD)1;      /* Invalid value */
   13b34: e3e00000  mvn r0, #0
   13b38: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
   13b3c: e1a00004  mov r0, r4
  } else {
    ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFFU : 1U;
  }

  return ncl;   /* Return new cluster number or error code */
}
   13b40: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
   13b44: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

  ncl = scl;        /* Start cluster */
  for (;;) {
    ncl++;              /* Next cluster */
    if (ncl >= fs->n_fatent) {    /* Wrap around */
      ncl = 2U;
   13b48: e3a04002  mov r4, #2
   13b4c: eaffffb3  b 13a20 <create_chain+0x54>

00013b50 <dir_next>:
static
FRESULT dir_next (  /* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
  DIR* dp,    /* Pointer to the directory object */
  s32 stretch   /* 0: Do not stretch table, 1: Stretch table if needed */
)
{
   13b50: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
  DWORD clst;
  UINT i;


  i = ((UINT)dp->index + (UINT)1U);
   13b54: e1d040b6  ldrh  r4, [r0, #6]
   13b58: e2844001  add r4, r4, #1
  if (((!(i & 0xFFFFU)) != 0U) || ((!dp->sect) != 0U)) {  /* Report EOT when index has reached 65535 */
   13b5c: e6ff3074  uxth  r3, r4
   13b60: e3530000  cmp r3, #0
   13b64: 1a000001  bne 13b70 <dir_next+0x20>
    return FR_NO_FILE;
   13b68: e3a00004  mov r0, #4
   13b6c: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
  DWORD clst;
  UINT i;


  i = ((UINT)dp->index + (UINT)1U);
  if (((!(i & 0xFFFFU)) != 0U) || ((!dp->sect) != 0U)) {  /* Report EOT when index has reached 65535 */
   13b70: e5903010  ldr r3, [r0, #16]
   13b74: e3530000  cmp r3, #0
   13b78: 0afffffa  beq 13b68 <dir_next+0x18>
    return FR_NO_FILE;
  }

  if ((!(i % (SS(dp->fs) / SZ_DIR))) != 0U) { /* Sector changed? */
   13b7c: e214700f  ands  r7, r4, #15
   13b80: e1a06001  mov r6, r1
   13b84: e1a05000  mov r5, r0
   13b88: 0a000006  beq 13ba8 <dir_next+0x58>
   13b8c: e5900000  ldr r0, [r0]
      }
    }
  }

  dp->index = (WORD)i;  /* Current index */
  dp->dir = dp->fs->win + ((i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Current entry in the window */
   13b90: e0800287  add r0, r0, r7, lsl #5
        dp->sect = clust2sect(dp->fs, clst);
      }
    }
  }

  dp->index = (WORD)i;  /* Current index */
   13b94: e1c540b6  strh  r4, [r5, #6]
  dp->dir = dp->fs->win + ((i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Current entry in the window */
   13b98: e2803040  add r3, r0, #64 ; 0x40

  return FR_OK;
   13b9c: e3a00000  mov r0, #0
      }
    }
  }

  dp->index = (WORD)i;  /* Current index */
  dp->dir = dp->fs->win + ((i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR); /* Current entry in the window */
   13ba0: e5853014  str r3, [r5, #20]

  return FR_OK;
   13ba4: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
  }

  if ((!(i % (SS(dp->fs) / SZ_DIR))) != 0U) { /* Sector changed? */
    dp->sect++;         /* Next sector */

    if ((!dp->clust) != 0U) {   /* Static table */
   13ba8: e590100c  ldr r1, [r0, #12]
  if (((!(i & 0xFFFFU)) != 0U) || ((!dp->sect) != 0U)) {  /* Report EOT when index has reached 65535 */
    return FR_NO_FILE;
  }

  if ((!(i % (SS(dp->fs) / SZ_DIR))) != 0U) { /* Sector changed? */
    dp->sect++;         /* Next sector */
   13bac: e2833001  add r3, r3, #1
   13bb0: e5803010  str r3, [r0, #16]

    if ((!dp->clust) != 0U) {   /* Static table */
   13bb4: e3510000  cmp r1, #0
      if (i >= dp->fs->n_rootdir) { /* Report EOT if it reached end of static table */
   13bb8: e5900000  ldr r0, [r0]
  }

  if ((!(i % (SS(dp->fs) / SZ_DIR))) != 0U) { /* Sector changed? */
    dp->sect++;         /* Next sector */

    if ((!dp->clust) != 0U) {   /* Static table */
   13bbc: 0a00000a  beq 13bec <dir_next+0x9c>
      if (i >= dp->fs->n_rootdir) { /* Report EOT if it reached end of static table */
        return FR_NO_FILE;
      }
    }
    else {          /* Dynamic table */
      if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1U)) == 0U) { /* Cluster changed? */
   13bc0: e5d03002  ldrb  r3, [r0, #2]
   13bc4: e2433001  sub r3, r3, #1
   13bc8: e0133224  ands  r3, r3, r4, lsr #4
   13bcc: 1affffef  bne 13b90 <dir_next+0x40>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   13bd0: e3510001  cmp r1, #1
   13bd4: 9a000002  bls 13be4 <dir_next+0x94>
   13bd8: e5903014  ldr r3, [r0, #20]
   13bdc: e1510003  cmp r1, r3
   13be0: 3a000005  bcc 13bfc <dir_next+0xac>
    }
    else {          /* Dynamic table */
      if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1U)) == 0U) { /* Cluster changed? */
        clst = get_fat(dp->fs, dp->clust);        /* Get next cluster */
        if (clst <= 1U) {
          return FR_INT_ERR;
   13be4: e3a00002  mov r0, #2
   13be8: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}

  if ((!(i % (SS(dp->fs) / SZ_DIR))) != 0U) { /* Sector changed? */
    dp->sect++;         /* Next sector */

    if ((!dp->clust) != 0U) {   /* Static table */
      if (i >= dp->fs->n_rootdir) { /* Report EOT if it reached end of static table */
   13bec: e1d030b8  ldrh  r3, [r0, #8]
   13bf0: e1540003  cmp r4, r3
   13bf4: 2affffdb  bcs 13b68 <dir_next+0x18>
   13bf8: eaffffe4  b 13b90 <dir_next+0x40>
   13bfc: ebfffe69  bl  135a8 <get_fat.part.6>
      }
    }
    else {          /* Dynamic table */
      if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1U)) == 0U) { /* Cluster changed? */
        clst = get_fat(dp->fs, dp->clust);        /* Get next cluster */
        if (clst <= 1U) {
   13c00: e3500001  cmp r0, #1
   13c04: e1a08000  mov r8, r0
   13c08: 9afffff5  bls 13be4 <dir_next+0x94>
          return FR_INT_ERR;
        }
        if (clst == 0xFFFFFFFFU) {
   13c0c: e3700001  cmn r0, #1
   13c10: 0a00001c  beq 13c88 <dir_next+0x138>
          return FR_DISK_ERR;
        }
        if (clst >= dp->fs->n_fatent) {         /* If it reached end of dynamic table, */
   13c14: e5950000  ldr r0, [r5]
   13c18: e5903014  ldr r3, [r0, #20]
   13c1c: e1530008  cmp r3, r8
   13c20: 82486002  subhi r6, r8, #2
   13c24: 8a00000b  bhi 13c58 <dir_next+0x108>
#if !_FS_READONLY
          UINT c;
          if (stretch == ((s32)0)) {
   13c28: e3560000  cmp r6, #0
   13c2c: 0affffcd  beq 13b68 <dir_next+0x18>
            return FR_NO_FILE;      /* If do not stretch, report EOT */
          }
          clst = create_chain(dp->fs, dp->clust);   /* Stretch cluster chain */
   13c30: e595100c  ldr r1, [r5, #12]
   13c34: ebffff64  bl  139cc <create_chain>
          if (clst == 0U) {
   13c38: e2508000  subs  r8, r0, #0
   13c3c: 1a000013  bne 13c90 <dir_next+0x140>
            return FR_DENIED;     /* No free cluster */
   13c40: e3a00007  mov r0, #7
   13c44: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
   13c48: e5903014  ldr r3, [r0, #20]
            if ((sync_window(dp->fs)) != 0U) {
              return FR_DISK_ERR;
            }
            dp->fs->winsect++;
          }
          dp->fs->winsect -= c;           /* Rewind window offset */
   13c4c: e590202c  ldr r2, [r0, #44] ; 0x2c
   13c50: e0699002  rsb r9, r9, r2
   13c54: e580902c  str r9, [r0, #44] ; 0x2c
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   13c58: e2433002  sub r3, r3, #2
            return FR_NO_FILE;      /* If do not stretch, report EOT (this is to suppress warning) */
          }
          return FR_NO_FILE;              /* Report EOT */
#endif
        }
        dp->clust = clst;       /* Initialize data for new cluster */
   13c5c: e585800c  str r8, [r5, #12]
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   13c60: e1560003  cmp r6, r3
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   13c64: 35d02002  ldrbcc  r2, [r0, #2]
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
    res = ((DWORD)0U);    /* Invalid cluster# */
   13c68: 23a06000  movcs r6, #0
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   13c6c: 35903028  ldrcc r3, [r0, #40] ; 0x28
   13c70: 30263692  mlacc r6, r2, r6, r3
          }
          return FR_NO_FILE;              /* Report EOT */
#endif
        }
        dp->clust = clst;       /* Initialize data for new cluster */
        dp->sect = clust2sect(dp->fs, clst);
   13c74: e5856010  str r6, [r5, #16]
   13c78: eaffffc4  b 13b90 <dir_next+0x40>
   13c7c: ebfffc5a  bl  12dec <sync_window.part.3>
          }
          if (clst == 0xFFFFFFFFU) {
            return FR_DISK_ERR;
          }
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
   13c80: e3500000  cmp r0, #0
   13c84: 0a000009  beq 13cb0 <dir_next+0x160>
        clst = get_fat(dp->fs, dp->clust);        /* Get next cluster */
        if (clst <= 1U) {
          return FR_INT_ERR;
        }
        if (clst == 0xFFFFFFFFU) {
          return FR_DISK_ERR;
   13c88: e3a00001  mov r0, #1
   13c8c: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
          }
          clst = create_chain(dp->fs, dp->clust);   /* Stretch cluster chain */
          if (clst == 0U) {
            return FR_DENIED;     /* No free cluster */
          }
          if (clst == 1U) {
   13c90: e3580001  cmp r8, #1
   13c94: 0affffd2  beq 13be4 <dir_next+0x94>
            return FR_INT_ERR;
          }
          if (clst == 0xFFFFFFFFU) {
   13c98: e3780001  cmn r8, #1
   13c9c: 0afffff9  beq 13c88 <dir_next+0x138>
            return FR_DISK_ERR;
          }
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
   13ca0: e5950000  ldr r0, [r5]
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   13ca4: e5d03004  ldrb  r3, [r0, #4]
   13ca8: e3530000  cmp r3, #0
   13cac: 1afffff2  bne 13c7c <dir_next+0x12c>
          }
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
   13cb0: e5952000  ldr r2, [r5]
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   13cb4: e3a01000  mov r1, #0
          }
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
   13cb8: e2823040  add r3, r2, #64 ; 0x40
   13cbc: e2822d09  add r2, r2, #576  ; 0x240
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   13cc0: e4c31001  strb  r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   13cc4: e1530002  cmp r3, r2
   13cc8: 1afffffc  bne 13cc0 <dir_next+0x170>
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
   13ccc: e5953000  ldr r3, [r5]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   13cd0: e2486002  sub r6, r8, #2
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
          for (c = 0U; c < dp->fs->csize; c++) {    /* Fill the new cluster with 0 */
   13cd4: e3a09000  mov r9, #0
            dp->fs->wflag = 1U;
   13cd8: e3a0a001  mov sl, #1
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   13cdc: e5932014  ldr r2, [r3, #20]
   13ce0: e2422002  sub r2, r2, #2
   13ce4: e1560002  cmp r6, r2
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   13ce8: 35d32002  ldrbcc  r2, [r3, #2]
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
    res = ((DWORD)0U);    /* Invalid cluster# */
   13cec: 23a02000  movcs r2, #0
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   13cf0: 35931028  ldrcc r1, [r3, #40] ; 0x28
   13cf4: 30221692  mlacc r2, r2, r6, r1
          /* Clean-up stretched table */
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
   13cf8: e583202c  str r2, [r3, #44] ; 0x2c
          for (c = 0U; c < dp->fs->csize; c++) {    /* Fill the new cluster with 0 */
   13cfc: ea000003  b 13d10 <dir_next+0x1c0>
            dp->fs->wflag = 1U;
            if ((sync_window(dp->fs)) != 0U) {
              return FR_DISK_ERR;
            }
            dp->fs->winsect++;
   13d00: e5952000  ldr r2, [r5]
   13d04: e592302c  ldr r3, [r2, #44] ; 0x2c
   13d08: e2833001  add r3, r3, #1
   13d0c: e582302c  str r3, [r2, #44] ; 0x2c
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
          for (c = 0U; c < dp->fs->csize; c++) {    /* Fill the new cluster with 0 */
   13d10: e5950000  ldr r0, [r5]
   13d14: e5d03002  ldrb  r3, [r0, #2]
   13d18: e1590003  cmp r9, r3
   13d1c: 2affffc9  bcs 13c48 <dir_next+0xf8>
            dp->fs->wflag = 1U;
   13d20: e5c0a004  strb  sl, [r0, #4]
          if ((sync_window(dp->fs)) != 0U) {
            return FR_DISK_ERR;/* Flush disk access window */
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
          for (c = 0U; c < dp->fs->csize; c++) {    /* Fill the new cluster with 0 */
   13d24: e2899001  add r9, r9, #1
            dp->fs->wflag = 1U;
            if ((sync_window(dp->fs)) != 0U) {
   13d28: e5950000  ldr r0, [r5]
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   13d2c: e5d03004  ldrb  r3, [r0, #4]
   13d30: e3530000  cmp r3, #0
   13d34: 0afffff1  beq 13d00 <dir_next+0x1b0>
   13d38: ebfffc2b  bl  12dec <sync_window.part.3>
          }
          mem_set(dp->fs->win, 0, SS(dp->fs));    /* Clear window buffer */
          dp->fs->winsect = clust2sect(dp->fs, clst); /* Cluster start sector */
          for (c = 0U; c < dp->fs->csize; c++) {    /* Fill the new cluster with 0 */
            dp->fs->wflag = 1U;
            if ((sync_window(dp->fs)) != 0U) {
   13d3c: e3500000  cmp r0, #0
   13d40: 0affffee  beq 13d00 <dir_next+0x1b0>
   13d44: eaffffcf  b 13c88 <dir_next+0x138>

00013d48 <follow_path>:
static
FRESULT follow_path ( /* FR_OK(0): successful, !=0: error code */
  DIR* dp,      /* Directory object to return last directory and found object */
  const TCHAR* path /* Full-path string to find a file or directory */
)
{
   13d48: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
   13d4c: e1a06001  mov r6, r1
    LocPath++;  dp->sclust = 0;   /* Strip it and start from the root dir */
  } else {              /* No heading separator */
    dp->sclust = dp->fs->cdir;  /* Start from the current dir */
  }
#else
  if ((*LocPath == '/') || (*LocPath == '\\')) {  /* Strip heading separator if exist */
   13d50: e5d13000  ldrb  r3, [r1]
    LocPath++;
  }
  dp->sclust = 0U;            /* Start from the root dir */
   13d54: e3a04000  mov r4, #0
   13d58: e5804008  str r4, [r0, #8]
static
FRESULT follow_path ( /* FR_OK(0): successful, !=0: error code */
  DIR* dp,      /* Directory object to return last directory and found object */
  const TCHAR* path /* Full-path string to find a file or directory */
)
{
   13d5c: e1a05000  mov r5, r0
    LocPath++;  dp->sclust = 0;   /* Strip it and start from the root dir */
  } else {              /* No heading separator */
    dp->sclust = dp->fs->cdir;  /* Start from the current dir */
  }
#else
  if ((*LocPath == '/') || (*LocPath == '\\')) {  /* Strip heading separator if exist */
   13d60: e353002f  cmp r3, #47 ; 0x2f
   13d64: 1353005c  cmpne r3, #92 ; 0x5c
    LocPath++;
   13d68: 02816001  addeq r6, r1, #1
  }
  dp->sclust = 0U;            /* Start from the root dir */
#endif
  Status = *LocPath;
   13d6c: e5d63000  ldrb  r3, [r6]
  if ((UINT)Status < (UINT)' ') {       /* Null path name is the origin directory itself */
   13d70: e353001f  cmp r3, #31
   13d74: 9a0000ae  bls 14034 <follow_path+0x2ec>
   13d78: e5908018  ldr r8, [r0, #24]
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   13d7c: e3a07020  mov r7, #32
  BYTE b, c, d, *sfn;
  UINT ni, si, i;
  const BYTE *p;
  p = *path;
  /* Create file name in directory form */
  for (; (*p == (BYTE)'/') || (*p == (BYTE)'\\'); ) {p++;}/* Strip duplicated separator */
   13d80: e353002f  cmp r3, #47 ; 0x2f
   13d84: 1353005c  cmpne r3, #92 ; 0x5c
   13d88: 05f63001  ldrbeq  r3, [r6, #1]!
   13d8c: 0afffffb  beq 13d80 <follow_path+0x38>
   13d90: e288200b  add r2, r8, #11
    LocPath++;
  }
  dp->sclust = 0U;            /* Start from the root dir */
#endif
  Status = *LocPath;
  if ((UINT)Status < (UINT)' ') {       /* Null path name is the origin directory itself */
   13d94: e1a03008  mov r3, r8
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   13d98: e4c37001  strb  r7, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   13d9c: e1530002  cmp r3, r2
   13da0: 1afffffc  bne 13d98 <follow_path+0x50>
   13da4: e3a00000  mov r0, #0
   13da8: e3a0c008  mov ip, #8
   13dac: e1a02000  mov r2, r0
   13db0: e1a0e000  mov lr, r0
    sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT; /* Set last segment flag if end of path */
    return FR_OK;
  }
#endif
  for (;;) {
    c = ((BYTE)(*(p+si)));
   13db4: e7d63002  ldrb  r3, [r6, r2]
    si+=1U;
   13db8: e2824001  add r4, r2, #1
    if (((c <= (BYTE)' ') != 0) || ((c == (BYTE)'/') != 0) || ((c == (BYTE)'\\') != 0)) {
   13dbc: e353002f  cmp r3, #47 ; 0x2f
   13dc0: 13530020  cmpne r3, #32
   13dc4: 93a01001  movls r1, #1
   13dc8: 83a01000  movhi r1, #0
   13dcc: 9a00007a  bls 13fbc <follow_path+0x274>
   13dd0: e353005c  cmp r3, #92 ; 0x5c
   13dd4: 0a00003c  beq 13ecc <follow_path+0x184>
      break;  /* Break on end of segment */
    }
    if ((c == (BYTE)'.') || (i >= ni)) {
   13dd8: e353002e  cmp r3, #46 ; 0x2e
   13ddc: 1150000c  cmpne r0, ip
   13de0: 3a000004  bcc 13df8 <follow_path+0xb0>
      if ((ni != 8U) || (c != (BYTE)'.')) {
   13de4: e35c0008  cmp ip, #8
   13de8: 0353002e  cmpeq r3, #46 ; 0x2e
   13dec: 0a000030  beq 13eb4 <follow_path+0x16c>
    }
  }
  *path = (p+si);           /* Return pointer to the next segment */
  c = (c <= (BYTE)' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */

  if (i == (UINT)0U){
   13df0: e3a00006  mov r0, #6
   13df4: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
#if !DF1S
      return FR_INVALID_NAME;   /* Reject extended characters (ASCII cfg) */
#endif
#endif
    }
    if (IsDBCS1(c)) {       /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   13df8: e2839020  add r9, r3, #32
   13dfc: e283107f  add r1, r3, #127  ; 0x7f
        return FR_INVALID_NAME;
      }
      i = 8U; ni = 11U;
      b <<= 2U; continue;
    }
    if (c >= 0x80U) {       /* Extended character? */
   13e00: e3130080  tst r3, #128  ; 0x80
#if !DF1S
      return FR_INVALID_NAME;   /* Reject extended characters (ASCII cfg) */
#endif
#endif
    }
    if (IsDBCS1(c)) {       /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   13e04: e6ef9079  uxtb  r9, r9
   13e08: e6ef1071  uxtb  r1, r1
      }
      i = 8U; ni = 11U;
      b <<= 2U; continue;
    }
    if (c >= 0x80U) {       /* Extended character? */
      b |= 3U;            /* Eliminate NT flag */
   13e0c: 138ee003  orrne lr, lr, #3
#if !DF1S
      return FR_INVALID_NAME;   /* Reject extended characters (ASCII cfg) */
#endif
#endif
    }
    if (IsDBCS1(c)) {       /* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   13e10: e351001e  cmp r1, #30
   13e14: 8359001c  cmphi r9, #28
   13e18: 8a00000e  bhi 13e58 <follow_path+0x110>
      d = ((BYTE)(*(p+si)));      /* Get 2nd byte */
   13e1c: e7d61004  ldrb  r1, [r6, r4]
      si+=1U;
   13e20: e2822002  add r2, r2, #2
      if ((!IsDBCS2(d)) || (i >= (ni - 1))) { /* Reject invalid DBC */
   13e24: e2219080  eor r9, r1, #128  ; 0x80
   13e28: e2414040  sub r4, r1, #64 ; 0x40
   13e2c: e359007c  cmp r9, #124  ; 0x7c
   13e30: 8354003e  cmphi r4, #62 ; 0x3e
   13e34: 8affffed  bhi 13df0 <follow_path+0xa8>
   13e38: e24c4001  sub r4, ip, #1
   13e3c: e1500004  cmp r0, r4
   13e40: 2affffea  bcs 13df0 <follow_path+0xa8>
        return FR_INVALID_NAME;
      }
      *(sfn+i) = c;
   13e44: e1a04008  mov r4, r8
   13e48: e7e43000  strb  r3, [r4, r0]!
      i+=1U;
      *(sfn+i) = d;
      i+=1U;
   13e4c: e2800002  add r0, r0, #2
      if ((!IsDBCS2(d)) || (i >= (ni - 1))) { /* Reject invalid DBC */
        return FR_INVALID_NAME;
      }
      *(sfn+i) = c;
      i+=1U;
      *(sfn+i) = d;
   13e50: e5c41001  strb  r1, [r4, #1]
   13e54: eaffffd6  b 13db4 <follow_path+0x6c>
/* Check if chr is contained in the string */
static
s32 chk_chr (const char* str, s32 chr) {
  char Status;
  const char *LocStr = str;
  while (((*LocStr) != (char)0) && ((*LocStr != chr) != 0U)){
   13e58: e3530022  cmp r3, #34 ; 0x22
   13e5c: 0affffe3  beq 13df0 <follow_path+0xa8>
   13e60: e3081788  movw  r1, #34696  ; 0x8788
   13e64: e3401001  movt  r1, #1
   13e68: ea000001  b 13e74 <follow_path+0x12c>
   13e6c: e1530002  cmp r3, r2
   13e70: 0affffde  beq 13df0 <follow_path+0xa8>
   13e74: e5f12001  ldrb  r2, [r1, #1]!
   13e78: e3520000  cmp r2, #0
   13e7c: 1afffffa  bne 13e6c <follow_path+0x124>
      i+=1U;
    } else {            /* Single byte code */
      if ((chk_chr("\"*+,:;<=>\?[]|\x7F", c)) != 0) { /* Reject illegal chrs for SFN */
        return FR_INVALID_NAME;
      }
      if (IsUpper(c)) {     /* ASCII large capital? */
   13e80: e2432041  sub r2, r3, #65 ; 0x41
   13e84: e3520019  cmp r2, #25
        b |= 2U;
   13e88: 938ee002  orrls lr, lr, #2
      i+=1U;
    } else {            /* Single byte code */
      if ((chk_chr("\"*+,:;<=>\?[]|\x7F", c)) != 0) { /* Reject illegal chrs for SFN */
        return FR_INVALID_NAME;
      }
      if (IsUpper(c)) {     /* ASCII large capital? */
   13e8c: 9a000004  bls 13ea4 <follow_path+0x15c>
        b |= 2U;
      } else {
        if (IsLower(c)) {   /* ASCII small capital? */
   13e90: e2432061  sub r2, r3, #97 ; 0x61
   13e94: e3520019  cmp r2, #25
          b |= 1U; c -= 0x20U;
   13e98: 92433020  subls r3, r3, #32
   13e9c: 938ee001  orrls lr, lr, #1
   13ea0: 96ef3073  uxtbls  r3, r3
        }
      }
      *(sfn+i) = c;
   13ea4: e7c83000  strb  r3, [r8, r0]
    return FR_OK;
  }
#endif
  for (;;) {
    c = ((BYTE)(*(p+si)));
    si+=1U;
   13ea8: e1a02004  mov r2, r4
        if (IsLower(c)) {   /* ASCII small capital? */
          b |= 1U; c -= 0x20U;
        }
      }
      *(sfn+i) = c;
      i+=1U;
   13eac: e2800001  add r0, r0, #1
   13eb0: eaffffbf  b 13db4 <follow_path+0x6c>
    if ((c == (BYTE)'.') || (i >= ni)) {
      if ((ni != 8U) || (c != (BYTE)'.')) {
        return FR_INVALID_NAME;
      }
      i = 8U; ni = 11U;
      b <<= 2U; continue;
   13eb4: e1a0e10e  lsl lr, lr, #2
    return FR_OK;
  }
#endif
  for (;;) {
    c = ((BYTE)(*(p+si)));
    si+=1U;
   13eb8: e1a02004  mov r2, r4
    }
    if ((c == (BYTE)'.') || (i >= ni)) {
      if ((ni != 8U) || (c != (BYTE)'.')) {
        return FR_INVALID_NAME;
      }
      i = 8U; ni = 11U;
   13ebc: e3a00008  mov r0, #8
   13ec0: e3a0c00b  mov ip, #11
      b <<= 2U; continue;
   13ec4: e6efe07e  uxtb  lr, lr
   13ec8: eaffffb9  b 13db4 <follow_path+0x6c>
      }
      *(sfn+i) = c;
      i+=1U;
    }
  }
  *path = (p+si);           /* Return pointer to the next segment */
   13ecc: e0866004  add r6, r6, r4
  c = (c <= (BYTE)' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */

  if (i == (UINT)0U){
   13ed0: e3500000  cmp r0, #0
   13ed4: 0affffc5  beq 13df0 <follow_path+0xa8>
    return FR_INVALID_NAME;   /* Reject nul string */
  }
  if ((*(sfn+0)) == DDE){
   13ed8: e5d83000  ldrb  r3, [r8]
  BYTE c, *directory;
#if _USE_LFN
  BYTE a, ord, sum;
#endif

  res = dir_sdi(dp, 0U);      /* Rewind directory object */
   13edc: e1a00005  mov r0, r5
  c = (c <= (BYTE)' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */

  if (i == (UINT)0U){
    return FR_INVALID_NAME;   /* Reject nul string */
  }
  if ((*(sfn+0)) == DDE){
   13ee0: e35300e5  cmp r3, #229  ; 0xe5
    *(sfn+0) = NDDE;  /* When first char collides with 0xE5, replace it with 0x05 */
   13ee4: 03a03005  moveq r3, #5
   13ee8: 05c83000  strbeq  r3, [r8]
  }
  if (ni == 8U){
   13eec: e35c0008  cmp ip, #8
    b <<= 2U;
   13ef0: 01a0e10e  lsleq lr, lr, #2
   13ef4: 06efe07e  uxtbeq  lr, lr
  }
  if ((b & 0x03U) == 0x01U){
   13ef8: e20e3003  and r3, lr, #3
    c |= NS_EXT;  /* NT flag (Name extension has only small capital) */
  }
  if ((b & 0x0CU) == 0x04U){
   13efc: e20ee00c  and lr, lr, #12
    *(sfn+0) = NDDE;  /* When first char collides with 0xE5, replace it with 0x05 */
  }
  if (ni == 8U){
    b <<= 2U;
  }
  if ((b & 0x03U) == 0x01U){
   13f00: e3530001  cmp r3, #1
    c |= NS_EXT;  /* NT flag (Name extension has only small capital) */
   13f04: 03811010  orreq r1, r1, #16
  }
  if ((b & 0x0CU) == 0x04U){
   13f08: e35e0004  cmp lr, #4
    c |= NS_BODY; /* NT flag (Name body has only small capital) */
   13f0c: 03811008  orreq r1, r1, #8
  }

  *(sfn+NS) = c;    /* Store NT flag, File name is created */
   13f10: e5c8100b  strb  r1, [r8, #11]
  BYTE c, *directory;
#if _USE_LFN
  BYTE a, ord, sum;
#endif

  res = dir_sdi(dp, 0U);      /* Rewind directory object */
   13f14: e3a01000  mov r1, #0
   13f18: ebfffde4  bl  136b0 <dir_sdi>
  if (res == FR_OK) {
   13f1c: e3500000  cmp r0, #0
   13f20: 1a00001d  bne 13f9c <follow_path+0x254>

#if _USE_LFN
  ord = sum = 0xFF; dp->lfn_idx = 0xFFFF; /* Reset LFN sequence */
#endif
  do {
    res = move_window(dp->fs, dp->sect);
   13f24: e5950000  ldr r0, [r5]
   13f28: e5951010  ldr r1, [r5, #16]
   13f2c: ebfffc1f  bl  12fb0 <move_window>
    if (res != FR_OK) {
   13f30: e3500000  cmp r0, #0
   13f34: 1a000018  bne 13f9c <follow_path+0x254>
      break;
    }
    directory = dp->dir;          /* Ptr to the directory entry of current index */
   13f38: e5951014  ldr r1, [r5, #20]
    c = *(directory+DIR_Name);
   13f3c: e5d13000  ldrb  r3, [r1]
    if (c == 0U) { res = FR_NO_FILE; break; } /* Reached to end of table */
   13f40: e3530000  cmp r3, #0
   13f44: 0a000021  beq 13fd0 <follow_path+0x288>
        }
        ord = 0xFF; dp->lfn_idx = 0xFFFF; /* Reset LFN sequence */
      }
    }
#else   /* Non LFN configuration */
    if (((!mem_cmp(directory, dp->fn, 11U)) != 0)&&((!(*(directory+DIR_Attr) & AM_VOL)) != 0U)) { /* Is it a valid entry? */
   13f48: e5958018  ldr r8, [r5, #24]
static
s32 mem_cmp (const void* dst, const void* src, UINT cnt) {
  const BYTE *d = dst, *s = src;
  s32 r = (s32)0;
  UINT LocCnt = cnt;
  while (((LocCnt)  != 0U) && ((r = (s32)(*d - *s)) == 0)) {
   13f4c: e5d82000  ldrb  r2, [r8]
   13f50: e1530002  cmp r3, r2
   13f54: 0281400a  addeq r4, r1, #10
   13f58: 01a03001  moveq r3, r1
   13f5c: 01a02008  moveq r2, r8
   13f60: 1a000008  bne 13f88 <follow_path+0x240>
   13f64: e5f3e001  ldrb  lr, [r3, #1]!
   13f68: e5f2c001  ldrb  ip, [r2, #1]!
   13f6c: e15e000c  cmp lr, ip
   13f70: 1a000004  bne 13f88 <follow_path+0x240>
   13f74: e1530004  cmp r3, r4
   13f78: 1afffff9  bne 13f64 <follow_path+0x21c>
        }
        ord = 0xFF; dp->lfn_idx = 0xFFFF; /* Reset LFN sequence */
      }
    }
#else   /* Non LFN configuration */
    if (((!mem_cmp(directory, dp->fn, 11U)) != 0)&&((!(*(directory+DIR_Attr) & AM_VOL)) != 0U)) { /* Is it a valid entry? */
   13f7c: e5d1300b  ldrb  r3, [r1, #11]
   13f80: e3130008  tst r3, #8
   13f84: 0a000014  beq 13fdc <follow_path+0x294>
      break;
    }
#endif
    res = dir_next(dp, 0);    /* Next entry */
   13f88: e1a00005  mov r0, r5
   13f8c: e3a01000  mov r1, #0
   13f90: ebfffeee  bl  13b50 <dir_next>
  } while (res == FR_OK);
   13f94: e3500000  cmp r0, #0
   13f98: 0affffe1  beq 13f24 <follow_path+0x1dc>
      res = create_name(dp, &LocPath);  /* Get a segment name of the path */
      if (res != FR_OK) {
        break;
      }
      res = dir_find(dp);       /* Find an object with the sagment name */
      NameStatus = *(dp->fn+NS);
   13f9c: e5953018  ldr r3, [r5, #24]
      if (res != FR_OK) {       /* Failed to find the object */
        if (res == FR_NO_FILE) {  /* Object is not found */
   13fa0: e3500004  cmp r0, #4
      res = create_name(dp, &LocPath);  /* Get a segment name of the path */
      if (res != FR_OK) {
        break;
      }
      res = dir_find(dp);       /* Find an object with the sagment name */
      NameStatus = *(dp->fn+NS);
   13fa4: e5d3300b  ldrb  r3, [r3, #11]
      if (res != FR_OK) {       /* Failed to find the object */
        if (res == FR_NO_FILE) {  /* Object is not found */
   13fa8: 18bd83f8  popne {r3, r4, r5, r6, r7, r8, r9, pc}
              continue; /* Continue to follow if not last segment */
            }
            res = FR_OK;          /* Ended at the root directroy. Function completed. */
          } else {              /* Could not find the object */
            if ((!(NameStatus & NS_LAST)) != 0U) {
              res = FR_NO_PATH; /* Adjust error code if not last segment */
   13fac: e3130004  tst r3, #4
   13fb0: 13a00004  movne r0, #4
   13fb4: 03a00005  moveq r0, #5
   13fb8: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
      *(sfn+i) = c;
      i+=1U;
    }
  }
  *path = (p+si);           /* Return pointer to the next segment */
  c = (c <= (BYTE)' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */
   13fbc: e3530021  cmp r3, #33 ; 0x21
      }
      *(sfn+i) = c;
      i+=1U;
    }
  }
  *path = (p+si);           /* Return pointer to the next segment */
   13fc0: e0866004  add r6, r6, r4
  c = (c <= (BYTE)' ') ? NS_LAST : 0;   /* Set last segment flag if end of path */
   13fc4: 33a01004  movcc r1, #4
   13fc8: 23a01000  movcs r1, #0
   13fcc: eaffffbf  b 13ed0 <follow_path+0x188>
      res = create_name(dp, &LocPath);  /* Get a segment name of the path */
      if (res != FR_OK) {
        break;
      }
      res = dir_find(dp);       /* Find an object with the sagment name */
      NameStatus = *(dp->fn+NS);
   13fd0: e5953018  ldr r3, [r5, #24]
   13fd4: e5d3300b  ldrb  r3, [r3, #11]
   13fd8: eafffff3  b 13fac <follow_path+0x264>
            }
          }
        }
        break;
      }
      if ((NameStatus & NS_LAST) != 0U) {
   13fdc: e5d8200b  ldrb  r2, [r8, #11]
   13fe0: e3120004  tst r2, #4
   13fe4: 1a000016  bne 14044 <follow_path+0x2fc>
        break;      /* Last segment matched. Function completed. */
      }
      directory = dp->dir;            /* Follow the sub-directory */
      if ((!((*(directory+DIR_Attr)) & AM_DIR)) != 0U) {  /* It is not a sub-directory and cannot follow */
   13fe8: e3130010  tst r3, #16
   13fec: 0a00000e  beq 1402c <follow_path+0x2e4>
   13ff0: e5952000  ldr r2, [r5]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   13ff4: e5d1001b  ldrb  r0, [r1, #27]
   13ff8: e5d1301a  ldrb  r3, [r1, #26]
  if (fs->fs_type == FS_FAT32) {
   13ffc: e5d22000  ldrb  r2, [r2]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14000: e1833400  orr r3, r3, r0, lsl #8
  if (fs->fs_type == FS_FAT32) {
   14004: e3520003  cmp r2, #3
   14008: 0a000002  beq 14018 <follow_path+0x2d0>
      }
      directory = dp->dir;            /* Follow the sub-directory */
      if ((!((*(directory+DIR_Attr)) & AM_DIR)) != 0U) {  /* It is not a sub-directory and cannot follow */
        res = FR_NO_PATH; break;
      }
      dp->sclust = (DWORD)ld_clust(dp->fs, directory);
   1400c: e5853008  str r3, [r5, #8]
   14010: e5d63000  ldrb  r3, [r6]
    }
   14014: eaffff59  b 13d80 <follow_path+0x38>
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   14018: e5d10015  ldrb  r0, [r1, #21]
   1401c: e5d12014  ldrb  r2, [r1, #20]
   14020: e1822400  orr r2, r2, r0, lsl #8
   14024: e1833802  orr r3, r3, r2, lsl #16
   14028: eafffff7  b 1400c <follow_path+0x2c4>
      if ((NameStatus & NS_LAST) != 0U) {
        break;      /* Last segment matched. Function completed. */
      }
      directory = dp->dir;            /* Follow the sub-directory */
      if ((!((*(directory+DIR_Attr)) & AM_DIR)) != 0U) {  /* It is not a sub-directory and cannot follow */
        res = FR_NO_PATH; break;
   1402c: e3a00005  mov r0, #5
   14030: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
  }
  dp->sclust = 0U;            /* Start from the root dir */
#endif
  Status = *LocPath;
  if ((UINT)Status < (UINT)' ') {       /* Null path name is the origin directory itself */
    res = dir_sdi(dp, 0U);
   14034: e1a01004  mov r1, r4
   14038: ebfffd9c  bl  136b0 <dir_sdi>
    dp->dir = 0U;
   1403c: e5854014  str r4, [r5, #20]
   14040: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
   14044: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

00014048 <remove_chain.part.10>:
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
   14048: e92d4038  push  {r3, r4, r5, lr}
   1404c: e1a04000  mov r4, r0
   14050: e1a05001  mov r5, r1
  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
    res = FR_INT_ERR;

  } else {
    res = FR_OK;
    while (LocClst < fs->n_fatent) {      /* Not a last link? */
   14054: e5943014  ldr r3, [r4, #20]
   14058: e1a01005  mov r1, r5
   1405c: e1a00004  mov r0, r4
   14060: e1550003  cmp r5, r3
   14064: 2a00001c  bcs 140dc <remove_chain.part.10+0x94>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   14068: e3550001  cmp r5, #1
   1406c: 9a000009  bls 14098 <remove_chain.part.10+0x50>
   14070: ebfffd4c  bl  135a8 <get_fat.part.6>

  } else {
    res = FR_OK;
    while (LocClst < fs->n_fatent) {      /* Not a last link? */
      nxt = get_fat(fs, LocClst);     /* Get cluster status */
      if (nxt == 0U) {
   14074: e2503000  subs  r3, r0, #0
   14078: 0a000017  beq 140dc <remove_chain.part.10+0x94>
        break;        /* Empty cluster? */
      }
      if (nxt == 1U) { res = FR_INT_ERR; break; } /* Internal error? */
   1407c: e3530001  cmp r3, #1
   14080: 0a000004  beq 14098 <remove_chain.part.10+0x50>
      if (nxt == 0xFFFFFFFFU) { res = FR_DISK_ERR; break; } /* Disk error? */
   14084: e3730001  cmn r3, #1
   14088: 0a000015  beq 140e4 <remove_chain.part.10+0x9c>
  UINT bc;
  BYTE *p;
  FRESULT res;
  DWORD LocVal = val;

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
   1408c: e5942014  ldr r2, [r4, #20]
   14090: e1550002  cmp r5, r2
   14094: 3a000001  bcc 140a0 <remove_chain.part.10+0x58>
    while (LocClst < fs->n_fatent) {      /* Not a last link? */
      nxt = get_fat(fs, LocClst);     /* Get cluster status */
      if (nxt == 0U) {
        break;        /* Empty cluster? */
      }
      if (nxt == 1U) { res = FR_INT_ERR; break; } /* Internal error? */
   14098: e3a00002  mov r0, #2
   1409c: e8bd8038  pop {r3, r4, r5, pc}
   140a0: e1a01005  mov r1, r5
   140a4: e1a00004  mov r0, r4
   140a8: e3a02000  mov r2, #0
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
   140ac: e1a05003  mov r5, r3
   140b0: ebfffde7  bl  13854 <put_fat.part.8>
        break;        /* Empty cluster? */
      }
      if (nxt == 1U) { res = FR_INT_ERR; break; } /* Internal error? */
      if (nxt == 0xFFFFFFFFU) { res = FR_DISK_ERR; break; } /* Disk error? */
      res = put_fat(fs, LocClst, 0U);     /* Mark the cluster "empty" */
      if (res != FR_OK) {
   140b4: e3500000  cmp r0, #0
   140b8: 18bd8038  popne {r3, r4, r5, pc}
        break;
      }
      if (fs->free_clust != 0xFFFFFFFFU) {  /* Update FSInfo */
   140bc: e5943010  ldr r3, [r4, #16]
   140c0: e3730001  cmn r3, #1
        fs->free_clust++;
   140c4: e2833001  add r3, r3, #1
   140c8: 15843010  strne r3, [r4, #16]
        fs->fsi_flag |= 1U;
   140cc: 15d42005  ldrbne  r2, [r4, #5]
   140d0: 13823001  orrne r3, r2, #1
   140d4: 15c43005  strbne  r3, [r4, #5]
   140d8: eaffffdd  b 14054 <remove_chain.part.10+0xc>
/*-----------------------------------------------------------------------*/
/* FAT handling - Remove a cluster chain                                 */
/*-----------------------------------------------------------------------*/
#if !_FS_READONLY
static
FRESULT remove_chain (
   140dc: e3a00000  mov r0, #0
   140e0: e8bd8038  pop {r3, r4, r5, pc}
      nxt = get_fat(fs, LocClst);     /* Get cluster status */
      if (nxt == 0U) {
        break;        /* Empty cluster? */
      }
      if (nxt == 1U) { res = FR_INT_ERR; break; } /* Internal error? */
      if (nxt == 0xFFFFFFFFU) { res = FR_DISK_ERR; break; } /* Disk error? */
   140e4: e3a00001  mov r0, #1
      LocClst = nxt;  /* Next cluster */
    }
  }

  return res;
}
   140e8: e8bd8038  pop {r3, r4, r5, pc}

000140ec <dir_read.constprop.11>:
/*-----------------------------------------------------------------------*/
/* Read an object from the directory                                     */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
static
FRESULT dir_read (
   140ec: e92d4010  push  {r4, lr}
  BYTE a, c, *directory;
#if _USE_LFN
  BYTE ord = 0xFF, sum = 0xFF;
#endif

  res = FR_NO_FILE;
   140f0: e3a03004  mov r3, #4
/*-----------------------------------------------------------------------*/
/* Read an object from the directory                                     */
/*-----------------------------------------------------------------------*/
#if _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2
static
FRESULT dir_read (
   140f4: e1a04000  mov r4, r0
   140f8: ea000002  b 14108 <dir_read.constprop.11+0x1c>
#else   /* Non LFN configuration */
    if (((c != DDE) != 0U) && ((_FS_RPATH || (c != (BYTE)'.')) != 0) && (a != AM_LFN) && (((a == AM_VOL) == vol)!= 0U)) { /* Is it a valid entry? */
      break;
    }
#endif
    res = dir_next(dp, 0);        /* Next entry */
   140fc: ebfffe93  bl  13b50 <dir_next>
    if (res != FR_OK) {
   14100: e2503000  subs  r3, r0, #0
   14104: 1a00001e  bne 14184 <dir_read.constprop.11+0x98>
#if _USE_LFN
  BYTE ord = 0xFF, sum = 0xFF;
#endif

  res = FR_NO_FILE;
  while ((dp->sect) != 0U) {
   14108: e5941010  ldr r1, [r4, #16]
   1410c: e3510000  cmp r1, #0
   14110: 0a000019  beq 1417c <dir_read.constprop.11+0x90>
    res = move_window(dp->fs, dp->sect);
   14114: e5940000  ldr r0, [r4]
   14118: ebfffba4  bl  12fb0 <move_window>
#else   /* Non LFN configuration */
    if (((c != DDE) != 0U) && ((_FS_RPATH || (c != (BYTE)'.')) != 0) && (a != AM_LFN) && (((a == AM_VOL) == vol)!= 0U)) { /* Is it a valid entry? */
      break;
    }
#endif
    res = dir_next(dp, 0);        /* Next entry */
   1411c: e3a01000  mov r1, #0
#endif

  res = FR_NO_FILE;
  while ((dp->sect) != 0U) {
    res = move_window(dp->fs, dp->sect);
    if (res != FR_OK) {
   14120: e2503000  subs  r3, r0, #0
#else   /* Non LFN configuration */
    if (((c != DDE) != 0U) && ((_FS_RPATH || (c != (BYTE)'.')) != 0) && (a != AM_LFN) && (((a == AM_VOL) == vol)!= 0U)) { /* Is it a valid entry? */
      break;
    }
#endif
    res = dir_next(dp, 0);        /* Next entry */
   14124: e1a00004  mov r0, r4
#endif

  res = FR_NO_FILE;
  while ((dp->sect) != 0U) {
    res = move_window(dp->fs, dp->sect);
    if (res != FR_OK) {
   14128: 1a000015  bne 14184 <dir_read.constprop.11+0x98>
      break;
    }
    directory = dp->dir;          /* Ptr to the directory entry of current index */
   1412c: e5942014  ldr r2, [r4, #20]
    c = *(directory+DIR_Name);
   14130: e5d23000  ldrb  r3, [r2]
    if (c == 0U) { res = FR_NO_FILE; break; } /* Reached to end of table */
   14134: e1530001  cmp r3, r1
   14138: 0a000015  beq 14194 <dir_read.constprop.11+0xa8>
    a = (*(directory+DIR_Attr)) & AM_MASK;
   1413c: e5d2200b  ldrb  r2, [r2, #11]
        }
        break;
      }
    }
#else   /* Non LFN configuration */
    if (((c != DDE) != 0U) && ((_FS_RPATH || (c != (BYTE)'.')) != 0) && (a != AM_LFN) && (((a == AM_VOL) == vol)!= 0U)) { /* Is it a valid entry? */
   14140: e35300e5  cmp r3, #229  ; 0xe5
      break;
    }
    directory = dp->dir;          /* Ptr to the directory entry of current index */
    c = *(directory+DIR_Name);
    if (c == 0U) { res = FR_NO_FILE; break; } /* Reached to end of table */
    a = (*(directory+DIR_Attr)) & AM_MASK;
   14144: e202203f  and r2, r2, #63 ; 0x3f
        }
        break;
      }
    }
#else   /* Non LFN configuration */
    if (((c != DDE) != 0U) && ((_FS_RPATH || (c != (BYTE)'.')) != 0) && (a != AM_LFN) && (((a == AM_VOL) == vol)!= 0U)) { /* Is it a valid entry? */
   14148: 0affffeb  beq 140fc <dir_read.constprop.11+0x10>
   1414c: e353002e  cmp r3, #46 ; 0x2e
   14150: 1352000f  cmpne r2, #15
   14154: 13a03001  movne r3, #1
   14158: 03a03000  moveq r3, #0
   1415c: e3520008  cmp r2, #8
   14160: 03a03000  moveq r3, #0
   14164: 12033001  andne r3, r3, #1
   14168: e3530000  cmp r3, #0
   1416c: 0affffe2  beq 140fc <dir_read.constprop.11+0x10>
#if _USE_LFN
  BYTE ord = 0xFF, sum = 0xFF;
#endif

  res = FR_NO_FILE;
  while ((dp->sect) != 0U) {
   14170: e3a03000  mov r3, #0
  if (res != FR_OK) {
    dp->sect = 0U;
  }

  return res;
}
   14174: e1a00003  mov r0, r3
   14178: e8bd8010  pop {r4, pc}
    if (res != FR_OK) {
      break;
    }
  }

  if (res != FR_OK) {
   1417c: e3530000  cmp r3, #0
   14180: 0afffffa  beq 14170 <dir_read.constprop.11+0x84>
    dp->sect = 0U;
   14184: e3a02000  mov r2, #0
   14188: e5842010  str r2, [r4, #16]
  }

  return res;
}
   1418c: e1a00003  mov r0, r3
   14190: e8bd8010  pop {r4, pc}
      break;
    }
  }

  if (res != FR_OK) {
    dp->sect = 0U;
   14194: e3a02000  mov r2, #0
    if (res != FR_OK) {
      break;
    }
    directory = dp->dir;          /* Ptr to the directory entry of current index */
    c = *(directory+DIR_Name);
    if (c == 0U) { res = FR_NO_FILE; break; } /* Reached to end of table */
   14198: e3a03004  mov r3, #4
      break;
    }
  }

  if (res != FR_OK) {
    dp->sect = 0U;
   1419c: e5842010  str r2, [r4, #16]
   141a0: eafffff9  b 1418c <dir_read.constprop.11+0xa0>

000141a4 <dir_register>:
#if !_FS_READONLY
static
FRESULT dir_register (  /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
  DIR* dp       /* Target directory with object name to be created */
)
{
   141a4: e92d4010  push  {r4, lr}
{
  FRESULT res;
  UINT n;


  res = dir_sdi(dp, 0U);
   141a8: e3a01000  mov r1, #0
#if !_FS_READONLY
static
FRESULT dir_register (  /* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
  DIR* dp       /* Target directory with object name to be created */
)
{
   141ac: e1a04000  mov r4, r0
{
  FRESULT res;
  UINT n;


  res = dir_sdi(dp, 0U);
   141b0: ebfffd3e  bl  136b0 <dir_sdi>
  if (res == FR_OK) {
   141b4: e3500000  cmp r0, #0
   141b8: 0a000007  beq 141dc <dir_register+0x38>
      }
      res = dir_next(dp, 1);    /* Next entry with table stretch enabled */
    } while (res == FR_OK);
  }
  if (res == FR_NO_FILE) {
    res = FR_DENIED;  /* No directory entry to allocate */
   141bc: e3500004  cmp r0, #4
   141c0: 03a00007  moveq r0, #7
   141c4: e8bd8010  pop {r4, pc}
          break;  /* A block of contiguous entries is found */
        }
      } else {
        n = 0U;         /* Not a blank entry. Restart to search */
      }
      res = dir_next(dp, 1);    /* Next entry with table stretch enabled */
   141c8: e1a00004  mov r0, r4
   141cc: e3a01001  mov r1, #1
   141d0: ebfffe5e  bl  13b50 <dir_next>
    } while (res == FR_OK);
   141d4: e3500000  cmp r0, #0
   141d8: 1afffff7  bne 141bc <dir_register+0x18>

  res = dir_sdi(dp, 0U);
  if (res == FR_OK) {
    n = 0U;
    do {
      res = move_window(dp->fs, dp->sect);
   141dc: e5940000  ldr r0, [r4]
   141e0: e5941010  ldr r1, [r4, #16]
   141e4: ebfffb71  bl  12fb0 <move_window>
      if (res != FR_OK) {
   141e8: e3500000  cmp r0, #0
   141ec: 1afffff2  bne 141bc <dir_register+0x18>
        break;
      }
      if ((dp->dir[0] == DDE) || (dp->dir[0] == 0U)) {  /* Is it a blank entry? */
   141f0: e5943014  ldr r3, [r4, #20]
   141f4: e5d33000  ldrb  r3, [r3]
   141f8: e35300e5  cmp r3, #229  ; 0xe5
   141fc: 13530000  cmpne r3, #0
   14200: 1afffff0  bne 141c8 <dir_register+0x24>
#else /* Non LFN configuration */
  res = dir_alloc(dp, 1U);    /* Allocate an entry for SFN */
#endif

  if (res == FR_OK) {       /* Set SFN entry */
    res = move_window(dp->fs, dp->sect);
   14204: e5940000  ldr r0, [r4]
   14208: e5941010  ldr r1, [r4, #16]
   1420c: ebfffb67  bl  12fb0 <move_window>
    if (res == FR_OK) {
   14210: e3500000  cmp r0, #0
   14214: 1a000011  bne 14260 <dir_register+0xbc>
      mem_set(dp->dir, 0, SZ_DIR);  /* Clean the entry */
   14218: e5943014  ldr r3, [r4, #20]
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   1421c: e1a01000  mov r1, r0
   14220: e2832020  add r2, r3, #32
   14224: e4c31001  strb  r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   14228: e1530002  cmp r3, r2
   1422c: 1afffffc  bne 14224 <dir_register+0x80>

  if (res == FR_OK) {       /* Set SFN entry */
    res = move_window(dp->fs, dp->sect);
    if (res == FR_OK) {
      mem_set(dp->dir, 0, SZ_DIR);  /* Clean the entry */
      mem_cpy(dp->dir, dp->fn, 11U);  /* Put SFN */
   14230: e5943014  ldr r3, [r4, #20]
   14234: e5942018  ldr r2, [r4, #24]
   14238: e283c00b  add ip, r3, #11
   1423c: e2422001  sub r2, r2, #1
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   14240: e5f21001  ldrb  r1, [r2, #1]!
   14244: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   14248: e153000c  cmp r3, ip
   1424c: 1afffffb  bne 14240 <dir_register+0x9c>
      mem_set(dp->dir, 0, SZ_DIR);  /* Clean the entry */
      mem_cpy(dp->dir, dp->fn, 11U);  /* Put SFN */
#if _USE_LFN
      dp->dir[DIR_NTres] = *(dp->fn+NS) & (NS_BODY | NS_EXT); /* Put NT flag */
#endif
      dp->fs->wflag = 1U;
   14250: e5943000  ldr r3, [r4]
   14254: e3a02001  mov r2, #1
   14258: e5c32004  strb  r2, [r3, #4]
   1425c: e8bd8010  pop {r4, pc}
    }
  }

  return res;
}
   14260: e8bd8010  pop {r4, pc}

00014264 <clust2sect>:
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   14264: e5903014  ldr r3, [r0, #20]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   14268: e2411002  sub r1, r1, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   1426c: e2433002  sub r3, r3, #2
   14270: e1510003  cmp r1, r3
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   14274: 35d02002  ldrbcc  r2, [r0, #2]
   14278: 35903028  ldrcc r3, [r0, #40] ; 0x28
   1427c: 30203192  mlacc r0, r2, r1, r3
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
    res = ((DWORD)0U);    /* Invalid cluster# */
   14280: 23a00000  movcs r0, #0
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
  }

  return res;
}
   14284: e12fff1e  bx  lr

00014288 <get_fat>:
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   14288: e3510001  cmp r1, #1
   1428c: 9a000003  bls 142a0 <get_fat+0x18>
   14290: e5902014  ldr r2, [r0, #20]
   14294: e1510002  cmp r1, r2
   14298: 2a000000  bcs 142a0 <get_fat+0x18>
   1429c: eafffcc1  b 135a8 <get_fat.part.6>
    /* This is added for Misrac Compliance */
    break;
  }
  }
  return Status;  /* An error occurred at the disk I/O layer */
}
   142a0: e3a00001  mov r0, #1
   142a4: e12fff1e  bx  lr

000142a8 <put_fat>:
  UINT bc;
  BYTE *p;
  FRESULT res;
  DWORD LocVal = val;

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
   142a8: e3510001  cmp r1, #1
   142ac: 9a000002  bls 142bc <put_fat+0x14>
   142b0: e590c014  ldr ip, [r0, #20]
   142b4: e151000c  cmp r1, ip
   142b8: 3a000001  bcc 142c4 <put_fat+0x1c>
    }
    fs->wflag = 1U;
  }

  return res;
}
   142bc: e3a00002  mov r0, #2
   142c0: e12fff1e  bx  lr
   142c4: eafffd62  b 13854 <put_fat.part.8>

000142c8 <f_mount>:
FRESULT f_mount (
  FATFS* fs,      /* Pointer to the file system object (NULL:unmount)*/
  const TCHAR* path,  /* Logical drive number to be mounted/unmounted */
  BYTE opt      /* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
   142c8: e92d4010  push  {r4, lr}
   142cc: e24dd010  sub sp, sp, #16
  FATFS *cfs;
  s32 vol;
  FRESULT res;
  const TCHAR *rp = path;
   142d0: e28d3010  add r3, sp, #16
FRESULT f_mount (
  FATFS* fs,      /* Pointer to the file system object (NULL:unmount)*/
  const TCHAR* path,  /* Logical drive number to be mounted/unmounted */
  BYTE opt      /* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
   142d4: e1a04002  mov r4, r2
   142d8: e58d0004  str r0, [sp, #4]
  FATFS *cfs;
  s32 vol;
  FRESULT res;
  const TCHAR *rp = path;
   142dc: e5231004  str r1, [r3, #-4]!


  vol = get_ldnumber(&rp);
   142e0: e1a00003  mov r0, r3
FRESULT f_mount (
  FATFS* fs,      /* Pointer to the file system object (NULL:unmount)*/
  const TCHAR* path,  /* Logical drive number to be mounted/unmounted */
  BYTE opt      /* 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
   142e4: e58d1000  str r1, [sp]
  s32 vol;
  FRESULT res;
  const TCHAR *rp = path;


  vol = get_ldnumber(&rp);
   142e8: ebfffa5e  bl  12c68 <get_ldnumber>
  if (vol < 0) {return FR_INVALID_DRIVE;}
   142ec: e250c000  subs  ip, r0, #0
   142f0: b3a0000b  movlt r0, #11
   142f4: ba00000e  blt 14334 <f_mount+0x6c>
  cfs = FatFs[vol];         /* Pointer to fs object */
   142f8: e3013568  movw  r3, #5480 ; 0x1568
   142fc: e3403002  movt  r3, #2
   14300: e793110c  ldr r1, [r3, ip, lsl #2]

  if (cfs != 0U) {
   14304: e3510000  cmp r1, #0
#if _FS_REENTRANT           /* Discard sync object of the current volume */
    if ((!ff_del_syncobj(cfs->sobj)) != 0U) {
      return FR_INT_ERR;
    }
#endif
    cfs->fs_type = 0U;        /* Clear old fs object */
   14308: 13a02000  movne r2, #0
   1430c: 15c12000  strbne  r2, [r1]
  }

  if (fs != 0U) {
   14310: e59d1004  ldr r1, [sp, #4]
   14314: e3510000  cmp r1, #0
   14318: 0a00000c  beq 14350 <f_mount+0x88>
    }
#endif
  }
  FatFs[vol] = fs;          /* Register new fs object */

  if (((!fs) != 0U) || (opt != 1U)) {
   1431c: e3540001  cmp r4, #1
#endif
    cfs->fs_type = 0U;        /* Clear old fs object */
  }

  if (fs != 0U) {
    fs->fs_type = 0U;       /* Clear new fs object */
   14320: e3a02000  mov r2, #0
   14324: e5c12000  strb  r2, [r1]
#endif
  }
  FatFs[vol] = fs;          /* Register new fs object */

  if (((!fs) != 0U) || (opt != 1U)) {
    return FR_OK; /* Do not mount now, it will be mounted later */
   14328: 11a00002  movne r0, r2
    if ((!ff_cre_syncobj((BYTE)vol, &fs->sobj)) != 0U) {
      return FR_INT_ERR;
    }
#endif
  }
  FatFs[vol] = fs;          /* Register new fs object */
   1432c: e783110c  str r1, [r3, ip, lsl #2]

  if (((!fs) != 0U) || (opt != 1U)) {
   14330: 0a000001  beq 1433c <f_mount+0x74>
    return FR_OK; /* Do not mount now, it will be mounted later */
  }

  res = find_volume(&fs, &path, 0U);  /* Force mounted the volume */
  LEAVE_FF(fs, res);
}
   14334: e28dd010  add sp, sp, #16
   14338: e8bd8010  pop {r4, pc}

  if (((!fs) != 0U) || (opt != 1U)) {
    return FR_OK; /* Do not mount now, it will be mounted later */
  }

  res = find_volume(&fs, &path, 0U);  /* Force mounted the volume */
   1433c: e28d0004  add r0, sp, #4
   14340: e1a0100d  mov r1, sp
   14344: ebfffb5e  bl  130c4 <find_volume>
  LEAVE_FF(fs, res);
}
   14348: e28dd010  add sp, sp, #16
   1434c: e8bd8010  pop {r4, pc}
#endif
  }
  FatFs[vol] = fs;          /* Register new fs object */

  if (((!fs) != 0U) || (opt != 1U)) {
    return FR_OK; /* Do not mount now, it will be mounted later */
   14350: e1a00001  mov r0, r1
    if ((!ff_cre_syncobj((BYTE)vol, &fs->sobj)) != 0U) {
      return FR_INT_ERR;
    }
#endif
  }
  FatFs[vol] = fs;          /* Register new fs object */
   14354: e783110c  str r1, [r3, ip, lsl #2]
   14358: eafffff5  b 14334 <f_mount+0x6c>

0001435c <f_open>:
FRESULT f_open (
  FIL* fp,      /* Pointer to the blank file object */
  const TCHAR* path,  /* Pointer to the file name */
  BYTE mode     /* Access mode and file open mode flags */
)
{
   1435c: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
  DIR dj = {0};
  BYTE *dir;
  DEF_NAMEBUF;


  if ((!fp) != 0U) {
   14360: e3500000  cmp r0, #0
FRESULT f_open (
  FIL* fp,      /* Pointer to the blank file object */
  const TCHAR* path,  /* Pointer to the file name */
  BYTE mode     /* Access mode and file open mode flags */
)
{
   14364: e24dd030  sub sp, sp, #48 ; 0x30
  FRESULT res;
  DIR dj = {0};
   14368: e3a03000  mov r3, #0
FRESULT f_open (
  FIL* fp,      /* Pointer to the blank file object */
  const TCHAR* path,  /* Pointer to the file name */
  BYTE mode     /* Access mode and file open mode flags */
)
{
   1436c: e58d1004  str r1, [sp, #4]
  FRESULT res;
  DIR dj = {0};
   14370: e58d3014  str r3, [sp, #20]
   14374: e58d3018  str r3, [sp, #24]
   14378: e58d301c  str r3, [sp, #28]
   1437c: e58d3020  str r3, [sp, #32]
   14380: e58d3024  str r3, [sp, #36] ; 0x24
   14384: e58d3028  str r3, [sp, #40] ; 0x28
   14388: e58d302c  str r3, [sp, #44] ; 0x2c
  BYTE *dir;
  DEF_NAMEBUF;


  if ((!fp) != 0U) {
   1438c: 0a00000a  beq 143bc <f_open+0x60>
    return FR_INVALID_OBJECT;
  }
  fp->fs = NULL;      /* Clear file object */
   14390: e5803000  str r3, [r0]
   14394: e1a05002  mov r5, r2
   14398: e1a04000  mov r4, r0

  /* Get logical drive number */
#if !_FS_READONLY
  mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
  res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
   1439c: e28d1004  add r1, sp, #4
   143a0: e202201e  and r2, r2, #30
   143a4: e28d0014  add r0, sp, #20
   143a8: ebfffb45  bl  130c4 <find_volume>
#else
  mode &= FA_READ;
  res = find_volume(&dj.fs, &path, 0U);
#endif
  if (res == FR_OK) {
   143ac: e3500000  cmp r0, #0
   143b0: 0a000004  beq 143c8 <f_open+0x6c>
      fp->id = fp->fs->id;
    }
  }

  LEAVE_FF(dj.fs, res);
}
   143b4: e28dd030  add sp, sp, #48 ; 0x30
   143b8: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  BYTE *dir;
  DEF_NAMEBUF;


  if ((!fp) != 0U) {
    return FR_INVALID_OBJECT;
   143bc: e3a00009  mov r0, #9
      fp->id = fp->fs->id;
    }
  }

  LEAVE_FF(dj.fs, res);
}
   143c0: e28dd030  add sp, sp, #48 ; 0x30
   143c4: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  mode &= FA_READ;
  res = find_volume(&dj.fs, &path, 0U);
#endif
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path); /* Follow the file path */
   143c8: e28d0014  add r0, sp, #20
   143cc: e59d1004  ldr r1, [sp, #4]
#else
  mode &= FA_READ;
  res = find_volume(&dj.fs, &path, 0U);
#endif
  if (res == FR_OK) {
    INIT_BUF(dj);
   143d0: e28d3008  add r3, sp, #8
   143d4: e58d302c  str r3, [sp, #44] ; 0x2c
    res = follow_path(&dj, path); /* Follow the file path */
   143d8: ebfffe5a  bl  13d48 <follow_path>
  }
  fp->fs = NULL;      /* Clear file object */

  /* Get logical drive number */
#if !_FS_READONLY
  mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   143dc: e205701f  and r7, r5, #31
  res = find_volume(&dj.fs, &path, 0U);
#endif
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path); /* Follow the file path */
    dir = dj.dir;
   143e0: e59d6028  ldr r6, [sp, #40] ; 0x28
#if !_FS_READONLY /* R/W configuration */
    if (res == FR_OK) {
   143e4: e3500000  cmp r0, #0
   143e8: 1a00002d  bne 144a4 <f_open+0x148>
      if ((!dir) != 0U) {/* Default directory itself */
   143ec: e3560000  cmp r6, #0
   143f0: 0a000047  beq 14514 <f_open+0x1b8>
      else
        res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
    }
    /* Create or Open a file */
    if ((mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) != (BYTE)0U) {
   143f4: e315001c  tst r5, #28
   143f8: 0a000034  beq 144d0 <f_open+0x174>
        }
        mode |= FA_CREATE_ALWAYS;   /* File is created */
        dir = dj.dir;         /* New entry */
      }
      else {                /* Any object is already existing */
        if ((*(dir+DIR_Attr) & (AM_RDO | AM_DIR)) != 0U) {  /* Cannot overwrite it (R/O or DIR) */
   143fc: e5d6300b  ldrb  r3, [r6, #11]
   14400: e3130011  tst r3, #17
   14404: 1a000040  bne 1450c <f_open+0x1b0>
          res = FR_DENIED;
        } else {
          if ((mode & FA_CREATE_NEW) != (BYTE)0U) { /* Cannot create as new file */
   14408: e3150004  tst r5, #4
            res = FR_EXIST;
   1440c: 13a00008  movne r0, #8
      }
      else {                /* Any object is already existing */
        if ((*(dir+DIR_Attr) & (AM_RDO | AM_DIR)) != 0U) {  /* Cannot overwrite it (R/O or DIR) */
          res = FR_DENIED;
        } else {
          if ((mode & FA_CREATE_NEW) != (BYTE)0U) { /* Cannot create as new file */
   14410: 1affffe7  bne 143b4 <f_open+0x58>
            res = FR_EXIST;
          }
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
   14414: e3170008  tst r7, #8
   14418: 059dc014  ldreq ip, [sp, #20]
   1441c: 1a00003e  bne 1451c <f_open+0x1c0>
    }
    if (res == FR_OK) {
      if ((mode & FA_CREATE_ALWAYS) != 0U) {    /* Set file change flag if created or overwritten */
        mode |= FA__WRITTEN;
      }
      fp->dir_sect = dj.fs->winsect;    /* Pointer to the directory entry */
   14420: e59c202c  ldr r2, [ip, #44] ; 0x2c
#endif
    FREE_BUF();

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
   14424: e3a03000  mov r3, #0
    }
#endif
    FREE_BUF();

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
   14428: e5c47006  strb  r7, [r4, #6]
      fp->err = 0U;           /* Clear error flag */
      fp->sclust = ld_clust(dj.fs, dir);  /* File start cluster */
      fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
      fp->fptr = 0U;            /* File pointer */
   1442c: e3a0e000  mov lr, #0
#endif
    FREE_BUF();

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
   14430: e5c43007  strb  r3, [r4, #7]
      fp->dsect = 0U;
#if _USE_FASTSEEK
      fp->cltbl = 0;            /* Normal seek mode */
#endif
      fp->fs = dj.fs;           /* Validate file object */
      fp->id = fp->fs->id;
   14434: e1a0000e  mov r0, lr
    if (res == FR_OK) {
      if ((mode & FA_CREATE_ALWAYS) != 0U) {    /* Set file change flag if created or overwritten */
        mode |= FA__WRITTEN;
      }
      fp->dir_sect = dj.fs->winsect;    /* Pointer to the directory entry */
      fp->dir_ptr = dir;
   14438: e5846020  str r6, [r4, #32]
    }
    if (res == FR_OK) {
      if ((mode & FA_CREATE_ALWAYS) != 0U) {    /* Set file change flag if created or overwritten */
        mode |= FA__WRITTEN;
      }
      fp->dir_sect = dj.fs->winsect;    /* Pointer to the directory entry */
   1443c: e584201c  str r2, [r4, #28]
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
   14440: e5dc3000  ldrb  r3, [ip]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14444: e5d6201b  ldrb  r2, [r6, #27]
  if (fs->fs_type == FS_FAT32) {
   14448: e3530003  cmp r3, #3
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   1444c: e5d6301a  ldrb  r3, [r6, #26]
      fp->dsect = 0U;
#if _USE_FASTSEEK
      fp->cltbl = 0;            /* Normal seek mode */
#endif
      fp->fs = dj.fs;           /* Validate file object */
      fp->id = fp->fs->id;
   14450: e1dc50b6  ldrh  r5, [ip, #6]
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   14454: 05d61015  ldrbeq  r1, [r6, #21]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14458: e1833402  orr r3, r3, r2, lsl #8
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   1445c: 05d62014  ldrbeq  r2, [r6, #20]
   14460: 01822401  orreq r2, r2, r1, lsl #8
   14464: 01833802  orreq r3, r3, r2, lsl #16
    FREE_BUF();

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
      fp->sclust = ld_clust(dj.fs, dir);  /* File start cluster */
   14468: e5843010  str r3, [r4, #16]
      fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
   1446c: e5d6101e  ldrb  r1, [r6, #30]
   14470: e5d6301f  ldrb  r3, [r6, #31]
   14474: e5d6201c  ldrb  r2, [r6, #28]
   14478: e1a01801  lsl r1, r1, #16
   1447c: e5d6601d  ldrb  r6, [r6, #29]
   14480: e1813c03  orr r3, r1, r3, lsl #24
      fp->fptr = 0U;            /* File pointer */
      fp->dsect = 0U;
#if _USE_FASTSEEK
      fp->cltbl = 0;            /* Normal seek mode */
#endif
      fp->fs = dj.fs;           /* Validate file object */
   14484: e584c000  str ip, [r4]
   14488: e1833002  orr r3, r3, r2
    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
      fp->sclust = ld_clust(dj.fs, dir);  /* File start cluster */
      fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
      fp->fptr = 0U;            /* File pointer */
   1448c: e584e008  str lr, [r4, #8]

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
      fp->sclust = ld_clust(dj.fs, dir);  /* File start cluster */
      fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
   14490: e1833406  orr r3, r3, r6, lsl #8
      fp->dsect = 0U;
#if _USE_FASTSEEK
      fp->cltbl = 0;            /* Normal seek mode */
#endif
      fp->fs = dj.fs;           /* Validate file object */
      fp->id = fp->fs->id;
   14494: e1c450b4  strh  r5, [r4, #4]

    if (res == FR_OK) {
      fp->flag = mode;          /* File access mode */
      fp->err = 0U;           /* Clear error flag */
      fp->sclust = ld_clust(dj.fs, dir);  /* File start cluster */
      fp->fsize = LD_DWORD(dir+DIR_FileSize); /* File size */
   14498: e584300c  str r3, [r4, #12]
      fp->fptr = 0U;            /* File pointer */
      fp->dsect = 0U;
   1449c: e584e018  str lr, [r4, #24]
   144a0: eaffffc3  b 143b4 <f_open+0x58>
      else
        res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
#endif
    }
    /* Create or Open a file */
    if ((mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) != (BYTE)0U) {
   144a4: e315001c  tst r5, #28
   144a8: 0affffc1  beq 143b4 <f_open+0x58>
      DWORD dw, cl;

      if (res != FR_OK) {         /* No file, create new */
        if (res == FR_NO_FILE) {      /* There is no file to open, create a new entry */
   144ac: e3500004  cmp r0, #4
   144b0: 1affffbf  bne 143b4 <f_open+0x58>
#if _FS_LOCK
          res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
          res = dir_register(&dj);
   144b4: e28d0014  add r0, sp, #20
#endif
        }
        mode |= FA_CREATE_ALWAYS;   /* File is created */
   144b8: e3877008  orr r7, r7, #8
      if (res != FR_OK) {         /* No file, create new */
        if (res == FR_NO_FILE) {      /* There is no file to open, create a new entry */
#if _FS_LOCK
          res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
#else
          res = dir_register(&dj);
   144bc: ebffff38  bl  141a4 <dir_register>
#endif
        }
        mode |= FA_CREATE_ALWAYS;   /* File is created */
        dir = dj.dir;         /* New entry */
   144c0: e59d6028  ldr r6, [sp, #40] ; 0x28
          if ((mode & FA_CREATE_NEW) != (BYTE)0U) { /* Cannot create as new file */
            res = FR_EXIST;
          }
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
   144c4: e3500000  cmp r0, #0
   144c8: 0affffd1  beq 14414 <f_open+0xb8>
   144cc: eaffffb8  b 143b4 <f_open+0x58>
        }
      }
    }
    else {  /* Open an existing file */
      if (res == FR_OK) {         /* Follow succeeded */
        if ((*(dir+DIR_Attr) & AM_DIR) != 0U) { /* It is a directory */
   144d0: e5d6300b  ldrb  r3, [r6, #11]
   144d4: e3130010  tst r3, #16
          res = FR_NO_FILE;
   144d8: 13a00004  movne r0, #4
        }
      }
    }
    else {  /* Open an existing file */
      if (res == FR_OK) {         /* Follow succeeded */
        if ((*(dir+DIR_Attr) & AM_DIR) != 0U) { /* It is a directory */
   144dc: 1affffb4  bne 143b4 <f_open+0x58>
          res = FR_NO_FILE;
        } else {
          if (((mode & FA_WRITE) != 0U) && (((*(dir+DIR_Attr)) & AM_RDO) != 0U)) {/* R/O violation */
   144e0: e3150002  tst r5, #2
   144e4: 0a000001  beq 144f0 <f_open+0x194>
   144e8: e3130001  tst r3, #1
   144ec: 1a000006  bne 1450c <f_open+0x1b0>
   144f0: e2053008  and r3, r5, #8
   144f4: e59dc014  ldr ip, [sp, #20]
   144f8: e6ef3073  uxtb  r3, r3
          }
        }
      }
    }
    if (res == FR_OK) {
      if ((mode & FA_CREATE_ALWAYS) != 0U) {    /* Set file change flag if created or overwritten */
   144fc: e3530000  cmp r3, #0
   14500: 0affffc6  beq 14420 <f_open+0xc4>
        mode |= FA__WRITTEN;
   14504: e3877020  orr r7, r7, #32
   14508: eaffffc4  b 14420 <f_open+0xc4>
      if (res == FR_OK) {         /* Follow succeeded */
        if ((*(dir+DIR_Attr) & AM_DIR) != 0U) { /* It is a directory */
          res = FR_NO_FILE;
        } else {
          if (((mode & FA_WRITE) != 0U) && (((*(dir+DIR_Attr)) & AM_RDO) != 0U)) {/* R/O violation */
            res = FR_DENIED;
   1450c: e3a00007  mov r0, #7
   14510: eaffffa7  b 143b4 <f_open+0x58>
    res = follow_path(&dj, path); /* Follow the file path */
    dir = dj.dir;
#if !_FS_READONLY /* R/W configuration */
    if (res == FR_OK) {
      if ((!dir) != 0U) {/* Default directory itself */
        res = FR_INVALID_NAME;
   14514: e3a00006  mov r0, #6
   14518: eaffffa5  b 143b4 <f_open+0x58>
            res = FR_EXIST;
          }
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
        dw = get_fattime();       /* Created time */
   1451c: eb000692  bl  15f6c <get_fattime>
        ST_DWORD(dir+DIR_CrtTime, dw);
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
        cl = ld_clust(dj.fs, dir);    /* Get start cluster */
   14520: e59dc014  ldr ip, [sp, #20]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14524: e5d6501b  ldrb  r5, [r6, #27]
          }
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
        dw = get_fattime();       /* Created time */
        ST_DWORD(dir+DIR_CrtTime, dw);
   14528: e586000e  str r0, [r6, #14]
   1452c: e1a02420  lsr r2, r0, #8
   14530: e1a03820  lsr r3, r0, #16
   14534: e5c6200f  strb  r2, [r6, #15]
   14538: e5c63010  strb  r3, [r6, #16]
   1453c: e1a00c20  lsr r0, r0, #24
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
   14540: e3a03000  mov r3, #0
          }
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
        dw = get_fattime();       /* Created time */
        ST_DWORD(dir+DIR_CrtTime, dw);
   14544: e5c60011  strb  r0, [r6, #17]
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
   14548: e586301c  str r3, [r6, #28]
        }
      }
      if ((res == FR_OK) && ((mode & FA_CREATE_ALWAYS) != (BYTE)0U)) {  /* Truncate it if overwrite mode */
        dw = get_fattime();       /* Created time */
        ST_DWORD(dir+DIR_CrtTime, dw);
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
   1454c: e5c6300b  strb  r3, [r6, #11]
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
   14550: e5c6301d  strb  r3, [r6, #29]
   14554: e5c6301e  strb  r3, [r6, #30]
   14558: e5c6301f  strb  r3, [r6, #31]
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
   1455c: e5dc3000  ldrb  r3, [ip]
   14560: e3530003  cmp r3, #3
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14564: e5d6301a  ldrb  r3, [r6, #26]
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   14568: 05d62015  ldrbeq  r2, [r6, #21]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   1456c: e1835405  orr r5, r3, r5, lsl #8
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   14570: 05d63014  ldrbeq  r3, [r6, #20]
   14574: 01833402  orreq r3, r3, r2, lsl #8
        ST_DWORD(dir+DIR_CrtTime, dw);
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
        cl = ld_clust(dj.fs, dir);    /* Get start cluster */
        st_clust(dir, 0U);        /* cluster = 0 */
        dj.fs->wflag = 1U;
   14578: e3a02001  mov r2, #1
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   1457c: 01855803  orreq r5, r5, r3, lsl #16
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14580: e3a03000  mov r3, #0
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
        cl = ld_clust(dj.fs, dir);    /* Get start cluster */
        st_clust(dir, 0U);        /* cluster = 0 */
        dj.fs->wflag = 1U;
        if (cl != (DWORD)0U) {            /* Remove the cluster chain if exist */
   14584: e3550000  cmp r5, #0
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14588: e1c631ba  strh  r3, [r6, #26]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   1458c: e1c631b4  strh  r3, [r6, #20]
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14590: e1c631bb  strh  r3, [r6, #27]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   14594: e1c631b5  strh  r3, [r6, #21]
        ST_DWORD(dir+DIR_CrtTime, dw);
        (*(dir+DIR_Attr)) = 0U;       /* Reset attribute */
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
        cl = ld_clust(dj.fs, dir);    /* Get start cluster */
        st_clust(dir, 0U);        /* cluster = 0 */
        dj.fs->wflag = 1U;
   14598: e5cc2004  strb  r2, [ip, #4]
        if (cl != (DWORD)0U) {            /* Remove the cluster chain if exist */
   1459c: 0affffd8  beq 14504 <f_open+0x1a8>
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   145a0: e1550002  cmp r5, r2
        ST_DWORD(dir+DIR_FileSize, 0);  /* size = 0 */
        cl = ld_clust(dj.fs, dir);    /* Get start cluster */
        st_clust(dir, 0U);        /* cluster = 0 */
        dj.fs->wflag = 1U;
        if (cl != (DWORD)0U) {            /* Remove the cluster chain if exist */
          dw = dj.fs->winsect;
   145a4: e59c802c  ldr r8, [ip, #44] ; 0x2c
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   145a8: 9a000002  bls 145b8 <f_open+0x25c>
   145ac: e59c3014  ldr r3, [ip, #20]
   145b0: e1530005  cmp r3, r5
   145b4: 8a000001  bhi 145c0 <f_open+0x264>
   145b8: e3a00002  mov r0, #2
   145bc: eaffff7c  b 143b4 <f_open+0x58>
   145c0: e1a0000c  mov r0, ip
   145c4: e1a01005  mov r1, r5
   145c8: ebfffe9e  bl  14048 <remove_chain.part.10>
        st_clust(dir, 0U);        /* cluster = 0 */
        dj.fs->wflag = 1U;
        if (cl != (DWORD)0U) {            /* Remove the cluster chain if exist */
          dw = dj.fs->winsect;
          res = remove_chain(dj.fs, cl);
          if (res == FR_OK) {
   145cc: e3500000  cmp r0, #0
   145d0: 1affff77  bne 143b4 <f_open+0x58>
            dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
   145d4: e59d0014  ldr r0, [sp, #20]
   145d8: e2455001  sub r5, r5, #1
            res = move_window(dj.fs, dw);
   145dc: e1a01008  mov r1, r8
        dj.fs->wflag = 1U;
        if (cl != (DWORD)0U) {            /* Remove the cluster chain if exist */
          dw = dj.fs->winsect;
          res = remove_chain(dj.fs, cl);
          if (res == FR_OK) {
            dj.fs->last_clust = cl - 1; /* Reuse the cluster hole */
   145e0: e580500c  str r5, [r0, #12]
            res = move_window(dj.fs, dw);
   145e4: ebfffa71  bl  12fb0 <move_window>
            res = FR_DENIED;
          }
        }
      }
    }
    if (res == FR_OK) {
   145e8: e3500000  cmp r0, #0
   145ec: 059dc014  ldreq ip, [sp, #20]
   145f0: 0affffc3  beq 14504 <f_open+0x1a8>
   145f4: eaffff6e  b 143b4 <f_open+0x58>

000145f8 <f_read>:
  FIL* fp,    /* Pointer to the file object */
  void* buff,   /* Pointer to data buffer */
  UINT btr,   /* Number of bytes to read */
  UINT* br    /* Pointer to number of bytes read */
)
{
   145f8: e92d4ff8  push  {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   145fc: e1a07003  mov r7, r3
  DWORD clst, sect, remain;
  UINT rcnt, cc;
  BYTE csect, *rbuff = (BYTE*)(void *)buff;


  *br = 0U; /* Clear read byte counter */
   14600: e3a03000  mov r3, #0
   14604: e5873000  str r3, [r7]
  FIL* fp,    /* Pointer to the file object */
  void* buff,   /* Pointer to data buffer */
  UINT btr,   /* Number of bytes to read */
  UINT* br    /* Pointer to number of bytes read */
)
{
   14608: e1a04001  mov r4, r1
   1460c: e1a06002  mov r6, r2
   14610: e1a05000  mov r5, r0
  BYTE csect, *rbuff = (BYTE*)(void *)buff;


  *br = 0U; /* Clear read byte counter */

  res = validate(fp);             /* Check validity */
   14614: ebfff9b2  bl  12ce4 <validate>
  if (res != FR_OK) {
   14618: e3500000  cmp r0, #0
   1461c: 18bd8ff8  popne {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LEAVE_FF(fp->fs, res);
  }
  if (fp->err != (BYTE)0U) {                /* Check error */
   14620: e5d50007  ldrb  r0, [r5, #7]
   14624: e3500000  cmp r0, #0
   14628: 18bd8ff8  popne {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LEAVE_FF(fp->fs, (FRESULT)fp->err);
  }
  if ((!(fp->flag & FA_READ)) != 0U) {          /* Check access mode */
   1462c: e5d53006  ldrb  r3, [r5, #6]
   14630: e3130001  tst r3, #1
   14634: 0a00004f  beq 14778 <f_read+0x180>
    LEAVE_FF(fp->fs, FR_DENIED);
  }
  remain = fp->fsize - fp->fptr;
   14638: e5951008  ldr r1, [r5, #8]
   1463c: e595300c  ldr r3, [r5, #12]
   14640: e0613003  rsb r3, r1, r3
   14644: e1560003  cmp r6, r3
   14648: 21a06003  movcs r6, r3
  if (btr > (UINT)remain) {
    btr = (UINT)remain;   /* Truncate btr by remaining bytes */
  }
  while(btr != (UINT)0U) {                /* Repeat until all data read */
   1464c: e3560000  cmp r6, #0
   14650: 0a000087  beq 14874 <f_read+0x27c>

    if ((fp->fptr % SS(fp->fs)) == 0U) {    /* On the sector boundary? */
   14654: e7e8c051  ubfx  ip, r1, #0, #9
      }
#if !_FS_TINY
      if (fp->dsect != sect) {      /* Load data sector if not in cache */
#if !_FS_READONLY
        if ((fp->flag & FA__DIRTY) != (BYTE)0U) {   /* Write-back dirty sector cache */
          if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   14658: e2858040  add r8, r5, #64 ; 0x40
  if (btr > (UINT)remain) {
    btr = (UINT)remain;   /* Truncate btr by remaining bytes */
  }
  while(btr != (UINT)0U) {                /* Repeat until all data read */

    if ((fp->fptr % SS(fp->fs)) == 0U) {    /* On the sector boundary? */
   1465c: e35c0000  cmp ip, #0
   14660: 1a000032  bne 14730 <f_read+0x138>
      csect = (BYTE)(((BYTE)((DWORD)fp->fptr / (DWORD)SS(fp->fs))) & (BYTE)(fp->fs->csize - (BYTE)1U)); /* Sector offset in the cluster */
   14664: e5950000  ldr r0, [r5]
   14668: e5d03002  ldrb  r3, [r0, #2]
   1466c: e2433001  sub r3, r3, #1
   14670: e00334a1  and r3, r3, r1, lsr #9
      if ((!csect) != 0U) {           /* On the cluster boundary? */
   14674: e213b0ff  ands  fp, r3, #255  ; 0xff
   14678: 0a000049  beq 147a4 <f_read+0x1ac>
   1467c: e5953014  ldr r3, [r5, #20]
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   14680: e5902014  ldr r2, [r0, #20]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   14684: e2433002  sub r3, r3, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   14688: e2422002  sub r2, r2, #2
   1468c: e1530002  cmp r3, r2
   14690: 2a000040  bcs 14798 <f_read+0x1a0>
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   14694: e5d02002  ldrb  r2, [r0, #2]
   14698: e590a028  ldr sl, [r0, #40] ; 0x28
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->clust = clst;       /* Update current cluster */
      }
      sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
      if ((!sect) != 0U) {
   1469c: e033a392  mlas  r3, r2, r3, sl
   146a0: 0a00003c  beq 14798 <f_read+0x1a0>
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
      cc = btr / SS(fp->fs);        /* When remaining bytes >= sector size, */
      if (cc != 0U) {             /* Read maximum contiguous sectors directly */
   146a4: e1b094a6  lsrs  r9, r6, #9
      }
      sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
      if ((!sect) != 0U) {
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
   146a8: e083a00b  add sl, r3, fp
      cc = btr / SS(fp->fs);        /* When remaining bytes >= sector size, */
      if (cc != 0U) {             /* Read maximum contiguous sectors directly */
   146ac: 0a000047  beq 147d0 <f_read+0x1d8>
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
   146b0: e08b3009  add r3, fp, r9
          cc = (UINT)(fp->fs->csize - csect);
        }
        if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK) {
   146b4: e5d00001  ldrb  r0, [r0, #1]
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
      cc = btr / SS(fp->fs);        /* When remaining bytes >= sector size, */
      if (cc != 0U) {             /* Read maximum contiguous sectors directly */
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
   146b8: e1530002  cmp r3, r2
          cc = (UINT)(fp->fs->csize - csect);
        }
        if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK) {
   146bc: e1a01004  mov r1, r4
      }
      sect += csect;
      cc = btr / SS(fp->fs);        /* When remaining bytes >= sector size, */
      if (cc != 0U) {             /* Read maximum contiguous sectors directly */
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
          cc = (UINT)(fp->fs->csize - csect);
   146c0: 806b9002  rsbhi r9, fp, r2
        }
        if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK) {
   146c4: e1a0200a  mov r2, sl
   146c8: e6ef3079  uxtb  r3, r9
   146cc: eb0005f7  bl  15eb0 <disk_read>
   146d0: e3500000  cmp r0, #0
   146d4: 1a000058  bne 1483c <f_read+0x244>
#if _FS_TINY
        if ((fp->fs->wflag != 0U) && (((fp->fs->winsect - sect) < cc) != 0U)) {
          mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
        }
#else
        if (((fp->flag & FA__DIRTY) != (BYTE)0U) && ((fp->dsect - sect) < cc)) {
   146d8: e5d53006  ldrb  r3, [r5, #6]
   146dc: e3130040  tst r3, #64 ; 0x40
   146e0: 0a000003  beq 146f4 <f_read+0xfc>
   146e4: e5953018  ldr r3, [r5, #24]
   146e8: e06a3003  rsb r3, sl, r3
   146ec: e1590003  cmp r9, r3
   146f0: 8a000054  bhi 14848 <f_read+0x250>
          mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
        }
#endif
#endif
        rcnt = SS(fp->fs) * cc;     /* Number of bytes transferred */
        rbuff += rcnt; fp->fptr += rcnt; *br += rcnt;btr -= rcnt;
   146f4: e5952008  ldr r2, [r5, #8]
        if (((fp->flag & FA__DIRTY) != (BYTE)0U) && ((fp->dsect - sect) < cc)) {
          mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
        }
#endif
#endif
        rcnt = SS(fp->fs) * cc;     /* Number of bytes transferred */
   146f8: e1a09489  lsl r9, r9, #9
        rbuff += rcnt; fp->fptr += rcnt; *br += rcnt;btr -= rcnt;
   146fc: e5973000  ldr r3, [r7]
   14700: e0844009  add r4, r4, r9
   14704: e0822009  add r2, r2, r9
   14708: e0696006  rsb r6, r9, r6
   1470c: e5852008  str r2, [r5, #8]
   14710: e0839009  add r9, r3, r9
   14714: e5879000  str r9, [r7]
  }
  remain = fp->fsize - fp->fptr;
  if (btr > (UINT)remain) {
    btr = (UINT)remain;   /* Truncate btr by remaining bytes */
  }
  while(btr != (UINT)0U) {                /* Repeat until all data read */
   14718: e3560000  cmp r6, #0
   1471c: 0a000054  beq 14874 <f_read+0x27c>
   14720: e5951008  ldr r1, [r5, #8]

    if ((fp->fptr % SS(fp->fs)) == 0U) {    /* On the sector boundary? */
   14724: e7e8c051  ubfx  ip, r1, #0, #9
   14728: e35c0000  cmp ip, #0
   1472c: 0affffcc  beq 14664 <f_read+0x6c>
        }
      }
#endif
      fp->dsect = sect;
    }
    rcnt = (UINT)SS(fp->fs) - (UINT)(fp->fptr % SS(fp->fs));  /* Get partial sector data from sector buffer */
   14730: e26c1c02  rsb r1, ip, #512  ; 0x200
    if (move_window(fp->fs, fp->dsect) != 0U) {   /* Move sector window */
      ABORT(fp->fs, FR_DISK_ERR);
    }
    mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
#else
    mem_cpy(rbuff, (void *)&fp->buf[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
   14734: e085c00c  add ip, r5, ip
   14738: e1510006  cmp r1, r6
   1473c: e28cc03f  add ip, ip, #63 ; 0x3f
   14740: 21a01006  movcs r1, r6
   14744: e0842001  add r2, r4, r1
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   14748: e5fc3001  ldrb  r3, [ip, #1]!
   1474c: e4c43001  strb  r3, [r4], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   14750: e1540002  cmp r4, r2
   14754: 1afffffb  bne 14748 <f_read+0x150>
    }
    mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
#else
    mem_cpy(rbuff, (void *)&fp->buf[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
#endif
    rbuff += rcnt; fp->fptr += rcnt; *br += rcnt;btr -= rcnt;
   14758: e5952008  ldr r2, [r5, #8]
   1475c: e0616006  rsb r6, r1, r6
   14760: e5973000  ldr r3, [r7]
   14764: e0822001  add r2, r2, r1
   14768: e5852008  str r2, [r5, #8]
   1476c: e0831001  add r1, r3, r1
   14770: e5871000  str r1, [r7]
   14774: eaffffe7  b 14718 <f_read+0x120>
  }
  if (fp->err != (BYTE)0U) {                /* Check error */
    LEAVE_FF(fp->fs, (FRESULT)fp->err);
  }
  if ((!(fp->flag & FA_READ)) != 0U) {          /* Check access mode */
    LEAVE_FF(fp->fs, FR_DENIED);
   14778: e3a00007  mov r0, #7
   1477c: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          if (fp->cltbl) {
            clst = clmt_clust(fp, fp->fptr);  /* Get cluster# from the CLMT */
          }
          else
#endif
            clst = get_fat(fp->fs, fp->clust);  /* Follow cluster chain on the FAT */
   14780: e5951014  ldr r1, [r5, #20]
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   14784: e3510001  cmp r1, #1
   14788: 9a000002  bls 14798 <f_read+0x1a0>
   1478c: e5903014  ldr r3, [r0, #20]
   14790: e1510003  cmp r1, r3
   14794: 3a000033  bcc 14868 <f_read+0x270>
          else
#endif
            clst = get_fat(fp->fs, fp->clust);  /* Follow cluster chain on the FAT */
        }
        if (clst < 2U) {
          ABORT(fp->fs, FR_INT_ERR);
   14798: e3a00002  mov r0, #2
   1479c: e5c50007  strb  r0, [r5, #7]
   147a0: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  while(btr != (UINT)0U) {                /* Repeat until all data read */

    if ((fp->fptr % SS(fp->fs)) == 0U) {    /* On the sector boundary? */
      csect = (BYTE)(((BYTE)((DWORD)fp->fptr / (DWORD)SS(fp->fs))) & (BYTE)(fp->fs->csize - (BYTE)1U)); /* Sector offset in the cluster */
      if ((!csect) != 0U) {           /* On the cluster boundary? */
        if (fp->fptr == 0U) {     /* On the top of the file? */
   147a4: e3510000  cmp r1, #0
   147a8: 1afffff4  bne 14780 <f_read+0x188>
          clst = fp->sclust;      /* Follow from the origin */
   147ac: e5952010  ldr r2, [r5, #16]
          }
          else
#endif
            clst = get_fat(fp->fs, fp->clust);  /* Follow cluster chain on the FAT */
        }
        if (clst < 2U) {
   147b0: e3520001  cmp r2, #1
   147b4: 9afffff7  bls 14798 <f_read+0x1a0>
          ABORT(fp->fs, FR_INT_ERR);
        }
        if (clst == 0xFFFFFFFFU) {
   147b8: e3720001  cmn r2, #1
   147bc: 0a00001e  beq 1483c <f_read+0x244>
   147c0: e5950000  ldr r0, [r5]
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->clust = clst;       /* Update current cluster */
   147c4: e1a03002  mov r3, r2
   147c8: e5852014  str r2, [r5, #20]
   147cc: eaffffab  b 14680 <f_read+0x88>
        rcnt = SS(fp->fs) * cc;     /* Number of bytes transferred */
        rbuff += rcnt; fp->fptr += rcnt; *br += rcnt;btr -= rcnt;
        continue;
      }
#if !_FS_TINY
      if (fp->dsect != sect) {      /* Load data sector if not in cache */
   147d0: e5952018  ldr r2, [r5, #24]
   147d4: e152000a  cmp r2, sl
   147d8: 0a000013  beq 1482c <f_read+0x234>
#if !_FS_READONLY
        if ((fp->flag & FA__DIRTY) != (BYTE)0U) {   /* Write-back dirty sector cache */
   147dc: e5d53006  ldrb  r3, [r5, #6]
   147e0: e3130040  tst r3, #64 ; 0x40
   147e4: 0a000009  beq 14810 <f_read+0x218>
          if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   147e8: e5d00001  ldrb  r0, [r0, #1]
   147ec: e1a01008  mov r1, r8
   147f0: e3a03001  mov r3, #1
   147f4: eb0005df  bl  15f78 <disk_write>
   147f8: e3500000  cmp r0, #0
   147fc: 1a00000e  bne 1483c <f_read+0x244>
   14800: e5950000  ldr r0, [r5]
            ABORT(fp->fs, FR_DISK_ERR);
          }
          fp->flag &= ~FA__DIRTY;
   14804: e5d53006  ldrb  r3, [r5, #6]
   14808: e3c33040  bic r3, r3, #64 ; 0x40
   1480c: e5c53006  strb  r3, [r5, #6]
        }
#endif
        if (disk_read(fp->fs->drv, fp->buf, sect, 1U) != RES_OK) {  /* Fill sector cache */
   14810: e5d00001  ldrb  r0, [r0, #1]
   14814: e1a01008  mov r1, r8
   14818: e1a0200a  mov r2, sl
   1481c: e3a03001  mov r3, #1
   14820: eb0005a2  bl  15eb0 <disk_read>
   14824: e3500000  cmp r0, #0
   14828: 1a000003  bne 1483c <f_read+0x244>
   1482c: e595c008  ldr ip, [r5, #8]
          ABORT(fp->fs, FR_DISK_ERR);
        }
      }
#endif
      fp->dsect = sect;
   14830: e585a018  str sl, [r5, #24]
   14834: e7e8c05c  ubfx  ip, ip, #0, #9
   14838: eaffffbc  b 14730 <f_read+0x138>
        }
        if (clst < 2U) {
          ABORT(fp->fs, FR_INT_ERR);
        }
        if (clst == 0xFFFFFFFFU) {
          ABORT(fp->fs, FR_DISK_ERR);
   1483c: e3a00001  mov r0, #1
   14840: e5c50007  strb  r0, [r5, #7]
   14844: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((fp->fs->wflag != 0U) && (((fp->fs->winsect - sect) < cc) != 0U)) {
          mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
        }
#else
        if (((fp->flag & FA__DIRTY) != (BYTE)0U) && ((fp->dsect - sect) < cc)) {
          mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
   14848: e0843483  add r3, r4, r3, lsl #9
   1484c: e285203f  add r2, r5, #63 ; 0x3f
   14850: e2830c02  add r0, r3, #512  ; 0x200
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   14854: e5f21001  ldrb  r1, [r2, #1]!
   14858: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   1485c: e1530000  cmp r3, r0
   14860: 1afffffb  bne 14854 <f_read+0x25c>
   14864: eaffffa2  b 146f4 <f_read+0xfc>
   14868: ebfffb4e  bl  135a8 <get_fat.part.6>
   1486c: e1a02000  mov r2, r0
   14870: eaffffce  b 147b0 <f_read+0x1b8>
    mem_cpy(rbuff, (void *)&fp->buf[fp->fptr % SS(fp->fs)], rcnt);  /* Pick partial sector */
#endif
    rbuff += rcnt; fp->fptr += rcnt; *br += rcnt;btr -= rcnt;
  }

  LEAVE_FF(fp->fs, FR_OK);
   14874: e3a00000  mov r0, #0
   14878: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0001487c <f_write>:
  FIL* fp,      /* Pointer to the file object */
  const void *buff, /* Pointer to the data to be written */
  UINT btw,     /* Number of bytes to write */
  UINT* bw      /* Pointer to number of bytes written */
)
{
   1487c: e92d4ff8  push  {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
   14880: e1a06003  mov r6, r3
  UINT wcnt, cc;
  const BYTE *wbuff = buff;
  BYTE csect;
  UINT LocBtw = btw;

  *bw = 0U; /* Clear write byte counter */
   14884: e3a03000  mov r3, #0
   14888: e5863000  str r3, [r6]
  FIL* fp,      /* Pointer to the file object */
  const void *buff, /* Pointer to the data to be written */
  UINT btw,     /* Number of bytes to write */
  UINT* bw      /* Pointer to number of bytes written */
)
{
   1488c: e1a07001  mov r7, r1
   14890: e1a05002  mov r5, r2
   14894: e1a04000  mov r4, r0
  BYTE csect;
  UINT LocBtw = btw;

  *bw = 0U; /* Clear write byte counter */

  res = validate(fp);           /* Check validity */
   14898: ebfff911  bl  12ce4 <validate>
  if (res != FR_OK) {
   1489c: e3500000  cmp r0, #0
   148a0: 18bd8ff8  popne {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LEAVE_FF(fp->fs, res);
  }
  if (fp->err != (BYTE)0U) {              /* Check error */
   148a4: e5d40007  ldrb  r0, [r4, #7]
   148a8: e3500000  cmp r0, #0
   148ac: 18bd8ff8  popne {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    LEAVE_FF(fp->fs, (FRESULT)fp->err);
  }
  if ((!(fp->flag & FA_WRITE)) != 0U) {     /* Check access mode */
   148b0: e5d42006  ldrb  r2, [r4, #6]
   148b4: e3120002  tst r2, #2
   148b8: 0a000009  beq 148e4 <f_write+0x68>
    LEAVE_FF(fp->fs, FR_DENIED);
  }
  if ((fp->fptr + LocBtw) < fp->fptr) {
   148bc: e5943008  ldr r3, [r4, #8]
   148c0: e1750003  cmn r5, r3
   148c4: 3a000008  bcc 148ec <f_write+0x70>
    fp->flag |= FA__DIRTY;
#endif
    wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
  }

  if (fp->fptr > fp->fsize) {
   148c8: e594100c  ldr r1, [r4, #12]
    fp->fsize = fp->fptr; /* Update file size if needed */
  }
  fp->flag |= FA__WRITTEN;            /* Set file change flag */
   148cc: e3822020  orr r2, r2, #32

  LEAVE_FF(fp->fs, FR_OK);
   148d0: e3a00000  mov r0, #0
  }

  if (fp->fptr > fp->fsize) {
    fp->fsize = fp->fptr; /* Update file size if needed */
  }
  fp->flag |= FA__WRITTEN;            /* Set file change flag */
   148d4: e5c42006  strb  r2, [r4, #6]
    fp->flag |= FA__DIRTY;
#endif
    wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
  }

  if (fp->fptr > fp->fsize) {
   148d8: e1510003  cmp r1, r3
    fp->fsize = fp->fptr; /* Update file size if needed */
   148dc: 3584300c  strcc r3, [r4, #12]
  }
  fp->flag |= FA__WRITTEN;            /* Set file change flag */

  LEAVE_FF(fp->fs, FR_OK);
   148e0: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }
  if (fp->err != (BYTE)0U) {              /* Check error */
    LEAVE_FF(fp->fs, (FRESULT)fp->err);
  }
  if ((!(fp->flag & FA_WRITE)) != 0U) {     /* Check access mode */
    LEAVE_FF(fp->fs, FR_DENIED);
   148e4: e3a00007  mov r0, #7
   148e8: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
  }
  if ((fp->fptr + LocBtw) < fp->fptr) {
    LocBtw = 0U;  /* File size cannot reach 4GB */
  }

  while(LocBtw != (UINT)0U) {             /* Repeat until all data written */
   148ec: e3550000  cmp r5, #0
   148f0: 0afffff4  beq 148c8 <f_write+0x4c>
        fp->fs->winsect = sect;
      }
#else
      if (fp->dsect != sect) {    /* Fill sector cache with file data */
        if (((fp->fptr < fp->fsize) != 0U) &&
          (disk_read(fp->fs->drv, fp->buf, sect, 1U) != RES_OK)) {
   148f4: e2848040  add r8, r4, #64 ; 0x40
    LocBtw = 0U;  /* File size cannot reach 4GB */
  }

  while(LocBtw != (UINT)0U) {             /* Repeat until all data written */

    if ((fp->fptr % SS(fp->fs)) == 0U) {  /* On the sector boundary? */
   148f8: e7e8c053  ubfx  ip, r3, #0, #9
   148fc: e35c0000  cmp ip, #0
   14900: 1a000030  bne 149c8 <f_write+0x14c>
      csect = (BYTE)((fp->fptr / ((DWORD)SS(fp->fs))) & (DWORD)(fp->fs->csize - 1U)); /* Sector offset in the cluster */
   14904: e5942000  ldr r2, [r4]
   14908: e5d2b002  ldrb  fp, [r2, #2]
   1490c: e24bb001  sub fp, fp, #1
   14910: e00bb4a3  and fp, fp, r3, lsr #9
      if ((!csect) != 0U) {         /* On the cluster boundary? */
   14914: e21bb0ff  ands  fp, fp, #255  ; 0xff
   14918: 1a00000d  bne 14954 <f_write+0xd8>
        if (fp->fptr == 0U) {   /* On the top of the file? */
   1491c: e3530000  cmp r3, #0
   14920: 1a00007b  bne 14b14 <f_write+0x298>
          clst = fp->sclust;    /* Follow from the origin */
   14924: e5940010  ldr r0, [r4, #16]
          if (clst == 0U) {   /* When no cluster is allocated, */
   14928: e3500000  cmp r0, #0
   1492c: 0a000080  beq 14b34 <f_write+0x2b8>
            clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
        }
        if (clst == 0U) {
          break;    /* Could not allocate a new cluster (disk full) */
        }
        if (clst == 1U) {
   14930: e3500001  cmp r0, #1
   14934: 0a00000f  beq 14978 <f_write+0xfc>
          ABORT(fp->fs, FR_INT_ERR);
        }
        if (clst == 0xFFFFFFFFU) {
   14938: e3700001  cmn r0, #1
   1493c: 0a000071  beq 14b08 <f_write+0x28c>
   14940: e5942000  ldr r2, [r4]
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->clust = clst;     /* Update current cluster */
        if (fp->sclust == 0U) {
   14944: e5943010  ldr r3, [r4, #16]
          ABORT(fp->fs, FR_INT_ERR);
        }
        if (clst == 0xFFFFFFFFU) {
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->clust = clst;     /* Update current cluster */
   14948: e5840014  str r0, [r4, #20]
        if (fp->sclust == 0U) {
   1494c: e3530000  cmp r3, #0
          fp->sclust = clst;  /* Set start cluster if the first write */
   14950: 05840010  streq r0, [r4, #16]
#if _FS_TINY
      if (fp->fs->winsect == fp->dsect && (sync_window(fp->fs) != 0U)) {  /* Write-back sector cache */
        ABORT(fp->fs, FR_DISK_ERR);
      }
#else
      if ((fp->flag & FA__DIRTY) != (BYTE)0U) {   /* Write-back sector cache */
   14954: e5d43006  ldrb  r3, [r4, #6]
   14958: e3130040  tst r3, #64 ; 0x40
   1495c: 1a00005d  bne 14ad8 <f_write+0x25c>
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   14960: e5943014  ldr r3, [r4, #20]
  if (LocalCluster >= (fs->n_fatent - 2)){
   14964: e5921014  ldr r1, [r2, #20]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   14968: e2433002  sub r3, r3, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   1496c: e2411002  sub r1, r1, #2
   14970: e1530001  cmp r3, r1
   14974: 3a00002d  bcc 14a30 <f_write+0x1b4>
        }
        if (clst == 0U) {
          break;    /* Could not allocate a new cluster (disk full) */
        }
        if (clst == 1U) {
          ABORT(fp->fs, FR_INT_ERR);
   14978: e3a00002  mov r0, #2
   1497c: e5c40007  strb  r0, [r4, #7]
   14980: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->fs->winsect = sect;
      }
#else
      if (fp->dsect != sect) {    /* Fill sector cache with file data */
   14984: e5943018  ldr r3, [r4, #24]
        if (((fp->fptr < fp->fsize) != 0U) &&
   14988: e594c008  ldr ip, [r4, #8]
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->fs->winsect = sect;
      }
#else
      if (fp->dsect != sect) {    /* Fill sector cache with file data */
   1498c: e153000a  cmp r3, sl
   14990: 0a00000a  beq 149c0 <f_write+0x144>
        if (((fp->fptr < fp->fsize) != 0U) &&
   14994: e594300c  ldr r3, [r4, #12]
   14998: e15c0003  cmp ip, r3
   1499c: 2a000007  bcs 149c0 <f_write+0x144>
          (disk_read(fp->fs->drv, fp->buf, sect, 1U) != RES_OK)) {
   149a0: e5d20001  ldrb  r0, [r2, #1]
   149a4: e1a01008  mov r1, r8
   149a8: e1a0200a  mov r2, sl
   149ac: e3a03001  mov r3, #1
   149b0: eb00053e  bl  15eb0 <disk_read>
        }
        fp->fs->winsect = sect;
      }
#else
      if (fp->dsect != sect) {    /* Fill sector cache with file data */
        if (((fp->fptr < fp->fsize) != 0U) &&
   149b4: e3500000  cmp r0, #0
   149b8: 1a000052  bne 14b08 <f_write+0x28c>
   149bc: e594c008  ldr ip, [r4, #8]
   149c0: e7e8c05c  ubfx  ip, ip, #0, #9
          (disk_read(fp->fs->drv, fp->buf, sect, 1U) != RES_OK)) {
            ABORT(fp->fs, FR_DISK_ERR);
        }
      }
#endif
      fp->dsect = sect;
   149c4: e584a018  str sl, [r4, #24]
    }
    wcnt = (((UINT)SS(fp->fs)) - ((UINT)fp->fptr % SS(fp->fs)));/* Put partial sector into file I/O buffer */
   149c8: e26c0c02  rsb r0, ip, #512  ; 0x200
      ABORT(fp->fs, FR_DISK_ERR);
    }
    mem_cpy((void *)&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
    fp->fs->wflag = 1U;
#else
    mem_cpy((void *)&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
   149cc: e28cc040  add ip, ip, #64 ; 0x40
   149d0: e1500005  cmp r0, r5
   149d4: e084c00c  add ip, r4, ip
   149d8: e2473001  sub r3, r7, #1
   149dc: 21a00005  movcs r0, r5
   149e0: e08c1000  add r1, ip, r0
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   149e4: e5f32001  ldrb  r2, [r3, #1]!
   149e8: e4cc2001  strb  r2, [ip], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   149ec: e15c0001  cmp ip, r1
   149f0: 1afffffb  bne 149e4 <f_write+0x168>
    }
    mem_cpy((void *)&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
    fp->fs->wflag = 1U;
#else
    mem_cpy((void *)&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
    fp->flag |= FA__DIRTY;
   149f4: e5d42006  ldrb  r2, [r4, #6]
#endif
    wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
   149f8: e0877000  add r7, r7, r0
   149fc: e5943008  ldr r3, [r4, #8]
   14a00: e0605005  rsb r5, r0, r5
    }
    mem_cpy((void *)&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
    fp->fs->wflag = 1U;
#else
    mem_cpy((void *)&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);  /* Fit partial sector */
    fp->flag |= FA__DIRTY;
   14a04: e3822040  orr r2, r2, #64 ; 0x40
   14a08: e5c42006  strb  r2, [r4, #6]
#endif
    wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
   14a0c: e5962000  ldr r2, [r6]
   14a10: e0803003  add r3, r0, r3
   14a14: e5843008  str r3, [r4, #8]
   14a18: e0820000  add r0, r2, r0
   14a1c: e5860000  str r0, [r6]
  }
  if ((fp->fptr + LocBtw) < fp->fptr) {
    LocBtw = 0U;  /* File size cannot reach 4GB */
  }

  while(LocBtw != (UINT)0U) {             /* Repeat until all data written */
   14a20: e3550000  cmp r5, #0
   14a24: 1affffb3  bne 148f8 <f_write+0x7c>
   14a28: e5d42006  ldrb  r2, [r4, #6]
   14a2c: eaffffa5  b 148c8 <f_write+0x4c>
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   14a30: e5d21002  ldrb  r1, [r2, #2]
   14a34: e592a028  ldr sl, [r2, #40] ; 0x28
        }
        fp->flag &= ~FA__DIRTY;
      }
#endif
      sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
      if ((!sect) != 0U) {
   14a38: e033a391  mlas  r3, r1, r3, sl
   14a3c: 0affffcd  beq 14978 <f_write+0xfc>
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
      cc = LocBtw / SS(fp->fs);     /* When remaining bytes >= sector size, */
      if (cc != 0U) {           /* Write maximum contiguous sectors directly */
   14a40: e1b094a5  lsrs  r9, r5, #9
#endif
      sect = clust2sect(fp->fs, fp->clust); /* Get current sector */
      if ((!sect) != 0U) {
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
   14a44: e08ba003  add sl, fp, r3
      cc = LocBtw / SS(fp->fs);     /* When remaining bytes >= sector size, */
      if (cc != 0U) {           /* Write maximum contiguous sectors directly */
   14a48: 0affffcd  beq 14984 <f_write+0x108>
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
   14a4c: e08b3009  add r3, fp, r9
          cc = (UINT)(fp->fs->csize - csect);
        }
        if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK) {
   14a50: e5d20001  ldrb  r0, [r2, #1]
        ABORT(fp->fs, FR_INT_ERR);
      }
      sect += csect;
      cc = LocBtw / SS(fp->fs);     /* When remaining bytes >= sector size, */
      if (cc != 0U) {           /* Write maximum contiguous sectors directly */
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
   14a54: e1530001  cmp r3, r1
          cc = (UINT)(fp->fs->csize - csect);
        }
        if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK) {
   14a58: e1a0200a  mov r2, sl
      }
      sect += csect;
      cc = LocBtw / SS(fp->fs);     /* When remaining bytes >= sector size, */
      if (cc != 0U) {           /* Write maximum contiguous sectors directly */
        if ((csect + cc) > fp->fs->csize) { /* Clip at cluster boundary */
          cc = (UINT)(fp->fs->csize - csect);
   14a5c: 806b9001  rsbhi r9, fp, r1
        }
        if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK) {
   14a60: e1a01007  mov r1, r7
   14a64: e6ef3079  uxtb  r3, r9
   14a68: eb000542  bl  15f78 <disk_write>
   14a6c: e3500000  cmp r0, #0
   14a70: 1a000024  bne 14b08 <f_write+0x28c>
        if ((fp->fs->winsect - sect) < cc) {  /* Refill sector cache if it gets invalidated by the direct write */
          mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
          fp->fs->wflag = 0U;
        }
#else
        if ((fp->dsect - sect) < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   14a74: e5943018  ldr r3, [r4, #24]
   14a78: e06a3003  rsb r3, sl, r3
   14a7c: e1590003  cmp r9, r3
   14a80: 9a00000a  bls 14ab0 <f_write+0x234>
   14a84: e0873483  add r3, r7, r3, lsl #9
   14a88: e2840d09  add r0, r4, #576  ; 0x240
   14a8c: e2432001  sub r2, r3, #1
          mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
   14a90: e1a03008  mov r3, r8
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   14a94: e5f21001  ldrb  r1, [r2, #1]!
   14a98: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   14a9c: e1530000  cmp r3, r0
   14aa0: 1afffffb  bne 14a94 <f_write+0x218>
          fp->fs->wflag = 0U;
        }
#else
        if ((fp->dsect - sect) < cc) { /* Refill sector cache if it gets invalidated by the direct write */
          mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
          fp->flag &= ~FA__DIRTY;
   14aa4: e5d43006  ldrb  r3, [r4, #6]
   14aa8: e3c33040  bic r3, r3, #64 ; 0x40
   14aac: e5c43006  strb  r3, [r4, #6]
        }
#endif
#endif
        wcnt = SS(fp->fs) * cc;   /* Number of bytes transferred */
        wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
   14ab0: e5943008  ldr r3, [r4, #8]
          mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
          fp->flag &= ~FA__DIRTY;
        }
#endif
#endif
        wcnt = SS(fp->fs) * cc;   /* Number of bytes transferred */
   14ab4: e1a09489  lsl r9, r9, #9
        wbuff += wcnt; fp->fptr += (DWORD)wcnt; *bw += wcnt; LocBtw -= wcnt;
   14ab8: e5962000  ldr r2, [r6]
   14abc: e0877009  add r7, r7, r9
   14ac0: e0893003  add r3, r9, r3
   14ac4: e0695005  rsb r5, r9, r5
   14ac8: e5843008  str r3, [r4, #8]
   14acc: e0829009  add r9, r2, r9
   14ad0: e5869000  str r9, [r6]
        continue;
   14ad4: eaffffd1  b 14a20 <f_write+0x1a4>
      if (fp->fs->winsect == fp->dsect && (sync_window(fp->fs) != 0U)) {  /* Write-back sector cache */
        ABORT(fp->fs, FR_DISK_ERR);
      }
#else
      if ((fp->flag & FA__DIRTY) != (BYTE)0U) {   /* Write-back sector cache */
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   14ad8: e5d20001  ldrb  r0, [r2, #1]
   14adc: e1a01008  mov r1, r8
   14ae0: e5942018  ldr r2, [r4, #24]
   14ae4: e3a03001  mov r3, #1
   14ae8: eb000522  bl  15f78 <disk_write>
   14aec: e3500000  cmp r0, #0
   14af0: 1a000004  bne 14b08 <f_write+0x28c>
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->flag &= ~FA__DIRTY;
   14af4: e5d43006  ldrb  r3, [r4, #6]
   14af8: e5942000  ldr r2, [r4]
   14afc: e3c33040  bic r3, r3, #64 ; 0x40
   14b00: e5c43006  strb  r3, [r4, #6]
   14b04: eaffff95  b 14960 <f_write+0xe4>
        }
        if (clst == 1U) {
          ABORT(fp->fs, FR_INT_ERR);
        }
        if (clst == 0xFFFFFFFFU) {
          ABORT(fp->fs, FR_DISK_ERR);
   14b08: e3a00001  mov r0, #1
   14b0c: e5c40007  strb  r0, [r4, #7]
   14b10: e8bd8ff8  pop {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
#if _USE_FASTSEEK
          if (fp->cltbl)
            clst = clmt_clust(fp, fp->fptr);  /* Get cluster# from the CLMT */
          else
#endif
            clst = create_chain(fp->fs, fp->clust); /* Follow or stretch cluster chain on the FAT */
   14b14: e1a00002  mov r0, r2
   14b18: e5941014  ldr r1, [r4, #20]
   14b1c: ebfffbaa  bl  139cc <create_chain>
        }
        if (clst == 0U) {
   14b20: e3500000  cmp r0, #0
   14b24: 1affff81  bne 14930 <f_write+0xb4>
   14b28: e5943008  ldr r3, [r4, #8]
   14b2c: e5d42006  ldrb  r2, [r4, #6]
   14b30: eaffff64  b 148c8 <f_write+0x4c>
      csect = (BYTE)((fp->fptr / ((DWORD)SS(fp->fs))) & (DWORD)(fp->fs->csize - 1U)); /* Sector offset in the cluster */
      if ((!csect) != 0U) {         /* On the cluster boundary? */
        if (fp->fptr == 0U) {   /* On the top of the file? */
          clst = fp->sclust;    /* Follow from the origin */
          if (clst == 0U) {   /* When no cluster is allocated, */
            clst = create_chain(fp->fs, 0U);  /* Create a new cluster chain */
   14b34: e1a00002  mov r0, r2
   14b38: e1a0100b  mov r1, fp
   14b3c: ebfffba2  bl  139cc <create_chain>
   14b40: eafffff6  b 14b20 <f_write+0x2a4>

00014b44 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
  FIL* fp   /* Pointer to the file object */
)
{
   14b44: e92d4070  push  {r4, r5, r6, lr}
   14b48: e1a05000  mov r5, r0
  FRESULT res;
  DWORD tm;
  BYTE *directory;


  res = validate(fp);         /* Check validity of the object */
   14b4c: ebfff864  bl  12ce4 <validate>
  if (res == FR_OK) {
   14b50: e3500000  cmp r0, #0
   14b54: 18bd8070  popne {r4, r5, r6, pc}
    if ((fp->flag & FA__WRITTEN) != 0U) { /* Has the file been written? */
   14b58: e5d52006  ldrb  r2, [r5, #6]
   14b5c: e2023020  and r3, r2, #32
   14b60: e21330ff  ands  r3, r3, #255  ; 0xff
   14b64: 0a000013  beq 14bb8 <f_sync+0x74>
      /* Write-back dirty buffer */
#if !_FS_TINY
      if ((fp->flag & FA__DIRTY) != (BYTE)0U) {
   14b68: e3120040  tst r2, #64 ; 0x40
   14b6c: 0a00000a  beq 14b9c <f_sync+0x58>
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   14b70: e1a01005  mov r1, r5
   14b74: e5952018  ldr r2, [r5, #24]
   14b78: e4910040  ldr r0, [r1], #64 ; 0x40
   14b7c: e3a03001  mov r3, #1
   14b80: e5d00001  ldrb  r0, [r0, #1]
   14b84: eb0004fb  bl  15f78 <disk_write>
   14b88: e3500000  cmp r0, #0
   14b8c: 1a000034  bne 14c64 <f_sync+0x120>
          LEAVE_FF(fp->fs, FR_DISK_ERR);
        }
        fp->flag &= ~FA__DIRTY;
   14b90: e5d53006  ldrb  r3, [r5, #6]
   14b94: e3c33040  bic r3, r3, #64 ; 0x40
   14b98: e5c53006  strb  r3, [r5, #6]
      }
#endif
      /* Update the directory entry */
      res = move_window(fp->fs, fp->dir_sect);
   14b9c: e5950000  ldr r0, [r5]
   14ba0: e595101c  ldr r1, [r5, #28]
   14ba4: ebfff901  bl  12fb0 <move_window>
      if (res == FR_OK) {
   14ba8: e2504000  subs  r4, r0, #0
   14bac: 0a000003  beq 14bc0 <f_sync+0x7c>
   14bb0: e1a00004  mov r0, r4
      }
    }
  }

  LEAVE_FF(fp->fs, res);
}
   14bb4: e8bd8070  pop {r4, r5, r6, pc}
   14bb8: e1a00003  mov r0, r3
   14bbc: e8bd8070  pop {r4, r5, r6, pc}
      }
#endif
      /* Update the directory entry */
      res = move_window(fp->fs, fp->dir_sect);
      if (res == FR_OK) {
        directory = fp->dir_ptr;
   14bc0: e5956020  ldr r6, [r5, #32]
        *(directory+DIR_Attr) |= AM_ARC;          /* Set archive bit */
   14bc4: e5d6300b  ldrb  r3, [r6, #11]
   14bc8: e3833020  orr r3, r3, #32
   14bcc: e5c6300b  strb  r3, [r6, #11]
        ST_DWORD(directory+DIR_FileSize, fp->fsize);    /* Update file size */
   14bd0: e595300c  ldr r3, [r5, #12]
   14bd4: e586301c  str r3, [r6, #28]
   14bd8: e595300c  ldr r3, [r5, #12]
   14bdc: e1a03423  lsr r3, r3, #8
   14be0: e5c6301d  strb  r3, [r6, #29]
   14be4: e1d530be  ldrh  r3, [r5, #14]
   14be8: e5c6301e  strb  r3, [r6, #30]
   14bec: e5d5300f  ldrb  r3, [r5, #15]
   14bf0: e5c6301f  strb  r3, [r6, #31]
        st_clust(directory, fp->sclust);          /* Update start cluster */
   14bf4: e5953010  ldr r3, [r5, #16]
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14bf8: e6ff2073  uxth  r2, r3
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   14bfc: e1a03823  lsr r3, r3, #16
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14c00: e1c621ba  strh  r2, [r6, #26]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   14c04: e1c631b4  strh  r3, [r6, #20]
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14c08: e1a02422  lsr r2, r2, #8
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   14c0c: e1a03423  lsr r3, r3, #8
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   14c10: e1c621bb  strh  r2, [r6, #27]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   14c14: e1c631b5  strh  r3, [r6, #21]
      if (res == FR_OK) {
        directory = fp->dir_ptr;
        *(directory+DIR_Attr) |= AM_ARC;          /* Set archive bit */
        ST_DWORD(directory+DIR_FileSize, fp->fsize);    /* Update file size */
        st_clust(directory, fp->sclust);          /* Update start cluster */
        tm = get_fattime();             /* Update updated time */
   14c18: eb0004d3  bl  15f6c <get_fattime>
        ST_DWORD(directory+DIR_WrtTime, tm);
        ST_WORD(directory+DIR_LstAccDate, 0);
        fp->flag &= ~FA__WRITTEN;
        fp->fs->wflag = 1U;
   14c1c: e3a01001  mov r1, #1
        directory = fp->dir_ptr;
        *(directory+DIR_Attr) |= AM_ARC;          /* Set archive bit */
        ST_DWORD(directory+DIR_FileSize, fp->fsize);    /* Update file size */
        st_clust(directory, fp->sclust);          /* Update start cluster */
        tm = get_fattime();             /* Update updated time */
        ST_DWORD(directory+DIR_WrtTime, tm);
   14c20: e5860016  str r0, [r6, #22]
   14c24: e1a02420  lsr r2, r0, #8
   14c28: e1a03820  lsr r3, r0, #16
   14c2c: e5c62017  strb  r2, [r6, #23]
   14c30: e5c63018  strb  r3, [r6, #24]
   14c34: e1a00c20  lsr r0, r0, #24
   14c38: e5c60019  strb  r0, [r6, #25]
        ST_WORD(directory+DIR_LstAccDate, 0);
        fp->flag &= ~FA__WRITTEN;
        fp->fs->wflag = 1U;
   14c3c: e5952000  ldr r2, [r5]
        *(directory+DIR_Attr) |= AM_ARC;          /* Set archive bit */
        ST_DWORD(directory+DIR_FileSize, fp->fsize);    /* Update file size */
        st_clust(directory, fp->sclust);          /* Update start cluster */
        tm = get_fattime();             /* Update updated time */
        ST_DWORD(directory+DIR_WrtTime, tm);
        ST_WORD(directory+DIR_LstAccDate, 0);
   14c40: e1c641b2  strh  r4, [r6, #18]
   14c44: e1c641b3  strh  r4, [r6, #19]
        fp->flag &= ~FA__WRITTEN;
   14c48: e5d53006  ldrb  r3, [r5, #6]
   14c4c: e3c33020  bic r3, r3, #32
   14c50: e5c53006  strb  r3, [r5, #6]
        fp->fs->wflag = 1U;
   14c54: e5c21004  strb  r1, [r2, #4]
        res = sync_fs(fp->fs);
   14c58: e5950000  ldr r0, [r5]
      }
    }
  }

  LEAVE_FF(fp->fs, res);
}
   14c5c: e8bd4070  pop {r4, r5, r6, lr}
        tm = get_fattime();             /* Update updated time */
        ST_DWORD(directory+DIR_WrtTime, tm);
        ST_WORD(directory+DIR_LstAccDate, 0);
        fp->flag &= ~FA__WRITTEN;
        fp->fs->wflag = 1U;
        res = sync_fs(fp->fs);
   14c60: eafff884  b 12e78 <sync_fs>
    if ((fp->flag & FA__WRITTEN) != 0U) { /* Has the file been written? */
      /* Write-back dirty buffer */
#if !_FS_TINY
      if ((fp->flag & FA__DIRTY) != (BYTE)0U) {
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
          LEAVE_FF(fp->fs, FR_DISK_ERR);
   14c64: e3a00001  mov r0, #1
   14c68: e8bd8070  pop {r4, r5, r6, pc}

00014c6c <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
  FIL *fp   /* Pointer to the file object to be closed */
)
{
   14c6c: e92d4010  push  {r4, lr}
   14c70: e1a04000  mov r4, r0
  FRESULT res;


#if !_FS_READONLY
  res = f_sync(fp);         /* Flush cached data */
   14c74: ebffffb2  bl  14b44 <f_sync>
  if (res == FR_OK)
   14c78: e3500000  cmp r0, #0
   14c7c: 18bd8010  popne {r4, pc}
#endif
  {
    res = validate(fp);       /* Lock volume */
   14c80: e1a00004  mov r0, r4
   14c84: ebfff816  bl  12ce4 <validate>
    if (res == FR_OK) {
   14c88: e3500000  cmp r0, #0
#endif
#if _FS_LOCK
      res = dec_lock(fp->lockid); /* Decrement file open counter */
      if (res == FR_OK)
#endif
        fp->fs = NULL;        /* Invalidate file object */
   14c8c: 05840000  streq r0, [r4]
      unlock_fs(fs, FR_OK);   /* Unlock volume */
#endif
    }
  }
  return res;
}
   14c90: e8bd8010  pop {r4, pc}

00014c94 <f_lseek>:

FRESULT f_lseek (
  FIL* fp,    /* Pointer to the file object */
  DWORD ofs   /* File pointer from top of file */
)
{
   14c94: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
   14c98: e1a05001  mov r5, r1
   14c9c: e1a04000  mov r4, r0
  FRESULT res;
  DWORD LocOfs = ofs;

  res = validate(fp);         /* Check validity of the object */
   14ca0: ebfff80f  bl  12ce4 <validate>
  if (res != FR_OK) {
   14ca4: e3500000  cmp r0, #0
   14ca8: 18bd83f8  popne {r3, r4, r5, r6, r7, r8, r9, pc}
    LEAVE_FF(fp->fs, res);
  }
  if (fp->err != (BYTE)0U) {            /* Check error */
   14cac: e5d40007  ldrb  r0, [r4, #7]
   14cb0: e3500000  cmp r0, #0
   14cb4: 18bd83f8  popne {r3, r4, r5, r6, r7, r8, r9, pc}

  /* Normal Seek */
  {
    DWORD clst, bcs, nsect, ifptr;

    if (((LocOfs > fp->fsize) != 0U)          /* In read-only mode, clip offset with the file size */
   14cb8: e594300c  ldr r3, [r4, #12]
   14cbc: e1550003  cmp r5, r3
   14cc0: 9a000002  bls 14cd0 <f_lseek+0x3c>
#if !_FS_READONLY
       && ((!(fp->flag & FA_WRITE)) != 0U)
   14cc4: e5d42006  ldrb  r2, [r4, #6]
   14cc8: e3120002  tst r2, #2
   14ccc: 01a05003  moveq r5, r3
        LocOfs = fp->fsize;
      }

    ifptr = fp->fptr;
    fp->fptr = 0U; nsect = 0U;
    if (LocOfs != (DWORD)0U) {
   14cd0: e3550000  cmp r5, #0
#endif
      ) {
        LocOfs = fp->fsize;
      }

    ifptr = fp->fptr;
   14cd4: e5942008  ldr r2, [r4, #8]
    fp->fptr = 0U; nsect = 0U;
   14cd8: e3a03000  mov r3, #0
   14cdc: e5843008  str r3, [r4, #8]
    if (LocOfs != (DWORD)0U) {
   14ce0: 0a000023  beq 14d74 <f_lseek+0xe0>
      bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
   14ce4: e5948000  ldr r8, [r4]
      if ((ifptr > 0U) &&
   14ce8: e1520003  cmp r2, r3
      }

    ifptr = fp->fptr;
    fp->fptr = 0U; nsect = 0U;
    if (LocOfs != (DWORD)0U) {
      bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
   14cec: e5d86002  ldrb  r6, [r8, #2]
   14cf0: e1a06486  lsl r6, r6, #9
      if ((ifptr > 0U) &&
   14cf4: 0a000009  beq 14d20 <f_lseek+0x8c>
        ((((LocOfs - 1) / bcs) >= ((ifptr - 1) / bcs)) != 0U)) {  /* When seek to same or following cluster, */
   14cf8: e1a01006  mov r1, r6
   14cfc: e2450001  sub r0, r5, #1
   14d00: e2427001  sub r7, r2, #1
   14d04: ebffd129  bl  91b0 <__aeabi_uidiv>
   14d08: e1a01006  mov r1, r6
   14d0c: e1a09000  mov r9, r0
   14d10: e1a00007  mov r0, r7
   14d14: ebffd125  bl  91b0 <__aeabi_uidiv>

    ifptr = fp->fptr;
    fp->fptr = 0U; nsect = 0U;
    if (LocOfs != (DWORD)0U) {
      bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
      if ((ifptr > 0U) &&
   14d18: e1590000  cmp r9, r0
   14d1c: 2a000070  bcs 14ee4 <f_lseek+0x250>
        ((((LocOfs - 1) / bcs) >= ((ifptr - 1) / bcs)) != 0U)) {  /* When seek to same or following cluster, */
        fp->fptr = (ifptr - 1) & ~(bcs - (DWORD)1); /* start from the current cluster */
        LocOfs -= fp->fptr;
        clst = fp->clust;
      } else {                  /* When seek to back cluster, */
        clst = fp->sclust;            /* start from the first cluster */
   14d20: e5941010  ldr r1, [r4, #16]
#if !_FS_READONLY
        if (clst == 0U) {           /* If no cluster chain, create a new chain */
   14d24: e3510000  cmp r1, #0
   14d28: 0a000062  beq 14eb8 <f_lseek+0x224>
            ABORT(fp->fs, FR_DISK_ERR);
          }
          fp->sclust = clst;
        }
#endif
        fp->clust = clst;
   14d2c: e5841014  str r1, [r4, #20]
      }
      if (clst != 0U) {
   14d30: e3510000  cmp r1, #0
   14d34: 0a000035  beq 14e10 <f_lseek+0x17c>
        while (LocOfs > bcs) {            /* Cluster following loop */
   14d38: e1550006  cmp r5, r6
   14d3c: 85940000  ldrhi r0, [r4]
   14d40: 9a000072  bls 14f10 <f_lseek+0x27c>
#if !_FS_READONLY
          if ((fp->flag & FA_WRITE) != (BYTE)0U) {      /* Check if in write mode or not */
   14d44: e5d43006  ldrb  r3, [r4, #6]
          if ((clst <= 1U) || ((clst >= fp->fs->n_fatent) != 0U)) {
            ABORT(fp->fs, FR_INT_ERR);
          }
          fp->clust = clst;
          fp->fptr += bcs;
          LocOfs -= bcs;
   14d48: e0665005  rsb r5, r6, r5
        fp->clust = clst;
      }
      if (clst != 0U) {
        while (LocOfs > bcs) {            /* Cluster following loop */
#if !_FS_READONLY
          if ((fp->flag & FA_WRITE) != (BYTE)0U) {      /* Check if in write mode or not */
   14d4c: e3130002  tst r3, #2
   14d50: 1a000009  bne 14d7c <f_lseek+0xe8>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   14d54: e3510001  cmp r1, #1
   14d58: 9a000002  bls 14d68 <f_lseek+0xd4>
   14d5c: e5903014  ldr r3, [r0, #20]
   14d60: e1530001  cmp r3, r1
   14d64: 8a000026  bhi 14e04 <f_lseek+0x170>
        clst = fp->sclust;            /* start from the first cluster */
#if !_FS_READONLY
        if (clst == 0U) {           /* If no cluster chain, create a new chain */
          clst = create_chain(fp->fs, 0U);
          if (clst == 1U) {
            ABORT(fp->fs, FR_INT_ERR);
   14d68: e3a00002  mov r0, #2
   14d6c: e5c40007  strb  r0, [r4, #7]
   14d70: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
   14d74: e1a00005  mov r0, r5
   14d78: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
      }
      if (clst != 0U) {
        while (LocOfs > bcs) {            /* Cluster following loop */
#if !_FS_READONLY
          if ((fp->flag & FA_WRITE) != (BYTE)0U) {      /* Check if in write mode or not */
            clst = create_chain(fp->fs, clst);  /* Force stretch if in write mode */
   14d7c: ebfffb12  bl  139cc <create_chain>
            if (clst == 0U) {       /* When disk gets full, clip file size */
   14d80: e2501000  subs  r1, r0, #0
   14d84: 0a000060  beq 14f0c <f_lseek+0x278>
            }
          } else {
#endif
            clst = get_fat(fp->fs, clst); /* Follow cluster chain if not in write mode */
          }
          if (clst == 0xFFFFFFFFU) {
   14d88: e3710001  cmn r1, #1
   14d8c: 0a000051  beq 14ed8 <f_lseek+0x244>
            ABORT(fp->fs, FR_DISK_ERR);
          }
          if ((clst <= 1U) || ((clst >= fp->fs->n_fatent) != 0U)) {
   14d90: e3510001  cmp r1, #1
   14d94: 9afffff3  bls 14d68 <f_lseek+0xd4>
   14d98: e5940000  ldr r0, [r4]
   14d9c: e5903014  ldr r3, [r0, #20]
   14da0: e1510003  cmp r1, r3
   14da4: 2affffef  bcs 14d68 <f_lseek+0xd4>
            ABORT(fp->fs, FR_INT_ERR);
          }
          fp->clust = clst;
          fp->fptr += bcs;
   14da8: e5943008  ldr r3, [r4, #8]
        }
#endif
        fp->clust = clst;
      }
      if (clst != 0U) {
        while (LocOfs > bcs) {            /* Cluster following loop */
   14dac: e1560005  cmp r6, r5
            ABORT(fp->fs, FR_DISK_ERR);
          }
          if ((clst <= 1U) || ((clst >= fp->fs->n_fatent) != 0U)) {
            ABORT(fp->fs, FR_INT_ERR);
          }
          fp->clust = clst;
   14db0: e5841014  str r1, [r4, #20]
          fp->fptr += bcs;
   14db4: e0863003  add r3, r6, r3
   14db8: e5843008  str r3, [r4, #8]
        }
#endif
        fp->clust = clst;
      }
      if (clst != 0U) {
        while (LocOfs > bcs) {            /* Cluster following loop */
   14dbc: 3affffe0  bcc 14d44 <f_lseek+0xb0>
          fp->clust = clst;
          fp->fptr += bcs;
          LocOfs -= bcs;
        }
        fp->fptr += LocOfs;
        if ((LocOfs % SS(fp->fs)) != (UINT)0U) {
   14dc0: e7e82055  ubfx  r2, r5, #0, #9
          }
          fp->clust = clst;
          fp->fptr += bcs;
          LocOfs -= bcs;
        }
        fp->fptr += LocOfs;
   14dc4: e0833005  add r3, r3, r5
        if ((LocOfs % SS(fp->fs)) != (UINT)0U) {
   14dc8: e3520000  cmp r2, #0
          }
          fp->clust = clst;
          fp->fptr += bcs;
          LocOfs -= bcs;
        }
        fp->fptr += LocOfs;
   14dcc: e5843008  str r3, [r4, #8]
        if ((LocOfs % SS(fp->fs)) != (UINT)0U) {
   14dd0: 0a00004b  beq 14f04 <f_lseek+0x270>
          nsect = clust2sect(fp->fs, clst); /* Current sector */
   14dd4: e5940000  ldr r0, [r4]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   14dd8: e2412002  sub r2, r1, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   14ddc: e5901014  ldr r1, [r0, #20]
   14de0: e2411002  sub r1, r1, #2
   14de4: e1520001  cmp r2, r1
   14de8: 2affffde  bcs 14d68 <f_lseek+0xd4>
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   14dec: e5d01002  ldrb  r1, [r0, #2]
   14df0: e5900028  ldr r0, [r0, #40] ; 0x28
          LocOfs -= bcs;
        }
        fp->fptr += LocOfs;
        if ((LocOfs % SS(fp->fs)) != (UINT)0U) {
          nsect = clust2sect(fp->fs, clst); /* Current sector */
          if ((!nsect) != 0U) {
   14df4: e0320291  mlas  r2, r1, r2, r0
            ABORT(fp->fs, FR_INT_ERR);
          }
          nsect += LocOfs / SS(fp->fs);
   14df8: 108254a5  addne r5, r2, r5, lsr #9
          LocOfs -= bcs;
        }
        fp->fptr += LocOfs;
        if ((LocOfs % SS(fp->fs)) != (UINT)0U) {
          nsect = clust2sect(fp->fs, clst); /* Current sector */
          if ((!nsect) != 0U) {
   14dfc: 1a000005  bne 14e18 <f_lseek+0x184>
   14e00: eaffffd8  b 14d68 <f_lseek+0xd4>
   14e04: ebfff9e7  bl  135a8 <get_fat.part.6>
   14e08: e1a01000  mov r1, r0
   14e0c: eaffffdd  b 14d88 <f_lseek+0xf4>
   14e10: e5943008  ldr r3, [r4, #8]
      ) {
        LocOfs = fp->fsize;
      }

    ifptr = fp->fptr;
    fp->fptr = 0U; nsect = 0U;
   14e14: e1a05001  mov r5, r1
          }
          nsect += LocOfs / SS(fp->fs);
        }
      }
    }
    if (((fp->fptr % SS(fp->fs)) != 0U) && ((nsect != fp->dsect) != 0U)) {  /* Fill sector cache if needed */
   14e18: e7e82053  ubfx  r2, r3, #0, #9
   14e1c: e3520000  cmp r2, #0
   14e20: 0a000035  beq 14efc <f_lseek+0x268>
   14e24: e5942018  ldr r2, [r4, #24]
   14e28: e1520005  cmp r2, r5
   14e2c: 0a000032  beq 14efc <f_lseek+0x268>
#if !_FS_TINY
#if !_FS_READONLY
      if ((fp->flag & FA__DIRTY) != (BYTE)0U) {     /* Write-back dirty sector cache */
   14e30: e5d43006  ldrb  r3, [r4, #6]
   14e34: e3130040  tst r3, #64 ; 0x40
   14e38: 02846040  addeq r6, r4, #64 ; 0x40
   14e3c: 0a00000a  beq 14e6c <f_lseek+0x1d8>
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   14e40: e5940000  ldr r0, [r4]
   14e44: e2846040  add r6, r4, #64 ; 0x40
   14e48: e3a03001  mov r3, #1
   14e4c: e1a01006  mov r1, r6
   14e50: e5d00001  ldrb  r0, [r0, #1]
   14e54: eb000447  bl  15f78 <disk_write>
   14e58: e3500000  cmp r0, #0
   14e5c: 1a00001d  bne 14ed8 <f_lseek+0x244>
          ABORT(fp->fs, FR_DISK_ERR);
        }
        fp->flag &= ~FA__DIRTY;
   14e60: e5d43006  ldrb  r3, [r4, #6]
   14e64: e3c33040  bic r3, r3, #64 ; 0x40
   14e68: e5c43006  strb  r3, [r4, #6]
      }
#endif
      if (disk_read(fp->fs->drv, fp->buf, nsect, 1U) != RES_OK) { /* Fill sector cache */
   14e6c: e5940000  ldr r0, [r4]
   14e70: e1a01006  mov r1, r6
   14e74: e1a02005  mov r2, r5
   14e78: e3a03001  mov r3, #1
   14e7c: e5d00001  ldrb  r0, [r0, #1]
   14e80: eb00040a  bl  15eb0 <disk_read>
   14e84: e3500000  cmp r0, #0
   14e88: 1a000012  bne 14ed8 <f_lseek+0x244>
   14e8c: e5943008  ldr r3, [r4, #8]
   14e90: e594200c  ldr r2, [r4, #12]
        ABORT(fp->fs, FR_DISK_ERR);
      }
#endif
      fp->dsect = nsect;
   14e94: e5845018  str r5, [r4, #24]
    }
#if !_FS_READONLY
    if (fp->fptr > fp->fsize) {     /* Set file change flag if the file size is extended */
   14e98: e1520003  cmp r2, r3
   14e9c: 2a00001d  bcs 14f18 <f_lseek+0x284>
      fp->fsize = fp->fptr;
      fp->flag |= FA__WRITTEN;
   14ea0: e5d42006  ldrb  r2, [r4, #6]
   14ea4: e3a00000  mov r0, #0
#endif
      fp->dsect = nsect;
    }
#if !_FS_READONLY
    if (fp->fptr > fp->fsize) {     /* Set file change flag if the file size is extended */
      fp->fsize = fp->fptr;
   14ea8: e584300c  str r3, [r4, #12]
      fp->flag |= FA__WRITTEN;
   14eac: e3823020  orr r3, r2, #32
   14eb0: e5c43006  strb  r3, [r4, #6]
   14eb4: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
        clst = fp->clust;
      } else {                  /* When seek to back cluster, */
        clst = fp->sclust;            /* start from the first cluster */
#if !_FS_READONLY
        if (clst == 0U) {           /* If no cluster chain, create a new chain */
          clst = create_chain(fp->fs, 0U);
   14eb8: e1a00008  mov r0, r8
   14ebc: ebfffac2  bl  139cc <create_chain>
          if (clst == 1U) {
   14ec0: e3500001  cmp r0, #1
        clst = fp->clust;
      } else {                  /* When seek to back cluster, */
        clst = fp->sclust;            /* start from the first cluster */
#if !_FS_READONLY
        if (clst == 0U) {           /* If no cluster chain, create a new chain */
          clst = create_chain(fp->fs, 0U);
   14ec4: e1a01000  mov r1, r0
          if (clst == 1U) {
   14ec8: 0affffa6  beq 14d68 <f_lseek+0xd4>
            ABORT(fp->fs, FR_INT_ERR);
          }
          if (clst == 0xFFFFFFFFU) {
   14ecc: e3700001  cmn r0, #1
            ABORT(fp->fs, FR_DISK_ERR);
          }
          fp->sclust = clst;
   14ed0: 15840010  strne r0, [r4, #16]
        if (clst == 0U) {           /* If no cluster chain, create a new chain */
          clst = create_chain(fp->fs, 0U);
          if (clst == 1U) {
            ABORT(fp->fs, FR_INT_ERR);
          }
          if (clst == 0xFFFFFFFFU) {
   14ed4: 1affff94  bne 14d2c <f_lseek+0x98>
            ABORT(fp->fs, FR_DISK_ERR);
   14ed8: e3a00001  mov r0, #1
   14edc: e5c40007  strb  r0, [r4, #7]
   14ee0: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
    fp->fptr = 0U; nsect = 0U;
    if (LocOfs != (DWORD)0U) {
      bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
      if ((ifptr > 0U) &&
        ((((LocOfs - 1) / bcs) >= ((ifptr - 1) / bcs)) != 0U)) {  /* When seek to same or following cluster, */
        fp->fptr = (ifptr - 1) & ~(bcs - (DWORD)1); /* start from the current cluster */
   14ee4: e2663000  rsb r3, r6, #0
        LocOfs -= fp->fptr;
        clst = fp->clust;
   14ee8: e5941014  ldr r1, [r4, #20]
    fp->fptr = 0U; nsect = 0U;
    if (LocOfs != (DWORD)0U) {
      bcs = (DWORD)fp->fs->csize * SS(fp->fs);  /* Cluster size (byte) */
      if ((ifptr > 0U) &&
        ((((LocOfs - 1) / bcs) >= ((ifptr - 1) / bcs)) != 0U)) {  /* When seek to same or following cluster, */
        fp->fptr = (ifptr - 1) & ~(bcs - (DWORD)1); /* start from the current cluster */
   14eec: e0077003  and r7, r7, r3
   14ef0: e5847008  str r7, [r4, #8]
        LocOfs -= fp->fptr;
   14ef4: e0675005  rsb r5, r7, r5
        clst = fp->clust;
   14ef8: eaffff8c  b 14d30 <f_lseek+0x9c>
   14efc: e594200c  ldr r2, [r4, #12]
   14f00: eaffffe4  b 14e98 <f_lseek+0x204>
      ) {
        LocOfs = fp->fsize;
      }

    ifptr = fp->fptr;
    fp->fptr = 0U; nsect = 0U;
   14f04: e1a05002  mov r5, r2
   14f08: eaffffc2  b 14e18 <f_lseek+0x184>
      if (clst != 0U) {
        while (LocOfs > bcs) {            /* Cluster following loop */
#if !_FS_READONLY
          if ((fp->flag & FA_WRITE) != (BYTE)0U) {      /* Check if in write mode or not */
            clst = create_chain(fp->fs, clst);  /* Force stretch if in write mode */
            if (clst == 0U) {       /* When disk gets full, clip file size */
   14f0c: e1a05006  mov r5, r6
   14f10: e5943008  ldr r3, [r4, #8]
   14f14: eaffffa9  b 14dc0 <f_lseek+0x12c>
   14f18: e3a00000  mov r0, #0
   14f1c: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

00014f20 <f_opendir>:

FRESULT f_opendir (
  DIR* dp,      /* Pointer to directory object to create */
  const TCHAR* path /* Pointer to the directory path */
)
{
   14f20: e92d4010  push  {r4, lr}
  FRESULT res;
  FATFS* fs;
  DEF_NAMEBUF;


  if ((!dp) != 0U) {
   14f24: e3500000  cmp r0, #0

FRESULT f_opendir (
  DIR* dp,      /* Pointer to directory object to create */
  const TCHAR* path /* Pointer to the directory path */
)
{
   14f28: e24dd018  sub sp, sp, #24
   14f2c: e58d1004  str r1, [sp, #4]
  FRESULT res;
  FATFS* fs;
  DEF_NAMEBUF;


  if ((!dp) != 0U) {
   14f30: 0a00000a  beq 14f60 <f_opendir+0x40>
   14f34: e1a04000  mov r4, r0
    res = FR_INVALID_OBJECT;
  }
  else {
  /* Get logical drive number */
  res = find_volume(&fs, &path, 0U);
   14f38: e28d1004  add r1, sp, #4
   14f3c: e28d0008  add r0, sp, #8
   14f40: e3a02000  mov r2, #0
   14f44: ebfff85e  bl  130c4 <find_volume>
  if (res == FR_OK) {
   14f48: e3500000  cmp r0, #0
   14f4c: 0a000006  beq 14f6c <f_opendir+0x4c>
    if (res == FR_NO_FILE) {
      res = FR_NO_PATH;
    }
  }
  if (res != FR_OK) {
    dp->fs = NULL;    /* Invalidate the directory object if function faild */
   14f50: e3a03000  mov r3, #0
   14f54: e5843000  str r3, [r4]
  }

  }
  LEAVE_FF(fs, res);
}
   14f58: e28dd018  add sp, sp, #24
   14f5c: e8bd8010  pop {r4, pc}
  FATFS* fs;
  DEF_NAMEBUF;


  if ((!dp) != 0U) {
    res = FR_INVALID_OBJECT;
   14f60: e3a00009  mov r0, #9
    dp->fs = NULL;    /* Invalidate the directory object if function faild */
  }

  }
  LEAVE_FF(fs, res);
}
   14f64: e28dd018  add sp, sp, #24
   14f68: e8bd8010  pop {r4, pc}
  }
  else {
  /* Get logical drive number */
  res = find_volume(&fs, &path, 0U);
  if (res == FR_OK) {
    dp->fs = fs;
   14f6c: e59d3008  ldr r3, [sp, #8]
    INIT_BUF(*dp);
   14f70: e28d200c  add r2, sp, #12
    res = follow_path(dp, path);      /* Follow the path to the directory */
   14f74: e1a00004  mov r0, r4
  else {
  /* Get logical drive number */
  res = find_volume(&fs, &path, 0U);
  if (res == FR_OK) {
    dp->fs = fs;
    INIT_BUF(*dp);
   14f78: e5842018  str r2, [r4, #24]
    res = follow_path(dp, path);      /* Follow the path to the directory */
   14f7c: e59d1004  ldr r1, [sp, #4]
  }
  else {
  /* Get logical drive number */
  res = find_volume(&fs, &path, 0U);
  if (res == FR_OK) {
    dp->fs = fs;
   14f80: e5843000  str r3, [r4]
    INIT_BUF(*dp);
    res = follow_path(dp, path);      /* Follow the path to the directory */
   14f84: ebfffb6f  bl  13d48 <follow_path>
    FREE_BUF();
    if (res == FR_OK) {           /* Follow completed */
   14f88: e3500000  cmp r0, #0
   14f8c: 1a00001a  bne 14ffc <f_opendir+0xdc>
      if (dp->dir != NULL) {            /* It is not the origin directory itself */
   14f90: e5943014  ldr r3, [r4, #20]
   14f94: e3530000  cmp r3, #0
   14f98: 0a00001b  beq 1500c <f_opendir+0xec>
        if ((dp->dir[DIR_Attr] & AM_DIR) != (BYTE)0U) {/* The object is a sub directory */
   14f9c: e5d3200b  ldrb  r2, [r3, #11]
   14fa0: e3120010  tst r2, #16
   14fa4: 0a000016  beq 15004 <f_opendir+0xe4>
          dp->sclust = ld_clust(fs, dp->dir);
   14fa8: e59d1008  ldr r1, [sp, #8]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14fac: e5d3c01b  ldrb  ip, [r3, #27]
   14fb0: e5d3201a  ldrb  r2, [r3, #26]
  if (fs->fs_type == FS_FAT32) {
   14fb4: e5d10000  ldrb  r0, [r1]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   14fb8: e182240c  orr r2, r2, ip, lsl #8
  if (fs->fs_type == FS_FAT32) {
   14fbc: e3500003  cmp r0, #3
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   14fc0: 05d30015  ldrbeq  r0, [r3, #21]
   14fc4: 05d33014  ldrbeq  r3, [r3, #20]
   14fc8: 01833400  orreq r3, r3, r0, lsl #8
   14fcc: 01822803  orreq r2, r2, r3, lsl #16
    res = follow_path(dp, path);      /* Follow the path to the directory */
    FREE_BUF();
    if (res == FR_OK) {           /* Follow completed */
      if (dp->dir != NULL) {            /* It is not the origin directory itself */
        if ((dp->dir[DIR_Attr] & AM_DIR) != (BYTE)0U) {/* The object is a sub directory */
          dp->sclust = ld_clust(fs, dp->dir);
   14fd0: e5842008  str r2, [r4, #8]
        else {              /* The object is a file */
          res = FR_NO_PATH;
        }
      }
      if (res == FR_OK) {
        dp->id = fs->id;
   14fd4: e1d130b6  ldrh  r3, [r1, #6]
        res = dir_sdi(dp, 0U);      /* Rewind directory */
   14fd8: e1a00004  mov r0, r4
   14fdc: e3a01000  mov r1, #0
        else {              /* The object is a file */
          res = FR_NO_PATH;
        }
      }
      if (res == FR_OK) {
        dp->id = fs->id;
   14fe0: e1c430b4  strh  r3, [r4, #4]
        res = dir_sdi(dp, 0U);      /* Rewind directory */
   14fe4: ebfff9b1  bl  136b0 <dir_sdi>
          }
        }
#endif
      }
    }
    if (res == FR_NO_FILE) {
   14fe8: e3500004  cmp r0, #4
   14fec: 0a000004  beq 15004 <f_opendir+0xe4>
      res = FR_NO_PATH;
    }
  }
  if (res != FR_OK) {
   14ff0: e3500000  cmp r0, #0
   14ff4: 0affffd7  beq 14f58 <f_opendir+0x38>
   14ff8: eaffffd4  b 14f50 <f_opendir+0x30>
          }
        }
#endif
      }
    }
    if (res == FR_NO_FILE) {
   14ffc: e3500004  cmp r0, #4
   15000: 1affffd2  bne 14f50 <f_opendir+0x30>
      if (dp->dir != NULL) {            /* It is not the origin directory itself */
        if ((dp->dir[DIR_Attr] & AM_DIR) != (BYTE)0U) {/* The object is a sub directory */
          dp->sclust = ld_clust(fs, dp->dir);
        }
        else {              /* The object is a file */
          res = FR_NO_PATH;
   15004: e3a00005  mov r0, #5
   15008: eaffffd0  b 14f50 <f_opendir+0x30>
   1500c: e59d1008  ldr r1, [sp, #8]
   15010: eaffffef  b 14fd4 <f_opendir+0xb4>

00015014 <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
  DIR *dp   /* Pointer to the directory object to be closed */
)
{
   15014: e92d4010  push  {r4, lr}
   15018: e1a04000  mov r4, r0
  FRESULT res;


  res = validate(dp);
   1501c: ebfff730  bl  12ce4 <validate>
  if (res == FR_OK) {
   15020: e3500000  cmp r0, #0
    if (dp->lockid) {       /* Decrement sub-directory open counter */
      res = dec_lock(dp->lockid);
    }
    if (res == FR_OK)
#endif
      dp->fs = NULL;        /* Invalidate directory object */
   15024: 05840000  streq r0, [r4]
#if _FS_REENTRANT
    unlock_fs(fs, FR_OK);   /* Unlock volume */
#endif
  }
  return res;
}
   15028: e8bd8010  pop {r4, pc}

0001502c <f_readdir>:

FRESULT f_readdir (
  DIR* dp,      /* Pointer to the open directory object */
  FILINFO* fno    /* Pointer to file information to return */
)
{
   1502c: e92d4070  push  {r4, r5, r6, lr}
   15030: e24dd010  sub sp, sp, #16
   15034: e1a06001  mov r6, r1
   15038: e1a05000  mov r5, r0
  FRESULT res;
  DEF_NAMEBUF;


  res = validate(dp);           /* Check validity of the object */
   1503c: ebfff728  bl  12ce4 <validate>
  if (res == FR_OK) {
   15040: e2504000  subs  r4, r0, #0
   15044: 1a00000a  bne 15074 <f_readdir+0x48>
    if ((!fno) != 0U) {
   15048: e3560000  cmp r6, #0
   1504c: 0a000018  beq 150b4 <f_readdir+0x88>
      res = dir_sdi(dp, 0U);      /* Rewind the directory object */
    } else {
      INIT_BUF(*dp);
   15050: e28d3004  add r3, sp, #4
      res = dir_read(dp, 0);      /* Read an item */
   15054: e1a00005  mov r0, r5
  res = validate(dp);           /* Check validity of the object */
  if (res == FR_OK) {
    if ((!fno) != 0U) {
      res = dir_sdi(dp, 0U);      /* Rewind the directory object */
    } else {
      INIT_BUF(*dp);
   15058: e5853018  str r3, [r5, #24]
      res = dir_read(dp, 0);      /* Read an item */
   1505c: ebfffc22  bl  140ec <dir_read.constprop.11>
      if (res == FR_NO_FILE) {    /* Reached end of directory */
   15060: e3500004  cmp r0, #4
   15064: 0a000005  beq 15080 <f_readdir+0x54>
        dp->sect = 0U;
        res = FR_OK;
      }
      if (res == FR_OK) {       /* A valid entry is found */
   15068: e3500000  cmp r0, #0
   1506c: 0a000014  beq 150c4 <f_readdir+0x98>


  res = validate(dp);           /* Check validity of the object */
  if (res == FR_OK) {
    if ((!fno) != 0U) {
      res = dir_sdi(dp, 0U);      /* Rewind the directory object */
   15070: e1a04000  mov r4, r0
      FREE_BUF();
    }
  }

  LEAVE_FF(dp->fs, res);
}
   15074: e1a00004  mov r0, r4
   15078: e28dd010  add sp, sp, #16
   1507c: e8bd8070  pop {r4, r5, r6, pc}
      res = dir_sdi(dp, 0U);      /* Rewind the directory object */
    } else {
      INIT_BUF(*dp);
      res = dir_read(dp, 0);      /* Read an item */
      if (res == FR_NO_FILE) {    /* Reached end of directory */
        dp->sect = 0U;
   15080: e1a00004  mov r0, r4
   15084: e5854010  str r4, [r5, #16]
        res = FR_OK;
      }
      if (res == FR_OK) {       /* A valid entry is found */
        get_fileinfo(dp, fno);    /* Get the object information */
   15088: e1a02006  mov r2, r6
   1508c: e2851014  add r1, r5, #20
   15090: ebfff72a  bl  12d40 <get_fileinfo.isra.1>
        res = dir_next(dp, 0);    /* Increment index for next */
   15094: e1a00005  mov r0, r5
   15098: e3a01000  mov r1, #0
   1509c: ebfffaab  bl  13b50 <dir_next>
        if (res == FR_NO_FILE) {
   150a0: e3500004  cmp r0, #4
          dp->sect = 0U;
   150a4: 03a03000  moveq r3, #0
   150a8: 05853010  streq r3, [r5, #16]
        res = FR_OK;
      }
      if (res == FR_OK) {       /* A valid entry is found */
        get_fileinfo(dp, fno);    /* Get the object information */
        res = dir_next(dp, 0);    /* Increment index for next */
        if (res == FR_NO_FILE) {
   150ac: 1affffef  bne 15070 <f_readdir+0x44>
   150b0: eaffffef  b 15074 <f_readdir+0x48>


  res = validate(dp);           /* Check validity of the object */
  if (res == FR_OK) {
    if ((!fno) != 0U) {
      res = dir_sdi(dp, 0U);      /* Rewind the directory object */
   150b4: e1a00005  mov r0, r5
   150b8: e1a01004  mov r1, r4
   150bc: ebfff97b  bl  136b0 <dir_sdi>
   150c0: eaffffea  b 15070 <f_readdir+0x44>
   150c4: e5950010  ldr r0, [r5, #16]
   150c8: eaffffee  b 15088 <f_readdir+0x5c>

000150cc <f_stat>:

FRESULT f_stat (
  const TCHAR* path,  /* Pointer to the file path */
  FILINFO* fno    /* Pointer to file information to return */
)
{
   150cc: e92d4030  push  {r4, r5, lr}
   150d0: e24dd034  sub sp, sp, #52 ; 0x34
  FRESULT res;
  DIR dj = {0};
   150d4: e3a03000  mov r3, #0

FRESULT f_stat (
  const TCHAR* path,  /* Pointer to the file path */
  FILINFO* fno    /* Pointer to file information to return */
)
{
   150d8: e1a05001  mov r5, r1
   150dc: e58d0004  str r0, [sp, #4]
  DIR dj = {0};
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 0U);
   150e0: e1a02003  mov r2, r3
   150e4: e28d0014  add r0, sp, #20
   150e8: e28d1004  add r1, sp, #4
  const TCHAR* path,  /* Pointer to the file path */
  FILINFO* fno    /* Pointer to file information to return */
)
{
  FRESULT res;
  DIR dj = {0};
   150ec: e58d3014  str r3, [sp, #20]
   150f0: e58d3018  str r3, [sp, #24]
   150f4: e58d301c  str r3, [sp, #28]
   150f8: e58d3020  str r3, [sp, #32]
   150fc: e58d3024  str r3, [sp, #36] ; 0x24
   15100: e58d3028  str r3, [sp, #40] ; 0x28
   15104: e58d302c  str r3, [sp, #44] ; 0x2c
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 0U);
   15108: ebfff7ed  bl  130c4 <find_volume>
  if (res == FR_OK) {
   1510c: e2504000  subs  r4, r0, #0
   15110: 0a000002  beq 15120 <f_stat+0x54>
    }
    FREE_BUF();
  }

  LEAVE_FF(dj.fs, res);
}
   15114: e1a00004  mov r0, r4
   15118: e28dd034  add sp, sp, #52 ; 0x34
   1511c: e8bd8030  pop {r4, r5, pc}

  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 0U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path); /* Follow the file path */
   15120: e28d0014  add r0, sp, #20
   15124: e59d1004  ldr r1, [sp, #4]


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 0U);
  if (res == FR_OK) {
    INIT_BUF(dj);
   15128: e28d3008  add r3, sp, #8
   1512c: e58d302c  str r3, [sp, #44] ; 0x2c
    res = follow_path(&dj, path); /* Follow the file path */
   15130: ebfffb04  bl  13d48 <follow_path>
    if (res == FR_OK) {       /* Follow completed */
   15134: e2504000  subs  r4, r0, #0
   15138: 1afffff5  bne 15114 <f_stat+0x48>
      if (dj.dir != NULL) {   /* Found an object */
   1513c: e59d3028  ldr r3, [sp, #40] ; 0x28
   15140: e3530000  cmp r3, #0
        if (fno != NULL) {
          get_fileinfo(&dj, fno);
        }
      } else {      /* It is root directory */
        res = FR_INVALID_NAME;
   15144: 03a04006  moveq r4, #6
  res = find_volume(&dj.fs, &path, 0U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path); /* Follow the file path */
    if (res == FR_OK) {       /* Follow completed */
      if (dj.dir != NULL) {   /* Found an object */
   15148: 0afffff1  beq 15114 <f_stat+0x48>
        if (fno != NULL) {
   1514c: e3550000  cmp r5, #0
   15150: 0affffef  beq 15114 <f_stat+0x48>
          get_fileinfo(&dj, fno);
   15154: e59d0024  ldr r0, [sp, #36] ; 0x24
   15158: e1a02005  mov r2, r5
   1515c: e28d1028  add r1, sp, #40 ; 0x28
   15160: ebfff6f6  bl  12d40 <get_fileinfo.isra.1>
    }
    FREE_BUF();
  }

  LEAVE_FF(dj.fs, res);
}
   15164: e1a00004  mov r0, r4
   15168: e28dd034  add sp, sp, #52 ; 0x34
   1516c: e8bd8030  pop {r4, r5, pc}

00015170 <f_getfree>:
FRESULT f_getfree (
  const TCHAR* path,  /* Path name of the logical drive number */
  DWORD* nclst,   /* Pointer to a variable to return number of free clusters */
  FATFS** fatfsys   /* Pointer to return pointer to corresponding file system object */
)
{
   15170: e92d47f0  push  {r4, r5, r6, r7, r8, r9, sl, lr}
   15174: e24dd008  sub sp, sp, #8
   15178: e28d3008  add r3, sp, #8
   1517c: e1a04002  mov r4, r2
   15180: e1a08001  mov r8, r1
  UINT i;
  BYTE fat, *p;


  /* Get logical drive number */
  res = find_volume(fatfsys, &path, 0U);
   15184: e3a02000  mov r2, #0
FRESULT f_getfree (
  const TCHAR* path,  /* Path name of the logical drive number */
  DWORD* nclst,   /* Pointer to a variable to return number of free clusters */
  FATFS** fatfsys   /* Pointer to return pointer to corresponding file system object */
)
{
   15188: e5230004  str r0, [r3, #-4]!
  UINT i;
  BYTE fat, *p;


  /* Get logical drive number */
  res = find_volume(fatfsys, &path, 0U);
   1518c: e1a00004  mov r0, r4
   15190: e1a01003  mov r1, r3
   15194: ebfff7ca  bl  130c4 <find_volume>
  fs = *fatfsys;
   15198: e5945000  ldr r5, [r4]
  if (res == FR_OK) {
   1519c: e2507000  subs  r7, r0, #0
   151a0: 1a000037  bne 15284 <f_getfree+0x114>
    /* If free_clust is valid, return it without full cluster scan */
    if (fs->free_clust <= (fs->n_fatent - 2)) {
   151a4: e5954014  ldr r4, [r5, #20]
   151a8: e5953010  ldr r3, [r5, #16]
   151ac: e2442002  sub r2, r4, #2
   151b0: e1530002  cmp r3, r2
      *nclst = fs->free_clust;
   151b4: 95883000  strls r3, [r8]
  /* Get logical drive number */
  res = find_volume(fatfsys, &path, 0U);
  fs = *fatfsys;
  if (res == FR_OK) {
    /* If free_clust is valid, return it without full cluster scan */
    if (fs->free_clust <= (fs->n_fatent - 2)) {
   151b8: 9a000031  bls 15284 <f_getfree+0x114>
      *nclst = fs->free_clust;
    } else {
      /* Get number of free clusters */
      fat = fs->fs_type;
   151bc: e5d59000  ldrb  r9, [r5]
      n = 0U;
      if (fat == FS_FAT12) {
   151c0: e3590001  cmp r9, #1
   151c4: 0a000031  beq 15290 <f_getfree+0x120>
          if (stat == 0U) { n++; }
          clst += (DWORD)1;
        } while (clst < fs->n_fatent);
      } else {
        clst = fs->n_fatent;
        sect = fs->fatbase;
   151c8: e595a020  ldr sl, [r5, #32]
        i = 0U; p = 0U;
   151cc: e1a03007  mov r3, r7
   151d0: e1a00007  mov r0, r7
    if (fs->free_clust <= (fs->n_fatent - 2)) {
      *nclst = fs->free_clust;
    } else {
      /* Get number of free clusters */
      fat = fs->fs_type;
      n = 0U;
   151d4: e1a06007  mov r6, r7
   151d8: ea000010  b 15220 <f_getfree+0xb0>
              break;
            }
            p = fs->win;
            i = SS(fs);
          }
          if (fat == FS_FAT16) {
   151dc: e3590002  cmp r9, #2
   151e0: 0a00001a  beq 15250 <f_getfree+0xe0>
            if (LD_WORD(p) == 0U) {
              n++;
            }
            p += 2; i -= (UINT)2;
          } else {
            if ((LD_DWORD(p) & 0x0FFFFFFFU) == 0U) {
   151e4: e5d3c002  ldrb  ip, [r3, #2]
              n++;
            }
            p += 4; i -= (UINT)4;
   151e8: e2400004  sub r0, r0, #4
            if (LD_WORD(p) == 0U) {
              n++;
            }
            p += 2; i -= (UINT)2;
          } else {
            if ((LD_DWORD(p) & 0x0FFFFFFFU) == 0U) {
   151ec: e5d32003  ldrb  r2, [r3, #3]
              n++;
            }
            p += 4; i -= (UINT)4;
   151f0: e2833004  add r3, r3, #4
            if (LD_WORD(p) == 0U) {
              n++;
            }
            p += 2; i -= (UINT)2;
          } else {
            if ((LD_DWORD(p) & 0x0FFFFFFFU) == 0U) {
   151f4: e5531004  ldrb  r1, [r3, #-4]
   151f8: e553e003  ldrb  lr, [r3, #-3]
   151fc: e1a0c80c  lsl ip, ip, #16
   15200: e18c2c02  orr r2, ip, r2, lsl #24
   15204: e1822001  orr r2, r2, r1
   15208: e182240e  orr r2, r2, lr, lsl #8
   1520c: e3c2220f  bic r2, r2, #-268435456 ; 0xf0000000
   15210: e3520000  cmp r2, #0
              n++;
   15214: 02866001  addeq r6, r6, #1
            }
            p += 4; i -= (UINT)4;
          }
          clst -= (DWORD)1;
        } while (clst != (DWORD)0U);
   15218: e2544001  subs  r4, r4, #1
   1521c: 0a000013  beq 15270 <f_getfree+0x100>
      } else {
        clst = fs->n_fatent;
        sect = fs->fatbase;
        i = 0U; p = 0U;
        do {
          if (i == (UINT)0U) {
   15220: e3500000  cmp r0, #0
   15224: 1affffec  bne 151dc <f_getfree+0x6c>
            res = move_window(fs, sect);
   15228: e1a0100a  mov r1, sl
   1522c: e1a00005  mov r0, r5
   15230: ebfff75e  bl  12fb0 <move_window>
            sect += (DWORD)1;
   15234: e28aa001  add sl, sl, #1
            if (res != FR_OK) {
   15238: e3500000  cmp r0, #0
   1523c: 1a000028  bne 152e4 <f_getfree+0x174>
              break;
            }
            p = fs->win;
            i = SS(fs);
          }
          if (fat == FS_FAT16) {
   15240: e3590002  cmp r9, #2
            res = move_window(fs, sect);
            sect += (DWORD)1;
            if (res != FR_OK) {
              break;
            }
            p = fs->win;
   15244: e2853040  add r3, r5, #64 ; 0x40
            i = SS(fs);
   15248: e3a00c02  mov r0, #512  ; 0x200
          }
          if (fat == FS_FAT16) {
   1524c: 1affffe4  bne 151e4 <f_getfree+0x74>
            if (LD_WORD(p) == 0U) {
   15250: e5d31001  ldrb  r1, [r3, #1]
              n++;
            }
            p += 2; i -= (UINT)2;
   15254: e2400002  sub r0, r0, #2
            }
            p = fs->win;
            i = SS(fs);
          }
          if (fat == FS_FAT16) {
            if (LD_WORD(p) == 0U) {
   15258: e5d32000  ldrb  r2, [r3]
              n++;
            }
            p += 2; i -= (UINT)2;
   1525c: e2833002  add r3, r3, #2
            }
            p = fs->win;
            i = SS(fs);
          }
          if (fat == FS_FAT16) {
            if (LD_WORD(p) == 0U) {
   15260: e1922401  orrs  r2, r2, r1, lsl #8
              n++;
   15264: 02866001  addeq r6, r6, #1
              n++;
            }
            p += 4; i -= (UINT)4;
          }
          clst -= (DWORD)1;
        } while (clst != (DWORD)0U);
   15268: e2544001  subs  r4, r4, #1
   1526c: 1affffeb  bne 15220 <f_getfree+0xb0>
      }
      fs->free_clust = n;
      fs->fsi_flag |= 1U;
   15270: e5d53005  ldrb  r3, [r5, #5]
            p += 4; i -= (UINT)4;
          }
          clst -= (DWORD)1;
        } while (clst != (DWORD)0U);
      }
      fs->free_clust = n;
   15274: e5856010  str r6, [r5, #16]
      fs->fsi_flag |= 1U;
   15278: e3833001  orr r3, r3, #1
   1527c: e5c53005  strb  r3, [r5, #5]
      *nclst = n;
   15280: e5886000  str r6, [r8]
    }
  }
  LEAVE_FF(fs, res);
}
   15284: e1a00007  mov r0, r7
   15288: e28dd008  add sp, sp, #8
   1528c: e8bd87f0  pop {r4, r5, r6, r7, r8, r9, sl, pc}
      *nclst = fs->free_clust;
    } else {
      /* Get number of free clusters */
      fat = fs->fs_type;
      n = 0U;
      if (fat == FS_FAT12) {
   15290: e3a09002  mov r9, #2
   15294: e1a06007  mov r6, r7
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   15298: e1540009  cmp r4, r9
   1529c: e1a01009  mov r1, r9
   152a0: e1a00005  mov r0, r5
        do {
          stat = get_fat(fs, clst);
          if (stat == (DWORD)0xFFFFFFFFU) { res = FR_DISK_ERR; break; }
          if (stat == 1U) { res = FR_INT_ERR; break; }
          if (stat == 0U) { n++; }
          clst += (DWORD)1;
   152a4: e2899001  add r9, r9, #1
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   152a8: 9a00000b  bls 152dc <f_getfree+0x16c>
   152ac: ebfff8bd  bl  135a8 <get_fat.part.6>
      n = 0U;
      if (fat == FS_FAT12) {
        clst = (DWORD)2;
        do {
          stat = get_fat(fs, clst);
          if (stat == (DWORD)0xFFFFFFFFU) { res = FR_DISK_ERR; break; }
   152b0: e3700001  cmn r0, #1
   152b4: 0a00000c  beq 152ec <f_getfree+0x17c>
          if (stat == 1U) { res = FR_INT_ERR; break; }
   152b8: e3500001  cmp r0, #1
   152bc: 0a000006  beq 152dc <f_getfree+0x16c>
          if (stat == 0U) { n++; }
          clst += (DWORD)1;
        } while (clst < fs->n_fatent);
   152c0: e5954014  ldr r4, [r5, #20]
        clst = (DWORD)2;
        do {
          stat = get_fat(fs, clst);
          if (stat == (DWORD)0xFFFFFFFFU) { res = FR_DISK_ERR; break; }
          if (stat == 1U) { res = FR_INT_ERR; break; }
          if (stat == 0U) { n++; }
   152c4: e3500000  cmp r0, #0
   152c8: 02866001  addeq r6, r6, #1
          clst += (DWORD)1;
        } while (clst < fs->n_fatent);
   152cc: e1590004  cmp r9, r4
   152d0: 2affffe6  bcs 15270 <f_getfree+0x100>
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   152d4: e3590001  cmp r9, #1
   152d8: 8affffee  bhi 15298 <f_getfree+0x128>
      if (fat == FS_FAT12) {
        clst = (DWORD)2;
        do {
          stat = get_fat(fs, clst);
          if (stat == (DWORD)0xFFFFFFFFU) { res = FR_DISK_ERR; break; }
          if (stat == 1U) { res = FR_INT_ERR; break; }
   152dc: e3a07002  mov r7, #2
   152e0: eaffffe2  b 15270 <f_getfree+0x100>
   152e4: e1a07000  mov r7, r0
   152e8: eaffffe0  b 15270 <f_getfree+0x100>
      n = 0U;
      if (fat == FS_FAT12) {
        clst = (DWORD)2;
        do {
          stat = get_fat(fs, clst);
          if (stat == (DWORD)0xFFFFFFFFU) { res = FR_DISK_ERR; break; }
   152ec: e3a07001  mov r7, #1
   152f0: eaffffde  b 15270 <f_getfree+0x100>

000152f4 <f_truncate>:
/*-----------------------------------------------------------------------*/

FRESULT f_truncate (
  FIL* fp   /* Pointer to the file object */
)
{
   152f4: e92d4070  push  {r4, r5, r6, lr}
   152f8: e1a04000  mov r4, r0
  FRESULT res;
  DWORD ncl;


  res = validate(fp);           /* Check validity of the object */
   152fc: ebfff678  bl  12ce4 <validate>
  if (res == FR_OK) {
   15300: e2505000  subs  r5, r0, #0
   15304: 1a000003  bne 15318 <f_truncate+0x24>
    if (fp->err != (BYTE) 0U) {           /* Check error */
   15308: e5d43007  ldrb  r3, [r4, #7]
   1530c: e3530000  cmp r3, #0
   15310: 11a05003  movne r5, r3
   15314: 0a000001  beq 15320 <f_truncate+0x2c>
      fp->err = (FRESULT)res;
    }
  }

  LEAVE_FF(fp->fs, res);
}
   15318: e1a00005  mov r0, r5
   1531c: e8bd8070  pop {r4, r5, r6, pc}
  res = validate(fp);           /* Check validity of the object */
  if (res == FR_OK) {
    if (fp->err != (BYTE) 0U) {           /* Check error */
      res = (FRESULT)fp->err;
    } else {
      if ((!(fp->flag & FA_WRITE)) != 0U) {   /* Check access mode */
   15320: e5d43006  ldrb  r3, [r4, #6]
   15324: e3130002  tst r3, #2
        res = FR_DENIED;
   15328: 03a05007  moveq r5, #7
  res = validate(fp);           /* Check validity of the object */
  if (res == FR_OK) {
    if (fp->err != (BYTE) 0U) {           /* Check error */
      res = (FRESULT)fp->err;
    } else {
      if ((!(fp->flag & FA_WRITE)) != 0U) {   /* Check access mode */
   1532c: 0afffff9  beq 15318 <f_truncate+0x24>
        res = FR_DENIED;
      }
    }
  }
  if (res == FR_OK) {
    if (fp->fsize > fp->fptr) {
   15330: e5942008  ldr r2, [r4, #8]
   15334: e594100c  ldr r1, [r4, #12]
   15338: e1510002  cmp r1, r2
   1533c: 9afffff5  bls 15318 <f_truncate+0x24>
      fp->fsize = fp->fptr; /* Set file size to current R/W point */
      fp->flag |= FA__WRITTEN;
      if (fp->fptr == 0U) { /* When set file size to zero, remove entire cluster chain */
   15340: e3520000  cmp r2, #0
    }
  }
  if (res == FR_OK) {
    if (fp->fsize > fp->fptr) {
      fp->fsize = fp->fptr; /* Set file size to current R/W point */
      fp->flag |= FA__WRITTEN;
   15344: e3833020  orr r3, r3, #32
      }
    }
  }
  if (res == FR_OK) {
    if (fp->fsize > fp->fptr) {
      fp->fsize = fp->fptr; /* Set file size to current R/W point */
   15348: e584200c  str r2, [r4, #12]
      fp->flag |= FA__WRITTEN;
   1534c: e5c43006  strb  r3, [r4, #6]
      if (fp->fptr == 0U) { /* When set file size to zero, remove entire cluster chain */
   15350: 1a00001a  bne 153c0 <f_truncate+0xcc>
        res = remove_chain(fp->fs, fp->sclust);
   15354: e5941010  ldr r1, [r4, #16]
   15358: e5940000  ldr r0, [r4]
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   1535c: e3510001  cmp r1, #1
   15360: 9a000002  bls 15370 <f_truncate+0x7c>
   15364: e5903014  ldr r3, [r0, #20]
   15368: e1510003  cmp r1, r3
   1536c: 3a000022  bcc 153fc <f_truncate+0x108>
    res = FR_INT_ERR;
   15370: e3a00002  mov r0, #2
    if (fp->fsize > fp->fptr) {
      fp->fsize = fp->fptr; /* Set file size to current R/W point */
      fp->flag |= FA__WRITTEN;
      if (fp->fptr == 0U) { /* When set file size to zero, remove entire cluster chain */
        res = remove_chain(fp->fs, fp->sclust);
        fp->sclust = 0U;
   15374: e3a03000  mov r3, #0
   15378: e5843010  str r3, [r4, #16]
            res = remove_chain(fp->fs, ncl);
          }
        }
      }
#if !_FS_TINY
      if ((res == FR_OK) && ((fp->flag & FA__DIRTY) != (BYTE)0U)) {
   1537c: e3500000  cmp r0, #0
   15380: 1a00001b  bne 153f4 <f_truncate+0x100>
   15384: e5d43006  ldrb  r3, [r4, #6]
   15388: e3130040  tst r3, #64 ; 0x40
   1538c: 0affffe1  beq 15318 <f_truncate+0x24>
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
   15390: e1a01004  mov r1, r4
   15394: e5942018  ldr r2, [r4, #24]
   15398: e4910040  ldr r0, [r1], #64 ; 0x40
   1539c: e3a03001  mov r3, #1
   153a0: e5d00001  ldrb  r0, [r0, #1]
   153a4: eb0002f3  bl  15f78 <disk_write>
   153a8: e3500000  cmp r0, #0
   153ac: 1a00000e  bne 153ec <f_truncate+0xf8>
          res = FR_DISK_ERR;
        }
        else {
          fp->flag &= ~FA__DIRTY;
   153b0: e5d43006  ldrb  r3, [r4, #6]
   153b4: e3c33040  bic r3, r3, #64 ; 0x40
   153b8: e5c43006  strb  r3, [r4, #6]
   153bc: eaffffd5  b 15318 <f_truncate+0x24>
      fp->flag |= FA__WRITTEN;
      if (fp->fptr == 0U) { /* When set file size to zero, remove entire cluster chain */
        res = remove_chain(fp->fs, fp->sclust);
        fp->sclust = 0U;
      } else {        /* When truncate a part of the file, remove remaining clusters */
        ncl = get_fat(fp->fs, fp->clust);
   153c0: e5941014  ldr r1, [r4, #20]
   153c4: e5940000  ldr r0, [r4]
  UINT wc, bc;
  BYTE *p,temp;
  DWORD Status = 0xFFFFFFFFU;


  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)){ /* Chack range */
   153c8: e3510001  cmp r1, #1
   153cc: 9a000002  bls 153dc <f_truncate+0xe8>
   153d0: e5903014  ldr r3, [r0, #20]
   153d4: e1530001  cmp r3, r1
   153d8: 8a000009  bhi 15404 <f_truncate+0x110>
        res = FR_OK;
        if (ncl == (DWORD)0xFFFFFFFFU) {
          res = FR_DISK_ERR;
        }
        if (ncl == 1U) {
          res = FR_INT_ERR;
   153dc: e3a05002  mov r5, #2
        }
      }
#endif
    }
    if (res != FR_OK) {
      fp->err = (FRESULT)res;
   153e0: e5c45007  strb  r5, [r4, #7]
    }
  }

  LEAVE_FF(fp->fs, res);
}
   153e4: e1a00005  mov r0, r5
   153e8: e8bd8070  pop {r4, r5, r6, pc}
        }
      }
#if !_FS_TINY
      if ((res == FR_OK) && ((fp->flag & FA__DIRTY) != (BYTE)0U)) {
        if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1U) != RES_OK) {
          res = FR_DISK_ERR;
   153ec: e3a05001  mov r5, #1
   153f0: eafffffa  b 153e0 <f_truncate+0xec>
   153f4: e1a05000  mov r5, r0
   153f8: eafffff8  b 153e0 <f_truncate+0xec>
   153fc: ebfffb11  bl  14048 <remove_chain.part.10>
   15400: eaffffdb  b 15374 <f_truncate+0x80>
   15404: ebfff867  bl  135a8 <get_fat.part.6>
        res = remove_chain(fp->fs, fp->sclust);
        fp->sclust = 0U;
      } else {        /* When truncate a part of the file, remove remaining clusters */
        ncl = get_fat(fp->fs, fp->clust);
        res = FR_OK;
        if (ncl == (DWORD)0xFFFFFFFFU) {
   15408: e3700001  cmn r0, #1
   1540c: e1a06000  mov r6, r0
   15410: 0afffff5  beq 153ec <f_truncate+0xf8>
          res = FR_DISK_ERR;
        }
        if (ncl == 1U) {
   15414: e3500001  cmp r0, #1
   15418: 0affffef  beq 153dc <f_truncate+0xe8>
          res = FR_INT_ERR;
        }
        if ((res == FR_OK) && ((ncl < fp->fs->n_fatent) != 0U)) {
   1541c: e5940000  ldr r0, [r4]
   15420: e5903014  ldr r3, [r0, #20]
   15424: e1530006  cmp r3, r6
   15428: 9affffd5  bls 15384 <f_truncate+0x90>
          res = put_fat(fp->fs, fp->clust, 0x0FFFFFFFU);
   1542c: e5941014  ldr r1, [r4, #20]
  UINT bc;
  BYTE *p;
  FRESULT res;
  DWORD LocVal = val;

  if (((clst < 2U) != 0U) || ((clst >= fs->n_fatent) != 0U)) {  /* Check range */
   15430: e1530001  cmp r3, r1
   15434: 83510001  cmphi r1, #1
   15438: 9affffe7  bls 153dc <f_truncate+0xe8>
   1543c: e3e0220f  mvn r2, #-268435456 ; 0xf0000000
   15440: ebfff903  bl  13854 <put_fat.part.8>
        if (ncl == 1U) {
          res = FR_INT_ERR;
        }
        if ((res == FR_OK) && ((ncl < fp->fs->n_fatent) != 0U)) {
          res = put_fat(fp->fs, fp->clust, 0x0FFFFFFFU);
          if (res == FR_OK) {
   15444: e3500000  cmp r0, #0
   15448: 1affffe9  bne 153f4 <f_truncate+0x100>
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   1544c: e3560001  cmp r6, #1
          res = FR_INT_ERR;
        }
        if ((res == FR_OK) && ((ncl < fp->fs->n_fatent) != 0U)) {
          res = put_fat(fp->fs, fp->clust, 0x0FFFFFFFU);
          if (res == FR_OK) {
            res = remove_chain(fp->fs, ncl);
   15450: e5940000  ldr r0, [r4]
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   15454: 9affffe0  bls 153dc <f_truncate+0xe8>
   15458: e5903014  ldr r3, [r0, #20]
   1545c: e1530006  cmp r3, r6
   15460: 9affffdd  bls 153dc <f_truncate+0xe8>
   15464: e1a01006  mov r1, r6
   15468: ebfffaf6  bl  14048 <remove_chain.part.10>
   1546c: eaffffc2  b 1537c <f_truncate+0x88>

00015470 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
  const TCHAR* path   /* Pointer to the file or directory path */
)
{
   15470: e92d4010  push  {r4, lr}
   15474: e24dd050  sub sp, sp, #80 ; 0x50
  DWORD dclst;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15478: e28d1004  add r1, sp, #4
   1547c: e3a02001  mov r2, #1
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
  const TCHAR* path   /* Pointer to the file or directory path */
)
{
   15480: e58d0004  str r0, [sp, #4]
  DWORD dclst;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15484: e28d0018  add r0, sp, #24
FRESULT f_unlink (
  const TCHAR* path   /* Pointer to the file or directory path */
)
{
  FRESULT res;
  DIR dj = {0}, sdj = {0};
   15488: e3a03000  mov r3, #0
   1548c: e58d3018  str r3, [sp, #24]
   15490: e58d301c  str r3, [sp, #28]
   15494: e58d3020  str r3, [sp, #32]
   15498: e58d3024  str r3, [sp, #36] ; 0x24
   1549c: e58d3028  str r3, [sp, #40] ; 0x28
   154a0: e58d302c  str r3, [sp, #44] ; 0x2c
   154a4: e58d3030  str r3, [sp, #48] ; 0x30
   154a8: e58d3034  str r3, [sp, #52] ; 0x34
   154ac: e58d3038  str r3, [sp, #56] ; 0x38
   154b0: e58d303c  str r3, [sp, #60] ; 0x3c
   154b4: e58d3040  str r3, [sp, #64] ; 0x40
   154b8: e58d3044  str r3, [sp, #68] ; 0x44
   154bc: e58d3048  str r3, [sp, #72] ; 0x48
   154c0: e58d304c  str r3, [sp, #76] ; 0x4c
  DWORD dclst;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   154c4: ebfff6fe  bl  130c4 <find_volume>
  if (res == FR_OK) {
   154c8: e3500000  cmp r0, #0
   154cc: 0a000001  beq 154d8 <f_unlink+0x68>
    }
    FREE_BUF();
  }

  LEAVE_FF(dj.fs, res);
}
   154d0: e28dd050  add sp, sp, #80 ; 0x50
   154d4: e8bd8010  pop {r4, pc}

  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path);   /* Follow the file path */
   154d8: e28d0018  add r0, sp, #24
   154dc: e59d1004  ldr r1, [sp, #4]


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
   154e0: e28d300c  add r3, sp, #12
   154e4: e58d3030  str r3, [sp, #48] ; 0x30
    res = follow_path(&dj, path);   /* Follow the file path */
   154e8: ebfffa16  bl  13d48 <follow_path>
#if _FS_LOCK
    if (res == FR_OK) {
      res = chk_lock(&dj, 2); /* Cannot remove open file */
    }
#endif
    if (res == FR_OK) {         /* The object is accessible */
   154ec: e3500000  cmp r0, #0
   154f0: 1afffff6  bne 154d0 <f_unlink+0x60>
      dir = dj.dir;
   154f4: e59d302c  ldr r3, [sp, #44] ; 0x2c
      if ((!dir) != 0U) {
   154f8: e3530000  cmp r3, #0
   154fc: 0a00003d  beq 155f8 <f_unlink+0x188>
        res = FR_INVALID_NAME;    /* Cannot remove the start directory */
      } else {
        if (((*(dir+DIR_Attr)) & AM_RDO) != (BYTE)0U) {
   15500: e5d3200b  ldrb  r2, [r3, #11]
          res = FR_DENIED;    /* Cannot remove R/O object */
   15504: e3120001  tst r2, #1
   15508: 03a00000  moveq r0, #0
   1550c: 13a00007  movne r0, #7
   15510: e59d2018  ldr r2, [sp, #24]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   15514: e5d3401b  ldrb  r4, [r3, #27]
   15518: e5d3101a  ldrb  r1, [r3, #26]
  if (fs->fs_type == FS_FAT32) {
   1551c: e5d22000  ldrb  r2, [r2]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   15520: e1814404  orr r4, r1, r4, lsl #8
  if (fs->fs_type == FS_FAT32) {
   15524: e3520003  cmp r2, #3
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   15528: 05d31015  ldrbeq  r1, [r3, #21]
   1552c: 05d32014  ldrbeq  r2, [r3, #20]
   15530: 01822401  orreq r2, r2, r1, lsl #8
   15534: 01844802  orreq r4, r4, r2, lsl #16
        if (((*(dir+DIR_Attr)) & AM_RDO) != (BYTE)0U) {
          res = FR_DENIED;    /* Cannot remove R/O object */
        }
      }
      dclst = ld_clust(dj.fs, dir);
      if ((res == FR_OK) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) { /* Is it a sub-dir? */
   15538: e3500000  cmp r0, #0
   1553c: 1affffe3  bne 154d0 <f_unlink+0x60>
   15540: e5d3300b  ldrb  r3, [r3, #11]
   15544: e3130010  tst r3, #16
   15548: 0a000015  beq 155a4 <f_unlink+0x134>
        if (dclst < 2U) {
   1554c: e3540001  cmp r4, #1
   15550: 9a00001f  bls 155d4 <f_unlink+0x164>
   15554: e28d2017  add r2, sp, #23
   15558: e28d3034  add r3, sp, #52 ; 0x34
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   1555c: e5f20001  ldrb  r0, [r2, #1]!
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   15560: e28d1050  add r1, sp, #80 ; 0x50
    *d=*s;
   15564: e4c30001  strb  r0, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   15568: e1530001  cmp r3, r1
   1556c: 1afffffa  bne 1555c <f_unlink+0xec>
        if (dclst < 2U) {
          res = FR_INT_ERR;
        } else {
          mem_cpy(&sdj, &dj, sizeof (DIR)); /* Check if the sub-directory is empty or not */
          sdj.sclust = dclst;
          res = dir_sdi(&sdj, 2U);    /* Exclude dot entries */
   15570: e28d0034  add r0, sp, #52 ; 0x34
   15574: e3a01002  mov r1, #2
      if ((res == FR_OK) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) { /* Is it a sub-dir? */
        if (dclst < 2U) {
          res = FR_INT_ERR;
        } else {
          mem_cpy(&sdj, &dj, sizeof (DIR)); /* Check if the sub-directory is empty or not */
          sdj.sclust = dclst;
   15578: e58d403c  str r4, [sp, #60] ; 0x3c
          res = dir_sdi(&sdj, 2U);    /* Exclude dot entries */
   1557c: ebfff84b  bl  136b0 <dir_sdi>
          if (res == FR_OK) {
   15580: e3500000  cmp r0, #0
   15584: 1affffd1  bne 154d0 <f_unlink+0x60>
            res = dir_read(&sdj, 0);  /* Read an item */
   15588: e28d0034  add r0, sp, #52 ; 0x34
   1558c: ebfffad6  bl  140ec <dir_read.constprop.11>
            if (res == FR_OK    /* Not empty directory */
   15590: e3500000  cmp r0, #0
#if _FS_RPATH
            || dclst == dj.fs->cdir /* Current directory */
#endif
            ) {
              res = FR_DENIED;
   15594: 03a00007  moveq r0, #7
          mem_cpy(&sdj, &dj, sizeof (DIR)); /* Check if the sub-directory is empty or not */
          sdj.sclust = dclst;
          res = dir_sdi(&sdj, 2U);    /* Exclude dot entries */
          if (res == FR_OK) {
            res = dir_read(&sdj, 0);  /* Read an item */
            if (res == FR_OK    /* Not empty directory */
   15598: 0affffcc  beq 154d0 <f_unlink+0x60>
            || dclst == dj.fs->cdir /* Current directory */
#endif
            ) {
              res = FR_DENIED;
            }
            if (res == FR_NO_FILE) {
   1559c: e3500004  cmp r0, #4
   155a0: 1affffca  bne 154d0 <f_unlink+0x60>
            }
          }
        }
      }
      if (res == FR_OK) {
        res = dir_remove(&dj);    /* Remove the directory entry */
   155a4: e28d0018  add r0, sp, #24
   155a8: ebfff891  bl  137f4 <dir_remove>
        if (res == FR_OK) {
   155ac: e3500000  cmp r0, #0
   155b0: 1affffc6  bne 154d0 <f_unlink+0x60>
          if (dclst != (DWORD)0U) {       /* Remove the cluster chain if exist */
   155b4: e3540000  cmp r4, #0
   155b8: 0a00000b  beq 155ec <f_unlink+0x17c>
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   155bc: e3540001  cmp r4, #1
      }
      if (res == FR_OK) {
        res = dir_remove(&dj);    /* Remove the directory entry */
        if (res == FR_OK) {
          if (dclst != (DWORD)0U) {       /* Remove the cluster chain if exist */
            res = remove_chain(dj.fs, dclst);
   155c0: e59d0018  ldr r0, [sp, #24]
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   155c4: 9a000002  bls 155d4 <f_unlink+0x164>
   155c8: e5903014  ldr r3, [r0, #20]
   155cc: e1530004  cmp r3, r4
   155d0: 8a000001  bhi 155dc <f_unlink+0x16c>
        }
      }
      dclst = ld_clust(dj.fs, dir);
      if ((res == FR_OK) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) { /* Is it a sub-dir? */
        if (dclst < 2U) {
          res = FR_INT_ERR;
   155d4: e3a00002  mov r0, #2
   155d8: eaffffbc  b 154d0 <f_unlink+0x60>
   155dc: e1a01004  mov r1, r4
   155e0: ebfffa98  bl  14048 <remove_chain.part.10>
        res = dir_remove(&dj);    /* Remove the directory entry */
        if (res == FR_OK) {
          if (dclst != (DWORD)0U) {       /* Remove the cluster chain if exist */
            res = remove_chain(dj.fs, dclst);
          }
          if (res == FR_OK) {
   155e4: e3500000  cmp r0, #0
   155e8: 1affffb8  bne 154d0 <f_unlink+0x60>
            res = sync_fs(dj.fs);
   155ec: e59d0018  ldr r0, [sp, #24]
   155f0: ebfff620  bl  12e78 <sync_fs>
   155f4: eaffffb5  b 154d0 <f_unlink+0x60>
    }
#endif
    if (res == FR_OK) {         /* The object is accessible */
      dir = dj.dir;
      if ((!dir) != 0U) {
        res = FR_INVALID_NAME;    /* Cannot remove the start directory */
   155f8: e3a00006  mov r0, #6
   155fc: eaffffc3  b 15510 <f_unlink+0xa0>

00015600 <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
  const TCHAR* path   /* Pointer to the directory path */
)
{
   15600: e92d4ff0  push  {r4, r5, r6, r7, r8, r9, sl, fp, lr}
   15604: e24dd04c  sub sp, sp, #76 ; 0x4c
  FRESULT res;
  DIR dj = {0};
   15608: e3a03000  mov r3, #0
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
  const TCHAR* path   /* Pointer to the directory path */
)
{
   1560c: e58d001c  str r0, [sp, #28]
  FRESULT res;
  DIR dj = {0};
   15610: e58d302c  str r3, [sp, #44] ; 0x2c
   15614: e58d3030  str r3, [sp, #48] ; 0x30
   15618: e58d3034  str r3, [sp, #52] ; 0x34
   1561c: e58d3038  str r3, [sp, #56] ; 0x38
   15620: e58d303c  str r3, [sp, #60] ; 0x3c
   15624: e58d3040  str r3, [sp, #64] ; 0x40
   15628: e58d3044  str r3, [sp, #68] ; 0x44
  BYTE *dir, n;
  DWORD dsc, dcl, pcl, tm = get_fattime();
   1562c: eb00024e  bl  15f6c <get_fattime>
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15630: e28d101c  add r1, sp, #28
   15634: e3a02001  mov r2, #1
)
{
  FRESULT res;
  DIR dj = {0};
  BYTE *dir, n;
  DWORD dsc, dcl, pcl, tm = get_fattime();
   15638: e1a05000  mov r5, r0
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   1563c: e28d002c  add r0, sp, #44 ; 0x2c
   15640: ebfff69f  bl  130c4 <find_volume>
  if (res == FR_OK) {
   15644: e3500000  cmp r0, #0
  DWORD dsc, dcl, pcl, tm = get_fattime();
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15648: e1a06000  mov r6, r0
  if (res == FR_OK) {
   1564c: 0a000002  beq 1565c <f_mkdir+0x5c>
    }
    FREE_BUF();
  }

  LEAVE_FF(dj.fs, res);
}
   15650: e1a00006  mov r0, r6
   15654: e28dd04c  add sp, sp, #76 ; 0x4c
   15658: e8bd8ff0  pop {r4, r5, r6, r7, r8, r9, sl, fp, pc}
   1565c: e1a04000  mov r4, r0

  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path);     /* Follow the file path */
   15660: e59d101c  ldr r1, [sp, #28]
   15664: e28d002c  add r0, sp, #44 ; 0x2c


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
   15668: e28d3020  add r3, sp, #32
   1566c: e58d3044  str r3, [sp, #68] ; 0x44
    res = follow_path(&dj, path);     /* Follow the file path */
   15670: ebfff9b4  bl  13d48 <follow_path>
    if (res == FR_OK) {
   15674: e2506000  subs  r6, r0, #0
      res = FR_EXIST;   /* Any object with same name is already existing */
   15678: 03a06008  moveq r6, #8
  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path);     /* Follow the file path */
    if (res == FR_OK) {
   1567c: 0afffff3  beq 15650 <f_mkdir+0x50>
      res = FR_EXIST;   /* Any object with same name is already existing */
    }
    if (_FS_RPATH && (res == FR_NO_FILE) && ((dj.fn[NS] & NS_DOT) != (BYTE)0U)) {
      res = FR_INVALID_NAME;
    }
    if (res == FR_NO_FILE) {        /* Can create a new directory */
   15680: e3560004  cmp r6, #4
   15684: 1afffff1  bne 15650 <f_mkdir+0x50>
      dcl = create_chain(dj.fs, 0U);    /* Allocate a cluster for the new directory table */
   15688: e1a01004  mov r1, r4
   1568c: e59d002c  ldr r0, [sp, #44] ; 0x2c
   15690: ebfff8cd  bl  139cc <create_chain>
      res = FR_OK;
      if (dcl == 0U) {
   15694: e2507000  subs  r7, r0, #0
   15698: 0a00006b  beq 1584c <f_mkdir+0x24c>
        res = FR_DENIED;    /* No space to allocate a new cluster */
      }
      if (dcl == 1U) {
   1569c: e3570001  cmp r7, #1
        res = FR_INT_ERR;
   156a0: 03a06002  moveq r6, #2
      dcl = create_chain(dj.fs, 0U);    /* Allocate a cluster for the new directory table */
      res = FR_OK;
      if (dcl == 0U) {
        res = FR_DENIED;    /* No space to allocate a new cluster */
      }
      if (dcl == 1U) {
   156a4: 0a000069  beq 15850 <f_mkdir+0x250>
        res = FR_INT_ERR;
      }
      if (dcl == 0xFFFFFFFFU) {
   156a8: e3770001  cmn r7, #1
        res = FR_DISK_ERR;
   156ac: 03a06001  moveq r6, #1
        res = FR_DENIED;    /* No space to allocate a new cluster */
      }
      if (dcl == 1U) {
        res = FR_INT_ERR;
      }
      if (dcl == 0xFFFFFFFFU) {
   156b0: 0a000066  beq 15850 <f_mkdir+0x250>
        res = FR_DISK_ERR;
      }
      if (res == FR_OK) {         /* Flush FAT */
        res = sync_window(dj.fs);
   156b4: e59d602c  ldr r6, [sp, #44] ; 0x2c
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   156b8: e5d63004  ldrb  r3, [r6, #4]
   156bc: e3530000  cmp r3, #0
   156c0: 1a000094  bne 15918 <f_mkdir+0x318>
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   156c4: e5963014  ldr r3, [r6, #20]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   156c8: e2472002  sub r2, r7, #2
      if (res == FR_OK) {         /* Flush FAT */
        res = sync_window(dj.fs);
      }
      if (res == FR_OK) {         /* Initialize the new directory table */
        dsc = clust2sect(dj.fs, dcl);
        dir = dj.fs->win;
   156cc: e2869040  add r9, r6, #64 ; 0x40
   156d0: e2864d09  add r4, r6, #576  ; 0x240
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   156d4: e2433002  sub r3, r3, #2
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   156d8: e3a01000  mov r1, #0
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   156dc: e1520003  cmp r2, r3
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   156e0: 35963028  ldrcc r3, [r6, #40] ; 0x28
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
    res = ((DWORD)0U);    /* Invalid cluster# */
   156e4: 23a0b000  movcs fp, #0
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   156e8: 35d6b002  ldrbcc  fp, [r6, #2]
   156ec: 302b329b  mlacc fp, fp, r2, r3
}

/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;
   156f0: e1a03009  mov r3, r9

  while ((cnt) > 0U){
    *d = (BYTE)val;
   156f4: e4c31001  strb  r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   156f8: e1530004  cmp r3, r4
   156fc: 1afffffc  bne 156f4 <f_mkdir+0xf4>
   15700: e286004b  add r0, r6, #75 ; 0x4b
   15704: e1a03009  mov r3, r9
    *d = (BYTE)val;
   15708: e3a01020  mov r1, #32
   1570c: e4c31001  strb  r1, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   15710: e1530000  cmp r3, r0
   15714: 1afffffc  bne 1570c <f_mkdir+0x10c>
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15718: e6ff3077  uxth  r3, r7
   1571c: e58d3000  str r3, [sp]
      if (res == FR_OK) {         /* Initialize the new directory table */
        dsc = clust2sect(dj.fs, dcl);
        dir = dj.fs->win;
        mem_set(dir, 0, SS(dj.fs));
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
   15720: e3a0002e  mov r0, #46 ; 0x2e
   15724: e286e080  add lr, r6, #128  ; 0x80
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15728: e1a02003  mov r2, r3
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   1572c: e1a03827  lsr r3, r7, #16
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15730: e1c625ba  strh  r2, [r6, #90] ; 0x5a
   15734: e1a02422  lsr r2, r2, #8
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15738: e1a08003  mov r8, r3
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   1573c: e58d2010  str r2, [sp, #16]
   15740: e1a0a002  mov sl, r2
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15744: e1a02008  mov r2, r8
   15748: e1a02422  lsr r2, r2, #8
   1574c: e58d3014  str r3, [sp, #20]
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
        st_clust(dir, dcl);
        mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
   15750: e1a01000  mov r1, r0
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15754: e1c685b4  strh  r8, [r6, #84] ; 0x54
   15758: e58d2018  str r2, [sp, #24]
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
        st_clust(dir, dcl);
        mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
   1575c: e2863060  add r3, r6, #96 ; 0x60
      if (res == FR_OK) {         /* Initialize the new directory table */
        dsc = clust2sect(dj.fs, dcl);
        dir = dj.fs->win;
        mem_set(dir, 0, SS(dj.fs));
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
   15760: e5c60040  strb  r0, [r6, #64] ; 0x40
   15764: e1a0c009  mov ip, r9
        (*(dir+DIR_Attr)) = AM_DIR;
   15768: e3a00010  mov r0, #16
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   1576c: e1c625b5  strh  r2, [r6, #85] ; 0x55
        dsc = clust2sect(dj.fs, dcl);
        dir = dj.fs->win;
        mem_set(dir, 0, SS(dj.fs));
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
        (*(dir+DIR_Attr)) = AM_DIR;
   15770: e5c6004b  strb  r0, [r6, #75] ; 0x4b
        ST_DWORD(dir+DIR_WrtTime, tm);
   15774: e7e72455  ubfx  r2, r5, #8, #8
   15778: e7e70855  ubfx  r0, r5, #16, #8
   1577c: e58d2004  str r2, [sp, #4]
   15780: e5c62057  strb  r2, [r6, #87] ; 0x57
   15784: e1a02c25  lsr r2, r5, #24
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15788: e1c6a5bb  strh  sl, [r6, #91] ; 0x5b
        dir = dj.fs->win;
        mem_set(dir, 0, SS(dj.fs));
        mem_set(dir, (s32)' ', 11U);  /* Create "." entry */
        (*(dir+DIR_Name)) = ((BYTE)'.');
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
   1578c: e58d0008  str r0, [sp, #8]
   15790: e58d200c  str r2, [sp, #12]
   15794: e5c60058  strb  r0, [r6, #88] ; 0x58
   15798: e5c62059  strb  r2, [r6, #89] ; 0x59
   1579c: ea000000  b 157a4 <f_mkdir+0x1a4>
   157a0: e5fc1001  ldrb  r1, [ip, #1]!
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   157a4: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   157a8: e153000e  cmp r3, lr
   157ac: 1afffffb  bne 157a0 <f_mkdir+0x1a0>
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
        st_clust(dir, dcl);
        mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
        (*(dir+SZ_DIR+1U)) = ((BYTE)'.'); pcl = dj.sclust;
        if ((dj.fs->fs_type == FS_FAT32) && (pcl == dj.fs->dirbase)) {
   157b0: e59d002c  ldr r0, [sp, #44] ; 0x2c
        (*(dir+DIR_Name)) = ((BYTE)'.');
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
        st_clust(dir, dcl);
        mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
        (*(dir+SZ_DIR+1U)) = ((BYTE)'.'); pcl = dj.sclust;
   157b4: e3a0302e  mov r3, #46 ; 0x2e
   157b8: e5c63061  strb  r3, [r6, #97] ; 0x61
   157bc: e59d3034  ldr r3, [sp, #52] ; 0x34
        if ((dj.fs->fs_type == FS_FAT32) && (pcl == dj.fs->dirbase)) {
   157c0: e5d01000  ldrb  r1, [r0]
   157c4: e3510003  cmp r1, #3
   157c8: 0a00004a  beq 158f8 <f_mkdir+0x2f8>
   157cc: e6ffc073  uxth  ip, r3
   157d0: e1a03823  lsr r3, r3, #16
   157d4: e1a0e42c  lsr lr, ip, #8
   157d8: e1a01423  lsr r1, r3, #8
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   157dc: e1c6c7ba  strh  ip, [r6, #122]  ; 0x7a
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   157e0: e1c637b4  strh  r3, [r6, #116]  ; 0x74
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   157e4: e1c6e7bb  strh  lr, [r6, #123]  ; 0x7b
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   157e8: e1c617b5  strh  r1, [r6, #117]  ; 0x75
        (*(dir+SZ_DIR+1U)) = ((BYTE)'.'); pcl = dj.sclust;
        if ((dj.fs->fs_type == FS_FAT32) && (pcl == dj.fs->dirbase)) {
          pcl = 0U;
        }
        st_clust(dir+SZ_DIR, pcl);
        n = dj.fs->csize;
   157ec: e5d03002  ldrb  r3, [r0, #2]
        for (; n; n--) {  /* Write dot entries and clear following sectors */
   157f0: e3530000  cmp r3, #0
   157f4: 0a000023  beq 15888 <f_mkdir+0x288>
   157f8: e2433001  sub r3, r3, #1
          dj.fs->winsect = dsc;
          dsc += (DWORD)1;
          dj.fs->wflag = 1U;
   157fc: e3a08001  mov r8, #1
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   15800: e3a05000  mov r5, #0
   15804: e6ef3073  uxtb  r3, r3
   15808: e0833008  add r3, r3, r8
   1580c: e083a00b  add sl, r3, fp
        st_clust(dir+SZ_DIR, pcl);
        n = dj.fs->csize;
        for (; n; n--) {  /* Write dot entries and clear following sectors */
          dj.fs->winsect = dsc;
          dsc += (DWORD)1;
          dj.fs->wflag = 1U;
   15810: e59d302c  ldr r3, [sp, #44] ; 0x2c
          pcl = 0U;
        }
        st_clust(dir+SZ_DIR, pcl);
        n = dj.fs->csize;
        for (; n; n--) {  /* Write dot entries and clear following sectors */
          dj.fs->winsect = dsc;
   15814: e580b02c  str fp, [r0, #44] ; 0x2c
          dsc += (DWORD)1;
   15818: e28bb001  add fp, fp, #1
          dj.fs->wflag = 1U;
   1581c: e5c38004  strb  r8, [r3, #4]
)
{
  DWORD wsect;
  UINT nf;

  if (fs->wflag != 0U) {  /* Write back the sector if it is dirty */
   15820: e5d03004  ldrb  r3, [r0, #4]
   15824: e3530000  cmp r3, #0
   15828: 1a000011  bne 15874 <f_mkdir+0x274>
   1582c: e1a03009  mov r3, r9
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
    *d = (BYTE)val;
   15830: e4c35001  strb  r5, [r3], #1
/* Fill memory */
static
void mem_set (void* dst, s32 val, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;

  while ((cnt) > 0U){
   15834: e1540003  cmp r4, r3
   15838: 1afffffc  bne 15830 <f_mkdir+0x230>
        if ((dj.fs->fs_type == FS_FAT32) && (pcl == dj.fs->dirbase)) {
          pcl = 0U;
        }
        st_clust(dir+SZ_DIR, pcl);
        n = dj.fs->csize;
        for (; n; n--) {  /* Write dot entries and clear following sectors */
   1583c: e15b000a  cmp fp, sl
   15840: 0a000010  beq 15888 <f_mkdir+0x288>
   15844: e59d002c  ldr r0, [sp, #44] ; 0x2c
   15848: eafffff0  b 15810 <f_mkdir+0x210>
    }
    if (res == FR_NO_FILE) {        /* Can create a new directory */
      dcl = create_chain(dj.fs, 0U);    /* Allocate a cluster for the new directory table */
      res = FR_OK;
      if (dcl == 0U) {
        res = FR_DENIED;    /* No space to allocate a new cluster */
   1584c: e3a06007  mov r6, #7
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   15850: e3570001  cmp r7, #1
      }
      if (res == FR_OK) {
        res = dir_register(&dj);  /* Register the object to the directoy */
      }
      if (res != FR_OK) {
        (void)remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
   15854: e59d002c  ldr r0, [sp, #44] ; 0x2c
  DWORD LocClst = clst;
#if _USE_ERASE
  DWORD scl = LocClst, ecl = LocClst, rt[2];
#endif

  if (((LocClst < 2U) != 0U) || ((LocClst >= fs->n_fatent) != 0U)) {  /* Check range */
   15858: 9affff7c  bls 15650 <f_mkdir+0x50>
   1585c: e5903014  ldr r3, [r0, #20]
   15860: e1570003  cmp r7, r3
   15864: 2affff79  bcs 15650 <f_mkdir+0x50>
   15868: e1a01007  mov r1, r7
   1586c: ebfff9f5  bl  14048 <remove_chain.part.10>
   15870: eaffff76  b 15650 <f_mkdir+0x50>
   15874: ebfff55c  bl  12dec <sync_window.part.3>
        for (; n; n--) {  /* Write dot entries and clear following sectors */
          dj.fs->winsect = dsc;
          dsc += (DWORD)1;
          dj.fs->wflag = 1U;
          res = sync_window(dj.fs);
          if (res != FR_OK) {
   15878: e3500000  cmp r0, #0
   1587c: 0affffea  beq 1582c <f_mkdir+0x22c>
   15880: e1a06000  mov r6, r0
   15884: eafffff1  b 15850 <f_mkdir+0x250>
          }
          mem_set(dir, 0, SS(dj.fs));
        }
      }
      if (res == FR_OK) {
        res = dir_register(&dj);  /* Register the object to the directoy */
   15888: e28d002c  add r0, sp, #44 ; 0x2c
   1588c: ebfffa44  bl  141a4 <dir_register>
      }
      if (res != FR_OK) {
   15890: e2506000  subs  r6, r0, #0
   15894: 1affffed  bne 15850 <f_mkdir+0x250>
        (void)remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
      } else {
        dir = dj.dir;
   15898: e59d3040  ldr r3, [sp, #64] ; 0x40
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
   1589c: e3a0c010  mov ip, #16
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
   158a0: e5dde004  ldrb  lr, [sp, #4]
        st_clust(dir, dcl);         /* Table start cluster */
        dj.fs->wflag = 1U;
   158a4: e3a01001  mov r1, #1
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   158a8: e1dd00b0  ldrh  r0, [sp]
      } else {
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
        st_clust(dir, dcl);         /* Table start cluster */
        dj.fs->wflag = 1U;
   158ac: e59d202c  ldr r2, [sp, #44] ; 0x2c
      if (res != FR_OK) {
        (void)remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
      } else {
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
   158b0: e5c3e017  strb  lr, [r3, #23]
   158b4: e5dde008  ldrb  lr, [sp, #8]
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   158b8: e1c301ba  strh  r0, [r3, #26]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   158bc: e1dd01b4  ldrh  r0, [sp, #20]
      if (res != FR_OK) {
        (void)remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
      } else {
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
   158c0: e5c3e018  strb  lr, [r3, #24]
   158c4: e5dde00c  ldrb  lr, [sp, #12]
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   158c8: e1c301b4  strh  r0, [r3, #20]
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
        st_clust(dir, dcl);         /* Table start cluster */
        dj.fs->wflag = 1U;
        res = sync_fs(dj.fs);
   158cc: e1a00002  mov r0, r2
      }
      if (res != FR_OK) {
        (void)remove_chain(dj.fs, dcl);     /* Could not register, remove cluster chain */
      } else {
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
   158d0: e5c3c00b  strb  ip, [r3, #11]
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
   158d4: e5c3e019  strb  lr, [r3, #25]
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   158d8: e1dde1b0  ldrh  lr, [sp, #16]
   158dc: e1c3e1bb  strh  lr, [r3, #27]
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   158e0: e1dde1b8  ldrh  lr, [sp, #24]
   158e4: e1c3e1b5  strh  lr, [r3, #21]
      } else {
        dir = dj.dir;
        (*(dir+DIR_Attr)) = AM_DIR;       /* Attribute */
        ST_DWORD(dir+DIR_WrtTime, tm);    /* Created time */
        st_clust(dir, dcl);         /* Table start cluster */
        dj.fs->wflag = 1U;
   158e8: e5c21004  strb  r1, [r2, #4]
        res = sync_fs(dj.fs);
   158ec: ebfff561  bl  12e78 <sync_fs>
   158f0: e1a06000  mov r6, r0
   158f4: eaffff55  b 15650 <f_mkdir+0x50>
        (*(dir+DIR_Attr)) = AM_DIR;
        ST_DWORD(dir+DIR_WrtTime, tm);
        st_clust(dir, dcl);
        mem_cpy(dir+SZ_DIR, dir, SZ_DIR);   /* Create ".." entry */
        (*(dir+SZ_DIR+1U)) = ((BYTE)'.'); pcl = dj.sclust;
        if ((dj.fs->fs_type == FS_FAT32) && (pcl == dj.fs->dirbase)) {
   158f8: e5901024  ldr r1, [r0, #36] ; 0x24
   158fc: e1510003  cmp r1, r3
   15900: 1affffb1  bne 157cc <f_mkdir+0x1cc>
   15904: e3a01000  mov r1, #0
   15908: e1a03001  mov r3, r1
   1590c: e1a0e001  mov lr, r1
   15910: e1a0c001  mov ip, r1
   15914: eaffffb0  b 157dc <f_mkdir+0x1dc>
   15918: e1a00006  mov r0, r6
   1591c: ebfff532  bl  12dec <sync_window.part.3>
        res = FR_DISK_ERR;
      }
      if (res == FR_OK) {         /* Flush FAT */
        res = sync_window(dj.fs);
      }
      if (res == FR_OK) {         /* Initialize the new directory table */
   15920: e2506000  subs  r6, r0, #0
   15924: 1affffc9  bne 15850 <f_mkdir+0x250>
   15928: e59d602c  ldr r6, [sp, #44] ; 0x2c
   1592c: eaffff64  b 156c4 <f_mkdir+0xc4>

00015930 <f_chmod>:
FRESULT f_chmod (
  const TCHAR* path,  /* Pointer to the file path */
  BYTE value,     /* Attribute bits */
  BYTE mask     /* Attribute mask to change */
)
{
   15930: e92d4030  push  {r4, r5, lr}
   15934: e24dd034  sub sp, sp, #52 ; 0x34
   15938: e1a04001  mov r4, r1
   1593c: e1a05002  mov r5, r2
   15940: e58d0004  str r0, [sp, #4]
  BYTE *dir;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15944: e28d1004  add r1, sp, #4
   15948: e28d0014  add r0, sp, #20
   1594c: e3a02001  mov r2, #1
  BYTE value,     /* Attribute bits */
  BYTE mask     /* Attribute mask to change */
)
{
  FRESULT res;
  DIR dj = {0};
   15950: e3a03000  mov r3, #0
   15954: e58d3014  str r3, [sp, #20]
   15958: e58d3018  str r3, [sp, #24]
   1595c: e58d301c  str r3, [sp, #28]
   15960: e58d3020  str r3, [sp, #32]
   15964: e58d3024  str r3, [sp, #36] ; 0x24
   15968: e58d3028  str r3, [sp, #40] ; 0x28
   1596c: e58d302c  str r3, [sp, #44] ; 0x2c
  BYTE *dir;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15970: ebfff5d3  bl  130c4 <find_volume>
  if (res == FR_OK) {
   15974: e3500000  cmp r0, #0
   15978: 0a000001  beq 15984 <f_chmod+0x54>
      }
    }
  }

  LEAVE_FF(dj.fs, res);
}
   1597c: e28dd034  add sp, sp, #52 ; 0x34
   15980: e8bd8030  pop {r4, r5, pc}

  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path);   /* Follow the file path */
   15984: e28d0014  add r0, sp, #20
   15988: e59d1004  ldr r1, [sp, #4]


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
   1598c: e28d3008  add r3, sp, #8
   15990: e58d302c  str r3, [sp, #44] ; 0x2c
    res = follow_path(&dj, path);   /* Follow the file path */
   15994: ebfff8eb  bl  13d48 <follow_path>
    FREE_BUF();
    if (_FS_RPATH && (res == FR_OK) && ((dj.fn[NS] & NS_DOT) != (BYTE)0U)) {
      res = FR_INVALID_NAME;
    }
    if (res == FR_OK) {
   15998: e3500000  cmp r0, #0
   1599c: 1afffff6  bne 1597c <f_chmod+0x4c>
      dir = dj.dir;
   159a0: e59d3028  ldr r3, [sp, #40] ; 0x28
      if ((!dir) != 0U) {           /* Is it a root directory? */
   159a4: e3530000  cmp r3, #0
        res = FR_INVALID_NAME;
   159a8: 03a00006  moveq r0, #6
    if (_FS_RPATH && (res == FR_OK) && ((dj.fn[NS] & NS_DOT) != (BYTE)0U)) {
      res = FR_INVALID_NAME;
    }
    if (res == FR_OK) {
      dir = dj.dir;
      if ((!dir) != 0U) {           /* Is it a root directory? */
   159ac: 0afffff2  beq 1597c <f_chmod+0x4c>
        res = FR_INVALID_NAME;
      } else {            /* File or sub directory */
        mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
        (*(dir+DIR_Attr)) = (value & mask) | ((*(dir+DIR_Attr)) & (BYTE)~mask); /* Apply attribute change */
   159b0: e5d3200b  ldrb  r2, [r3, #11]
    if (res == FR_OK) {
      dir = dj.dir;
      if ((!dir) != 0U) {           /* Is it a root directory? */
        res = FR_INVALID_NAME;
      } else {            /* File or sub directory */
        mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
   159b4: e2055027  and r5, r5, #39 ; 0x27
        (*(dir+DIR_Attr)) = (value & mask) | ((*(dir+DIR_Attr)) & (BYTE)~mask); /* Apply attribute change */
        dj.fs->wflag = 1U;
   159b8: e59d1014  ldr r1, [sp, #20]
      dir = dj.dir;
      if ((!dir) != 0U) {           /* Is it a root directory? */
        res = FR_INVALID_NAME;
      } else {            /* File or sub directory */
        mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
        (*(dir+DIR_Attr)) = (value & mask) | ((*(dir+DIR_Attr)) & (BYTE)~mask); /* Apply attribute change */
   159bc: e0044005  and r4, r4, r5
   159c0: e1c25005  bic r5, r2, r5
        dj.fs->wflag = 1U;
   159c4: e3a02001  mov r2, #1
      dir = dj.dir;
      if ((!dir) != 0U) {           /* Is it a root directory? */
        res = FR_INVALID_NAME;
      } else {            /* File or sub directory */
        mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
        (*(dir+DIR_Attr)) = (value & mask) | ((*(dir+DIR_Attr)) & (BYTE)~mask); /* Apply attribute change */
   159c8: e1854004  orr r4, r5, r4
   159cc: e5c3400b  strb  r4, [r3, #11]
        dj.fs->wflag = 1U;
        res = sync_fs(dj.fs);
   159d0: e1a00001  mov r0, r1
      if ((!dir) != 0U) {           /* Is it a root directory? */
        res = FR_INVALID_NAME;
      } else {            /* File or sub directory */
        mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;  /* Valid attribute mask */
        (*(dir+DIR_Attr)) = (value & mask) | ((*(dir+DIR_Attr)) & (BYTE)~mask); /* Apply attribute change */
        dj.fs->wflag = 1U;
   159d4: e5c12004  strb  r2, [r1, #4]
        res = sync_fs(dj.fs);
   159d8: ebfff526  bl  12e78 <sync_fs>
      }
    }
  }

  LEAVE_FF(dj.fs, res);
}
   159dc: e28dd034  add sp, sp, #52 ; 0x34
   159e0: e8bd8030  pop {r4, r5, pc}

000159e4 <f_utime>:

FRESULT f_utime (
  const TCHAR* path,  /* Pointer to the file/directory name */
  const FILINFO* fno  /* Pointer to the time stamp to be set */
)
{
   159e4: e92d4010  push  {r4, lr}
   159e8: e24dd030  sub sp, sp, #48 ; 0x30
   159ec: e1a04001  mov r4, r1
  BYTE *dir;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   159f0: e3a02001  mov r2, #1

FRESULT f_utime (
  const TCHAR* path,  /* Pointer to the file/directory name */
  const FILINFO* fno  /* Pointer to the time stamp to be set */
)
{
   159f4: e58d0004  str r0, [sp, #4]
  BYTE *dir;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   159f8: e28d1004  add r1, sp, #4
   159fc: e28d0014  add r0, sp, #20
  const TCHAR* path,  /* Pointer to the file/directory name */
  const FILINFO* fno  /* Pointer to the time stamp to be set */
)
{
  FRESULT res;
  DIR dj = {0};
   15a00: e3a03000  mov r3, #0
   15a04: e58d3014  str r3, [sp, #20]
   15a08: e58d3018  str r3, [sp, #24]
   15a0c: e58d301c  str r3, [sp, #28]
   15a10: e58d3020  str r3, [sp, #32]
   15a14: e58d3024  str r3, [sp, #36] ; 0x24
   15a18: e58d3028  str r3, [sp, #40] ; 0x28
   15a1c: e58d302c  str r3, [sp, #44] ; 0x2c
  BYTE *dir;
  DEF_NAMEBUF;


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
   15a20: ebfff5a7  bl  130c4 <find_volume>
  if (res == FR_OK) {
   15a24: e3500000  cmp r0, #0
   15a28: 0a000001  beq 15a34 <f_utime+0x50>
      }
    }
  }

  LEAVE_FF(dj.fs, res);
}
   15a2c: e28dd030  add sp, sp, #48 ; 0x30
   15a30: e8bd8010  pop {r4, pc}

  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
    res = follow_path(&dj, path); /* Follow the file path */
   15a34: e28d0014  add r0, sp, #20
   15a38: e59d1004  ldr r1, [sp, #4]


  /* Get logical drive number */
  res = find_volume(&dj.fs, &path, 1U);
  if (res == FR_OK) {
    INIT_BUF(dj);
   15a3c: e28d3008  add r3, sp, #8
   15a40: e58d302c  str r3, [sp, #44] ; 0x2c
    res = follow_path(&dj, path); /* Follow the file path */
   15a44: ebfff8bf  bl  13d48 <follow_path>
    FREE_BUF();
    if (_FS_RPATH && (res == FR_OK) && ((dj.fn[NS] & NS_DOT) != (BYTE)0U)) {
      res = FR_INVALID_NAME;
    }
    if (res == FR_OK) {
   15a48: e3500000  cmp r0, #0
   15a4c: 1afffff6  bne 15a2c <f_utime+0x48>
      dir = dj.dir;
   15a50: e59d3028  ldr r3, [sp, #40] ; 0x28
      if ((!dir) != 0U) {         /* Root directory */
   15a54: e3530000  cmp r3, #0
        res = FR_INVALID_NAME;
   15a58: 03a00006  moveq r0, #6
    if (_FS_RPATH && (res == FR_OK) && ((dj.fn[NS] & NS_DOT) != (BYTE)0U)) {
      res = FR_INVALID_NAME;
    }
    if (res == FR_OK) {
      dir = dj.dir;
      if ((!dir) != 0U) {         /* Root directory */
   15a5c: 0afffff2  beq 15a2c <f_utime+0x48>
        res = FR_INVALID_NAME;
      } else {          /* File or sub-directory */
        ST_WORD(dir+DIR_WrtTime, fno->ftime);
   15a60: e1d420b6  ldrh  r2, [r4, #6]
        ST_WORD(dir+DIR_WrtDate, fno->fdate);
        dj.fs->wflag = 1U;
   15a64: e3a0c001  mov ip, #1
   15a68: e59d1014  ldr r1, [sp, #20]
    if (res == FR_OK) {
      dir = dj.dir;
      if ((!dir) != 0U) {         /* Root directory */
        res = FR_INVALID_NAME;
      } else {          /* File or sub-directory */
        ST_WORD(dir+DIR_WrtTime, fno->ftime);
   15a6c: e1c321b6  strh  r2, [r3, #22]
   15a70: e1d420b6  ldrh  r2, [r4, #6]
        ST_WORD(dir+DIR_WrtDate, fno->fdate);
        dj.fs->wflag = 1U;
        res = sync_fs(dj.fs);
   15a74: e1a00001  mov r0, r1
    if (res == FR_OK) {
      dir = dj.dir;
      if ((!dir) != 0U) {         /* Root directory */
        res = FR_INVALID_NAME;
      } else {          /* File or sub-directory */
        ST_WORD(dir+DIR_WrtTime, fno->ftime);
   15a78: e1a02422  lsr r2, r2, #8
   15a7c: e1c321b7  strh  r2, [r3, #23]
        ST_WORD(dir+DIR_WrtDate, fno->fdate);
   15a80: e1d420b4  ldrh  r2, [r4, #4]
   15a84: e1c321b8  strh  r2, [r3, #24]
   15a88: e1d420b4  ldrh  r2, [r4, #4]
   15a8c: e1a02422  lsr r2, r2, #8
   15a90: e1c321b9  strh  r2, [r3, #25]
        dj.fs->wflag = 1U;
   15a94: e5c1c004  strb  ip, [r1, #4]
        res = sync_fs(dj.fs);
   15a98: ebfff4f6  bl  12e78 <sync_fs>
      }
    }
  }

  LEAVE_FF(dj.fs, res);
}
   15a9c: e28dd030  add sp, sp, #48 ; 0x30
   15aa0: e8bd8010  pop {r4, pc}

00015aa4 <f_rename>:

FRESULT f_rename (
  const TCHAR* path_old,  /* Pointer to the object to be renamed */
  const TCHAR* path_new /* Pointer to the new name */
)
{
   15aa4: e52de004  push  {lr}    ; (str lr, [sp, #-4]!)
   15aa8: e24dd06c  sub sp, sp, #108  ; 0x6c
  DWORD dw;
  DEF_NAMEBUF;


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
   15aac: e3a02001  mov r2, #1
  const TCHAR* path_old,  /* Pointer to the object to be renamed */
  const TCHAR* path_new /* Pointer to the new name */
)
{
  FRESULT res;
  DIR djo = {0}, djn = {0};
   15ab0: e3a03000  mov r3, #0

FRESULT f_rename (
  const TCHAR* path_old,  /* Pointer to the object to be renamed */
  const TCHAR* path_new /* Pointer to the new name */
)
{
   15ab4: e58d0004  str r0, [sp, #4]
  DWORD dw;
  DEF_NAMEBUF;


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
   15ab8: e28d0030  add r0, sp, #48 ; 0x30

FRESULT f_rename (
  const TCHAR* path_old,  /* Pointer to the object to be renamed */
  const TCHAR* path_new /* Pointer to the new name */
)
{
   15abc: e58d1000  str r1, [sp]
  DWORD dw;
  DEF_NAMEBUF;


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
   15ac0: e28d1004  add r1, sp, #4
  const TCHAR* path_old,  /* Pointer to the object to be renamed */
  const TCHAR* path_new /* Pointer to the new name */
)
{
  FRESULT res;
  DIR djo = {0}, djn = {0};
   15ac4: e58d3030  str r3, [sp, #48] ; 0x30
   15ac8: e58d3034  str r3, [sp, #52] ; 0x34
   15acc: e58d3038  str r3, [sp, #56] ; 0x38
   15ad0: e58d303c  str r3, [sp, #60] ; 0x3c
   15ad4: e58d3040  str r3, [sp, #64] ; 0x40
   15ad8: e58d3044  str r3, [sp, #68] ; 0x44
   15adc: e58d3048  str r3, [sp, #72] ; 0x48
   15ae0: e58d304c  str r3, [sp, #76] ; 0x4c
   15ae4: e58d3050  str r3, [sp, #80] ; 0x50
   15ae8: e58d3054  str r3, [sp, #84] ; 0x54
   15aec: e58d3058  str r3, [sp, #88] ; 0x58
   15af0: e58d305c  str r3, [sp, #92] ; 0x5c
   15af4: e58d3060  str r3, [sp, #96] ; 0x60
   15af8: e58d3064  str r3, [sp, #100]  ; 0x64
  BYTE buf[21] = {0};
   15afc: e58d3018  str r3, [sp, #24]
   15b00: e58d301c  str r3, [sp, #28]
   15b04: e58d3020  str r3, [sp, #32]
   15b08: e58d3024  str r3, [sp, #36] ; 0x24
   15b0c: e58d3028  str r3, [sp, #40] ; 0x28
   15b10: e5cd302c  strb  r3, [sp, #44] ; 0x2c
  DWORD dw;
  DEF_NAMEBUF;


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
   15b14: ebfff56a  bl  130c4 <find_volume>
  if (res == FR_OK) {
   15b18: e3500000  cmp r0, #0
   15b1c: 0a000001  beq 15b28 <f_rename+0x84>
    }
    FREE_BUF();
  }

  LEAVE_FF(djo.fs, res);
}
   15b20: e28dd06c  add sp, sp, #108  ; 0x6c
   15b24: e49df004  pop {pc}    ; (ldr pc, [sp], #4)


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
  if (res == FR_OK) {
    djn.fs = djo.fs;
   15b28: e59d3030  ldr r3, [sp, #48] ; 0x30
    INIT_BUF(djo);
    res = follow_path(&djo, path_old);    /* Check old object */
   15b2c: e28d0030  add r0, sp, #48 ; 0x30
   15b30: e59d1004  ldr r1, [sp, #4]

  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
  if (res == FR_OK) {
    djn.fs = djo.fs;
    INIT_BUF(djo);
   15b34: e28d200c  add r2, sp, #12
   15b38: e58d2048  str r2, [sp, #72] ; 0x48


  /* Get logical drive number of the source object */
  res = find_volume(&djo.fs, &path_old, 1U);
  if (res == FR_OK) {
    djn.fs = djo.fs;
   15b3c: e58d304c  str r3, [sp, #76] ; 0x4c
    INIT_BUF(djo);
    res = follow_path(&djo, path_old);    /* Check old object */
   15b40: ebfff880  bl  13d48 <follow_path>
#if _FS_LOCK
    if (res == FR_OK) {
      res = chk_lock(&djo, 2);
    }
#endif
    if (res == FR_OK) {           /* Old object is found */
   15b44: e3500000  cmp r0, #0
   15b48: 1afffff4  bne 15b20 <f_rename+0x7c>
      if (djo.dir == NULL) {            /* Is root dir? */
   15b4c: e59d2044  ldr r2, [sp, #68] ; 0x44
   15b50: e3520000  cmp r2, #0
        res = FR_NO_FILE;
   15b54: 03a00004  moveq r0, #4
    if (res == FR_OK) {
      res = chk_lock(&djo, 2);
    }
#endif
    if (res == FR_OK) {           /* Old object is found */
      if (djo.dir == NULL) {            /* Is root dir? */
   15b58: 0afffff0  beq 15b20 <f_rename+0x7c>
   15b5c: e282200a  add r2, r2, #10
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
  BYTE *d = (BYTE*)(void *)dst;
   15b60: e28d3018  add r3, sp, #24
   15b64: e28d002d  add r0, sp, #45 ; 0x2d
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   15b68: e5f21001  ldrb  r1, [r2, #1]!
   15b6c: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   15b70: e1530000  cmp r3, r0
   15b74: 1afffffb  bne 15b68 <f_rename+0xc4>
   15b78: e28d202f  add r2, sp, #47 ; 0x2f
   15b7c: e28d304c  add r3, sp, #76 ; 0x4c
    *d=*s;
   15b80: e5f21001  ldrb  r1, [r2, #1]!
   15b84: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   15b88: e28d1068  add r1, sp, #104  ; 0x68
   15b8c: e1530001  cmp r3, r1
   15b90: 1afffffa  bne 15b80 <f_rename+0xdc>
      if (djo.dir == NULL) {            /* Is root dir? */
        res = FR_NO_FILE;
      } else {
        mem_cpy(buf, djo.dir+DIR_Attr, 21U);    /* Save the object information except name */
        mem_cpy(&djn, &djo, sizeof (DIR));    /* Duplicate the directory object */
        if (get_ldnumber(&path_new) >= 0) {   /* Snip drive number off and ignore it */
   15b94: e1a0000d  mov r0, sp
   15b98: ebfff432  bl  12c68 <get_ldnumber>
   15b9c: e3500000  cmp r0, #0
          res = follow_path(&djn, path_new);  /* and check if new object is exist */
        }
        else {
          res = FR_INVALID_DRIVE;
   15ba0: b3a0000b  movlt r0, #11
      if (djo.dir == NULL) {            /* Is root dir? */
        res = FR_NO_FILE;
      } else {
        mem_cpy(buf, djo.dir+DIR_Attr, 21U);    /* Save the object information except name */
        mem_cpy(&djn, &djo, sizeof (DIR));    /* Duplicate the directory object */
        if (get_ldnumber(&path_new) >= 0) {   /* Snip drive number off and ignore it */
   15ba4: baffffdd  blt 15b20 <f_rename+0x7c>
          res = follow_path(&djn, path_new);  /* and check if new object is exist */
   15ba8: e28d004c  add r0, sp, #76 ; 0x4c
   15bac: e59d1000  ldr r1, [sp]
   15bb0: ebfff864  bl  13d48 <follow_path>
        }
        else {
          res = FR_INVALID_DRIVE;
        }
        if (res == FR_OK) {
   15bb4: e3500000  cmp r0, #0
          res = FR_EXIST;   /* The new object name is already existing */
   15bb8: 03a00008  moveq r0, #8
          res = follow_path(&djn, path_new);  /* and check if new object is exist */
        }
        else {
          res = FR_INVALID_DRIVE;
        }
        if (res == FR_OK) {
   15bbc: 0affffd7  beq 15b20 <f_rename+0x7c>
          res = FR_EXIST;   /* The new object name is already existing */
        }
        if (res == FR_NO_FILE) {        /* Is it a valid path and no name collision? */
   15bc0: e3500004  cmp r0, #4
   15bc4: 1affffd5  bne 15b20 <f_rename+0x7c>
/* Start critical section that any interruption can cause a cross-link */
          res = dir_register(&djn);     /* Register the new entry */
   15bc8: e28d004c  add r0, sp, #76 ; 0x4c
   15bcc: ebfff974  bl  141a4 <dir_register>
          if (res == FR_OK) {
   15bd0: e3500000  cmp r0, #0
   15bd4: 1affffd1  bne 15b20 <f_rename+0x7c>
            dir = djn.dir;          /* Copy object information except name */
   15bd8: e59dc060  ldr ip, [sp, #96] ; 0x60
   15bdc: e28d2019  add r2, sp, #25
            mem_cpy(dir+13, buf+2, 19U);
   15be0: e28c300d  add r3, ip, #13
   15be4: e28c0020  add r0, ip, #32
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
    *d=*s;
   15be8: e5f21001  ldrb  r1, [r2, #1]!
   15bec: e4c31001  strb  r1, [r3], #1
    *(int*)d = *(int*)s;
    d += sizeof (int); s += sizeof (int);
    cnt -= sizeof (int);
  }
#endif
  while ((cnt) > 0U){
   15bf0: e1530000  cmp r3, r0
   15bf4: 1afffffb  bne 15be8 <f_rename+0x144>
          res = dir_register(&djn);     /* Register the new entry */
          if (res == FR_OK) {
            dir = djn.dir;          /* Copy object information except name */
            mem_cpy(dir+13, buf+2, 19U);
            (*(dir+DIR_Attr)) = buf[0] | AM_ARC;
            djo.fs->wflag = 1U;
   15bf8: e59d0030  ldr r0, [sp, #48] ; 0x30
   15bfc: e3a02001  mov r2, #1
/* Start critical section that any interruption can cause a cross-link */
          res = dir_register(&djn);     /* Register the new entry */
          if (res == FR_OK) {
            dir = djn.dir;          /* Copy object information except name */
            mem_cpy(dir+13, buf+2, 19U);
            (*(dir+DIR_Attr)) = buf[0] | AM_ARC;
   15c00: e5dd3018  ldrb  r3, [sp, #24]
   15c04: e3833020  orr r3, r3, #32
   15c08: e5cc300b  strb  r3, [ip, #11]
            djo.fs->wflag = 1U;
   15c0c: e5c02004  strb  r2, [r0, #4]
            if ((djo.sclust != djn.sclust) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) {   /* Update .. entry in the directory if needed */
   15c10: e59d2038  ldr r2, [sp, #56] ; 0x38
   15c14: e59d3054  ldr r3, [sp, #84] ; 0x54
   15c18: e1520003  cmp r2, r3
   15c1c: 0a00001b  beq 15c90 <f_rename+0x1ec>
   15c20: e5dc300b  ldrb  r3, [ip, #11]
   15c24: e3130010  tst r3, #16
   15c28: 0a000018  beq 15c90 <f_rename+0x1ec>
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
  if (fs->fs_type == FS_FAT32) {
   15c2c: e5d03000  ldrb  r3, [r0]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   15c30: e5dc201b  ldrb  r2, [ip, #27]
  if (fs->fs_type == FS_FAT32) {
   15c34: e3530003  cmp r3, #3
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   15c38: e5dc301a  ldrb  r3, [ip, #26]
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   15c3c: 05dc1015  ldrbeq  r1, [ip, #21]
  BYTE* dir /* Pointer to the directory entry */
)
{
  DWORD cl;

  cl = (DWORD)LD_WORD(dir+DIR_FstClusLO);
   15c40: e1833402  orr r3, r3, r2, lsl #8
  if (fs->fs_type == FS_FAT32) {
    cl |= (DWORD)(LD_WORD(dir+DIR_FstClusHI)) << 16;
   15c44: 05dc2014  ldrbeq  r2, [ip, #20]
   15c48: 01822401  orreq r2, r2, r1, lsl #8
   15c4c: 01833802  orreq r3, r3, r2, lsl #16
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
  if (LocalCluster >= (fs->n_fatent - 2)){
   15c50: e5902014  ldr r2, [r0, #20]
  DWORD clst    /* Cluster# to be converted */
)
{
  DWORD LocalCluster = clst;
  DWORD res;
  LocalCluster -= 2U;
   15c54: e2433002  sub r3, r3, #2
  if (LocalCluster >= (fs->n_fatent - 2)){
   15c58: e2422002  sub r2, r2, #2
   15c5c: e1530002  cmp r3, r2
   15c60: 2a000011  bcs 15cac <f_rename+0x208>
    res = ((DWORD)0U);    /* Invalid cluster# */
  }
  else {
    res = ((LocalCluster * fs->csize) + fs->database);
   15c64: e5d02002  ldrb  r2, [r0, #2]
   15c68: e5901028  ldr r1, [r0, #40] ; 0x28
            mem_cpy(dir+13, buf+2, 19U);
            (*(dir+DIR_Attr)) = buf[0] | AM_ARC;
            djo.fs->wflag = 1U;
            if ((djo.sclust != djn.sclust) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) {   /* Update .. entry in the directory if needed */
              dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
              if ((!dw) != 0U) {
   15c6c: e0311392  mlas  r1, r2, r3, r1
   15c70: 0a00000d  beq 15cac <f_rename+0x208>
                res = FR_INT_ERR;
              } else {
                res = move_window(djo.fs, dw);
   15c74: ebfff4cd  bl  12fb0 <move_window>
                dir = djo.fs->win+SZ_DIR; /* .. entry */
   15c78: e59d3030  ldr r3, [sp, #48] ; 0x30
                if ((res == FR_OK) && ((*(dir+1)) == ((BYTE)'.'))) {
   15c7c: e3500000  cmp r0, #0
   15c80: 1affffa6  bne 15b20 <f_rename+0x7c>
   15c84: e5d32061  ldrb  r2, [r3, #97] ; 0x61
   15c88: e352002e  cmp r2, #46 ; 0x2e
   15c8c: 0a000008  beq 15cb4 <f_rename+0x210>
                  djo.fs->wflag = 1U;
                }
              }
            }
            if (res == FR_OK) {
              res = dir_remove(&djo);   /* Remove old entry */
   15c90: e28d0030  add r0, sp, #48 ; 0x30
   15c94: ebfff6d6  bl  137f4 <dir_remove>
              if (res == FR_OK) {
   15c98: e3500000  cmp r0, #0
   15c9c: 1affff9f  bne 15b20 <f_rename+0x7c>
                res = sync_fs(djo.fs);
   15ca0: e59d0030  ldr r0, [sp, #48] ; 0x30
   15ca4: ebfff473  bl  12e78 <sync_fs>
   15ca8: eaffff9c  b 15b20 <f_rename+0x7c>
            (*(dir+DIR_Attr)) = buf[0] | AM_ARC;
            djo.fs->wflag = 1U;
            if ((djo.sclust != djn.sclust) && (((*(dir+DIR_Attr)) & AM_DIR) != (BYTE)0U)) {   /* Update .. entry in the directory if needed */
              dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
              if ((!dw) != 0U) {
                res = FR_INT_ERR;
   15cac: e3a00002  mov r0, #2
   15cb0: eaffff9a  b 15b20 <f_rename+0x7c>
              } else {
                res = move_window(djo.fs, dw);
                dir = djo.fs->win+SZ_DIR; /* .. entry */
                if ((res == FR_OK) && ((*(dir+1)) == ((BYTE)'.'))) {
                  dw = ((djo.fs->fs_type == FS_FAT32) && (djn.sclust == djo.fs->dirbase)) ? ((DWORD)0) : djn.sclust;
   15cb4: e5d32000  ldrb  r2, [r3]
   15cb8: e3520003  cmp r2, #3
   15cbc: 0a00000b  beq 15cf0 <f_rename+0x24c>
   15cc0: e59d0054  ldr r0, [sp, #84] ; 0x54
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15cc4: e6ff2070  uxth  r2, r0
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15cc8: e1a00820  lsr r0, r0, #16
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15ccc: e1c327ba  strh  r2, [r3, #122]  ; 0x7a
                res = move_window(djo.fs, dw);
                dir = djo.fs->win+SZ_DIR; /* .. entry */
                if ((res == FR_OK) && ((*(dir+1)) == ((BYTE)'.'))) {
                  dw = ((djo.fs->fs_type == FS_FAT32) && (djn.sclust == djo.fs->dirbase)) ? ((DWORD)0) : djn.sclust;
                  st_clust(dir, dw);
                  djo.fs->wflag = 1U;
   15cd0: e3a01001  mov r1, #1
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15cd4: e1c307b4  strh  r0, [r3, #116]  ; 0x74
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15cd8: e1a02422  lsr r2, r2, #8
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15cdc: e1a00420  lsr r0, r0, #8
void st_clust (
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
   15ce0: e1c327bb  strh  r2, [r3, #123]  ; 0x7b
                res = move_window(djo.fs, dw);
                dir = djo.fs->win+SZ_DIR; /* .. entry */
                if ((res == FR_OK) && ((*(dir+1)) == ((BYTE)'.'))) {
                  dw = ((djo.fs->fs_type == FS_FAT32) && (djn.sclust == djo.fs->dirbase)) ? ((DWORD)0) : djn.sclust;
                  st_clust(dir, dw);
                  djo.fs->wflag = 1U;
   15ce4: e5c31004  strb  r1, [r3, #4]
  BYTE* dir,  /* Pointer to the directory entry */
  DWORD cl  /* Value to be set */
)
{
  ST_WORD(dir+DIR_FstClusLO, cl);
  ST_WORD(dir+DIR_FstClusHI, cl >> 16);
   15ce8: e1c307b5  strh  r0, [r3, #117]  ; 0x75
   15cec: eaffffe7  b 15c90 <f_rename+0x1ec>
                res = FR_INT_ERR;
              } else {
                res = move_window(djo.fs, dw);
                dir = djo.fs->win+SZ_DIR; /* .. entry */
                if ((res == FR_OK) && ((*(dir+1)) == ((BYTE)'.'))) {
                  dw = ((djo.fs->fs_type == FS_FAT32) && (djn.sclust == djo.fs->dirbase)) ? ((DWORD)0) : djn.sclust;
   15cf0: e59d1054  ldr r1, [sp, #84] ; 0x54
   15cf4: e5932024  ldr r2, [r3, #36] ; 0x24
   15cf8: e1510002  cmp r1, r2
   15cfc: 1affffef  bne 15cc0 <f_rename+0x21c>
   15d00: eaffffef  b 15cc4 <f_rename+0x220>

00015d04 <disk_status>:
*
******************************************************************************/
DSTATUS disk_status (
    BYTE pdrv /* Drive number (0) */
)
{
   15d04: e92d4038  push  {r3, r4, r5, lr}
  DSTATUS s = Stat;
  u32 StatusReg;

#ifdef FILE_SYSTEM_INTERFACE_SD
    StatusReg = XSdPs_GetPresentStatusReg((u32)XPAR_XSDPS_0_BASEADDR);
   15d08: e3a00024  mov r0, #36 ; 0x24
******************************************************************************/
DSTATUS disk_status (
    BYTE pdrv /* Drive number (0) */
)
{
  DSTATUS s = Stat;
   15d0c: e3014580  movw  r4, #5504 ; 0x1580
  u32 StatusReg;

#ifdef FILE_SYSTEM_INTERFACE_SD
    StatusReg = XSdPs_GetPresentStatusReg((u32)XPAR_XSDPS_0_BASEADDR);
   15d10: e34e0010  movt  r0, #57360  ; 0xe010
******************************************************************************/
DSTATUS disk_status (
    BYTE pdrv /* Drive number (0) */
)
{
  DSTATUS s = Stat;
   15d14: e3404002  movt  r4, #2
   15d18: e5d45000  ldrb  r5, [r4]
  u32 StatusReg;

#ifdef FILE_SYSTEM_INTERFACE_SD
    StatusReg = XSdPs_GetPresentStatusReg((u32)XPAR_XSDPS_0_BASEADDR);
   15d1c: ebffc11d  bl  6198 <Xil_In32>
#if XPAR_XSDPS_0_HAS_CD
    if ((StatusReg & XSDPS_PSR_CARD_INSRT_MASK) == 0U) {
   15d20: e3100801  tst r0, #65536  ; 0x10000
        s = STA_NODISK | STA_NOINIT;
   15d24: 03a00003  moveq r0, #3
  u32 StatusReg;

#ifdef FILE_SYSTEM_INTERFACE_SD
    StatusReg = XSdPs_GetPresentStatusReg((u32)XPAR_XSDPS_0_BASEADDR);
#if XPAR_XSDPS_0_HAS_CD
    if ((StatusReg & XSDPS_PSR_CARD_INSRT_MASK) == 0U) {
   15d28: 1a000001  bne 15d34 <disk_status+0x30>
    }
#endif
    s &= ~STA_PROTECT;

Label:
    Stat = s;
   15d2c: e5c40000  strb  r0, [r4]
#endif
    return s;
}
   15d30: e8bd8038  pop {r3, r4, r5, pc}
        goto Label;
    }
#endif
    s &= ~STA_NODISK;
#if XPAR_XSDPS_0_HAS_WP
    if ((StatusReg & XSDPS_PSR_WPS_PL_MASK) == 0U){
   15d34: e3100702  tst r0, #524288 ; 0x80000
    if ((StatusReg & XSDPS_PSR_CARD_INSRT_MASK) == 0U) {
        s = STA_NODISK | STA_NOINIT;
        goto Label;
    }
#endif
    s &= ~STA_NODISK;
   15d38: 020500fd  andeq r0, r5, #253  ; 0xfd
    if ((StatusReg & XSDPS_PSR_WPS_PL_MASK) == 0U){
      s |= STA_PROTECT;
      goto Label;
    }
#endif
    s &= ~STA_PROTECT;
   15d3c: 120500f9  andne r0, r5, #249  ; 0xf9
    }
#endif
    s &= ~STA_NODISK;
#if XPAR_XSDPS_0_HAS_WP
    if ((StatusReg & XSDPS_PSR_WPS_PL_MASK) == 0U){
      s |= STA_PROTECT;
   15d40: 03800004  orreq r0, r0, #4
    }
#endif
    s &= ~STA_PROTECT;

Label:
    Stat = s;
   15d44: e5c40000  strb  r0, [r4]
#endif
    return s;
}
   15d48: e8bd8038  pop {r3, r4, r5, pc}

00015d4c <disk_initialize>:
*
******************************************************************************/
DSTATUS disk_initialize (
    BYTE pdrv /* Physical drive number (0) */
)
{
   15d4c: e92d4030  push  {r4, r5, lr}
  DSTATUS s;
  s32 Status;
  u8 SCR[8] = {0U};
   15d50: e3a03000  mov r3, #0
*
******************************************************************************/
DSTATUS disk_initialize (
    BYTE pdrv /* Physical drive number (0) */
)
{
   15d54: e24dd04c  sub sp, sp, #76 ; 0x4c
   15d58: e1a04000  mov r4, r0
  DSTATUS s;
  s32 Status;
  u8 SCR[8] = {0U};
  u8 ReadBuff[64] = {0U};
   15d5c: e1a01003  mov r1, r3
   15d60: e3a02040  mov r2, #64 ; 0x40
   15d64: e28d0008  add r0, sp, #8
    BYTE pdrv /* Physical drive number (0) */
)
{
  DSTATUS s;
  s32 Status;
  u8 SCR[8] = {0U};
   15d68: e58d3000  str r3, [sp]
   15d6c: e58d3004  str r3, [sp, #4]
  u8 ReadBuff[64] = {0U};
   15d70: ebffe342  bl  ea80 <memset>
  XSdPs_Config *SdConfig;

  /*
   * Check if card is in the socket
   */
  s = disk_status(pdrv);
   15d74: e1a00004  mov r0, r4
   15d78: ebffffe1  bl  15d04 <disk_status>
   15d7c: e1a04000  mov r4, r0
  if ((s & STA_NODISK) != 0U) {
   15d80: e2000002  and r0, r0, #2
   15d84: e21000ff  ands  r0, r0, #255  ; 0xff
   15d88: 11a00004  movne r0, r4
   15d8c: 0a000001  beq 15d98 <disk_initialize+0x4c>
  Stat = s;

#endif

  return s;
}
   15d90: e28dd04c  add sp, sp, #76 ; 0x4c
   15d94: e8bd8030  pop {r4, r5, pc}
  }

  /*
   * Initialize the host controller
   */
  SdConfig = XSdPs_LookupConfig((u16)SD_DEVICE_ID);
   15d98: eb000091  bl  15fe4 <XSdPs_LookupConfig>
  if (NULL == SdConfig) {
   15d9c: e2501000  subs  r1, r0, #0
   15da0: 0a000008  beq 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  Stat = STA_NOINIT;
   15da4: e3015580  movw  r5, #5504 ; 0x1580
   15da8: e3a03001  mov r3, #1
   15dac: e3405002  movt  r5, #2
  Status = XSdPs_CfgInitialize(&SdInstance, SdConfig,
   15db0: e5912004  ldr r2, [r1, #4]
  if (NULL == SdConfig) {
    s |= STA_NOINIT;
    return s;
  }

  Stat = STA_NOINIT;
   15db4: e1a00005  mov r0, r5
   15db8: e4c03020  strb  r3, [r0], #32
  Status = XSdPs_CfgInitialize(&SdInstance, SdConfig,
   15dbc: eb00008f  bl  16000 <XSdPs_CfgInitialize>
          SdConfig->BaseAddress);
  if (Status != XST_SUCCESS) {
   15dc0: e3500000  cmp r0, #0
   15dc4: 0a000003  beq 15dd8 <disk_initialize+0x8c>
    }
  }

  Status = XSdPs_SetBlkSize(&SdInstance, (u16)XSDPS_BLK_SIZE_512_MASK);
  if (Status != XST_SUCCESS) {
    s |= STA_NOINIT;
   15dc8: e3844001  orr r4, r4, #1
   15dcc: e6ef0074  uxtb  r0, r4
  Stat = s;

#endif

  return s;
}
   15dd0: e28dd04c  add sp, sp, #76 ; 0x4c
   15dd4: e8bd8030  pop {r4, r5, pc}
    s |= STA_NOINIT;
    return s;
  }

#ifndef MMC_CARD
  Status = XSdPs_SdCardInitialize(&SdInstance);
   15dd8: e2850020  add r0, r5, #32
   15ddc: eb00019b  bl  16450 <XSdPs_SdCardInitialize>
  if (Status != XST_SUCCESS) {
   15de0: e3500000  cmp r0, #0
   15de4: 1afffff7  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  Status = XSdPs_Change_ClkFreq(&SdInstance, SD_CLK_25_MHZ);
   15de8: e3071840  movw  r1, #30784  ; 0x7840
   15dec: e2850020  add r0, r5, #32
   15df0: e340117d  movt  r1, #381  ; 0x17d
   15df4: eb00048f  bl  17038 <XSdPs_Change_ClkFreq>
  if (Status != XST_SUCCESS) {
   15df8: e3500000  cmp r0, #0
   15dfc: 1afffff1  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  Status = XSdPs_Select_Card(&SdInstance);
   15e00: e2850020  add r0, r5, #32
   15e04: eb000223  bl  16698 <XSdPs_Select_Card>
  if (Status != XST_SUCCESS) {
   15e08: e3500000  cmp r0, #0
   15e0c: 1affffed  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  Status = XSdPs_Get_BusWidth(&SdInstance, SCR);
   15e10: e2850020  add r0, r5, #32
   15e14: e1a0100d  mov r1, sp
   15e18: eb00039c  bl  16c90 <XSdPs_Get_BusWidth>
  if (Status != XST_SUCCESS) {
   15e1c: e3500000  cmp r0, #0
   15e20: 1affffe8  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  Status = XSdPs_Get_BusSpeed(&SdInstance, ReadBuff);
   15e24: e28d1008  add r1, sp, #8
   15e28: e2850020  add r0, r5, #32
   15e2c: eb00042b  bl  16ee0 <XSdPs_Get_BusSpeed>
  if (Status != XST_SUCCESS) {
   15e30: e3500000  cmp r0, #0
   15e34: 1affffe3  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  if((ReadBuff[13] & HIGH_SPEED_SUPPORT) != 0U){
   15e38: e5dd3015  ldrb  r3, [sp, #21]
   15e3c: e3130001  tst r3, #1
   15e40: 0a000003  beq 15e54 <disk_initialize+0x108>
    Status = XSdPs_Change_BusSpeed(&SdInstance);
   15e44: e2850020  add r0, r5, #32
   15e48: eb0004cb  bl  1717c <XSdPs_Change_BusSpeed>
    if (Status != XST_SUCCESS) {
   15e4c: e3500000  cmp r0, #0
   15e50: 1affffdc  bne 15dc8 <disk_initialize+0x7c>
      s |= STA_NOINIT;
      return s;
    }
  }

  Status = XSdPs_Pullup(&SdInstance);
   15e54: e59f0050  ldr r0, [pc, #80] ; 15eac <disk_initialize+0x160>
   15e58: eb000526  bl  172f8 <XSdPs_Pullup>
  if (Status != XST_SUCCESS) {
   15e5c: e3500000  cmp r0, #0
   15e60: 1affffd8  bne 15dc8 <disk_initialize+0x7c>
    s |= STA_NOINIT;
    return s;
  }

  if ((SCR[1] & WIDTH_4_BIT_SUPPORT) != 0U) {
   15e64: e5dd3001  ldrb  r3, [sp, #1]
   15e68: e3130004  tst r3, #4
   15e6c: 0a000003  beq 15e80 <disk_initialize+0x134>
    Status = XSdPs_Change_BusWidth(&SdInstance);
   15e70: e59f0034  ldr r0, [pc, #52] ; 15eac <disk_initialize+0x160>
   15e74: eb0003e0  bl  16dfc <XSdPs_Change_BusWidth>
    if (Status != XST_SUCCESS) {
   15e78: e3500000  cmp r0, #0
   15e7c: 1affffd1  bne 15dc8 <disk_initialize+0x7c>
      s |= STA_NOINIT;
      return s;
    }
  }

  Status = XSdPs_SetBlkSize(&SdInstance, (u16)XSDPS_BLK_SIZE_512_MASK);
   15e80: e3015580  movw  r5, #5504 ; 0x1580
   15e84: e3a01c02  mov r1, #512  ; 0x200
   15e88: e3405002  movt  r5, #2
   15e8c: e2850020  add r0, r5, #32
   15e90: eb000346  bl  16bb0 <XSdPs_SetBlkSize>
  if (Status != XST_SUCCESS) {
   15e94: e3500000  cmp r0, #0
   15e98: 1affffca  bne 15dc8 <disk_initialize+0x7c>

  /*
   * Disk is initialized.
   * Store the same in Stat.
   */
  s &= (~STA_NOINIT);
   15e9c: e20440fe  and r4, r4, #254  ; 0xfe

  Stat = s;
   15ea0: e5c54000  strb  r4, [r5]

#endif

  return s;
   15ea4: e1a00004  mov r0, r4
   15ea8: eaffffb8  b 15d90 <disk_initialize+0x44>
   15eac: 000215a0  .word 0x000215a0

00015eb0 <disk_read>:
    BYTE pdrv,  /* Physical drive number (0) */
    BYTE *buff, /* Pointer to the data buffer to store read data */
    DWORD sector, /* Start sector number (LBA) */
    UINT count  /* Sector count (1..128) */
)
{
   15eb0: e92d4070  push  {r4, r5, r6, lr}
   15eb4: e1a06001  mov r6, r1
   15eb8: e1a05002  mov r5, r2
   15ebc: e1a04003  mov r4, r3
#ifdef FILE_SYSTEM_INTERFACE_SD
  DSTATUS s;
  s32 Status;
  DWORD LocSector = sector;

  s = disk_status(pdrv);
   15ec0: ebffff8f  bl  15d04 <disk_status>

  if ((s & STA_NOINIT) != 0U) {
   15ec4: e3100001  tst r0, #1
   15ec8: 0a000001  beq 15ed4 <disk_read+0x24>
    return RES_NOTRDY;
   15ecc: e3a00003  mov r0, #3
   15ed0: e8bd8070  pop {r4, r5, r6, pc}
  }
  if (count == 0U) {
   15ed4: e3540000  cmp r4, #0
   15ed8: 1a000001  bne 15ee4 <disk_read+0x34>
    return RES_PARERR;
   15edc: e3a00004  mov r0, #4
    return RES_ERROR;
  }

#endif
    return RES_OK;
}
   15ee0: e8bd8070  pop {r4, r5, r6, pc}
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15ee4: e3013580  movw  r3, #5504 ; 0x1580
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_ReadPolled(&SdInstance, (u32)LocSector, count, buff);
   15ee8: e1a02004  mov r2, r4
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15eec: e3403002  movt  r3, #2
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_ReadPolled(&SdInstance, (u32)LocSector, count, buff);
   15ef0: e59f0020  ldr r0, [pc, #32] ; 15f18 <disk_read+0x68>
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15ef4: e593303c  ldr r3, [r3, #60] ; 0x3c
   15ef8: e3530000  cmp r3, #0
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_ReadPolled(&SdInstance, (u32)LocSector, count, buff);
   15efc: e1a03006  mov r3, r6
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
   15f00: 01a05485  lsleq r5, r5, #9
  }

  Status  = XSdPs_ReadPolled(&SdInstance, (u32)LocSector, count, buff);
   15f04: e1a01005  mov r1, r5
   15f08: eb000227  bl  167ac <XSdPs_ReadPolled>
  DWORD LocSector = sector;

  s = disk_status(pdrv);

  if ((s & STA_NOINIT) != 0U) {
    return RES_NOTRDY;
   15f0c: e2900000  adds  r0, r0, #0
   15f10: 13a00001  movne r0, #1
   15f14: e8bd8070  pop {r4, r5, r6, pc}
   15f18: 000215a0  .word 0x000215a0

00015f1c <disk_ioctl>:
DRESULT disk_ioctl (
  BYTE pdrv,        /* Physical drive number (0) */
  BYTE cmd,       /* Control code */
  void *buff        /* Buffer to send/receive control data */
)
{
   15f1c: e92d4038  push  {r3, r4, r5, lr}
   15f20: e1a04001  mov r4, r1
   15f24: e1a05002  mov r5, r2
#ifdef FILE_SYSTEM_INTERFACE_SD
  DRESULT res;
  void *LocBuff = buff;
  if ((disk_status(pdrv) & STA_NOINIT) != 0U) { /* Check if card is in the socket */
   15f28: ebffff75  bl  15d04 <disk_status>
   15f2c: e2100001  ands  r0, r0, #1
   15f30: 0a000001  beq 15f3c <disk_ioctl+0x20>
    return RES_NOTRDY;
   15f34: e3a00003  mov r0, #3

    return res;
#else
    return 0;
#endif
}
   15f38: e8bd8038  pop {r3, r4, r5, pc}
  if ((disk_status(pdrv) & STA_NOINIT) != 0U) { /* Check if card is in the socket */
    return RES_NOTRDY;
  }

  res = RES_ERROR;
  switch (cmd) {
   15f3c: e3540001  cmp r4, #1
   15f40: 0a000005  beq 15f5c <disk_ioctl+0x40>
   15f44: 38bd8038  popcc {r3, r4, r5, pc}
   15f48: e3540003  cmp r4, #3
   15f4c: 1a000004  bne 15f64 <disk_ioctl+0x48>
    case (BYTE)GET_SECTOR_COUNT : /* Get number of sectors on the disk (DWORD) */
      res = RES_ERROR;
      break;

    case (BYTE)GET_BLOCK_SIZE : /* Get erase block size in unit of sector (DWORD) */
      (*((DWORD *)((void *)LocBuff))) = ((DWORD)128);
   15f50: e3a03080  mov r3, #128  ; 0x80
   15f54: e5853000  str r3, [r5]
      res = RES_OK;
      break;
   15f58: e8bd8038  pop {r3, r4, r5, pc}
    case (BYTE)CTRL_SYNC :  /* Make sure that no pending write process */
      res = RES_OK;
      break;

    case (BYTE)GET_SECTOR_COUNT : /* Get number of sectors on the disk (DWORD) */
      res = RES_ERROR;
   15f5c: e1a00004  mov r0, r4
   15f60: e8bd8038  pop {r3, r4, r5, pc}
      (*((DWORD *)((void *)LocBuff))) = ((DWORD)128);
      res = RES_OK;
      break;

    default:
      res = RES_PARERR;
   15f64: e3a00004  mov r0, #4
      break;
   15f68: e8bd8038  pop {r3, r4, r5, pc}

00015f6c <get_fattime>:
    | ((DWORD)1 << 21)
    | ((DWORD)1 << 16)
    | ((DWORD)0 << 11)
    | ((DWORD)0 << 5)
    | ((DWORD)0 >> 1);
}
   15f6c: e3a00000  mov r0, #0
   15f70: e3430c21  movt  r0, #15393  ; 0x3c21
   15f74: e12fff1e  bx  lr

00015f78 <disk_write>:
  BYTE pdrv,      /* Physical drive nmuber (0..) */
  const BYTE *buff, /* Data to be written */
  DWORD sector,   /* Sector address (LBA) */
  UINT count      /* Number of sectors to write (1..128) */
)
{
   15f78: e92d4070  push  {r4, r5, r6, lr}
   15f7c: e1a06001  mov r6, r1
   15f80: e1a05002  mov r5, r2
   15f84: e1a04003  mov r4, r3
  DSTATUS s;
  s32 Status;
  DWORD LocSector = sector;

#ifdef FILE_SYSTEM_INTERFACE_SD
  s = disk_status(pdrv);
   15f88: ebffff5d  bl  15d04 <disk_status>

  if ((s & STA_NOINIT) != 0U) {
   15f8c: e3100001  tst r0, #1
   15f90: 0a000001  beq 15f9c <disk_write+0x24>
    return RES_NOTRDY;
   15f94: e3a00003  mov r0, #3
   15f98: e8bd8070  pop {r4, r5, r6, pc}
  }
  if (count == 0U) {
   15f9c: e3540000  cmp r4, #0
   15fa0: 1a000001  bne 15fac <disk_write+0x34>
    return RES_PARERR;
   15fa4: e3a00004  mov r0, #4
    return RES_ERROR;
  }

#endif
  return RES_OK;
}
   15fa8: e8bd8070  pop {r4, r5, r6, pc}
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15fac: e3013580  movw  r3, #5504 ; 0x1580
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_WritePolled(&SdInstance, (u32)LocSector, count, buff);
   15fb0: e1a02004  mov r2, r4
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15fb4: e3403002  movt  r3, #2
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_WritePolled(&SdInstance, (u32)LocSector, count, buff);
   15fb8: e59f0020  ldr r0, [pc, #32] ; 15fe0 <disk_write+0x68>
  if (count == 0U) {
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
   15fbc: e593303c  ldr r3, [r3, #60] ; 0x3c
   15fc0: e3530000  cmp r3, #0
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
  }

  Status  = XSdPs_WritePolled(&SdInstance, (u32)LocSector, count, buff);
   15fc4: e1a03006  mov r3, r6
    return RES_PARERR;
  }

  /* Convert LBA to byte address if needed */
  if ((SdInstance.HCS) == 0U) {
    LocSector *= (DWORD)XSDPS_BLK_SIZE_512_MASK;
   15fc8: 01a05485  lsleq r5, r5, #9
  }

  Status  = XSdPs_WritePolled(&SdInstance, (u32)LocSector, count, buff);
   15fcc: e1a01005  mov r1, r5
   15fd0: eb000238  bl  168b8 <XSdPs_WritePolled>

#ifdef FILE_SYSTEM_INTERFACE_SD
  s = disk_status(pdrv);

  if ((s & STA_NOINIT) != 0U) {
    return RES_NOTRDY;
   15fd4: e2900000  adds  r0, r0, #0
   15fd8: 13a00001  movne r0, #1
   15fdc: e8bd8070  pop {r4, r5, r6, pc}
   15fe0: 000215a0  .word 0x000215a0

00015fe4 <XSdPs_LookupConfig>:
{
  XSdPs_Config *CfgPtr = NULL;
  int Index;

  for (Index = 0; Index < XPAR_XSDPS_NUM_INSTANCES; Index++) {
    if (XSdPs_ConfigTable[Index].DeviceId == DeviceId) {
   15fe4: e30b3c50  movw  r3, #48208  ; 0xbc50
   15fe8: e3403001  movt  r3, #1
   15fec: e1d320b0  ldrh  r2, [r3]
      CfgPtr = &XSdPs_ConfigTable[Index];
      break;
    }
  }
  return CfgPtr;
}
   15ff0: e1520000  cmp r2, r0
   15ff4: 01a00003  moveq r0, r3
   15ff8: 13a00000  movne r0, #0
   15ffc: e12fff1e  bx  lr

00016000 <XSdPs_CfgInitialize>:
*   32 bit ADMA2 is selected. Defualt Block size is 512 bytes.
*
******************************************************************************/
int XSdPs_CfgInitialize(XSdPs *InstancePtr, XSdPs_Config *ConfigPtr,
        u32 EffectiveAddr)
{
   16000: e92d4070  push  {r4, r5, r6, lr}
  u32 ClockReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16004: e2504000  subs  r4, r0, #0
   16008: 0a00004f  beq 1614c <XSdPs_CfgInitialize+0x14c>
  Xil_AssertNonvoid(ConfigPtr != NULL);
   1600c: e3510000  cmp r1, #0
        u32 EffectiveAddr)
{
  u32 ClockReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16010: e3026ae8  movw  r6, #10984  ; 0x2ae8
   16014: e3406002  movt  r6, #2
   16018: e1a03001  mov r3, r1
   1601c: e3a01000  mov r1, #0
   16020: e5861000  str r1, [r6]
  Xil_AssertNonvoid(ConfigPtr != NULL);
   16024: 0a000040  beq 1612c <XSdPs_CfgInitialize+0x12c>

  /*
   * Set some default values.
   */
  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->Config.InputClockHz = ConfigPtr->InputClockHz;
   16028: e5935008  ldr r5, [r3, #8]
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
   1602c: e301c111  movw  ip, #4369 ; 0x1111
  InstancePtr->Config.CardDetect =  ConfigPtr->CardDetect;
   16030: e593e00c  ldr lr, [r3, #12]
  /*
   * Set some default values.
   */
  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->Config.InputClockHz = ConfigPtr->InputClockHz;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
   16034: e7dfc81c  bfi ip, ip, #16, #16
  InstancePtr->Config.CardDetect =  ConfigPtr->CardDetect;
  InstancePtr->Config.WriteProtect =  ConfigPtr->WriteProtect;
   16038: e5933010  ldr r3, [r3, #16]

  /*
   * "Software reset for all" is initiated
   */
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress, XSDPS_SW_RST_OFFSET,
   1603c: e282002f  add r0, r2, #47 ; 0x2f
  Xil_AssertNonvoid(ConfigPtr != NULL);

  /*
   * Set some default values.
   */
  InstancePtr->Config.BaseAddress = EffectiveAddr;
   16040: e5842004  str r2, [r4, #4]
  InstancePtr->Config.WriteProtect =  ConfigPtr->WriteProtect;

  /*
   * "Software reset for all" is initiated
   */
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress, XSDPS_SW_RST_OFFSET,
   16044: e3a01001  mov r1, #1
  /*
   * Set some default values.
   */
  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->Config.InputClockHz = ConfigPtr->InputClockHz;
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
   16048: e584c014  str ip, [r4, #20]

  /*
   * Set some default values.
   */
  InstancePtr->Config.BaseAddress = EffectiveAddr;
  InstancePtr->Config.InputClockHz = ConfigPtr->InputClockHz;
   1604c: e5845008  str r5, [r4, #8]
  InstancePtr->IsReady = XIL_COMPONENT_IS_READY;
  InstancePtr->Config.CardDetect =  ConfigPtr->CardDetect;
   16050: e584e00c  str lr, [r4, #12]
  InstancePtr->Config.WriteProtect =  ConfigPtr->WriteProtect;
   16054: e5843010  str r3, [r4, #16]

  /*
   * "Software reset for all" is initiated
   */
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress, XSDPS_SW_RST_OFFSET,
   16058: ebffc050  bl  61a0 <Xil_Out8>
      XSDPS_SWRST_ALL_MASK);

  /*
   * Proceed with initialization only after reset is complete
   */
  while (XSdPs_ReadReg8(InstancePtr->Config.BaseAddress,
   1605c: e5940004  ldr r0, [r4, #4]
   16060: e280002f  add r0, r0, #47 ; 0x2f
   16064: ebffc047  bl  6188 <Xil_In8>
   16068: e3100001  tst r0, #1
   1606c: 1afffffa  bne 1605c <XSdPs_CfgInitialize+0x5c>

  /*
   * Read capabilities register and update it in Instance pointer.
   * It is sufficient to read this once on power on.
   */
  InstancePtr->Host_Caps = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16070: e5940004  ldr r0, [r4, #4]
   16074: e2800040  add r0, r0, #64 ; 0x40
   16078: ebffc046  bl  6198 <Xil_In32>
            XSDPS_CAPS_OFFSET);

  /*
   * Select voltage and enable bus power.
   */
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   1607c: e5943004  ldr r3, [r4, #4]
   16080: e3a0100f  mov r1, #15

  /*
   * Read capabilities register and update it in Instance pointer.
   * It is sufficient to read this once on power on.
   */
  InstancePtr->Host_Caps = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16084: e5840018  str r0, [r4, #24]
            XSDPS_CAPS_OFFSET);

  /*
   * Select voltage and enable bus power.
   */
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   16088: e2830029  add r0, r3, #41 ; 0x29
   1608c: ebffc043  bl  61a0 <Xil_Out8>
      XSDPS_PC_BUS_VSEL_3V3_MASK | XSDPS_PC_BUS_PWR_MASK);

  /*
   * Change the clock frequency to 400 KHz
   */
  Status = XSdPs_Change_ClkFreq(InstancePtr, XSDPS_CLK_400_KHZ);
   16090: e3a01d6a  mov r1, #6784 ; 0x1a80
   16094: e1a00004  mov r0, r4
   16098: e3401006  movt  r1, #6
   1609c: eb0003e5  bl  17038 <XSdPs_Change_ClkFreq>
  if (Status != XST_SUCCESS) {
   160a0: e2505000  subs  r5, r0, #0
   160a4: 13a05001  movne r5, #1
   160a8: 0a000001  beq 160b4 <XSdPs_CfgInitialize+0xb4>
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   160ac: e1a00005  mov r0, r5
   160b0: e8bd8070  pop {r4, r5, r6, pc}
  if (Status != XST_SUCCESS) {
    Status = XST_FAILURE;
    goto RETURN_PATH ;
  }

  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   160b4: e5940004  ldr r0, [r4, #4]
   160b8: e3a01010  mov r1, #16
   160bc: e2800028  add r0, r0, #40 ; 0x28
   160c0: ebffc036  bl  61a0 <Xil_Out8>
      XSDPS_HC_DMA_ADMA2_32_MASK);

  /*
   * Enable all interrupt status except card interrupt initially
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   160c4: e5940004  ldr r0, [r4, #4]
   160c8: e30f1eff  movw  r1, #65279  ; 0xfeff
   160cc: e2800034  add r0, r0, #52 ; 0x34
   160d0: ebffc034  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_EN_OFFSET,
      XSDPS_NORM_INTR_ALL_MASK & (~XSDPS_INTR_CARD_MASK));

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   160d4: e5940004  ldr r0, [r4, #4]
   160d8: e30f13ff  movw  r1, #62463  ; 0xf3ff
   160dc: e2800036  add r0, r0, #54 ; 0x36
   160e0: ebffc030  bl  61a8 <Xil_Out16>
      XSDPS_ERROR_INTR_ALL_MASK);

  /*
   * Disable all interrupt signals by default.
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   160e4: e5940004  ldr r0, [r4, #4]
   160e8: e1a01005  mov r1, r5
   160ec: e2800038  add r0, r0, #56 ; 0x38
   160f0: ebffc02c  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_SIG_EN_OFFSET, 0x0);
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   160f4: e5940004  ldr r0, [r4, #4]
   160f8: e1a01005  mov r1, r5
   160fc: e280003a  add r0, r0, #58 ; 0x3a
   16100: ebffc028  bl  61a8 <Xil_Out16>

  /*
   * Transfer mode register - default value
   * DMA enabled, block count enabled, data direction card to host(read)
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16104: e5940004  ldr r0, [r4, #4]
   16108: e3a01013  mov r1, #19
   1610c: e280000c  add r0, r0, #12
   16110: ebffc024  bl  61a8 <Xil_Out16>
      XSDPS_TM_DAT_DIR_SEL_MASK);

  /*
   * Set block size to 512 by default
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16114: e5940004  ldr r0, [r4, #4]
   16118: e3a01c02  mov r1, #512  ; 0x200
   1611c: e2800004  add r0, r0, #4
   16120: ebffc020  bl  61a8 <Xil_Out16>
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   16124: e1a00005  mov r0, r5
   16128: e8bd8070  pop {r4, r5, r6, pc}
{
  u32 ClockReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(ConfigPtr != NULL);
   1612c: e3080798  movw  r0, #34712  ; 0x8798
   16130: e3a0108b  mov r1, #139  ; 0x8b
   16134: e3400001  movt  r0, #1
   16138: e1a05003  mov r5, r3
   1613c: ebffcbd3  bl  9090 <Xil_Assert>
   16140: e3a03001  mov r3, #1
   16144: e5863000  str r3, [r6]
   16148: eaffffd7  b 160ac <XSdPs_CfgInitialize+0xac>
        u32 EffectiveAddr)
{
  u32 ClockReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   1614c: e3080798  movw  r0, #34712  ; 0x8798
   16150: e3a0108a  mov r1, #138  ; 0x8a
   16154: e3400001  movt  r0, #1
   16158: e1a05004  mov r5, r4
   1615c: ebffcbcb  bl  9090 <Xil_Assert>
   16160: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16164: e3403002  movt  r3, #2
   16168: e3a02001  mov r2, #1
   1616c: e5832000  str r2, [r3]
   16170: eaffffcd  b 160ac <XSdPs_CfgInitialize+0xac>

00016174 <XSdPs_FrameCmd>:
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   16174: e3500c11  cmp r0, #4352 ; 0x1100
   16178: 0a000034  beq 16250 <XSdPs_FrameCmd+0xdc>
   1617c: 8a00000b  bhi 161b0 <XSdPs_FrameCmd+0x3c>
   16180: e3500c07  cmp r0, #1792 ; 0x700
   16184: 0a000021  beq 16210 <XSdPs_FrameCmd+0x9c>
   16188: 8a000022  bhi 16218 <XSdPs_FrameCmd+0xa4>
   1618c: e3500c03  cmp r0, #768  ; 0x300
   16190: 0a000032  beq 16260 <XSdPs_FrameCmd+0xec>
   16194: 8a000013  bhi 161e8 <XSdPs_FrameCmd+0x74>
   16198: e3500c01  cmp r0, #256  ; 0x100
   1619c: 0a000037  beq 16280 <XSdPs_FrameCmd+0x10c>
    break;
    case CMD1:
      RetVal |= RESP_R3;
    break;
    case CMD2:
      RetVal |= RESP_R2;
   161a0: e3500c02  cmp r0, #512  ; 0x200
   161a4: e3003209  movw  r3, #521  ; 0x209
   161a8: 01a00003  moveq r0, r3
   161ac: e12fff1e  bx  lr
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   161b0: e3500c37  cmp r0, #14080  ; 0x3700
   161b4: 0a000027  beq 16258 <XSdPs_FrameCmd+0xe4>
   161b8: 9a00001f  bls 1623c <XSdPs_FrameCmd+0xc8>
   161bc: e3500c97  cmp r0, #38656  ; 0x9700
   161c0: 0a000022  beq 16250 <XSdPs_FrameCmd+0xdc>
   161c4: 9a00000d  bls 16200 <XSdPs_FrameCmd+0x8c>
   161c8: e3500caa  cmp r0, #43520  ; 0xaa00
   161cc: 0a000029  beq 16278 <XSdPs_FrameCmd+0x104>
   161d0: e3500cb3  cmp r0, #45824  ; 0xb300
   161d4: 0a000025  beq 16270 <XSdPs_FrameCmd+0xfc>
   161d8: e3500ca9  cmp r0, #43264  ; 0xa900
   161dc: e30a3902  movw  r3, #43266  ; 0xa902
   161e0: 01a00003  moveq r0, r3
   161e4: e12fff1e  bx  lr
   161e8: e3500c05  cmp r0, #1280 ; 0x500
   161ec: 0a00001d  beq 16268 <XSdPs_FrameCmd+0xf4>
      RetVal |= RESP_R1B;
    break;

#ifndef MMC_CARD
    case CMD6:
      RetVal |= RESP_R1 | XSDPS_DAT_PRESENT_SEL_MASK;
   161f0: e3500c06  cmp r0, #1536 ; 0x600
   161f4: e300363a  movw  r3, #1594 ; 0x63a
   161f8: 01a00003  moveq r0, r3
   161fc: e12fff1e  bx  lr
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   16200: e3500c86  cmp r0, #34304  ; 0x8600
   16204: 1a00002e  bne 162c4 <XSdPs_FrameCmd+0x150>
      RetVal |= RESP_R1B;
      break;
#endif

    case ACMD6:
      RetVal |= RESP_R1;
   16208: e308061a  movw  r0, #34330  ; 0x861a
    break;
   1620c: e12fff1e  bx  lr
    case CMD7:
      RetVal |= RESP_R1;
   16210: e300071a  movw  r0, #1818 ; 0x71a
    break;
   16214: e12fff1e  bx  lr
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   16218: e3500c0a  cmp r0, #2560 ; 0xa00
   1621c: 0a00000d  beq 16258 <XSdPs_FrameCmd+0xe4>
   16220: 8a000022  bhi 162b0 <XSdPs_FrameCmd+0x13c>
   16224: e3500b02  cmp r0, #2048 ; 0x800
   16228: 0a000016  beq 16288 <XSdPs_FrameCmd+0x114>
      RetVal |= RESP_R1 | XSDPS_DAT_PRESENT_SEL_MASK;
      break;
#endif

    case CMD9:
      RetVal |= RESP_R2;
   1622c: e3500c09  cmp r0, #2304 ; 0x900
   16230: e3003909  movw  r3, #2313 ; 0x909
   16234: 01a00003  moveq r0, r3
   16238: e12fff1e  bx  lr
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   1623c: e3500b06  cmp r0, #6144 ; 0x1800
   16240: 0a000002  beq 16250 <XSdPs_FrameCmd+0xdc>
   16244: 8a000011  bhi 16290 <XSdPs_FrameCmd+0x11c>
   16248: e3500c12  cmp r0, #4608 ; 0x1200
   1624c: 1a000014  bne 162a4 <XSdPs_FrameCmd+0x130>
   16250: e380003a  orr r0, r0, #58 ; 0x3a
   16254: e12fff1e  bx  lr
    case ACMD51:
      RetVal |= RESP_R1 | XSDPS_DAT_PRESENT_SEL_MASK;
    break;
    case CMD52:
    case CMD55:
      RetVal |= RESP_R1;
   16258: e380001a  orr r0, r0, #26
    break;
   1625c: e12fff1e  bx  lr
    break;
    case CMD2:
      RetVal |= RESP_R2;
    break;
    case CMD3:
      RetVal |= RESP_R6;
   16260: e300031b  movw  r0, #795  ; 0x31b
    break;
   16264: e12fff1e  bx  lr
    case CMD4:
      RetVal |= RESP_NONE;
      break;
    case CMD5:
      RetVal |= RESP_R1B;
   16268: e300051b  movw  r0, #1307 ; 0x51b
    break;
   1626c: e12fff1e  bx  lr
    break;
    case ACMD42:
      RetVal |= RESP_R1;
    break;
    case ACMD51:
      RetVal |= RESP_R1 | XSDPS_DAT_PRESENT_SEL_MASK;
   16270: e30b033a  movw  r0, #45882  ; 0xb33a
    break;
   16274: e12fff1e  bx  lr
      RetVal |= RESP_R1 | XSDPS_DAT_PRESENT_SEL_MASK;
    case ACMD41:
      RetVal |= RESP_R3;
    break;
    case ACMD42:
      RetVal |= RESP_R1;
   16278: e30a0a1a  movw  r0, #43546  ; 0xaa1a
    break;
   1627c: e12fff1e  bx  lr
    switch(Cmd) {
    case CMD0:
      RetVal |= RESP_NONE;
    break;
    case CMD1:
      RetVal |= RESP_R3;
   16280: e3000102  movw  r0, #258  ; 0x102
    case CMD58:
    break;
    }

    return RetVal;
}
   16284: e12fff1e  bx  lr
      RetVal |= RESP_R1;
    break;

#ifndef MMC_CARD
    case CMD8:
      RetVal |= RESP_R1;
   16288: e300081a  movw  r0, #2074 ; 0x81a
      break;
   1628c: e12fff1e  bx  lr
{
    u32 RetVal;

    RetVal = Cmd;

    switch(Cmd) {
   16290: e3500c19  cmp r0, #6400 ; 0x1900
   16294: 0affffed  beq 16250 <XSdPs_FrameCmd+0xdc>
   16298: e3500b0d  cmp r0, #13312  ; 0x3400
   1629c: 0affffed  beq 16258 <XSdPs_FrameCmd+0xe4>
   162a0: e12fff1e  bx  lr
   162a4: e3500c17  cmp r0, #5888 ; 0x1700
   162a8: 0affffe8  beq 16250 <XSdPs_FrameCmd+0xdc>
   162ac: e12fff1e  bx  lr
   162b0: e3500b03  cmp r0, #3072 ; 0xc00
   162b4: 0affffe7  beq 16258 <XSdPs_FrameCmd+0xe4>
   162b8: e3500a01  cmp r0, #4096 ; 0x1000
   162bc: 0affffe5  beq 16258 <XSdPs_FrameCmd+0xe4>
   162c0: e12fff1e  bx  lr
   162c4: e3500c8d  cmp r0, #36096  ; 0x8d00
   162c8: 0affffe2  beq 16258 <XSdPs_FrameCmd+0xe4>
   162cc: e12fff1e  bx  lr

000162d0 <XSdPs_CmdTransfer>:
*     - XST_FAILURE if failure - could be because another transfer
*       is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_CmdTransfer(XSdPs *InstancePtr, u32 Cmd, u32 Arg, u32 BlkCnt)
{
   162d0: e92d43f8  push  {r3, r4, r5, r6, r7, r8, r9, lr}
  u32 PresentStateReg;
  u32 CommandReg;
  u32 StatusReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   162d4: e2506000  subs  r6, r0, #0
   162d8: 0a00004c  beq 16410 <XSdPs_CmdTransfer+0x140>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   162dc: e596e014  ldr lr, [r6, #20]
   162e0: e301c111  movw  ip, #4369 ; 0x1111
   162e4: e341c111  movt  ip, #4369 ; 0x1111
  u32 PresentStateReg;
  u32 CommandReg;
  u32 StatusReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   162e8: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   162ec: e15e000c  cmp lr, ip
  u32 PresentStateReg;
  u32 CommandReg;
  u32 StatusReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   162f0: e3405002  movt  r5, #2
   162f4: e3a04000  mov r4, #0
   162f8: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   162fc: 0a000007  beq 16320 <XSdPs_CmdTransfer+0x50>
   16300: e3080798  movw  r0, #34712  ; 0x8798
   16304: e30011be  movw  r1, #446  ; 0x1be
   16308: e3400001  movt  r0, #1
   1630c: ebffcb5f  bl  9090 <Xil_Assert>
   16310: e3a03001  mov r3, #1
   16314: e1a00004  mov r0, r4
   16318: e5853000  str r3, [r5]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   1631c: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

  /*
   * Check the command inhibit to make sure no other
   * command transfer is in progress
   */
  PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16320: e5960004  ldr r0, [r6, #4]
   16324: e1a07001  mov r7, r1
   16328: e1a08002  mov r8, r2
   1632c: e1a09003  mov r9, r3
   16330: e2800024  add r0, r0, #36 ; 0x24
   16334: ebffbf97  bl  6198 <Xil_In32>
      XSDPS_PRES_STATE_OFFSET);
  if (PresentStateReg & XSDPS_PSR_INHIBIT_CMD_MASK) {
   16338: e3100001  tst r0, #1
   1633c: 0a000001  beq 16348 <XSdPs_CmdTransfer+0x78>
    if (StatusReg & XSDPS_INTR_ERR_MASK) {

      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16340: e3a00001  mov r0, #1
   16344: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /*
   * Write block count register
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16348: e5960004  ldr r0, [r6, #4]
   1634c: e6ff1079  uxth  r1, r9
   16350: e2800006  add r0, r0, #6
   16354: ebffbf93  bl  61a8 <Xil_Out16>
      XSDPS_BLK_CNT_OFFSET, BlkCnt);

  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   16358: e5960004  ldr r0, [r6, #4]
   1635c: e3a0100e  mov r1, #14
   16360: e280002e  add r0, r0, #46 ; 0x2e
   16364: ebffbf8d  bl  61a0 <Xil_Out8>
      XSDPS_TIMEOUT_CTRL_OFFSET, 0xE);

  /*
   * Write argument register
   */
  XSdPs_WriteReg(InstancePtr->Config.BaseAddress,
   16368: e5960004  ldr r0, [r6, #4]
   1636c: e1a01008  mov r1, r8
   16370: e2800008  add r0, r0, #8
   16374: ebffbf8d  bl  61b0 <Xil_Out32>
      XSDPS_ARGMT_OFFSET, Arg);

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16378: e5960004  ldr r0, [r6, #4]
   1637c: e30f1fff  movw  r1, #65535  ; 0xffff
   16380: e2800030  add r0, r0, #48 ; 0x30
   16384: ebffbf87  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_NORM_INTR_ALL_MASK);
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16388: e5960004  ldr r0, [r6, #4]
   1638c: e30f13ff  movw  r1, #62463  ; 0xf3ff
   16390: e2800032  add r0, r0, #50 ; 0x32
   16394: ebffbf83  bl  61a8 <Xil_Out16>
      XSDPS_ERR_INTR_STS_OFFSET, XSDPS_ERROR_INTR_ALL_MASK);
  /*
   * Command register is set to trigger transfer of command
   */
  CommandReg = XSdPs_FrameCmd(Cmd);
   16398: e1a00007  mov r0, r7
   1639c: ebffff74  bl  16174 <XSdPs_FrameCmd>
   163a0: e1a04000  mov r4, r0
  CommandReg = CommandReg & 0x3FFF;

  /*
   * Check for data inhibit in case of command using DAT lines
   */
  PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   163a4: e5960004  ldr r0, [r6, #4]
   163a8: e2800024  add r0, r0, #36 ; 0x24
   163ac: ebffbf79  bl  6198 <Xil_In32>
      XSDPS_PRES_STATE_OFFSET);
  if ((PresentStateReg & XSDPS_PSR_INHIBIT_DAT_MASK) &&
   163b0: e3100002  tst r0, #2
   163b4: 0a000001  beq 163c0 <XSdPs_CmdTransfer+0xf0>
   163b8: e3140020  tst r4, #32
   163bc: 1affffdf  bne 16340 <XSdPs_CmdTransfer+0x70>
      (CommandReg & XSDPS_DAT_PRESENT_SEL_MASK)) {
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress, XSDPS_CMD_OFFSET,
   163c0: e5960004  ldr r0, [r6, #4]
   163c4: e7ed1054  ubfx  r1, r4, #0, #14
   163c8: e280000e  add r0, r0, #14
   163cc: ebffbf75  bl  61a8 <Xil_Out16>
   163d0: ea000001  b 163dc <XSdPs_CmdTransfer+0x10c>
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while((StatusReg & XSDPS_INTR_CC_MASK) == 0);
   163d4: e3100001  tst r0, #1
   163d8: 1a000016  bne 16438 <XSdPs_CmdTransfer+0x168>

  /*
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   163dc: e5960004  ldr r0, [r6, #4]
   163e0: e2800030  add r0, r0, #48 ; 0x30
   163e4: ebffbf69  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);

    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   163e8: e3c03c7f  bic r3, r0, #32512  ; 0x7f00
   163ec: e3c330ff  bic r3, r3, #255  ; 0xff
   163f0: e6ff5073  uxth  r5, r3
   163f4: e3550000  cmp r5, #0
   163f8: 0afffff5  beq 163d4 <XSdPs_CmdTransfer+0x104>

      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   163fc: e5960004  ldr r0, [r6, #4]
   16400: e30f13ff  movw  r1, #62463  ; 0xf3ff
   16404: e2800032  add r0, r0, #50 ; 0x32
   16408: ebffbf66  bl  61a8 <Xil_Out16>
   1640c: eaffffcb  b 16340 <XSdPs_CmdTransfer+0x70>
  u32 PresentStateReg;
  u32 CommandReg;
  u32 StatusReg;
  u32 Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16410: e3080798  movw  r0, #34712  ; 0x8798
   16414: e30011bd  movw  r1, #445  ; 0x1bd
   16418: e3400001  movt  r0, #1
   1641c: ebffcb1b  bl  9090 <Xil_Assert>
   16420: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16424: e3403002  movt  r3, #2
   16428: e3a02001  mov r2, #1
   1642c: e1a00006  mov r0, r6
   16430: e5832000  str r2, [r3]
   16434: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}
    }
  } while((StatusReg & XSDPS_INTR_CC_MASK) == 0);
  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16438: e5960004  ldr r0, [r6, #4]
   1643c: e3a01001  mov r1, #1
   16440: e2800030  add r0, r0, #48 ; 0x30
   16444: ebffbf57  bl  61a8 <Xil_Out16>
   16448: e1a00005  mov r0, r5
   1644c: e8bd83f8  pop {r3, r4, r5, r6, r7, r8, r9, pc}

00016450 <XSdPs_SdCardInitialize>:
*   Relative card address respectively.
*   CMD9 is sent to read the card specific data.
*
******************************************************************************/
int XSdPs_SdCardInitialize(XSdPs *InstancePtr)
{
   16450: e92d4070  push  {r4, r5, r6, lr}
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   16454: e2504000  subs  r4, r0, #0
   16458: 0a000084  beq 16670 <XSdPs_SdCardInitialize+0x220>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   1645c: e5942014  ldr r2, [r4, #20]
   16460: e3013111  movw  r3, #4369 ; 0x1111
   16464: e3413111  movt  r3, #4369 ; 0x1111
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   16468: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   1646c: e1520003  cmp r2, r3
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   16470: e3406002  movt  r6, #2
   16474: e3a03000  mov r3, #0
   16478: e5863000  str r3, [r6]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   1647c: 1a000014  bne 164d4 <XSdPs_SdCardInitialize+0x84>

  if(InstancePtr->Config.CardDetect) {
   16480: e594300c  ldr r3, [r4, #12]
   16484: e3530000  cmp r3, #0
   16488: 1a00000b  bne 164bc <XSdPs_SdCardInitialize+0x6c>
   * 74 CLK delay after card is powered up, before the first command.
   */

#ifdef __arm__

  usleep(XSDPS_INIT_DELAY);
   1648c: e3a00e7d  mov r0, #2000 ; 0x7d0
   16490: ebffbc5e  bl  5610 <usleep>
#endif

  /*
   * CMD0 no response expected
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD0, 0, 0);
   16494: e3a01000  mov r1, #0
   16498: e1a03001  mov r3, r1
   1649c: e1a00004  mov r0, r4
   164a0: e1a02001  mov r2, r1
   164a4: ebffff89  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   164a8: e2503000  subs  r3, r0, #0
   164ac: 0a000011  beq 164f8 <XSdPs_SdCardInitialize+0xa8>
*   Relative card address respectively.
*   CMD9 is sent to read the card specific data.
*
******************************************************************************/
int XSdPs_SdCardInitialize(XSdPs *InstancePtr)
{
   164b0: e3a05001  mov r5, #1
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   164b4: e1a00005  mov r0, r5
   164b8: e8bd8070  pop {r4, r5, r6, pc}
  if(InstancePtr->Config.CardDetect) {
    /*
     * Check the present state register to make sure
     * card is inserted and detected by host controller
     */
    PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   164bc: e5940004  ldr r0, [r4, #4]
   164c0: e2800024  add r0, r0, #36 ; 0x24
   164c4: ebffbf33  bl  6198 <Xil_In32>
        XSDPS_PRES_STATE_OFFSET);
    if ((PresentStateReg & XSDPS_PSR_CARD_INSRT_MASK) == 0) {
   164c8: e3100801  tst r0, #65536  ; 0x10000
   164cc: 1affffee  bne 1648c <XSdPs_SdCardInitialize+0x3c>
   164d0: eafffff6  b 164b0 <XSdPs_SdCardInitialize+0x60>
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   164d4: e3080798  movw  r0, #34712  ; 0x8798
   164d8: e1a05003  mov r5, r3
   164dc: e3001107  movw  r1, #263  ; 0x107
   164e0: e3400001  movt  r0, #1
   164e4: ebffcae9  bl  9090 <Xil_Assert>
   164e8: e3a03001  mov r3, #1
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   164ec: e1a00005  mov r0, r5
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   164f0: e5863000  str r3, [r6]
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   164f4: e8bd8070  pop {r4, r5, r6, pc}

  /*
   * CMD8; response expected
   * 0x1AA - Supply Voltage 2.7 - 3.6V and AA is pattern
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD8,
   164f8: e1a00004  mov r0, r4
   164fc: e3a01b02  mov r1, #2048 ; 0x800
   16500: e30021aa  movw  r2, #426  ; 0x1aa
   16504: ebffff71  bl  162d0 <XSdPs_CmdTransfer>
      XSDPS_CMD8_VOL_PATTERN, 0);
  if (Status != XST_SUCCESS) {
   16508: e3500000  cmp r0, #0
   1650c: 1affffe7  bne 164b0 <XSdPs_SdCardInitialize+0x60>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  RespOCR = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16510: e5940004  ldr r0, [r4, #4]
   16514: e2800010  add r0, r0, #16
   16518: ebffbf1e  bl  6198 <Xil_In32>
            XSDPS_RESP0_OFFSET);
  if (RespOCR != XSDPS_CMD8_VOL_PATTERN) {
   1651c: e30031aa  movw  r3, #426  ; 0x1aa
   16520: e1500003  cmp r0, r3
    InstancePtr->CardType = CT_SD1;
   16524: 13a03002  movne r3, #2
  }
  else {
    InstancePtr->CardType = CT_SD2;
   16528: 03a03003  moveq r3, #3
   1652c: e5843034  str r3, [r4, #52] ; 0x34
  RespOCR = 0;
  /*
   * Send ACMD41 while card is still busy with power up
   */
  while ((RespOCR & XSDPS_RESPOCR_READY) == 0) {
    Status = XSdPs_CmdTransfer(InstancePtr, CMD55, 0, 0);
   16530: e3a02000  mov r2, #0
   16534: e3a01c37  mov r1, #14080  ; 0x3700
   16538: e1a03002  mov r3, r2
   1653c: e1a00004  mov r0, r4
   16540: ebffff62  bl  162d0 <XSdPs_CmdTransfer>
    }

    /*
     * 0x40300000 - Host High Capacity support & 3.3V window
     */
    Status = XSdPs_CmdTransfer(InstancePtr, ACMD41,
   16544: e3a02000  mov r2, #0
   16548: e3a01ca9  mov r1, #43264  ; 0xa900
   1654c: e3442030  movt  r2, #16432  ; 0x4030
  /*
   * Send ACMD41 while card is still busy with power up
   */
  while ((RespOCR & XSDPS_RESPOCR_READY) == 0) {
    Status = XSdPs_CmdTransfer(InstancePtr, CMD55, 0, 0);
    if (Status != XST_SUCCESS) {
   16550: e2503000  subs  r3, r0, #0
    }

    /*
     * 0x40300000 - Host High Capacity support & 3.3V window
     */
    Status = XSdPs_CmdTransfer(InstancePtr, ACMD41,
   16554: e1a00004  mov r0, r4
  /*
   * Send ACMD41 while card is still busy with power up
   */
  while ((RespOCR & XSDPS_RESPOCR_READY) == 0) {
    Status = XSdPs_CmdTransfer(InstancePtr, CMD55, 0, 0);
    if (Status != XST_SUCCESS) {
   16558: 1affffd4  bne 164b0 <XSdPs_SdCardInitialize+0x60>
    }

    /*
     * 0x40300000 - Host High Capacity support & 3.3V window
     */
    Status = XSdPs_CmdTransfer(InstancePtr, ACMD41,
   1655c: ebffff5b  bl  162d0 <XSdPs_CmdTransfer>
        (XSDPS_ACMD41_HCS | XSDPS_ACMD41_3V3), 0);
    if (Status != XST_SUCCESS) {
   16560: e3500000  cmp r0, #0
   16564: 1affffd1  bne 164b0 <XSdPs_SdCardInitialize+0x60>
    }

    /*
     * Response with card capacity
     */
    RespOCR = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16568: e5940004  ldr r0, [r4, #4]
   1656c: e2800010  add r0, r0, #16
   16570: ebffbf08  bl  6198 <Xil_In32>

  RespOCR = 0;
  /*
   * Send ACMD41 while card is still busy with power up
   */
  while ((RespOCR & XSDPS_RESPOCR_READY) == 0) {
   16574: e3500000  cmp r0, #0
   16578: aaffffec  bge 16530 <XSdPs_SdCardInitialize+0xe0>
  }

  /*
   * Update HCS support flag based on card capacity response
   */
  if (RespOCR & XSDPS_ACMD41_HCS)
   1657c: e3100101  tst r0, #1073741824 ; 0x40000000
    InstancePtr->HCS = 1;

  /*
   * CMD2 for Card ID
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD2, 0, 0);
   16580: e3a02000  mov r2, #0
   16584: e1a00004  mov r0, r4
   16588: e3a01c02  mov r1, #512  ; 0x200

  /*
   * Update HCS support flag based on card capacity response
   */
  if (RespOCR & XSDPS_ACMD41_HCS)
    InstancePtr->HCS = 1;
   1658c: 13a03001  movne r3, #1
   16590: 1584301c  strne r3, [r4, #28]

  /*
   * CMD2 for Card ID
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD2, 0, 0);
   16594: e1a03002  mov r3, r2
   16598: ebffff4c  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   1659c: e3500000  cmp r0, #0
   165a0: 1affffc2  bne 164b0 <XSdPs_SdCardInitialize+0x60>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  InstancePtr->CardID[0] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165a4: e5940004  ldr r0, [r4, #4]
   165a8: e2800010  add r0, r0, #16
   165ac: ebffbef7  bl  6190 <Xil_In16>
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165b0: e5943004  ldr r3, [r4, #4]
  if (Status != XST_SUCCESS) {
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  InstancePtr->CardID[0] =
   165b4: e5840020  str r0, [r4, #32]
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165b8: e2830014  add r0, r3, #20
   165bc: ebffbef3  bl  6190 <Xil_In16>
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165c0: e5943004  ldr r3, [r4, #4]
  }

  InstancePtr->CardID[0] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
   165c4: e5840024  str r0, [r4, #36] ; 0x24
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165c8: e2830018  add r0, r3, #24
   165cc: ebffbeef  bl  6190 <Xil_In16>
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165d0: e5943004  ldr r3, [r4, #4]
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
   165d4: e5840028  str r0, [r4, #40] ; 0x28
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   165d8: e283001c  add r0, r3, #28
   165dc: ebffbeeb  bl  6190 <Xil_In16>
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
   165e0: e584002c  str r0, [r4, #44] ; 0x2c
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP3_OFFSET);
  do {
    Status = XSdPs_CmdTransfer(InstancePtr, CMD3, 0, 0);
   165e4: e3a02000  mov r2, #0
   165e8: e1a00004  mov r0, r4
   165ec: e1a03002  mov r3, r2
   165f0: e3a01c03  mov r1, #768  ; 0x300
   165f4: ebffff35  bl  162d0 <XSdPs_CmdTransfer>
    if (Status != XST_SUCCESS) {
   165f8: e2505000  subs  r5, r0, #0
   165fc: 1affffab  bne 164b0 <XSdPs_SdCardInitialize+0x60>
    /*
     * Relative card address is stored as the upper 16 bits
     * This is to avoid shifting when sending commands
     */
    InstancePtr->RelCardAddr =
        XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16600: e5940004  ldr r0, [r4, #4]
   16604: e2800010  add r0, r0, #16
   16608: ebffbee2  bl  6198 <Xil_In32>
          XSDPS_RESP0_OFFSET) & 0xFFFF0000;
   1660c: e1a00820  lsr r0, r0, #16
   16610: e1a00800  lsl r0, r0, #16

    /*
     * Relative card address is stored as the upper 16 bits
     * This is to avoid shifting when sending commands
     */
    InstancePtr->RelCardAddr =
   16614: e5840030  str r0, [r4, #48] ; 0x30
        XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
          XSDPS_RESP0_OFFSET) & 0xFFFF0000;
  } while (InstancePtr->RelCardAddr == 0);
   16618: e3500000  cmp r0, #0
   1661c: 0afffff0  beq 165e4 <XSdPs_SdCardInitialize+0x194>

  Status = XSdPs_CmdTransfer(InstancePtr, CMD9, (InstancePtr->RelCardAddr), 0);
   16620: e1a02000  mov r2, r0
   16624: e1a03005  mov r3, r5
   16628: e1a00004  mov r0, r4
   1662c: e3a01c09  mov r1, #2304 ; 0x900
   16630: ebffff26  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16634: e2505000  subs  r5, r0, #0
   16638: 1affff9c  bne 164b0 <XSdPs_SdCardInitialize+0x60>

  /*
   * Card specific data is read.
   * Currently not used for any operation.
   */
  CSD[0] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   1663c: e5940004  ldr r0, [r4, #4]
   16640: e2800010  add r0, r0, #16
   16644: ebffbed3  bl  6198 <Xil_In32>
      XSDPS_RESP0_OFFSET);
  CSD[1] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16648: e5940004  ldr r0, [r4, #4]
   1664c: e2800014  add r0, r0, #20
   16650: ebffbed0  bl  6198 <Xil_In32>
      XSDPS_RESP1_OFFSET);
  CSD[2] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16654: e5940004  ldr r0, [r4, #4]
   16658: e2800018  add r0, r0, #24
   1665c: ebffbecd  bl  6198 <Xil_In32>
      XSDPS_RESP2_OFFSET);
  CSD[3] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16660: e5940004  ldr r0, [r4, #4]
   16664: e280001c  add r0, r0, #28
   16668: ebffbeca  bl  6198 <Xil_In32>
      XSDPS_RESP3_OFFSET);

  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;
   1666c: eaffff90  b 164b4 <XSdPs_SdCardInitialize+0x64>
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   16670: e3080798  movw  r0, #34712  ; 0x8798
   16674: e3001106  movw  r1, #262  ; 0x106
   16678: e3400001  movt  r0, #1
   1667c: e1a05004  mov r5, r4
   16680: ebffca82  bl  9090 <Xil_Assert>
   16684: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16688: e3403002  movt  r3, #2
   1668c: e3a02001  mov r2, #1
   16690: e5832000  str r2, [r3]
   16694: eaffff86  b 164b4 <XSdPs_SdCardInitialize+0x64>

00016698 <XSdPs_Select_Card>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Select_Card (XSdPs *InstancePtr)
{
   16698: e92d4010  push  {r4, lr}
  u32 Status = 0;

  /*
   * Send CMD7 - Select card
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD7,
   1669c: e3a01c07  mov r1, #1792 ; 0x700
   166a0: e5902030  ldr r2, [r0, #48] ; 0x30
   166a4: e3a03000  mov r3, #0
*
* @note   None.
*
******************************************************************************/
int XSdPs_Select_Card (XSdPs *InstancePtr)
{
   166a8: e1a04000  mov r4, r0
  u32 Status = 0;

  /*
   * Send CMD7 - Select card
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD7,
   166ac: ebffff07  bl  162d0 <XSdPs_CmdTransfer>
      InstancePtr->RelCardAddr, 0);
  if (Status != XST_SUCCESS) {
   166b0: e3500000  cmp r0, #0
   166b4: 0a000001  beq 166c0 <XSdPs_Select_Card+0x28>
   166b8: e3a00001  mov r0, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   166bc: e8bd8010  pop {r4, pc}
  if (Status != XST_SUCCESS) {
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   166c0: e5940004  ldr r0, [r4, #4]
   166c4: e2800010  add r0, r0, #16
   166c8: ebffbeb2  bl  6198 <Xil_In32>
      XSDPS_RESP0_OFFSET);

  /*
   * Set default block size
   */
  Status = XSdPs_SetBlkSize(InstancePtr, XSDPS_BLK_SIZE_512_MASK);
   166cc: e1a00004  mov r0, r4
   166d0: e3a01c02  mov r1, #512  ; 0x200
   166d4: eb000135  bl  16bb0 <XSdPs_SetBlkSize>
  if (Status != XST_SUCCESS) {
   166d8: e2900000  adds  r0, r0, #0
   166dc: 13a00001  movne r0, #1
   166e0: e8bd8010  pop {r4, pc}

000166e4 <XSdPs_SetupADMA2DescTbl>:
*
* @note   None.
*
******************************************************************************/
void XSdPs_SetupADMA2DescTbl(XSdPs *InstancePtr, u32 BlkCnt, const u8 *Buff)
{
   166e4: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
   166e8: e1a06000  mov r6, r0
  u32 BlkSize = 0;

  /*
   * Setup ADMA2 - Write descriptor table and point ADMA SAR to it
   */
  BlkSize = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   166ec: e5900004  ldr r0, [r0, #4]
*
* @note   None.
*
******************************************************************************/
void XSdPs_SetupADMA2DescTbl(XSdPs *InstancePtr, u32 BlkCnt, const u8 *Buff)
{
   166f0: e1a07001  mov r7, r1
   166f4: e1a08002  mov r8, r2
  u32 BlkSize = 0;

  /*
   * Setup ADMA2 - Write descriptor table and point ADMA SAR to it
   */
  BlkSize = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   166f8: e2800004  add r0, r0, #4
   166fc: ebffbea3  bl  6190 <Xil_In16>
          XSDPS_BLK_SIZE_OFFSET);
  BlkSize = BlkSize & XSDPS_BLK_SIZE_MASK;
   16700: e7eb0050  ubfx  r0, r0, #0, #12

  if((BlkCnt*BlkSize) < XSDPS_DESC_MAX_LENGTH) {
   16704: e0030097  mul r3, r7, r0
   16708: e3530801  cmp r3, #65536  ; 0x10000
   1670c: 33a0c000  movcc ip, #0
    if ((BlkCnt * BlkSize) % XSDPS_DESC_MAX_LENGTH)
      TotalDescLines += 1;

  }

  for (DescNum = 0; DescNum < (TotalDescLines-1); DescNum++) {
   16710: 31a0200c  movcc r2, ip
   */
  BlkSize = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
          XSDPS_BLK_SIZE_OFFSET);
  BlkSize = BlkSize & XSDPS_BLK_SIZE_MASK;

  if((BlkCnt*BlkSize) < XSDPS_DESC_MAX_LENGTH) {
   16714: 3a000014  bcc 1676c <XSdPs_SetupADMA2DescTbl+0x88>
    TotalDescLines = 1;

  }else {

    TotalDescLines = ((BlkCnt*BlkSize) / XSDPS_DESC_MAX_LENGTH);
    if ((BlkCnt * BlkSize) % XSDPS_DESC_MAX_LENGTH)
   16718: e6ff2073  uxth  r2, r3

    TotalDescLines = 1;

  }else {

    TotalDescLines = ((BlkCnt*BlkSize) / XSDPS_DESC_MAX_LENGTH);
   1671c: e1a03823  lsr r3, r3, #16
    if ((BlkCnt * BlkSize) % XSDPS_DESC_MAX_LENGTH)
   16720: e3520000  cmp r2, #0
      TotalDescLines += 1;
   16724: 12833001  addne r3, r3, #1

  }

  for (DescNum = 0; DescNum < (TotalDescLines-1); DescNum++) {
   16728: e2532001  subs  r2, r3, #1
   1672c: 01a0c002  moveq ip, r2
   16730: 0a00000d  beq 1676c <XSdPs_SetupADMA2DescTbl+0x88>
   16734: e243e21e  sub lr, r3, #-536870911 ; 0xe0000001
   16738: e1a0c008  mov ip, r8
   1673c: e1a03006  mov r3, r6
    InstancePtr->Adma2_DescrTbl[DescNum].Address =
        (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));
    InstancePtr->Adma2_DescrTbl[DescNum].Attribute =
   16740: e3a05021  mov r5, #33 ; 0x21
   16744: e086e18e  add lr, r6, lr, lsl #3
        XSDPS_DESC_TRAN | XSDPS_DESC_VALID;
    /*
     * This will write '0' to length field which indicates 65536
     */
    InstancePtr->Adma2_DescrTbl[DescNum].Length =
   16748: e3a04000  mov r4, #0
      TotalDescLines += 1;

  }

  for (DescNum = 0; DescNum < (TotalDescLines-1); DescNum++) {
    InstancePtr->Adma2_DescrTbl[DescNum].Address =
   1674c: e583c044  str ip, [r3, #68] ; 0x44
   16750: e2833008  add r3, r3, #8
        (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));
    InstancePtr->Adma2_DescrTbl[DescNum].Attribute =
   16754: e1c353b8  strh  r5, [r3, #56] ; 0x38
   16758: e28cc801  add ip, ip, #65536  ; 0x10000
        XSDPS_DESC_TRAN | XSDPS_DESC_VALID;
    /*
     * This will write '0' to length field which indicates 65536
     */
    InstancePtr->Adma2_DescrTbl[DescNum].Length =
   1675c: e1c343ba  strh  r4, [r3, #58] ; 0x3a
    if ((BlkCnt * BlkSize) % XSDPS_DESC_MAX_LENGTH)
      TotalDescLines += 1;

  }

  for (DescNum = 0; DescNum < (TotalDescLines-1); DescNum++) {
   16760: e153000e  cmp r3, lr
   16764: 1afffff8  bne 1674c <XSdPs_SetupADMA2DescTbl+0x68>
   16768: e1a0c802  lsl ip, r2, #16
      (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Attribute =
      XSDPS_DESC_TRAN | XSDPS_DESC_END | XSDPS_DESC_VALID;

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Length =
   1676c: e1670780  smulbb  r7, r0, r7
   16770: e0863182  add r3, r6, r2, lsl #3
    InstancePtr->Adma2_DescrTbl[DescNum].Length =
        (u16)XSDPS_DESC_MAX_LENGTH;
  }

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Address =
      (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));
   16774: e088800c  add r8, r8, ip

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Length =
      (BlkCnt*BlkSize) - (DescNum*XSDPS_DESC_MAX_LENGTH);


  XSdPs_WriteReg(InstancePtr->Config.BaseAddress, XSDPS_ADMA_SAR_OFFSET,
   16778: e2864040  add r4, r6, #64 ; 0x40
     */
    InstancePtr->Adma2_DescrTbl[DescNum].Length =
        (u16)XSDPS_DESC_MAX_LENGTH;
  }

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Address =
   1677c: e5838044  str r8, [r3, #68] ; 0x44
      (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Attribute =
   16780: e3a02023  mov r2, #35 ; 0x23
   16784: e1c324b0  strh  r2, [r3, #64] ; 0x40

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Length =
      (BlkCnt*BlkSize) - (DescNum*XSDPS_DESC_MAX_LENGTH);


  XSdPs_WriteReg(InstancePtr->Config.BaseAddress, XSDPS_ADMA_SAR_OFFSET,
   16788: e1a01004  mov r1, r4
      (u32)(Buff + (DescNum*XSDPS_DESC_MAX_LENGTH));

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Attribute =
      XSDPS_DESC_TRAN | XSDPS_DESC_END | XSDPS_DESC_VALID;

  InstancePtr->Adma2_DescrTbl[TotalDescLines-1].Length =
   1678c: e1c374b2  strh  r7, [r3, #66] ; 0x42
      (BlkCnt*BlkSize) - (DescNum*XSDPS_DESC_MAX_LENGTH);


  XSdPs_WriteReg(InstancePtr->Config.BaseAddress, XSDPS_ADMA_SAR_OFFSET,
   16790: e5960004  ldr r0, [r6, #4]
   16794: e2800058  add r0, r0, #88 ; 0x58
   16798: ebffbe84  bl  61b0 <Xil_Out32>
      (u32)&(InstancePtr->Adma2_DescrTbl[0]));

  Xil_DCacheFlushRange(&(InstancePtr->Adma2_DescrTbl[0]),
   1679c: e1a00004  mov r0, r4
   167a0: e3a01c01  mov r1, #256  ; 0x100
      sizeof(XSdPs_Adma2Descriptor) * 32);

}
   167a4: e8bd41f0  pop {r4, r5, r6, r7, r8, lr}


  XSdPs_WriteReg(InstancePtr->Config.BaseAddress, XSDPS_ADMA_SAR_OFFSET,
      (u32)&(InstancePtr->Adma2_DescrTbl[0]));

  Xil_DCacheFlushRange(&(InstancePtr->Adma2_DescrTbl[0]),
   167a8: eaffbbf1  b 5774 <Xil_DCacheFlushRange>

000167ac <XSdPs_ReadPolled>:
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_ReadPolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, u8 *Buff)
{
   167ac: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
   167b0: e1a04000  mov r4, r0
  u32 Status;
  u32 PresentStateReg;
  u32 StatusReg;

  if(InstancePtr->Config.CardDetect) {
   167b4: e590000c  ldr r0, [r0, #12]
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_ReadPolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, u8 *Buff)
{
   167b8: e1a07001  mov r7, r1
   167bc: e1a05002  mov r5, r2
   167c0: e1a06003  mov r6, r3
  u32 Status;
  u32 PresentStateReg;
  u32 StatusReg;

  if(InstancePtr->Config.CardDetect) {
   167c4: e3500000  cmp r0, #0
   167c8: 0a000004  beq 167e0 <XSdPs_ReadPolled+0x34>
    /*
     * Check status to ensure card is initialized
     */
    PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   167cc: e5940004  ldr r0, [r4, #4]
   167d0: e2800024  add r0, r0, #36 ; 0x24
   167d4: ebffbe6f  bl  6198 <Xil_In32>
        XSDPS_PRES_STATE_OFFSET);
    if ((PresentStateReg & XSDPS_PSR_CARD_INSRT_MASK) == 0x0) {
   167d8: e3100801  tst r0, #65536  ; 0x10000
   167dc: 0a00001b  beq 16850 <XSdPs_ReadPolled+0xa4>
  }

  /*
   * Set block size to 512 if not already set
   */
  if( XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   167e0: e5940004  ldr r0, [r4, #4]
   167e4: e2800004  add r0, r0, #4
   167e8: ebffbe6a  bl  6198 <Xil_In32>
   167ec: e3500c02  cmp r0, #512  ; 0x200
   167f0: 0a000004  beq 16808 <XSdPs_ReadPolled+0x5c>
      XSDPS_BLK_SIZE_OFFSET) != XSDPS_BLK_SIZE_512_MASK ) {
    Status = XSdPs_SetBlkSize(InstancePtr,
   167f4: e1a00004  mov r0, r4
   167f8: e3a01c02  mov r1, #512  ; 0x200
   167fc: eb0000eb  bl  16bb0 <XSdPs_SetBlkSize>
      XSDPS_BLK_SIZE_512_MASK);
    if (Status != XST_SUCCESS) {
   16800: e3500000  cmp r0, #0
   16804: 1a000011  bne 16850 <XSdPs_ReadPolled+0xa4>
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  }

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, Buff);
   16808: e1a02006  mov r2, r6
   1680c: e1a01005  mov r1, r5
   16810: e1a00004  mov r0, r4
   16814: ebffffb2  bl  166e4 <XSdPs_SetupADMA2DescTbl>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16818: e5940004  ldr r0, [r4, #4]
   1681c: e3a01037  mov r1, #55 ; 0x37
   16820: e280000c  add r0, r0, #12
   16824: ebffbe5f  bl  61a8 <Xil_Out16>
      XSDPS_XFER_MODE_OFFSET,
      XSDPS_TM_AUTO_CMD12_EN_MASK |
      XSDPS_TM_BLK_CNT_EN_MASK | XSDPS_TM_DAT_DIR_SEL_MASK |
      XSDPS_TM_DMA_EN_MASK | XSDPS_TM_MUL_SIN_BLK_SEL_MASK);

  Xil_DCacheInvalidateRange(Buff, BlkCnt * XSDPS_BLK_SIZE_512_MASK);
   16828: e1a01485  lsl r1, r5, #9
   1682c: e1a00006  mov r0, r6
   16830: ebffbdb5  bl  5f0c <Xil_DCacheInvalidateRange>

  /*
   * Send block read command
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD18, Arg, BlkCnt);
   16834: e1a03005  mov r3, r5
   16838: e1a00004  mov r0, r4
   1683c: e1a02007  mov r2, r7
   16840: e3a01c12  mov r1, #4608 ; 0x1200
   16844: ebfffea1  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16848: e2505000  subs  r5, r0, #0
   1684c: 0a000004  beq 16864 <XSdPs_ReadPolled+0xb8>
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_ReadPolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, u8 *Buff)
{
   16850: e3a05001  mov r5, #1

  Status = XST_SUCCESS;

  RETURN_PATH:
  return Status;
}
   16854: e1a00005  mov r0, r5
   16858: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   1685c: e3100002  tst r0, #2
   16860: 1a00000b  bne 16894 <XSdPs_ReadPolled+0xe8>

  /*
   * Check for transfer complete
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16864: e5940004  ldr r0, [r4, #4]
   16868: e2800030  add r0, r0, #48 ; 0x30
   1686c: ebffbe47  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   16870: e3100902  tst r0, #32768  ; 0x8000
   16874: 0afffff8  beq 1685c <XSdPs_ReadPolled+0xb0>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16878: e5940004  ldr r0, [r4, #4]
   1687c: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   16880: e3a05001  mov r5, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16884: e2800032  add r0, r0, #50 ; 0x32
   16888: ebffbe46  bl  61a8 <Xil_Out16>

  Status = XST_SUCCESS;

  RETURN_PATH:
  return Status;
}
   1688c: e1a00005  mov r0, r5
   16890: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  } while((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16894: e5940004  ldr r0, [r4, #4]
   16898: e3a01002  mov r1, #2
   1689c: e2800030  add r0, r0, #48 ; 0x30
   168a0: ebffbe40  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_INTR_TC_MASK);
  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   168a4: e5940004  ldr r0, [r4, #4]
   168a8: e2800010  add r0, r0, #16
   168ac: ebffbe39  bl  6198 <Xil_In32>

  Status = XST_SUCCESS;

  RETURN_PATH:
  return Status;
}
   168b0: e1a00005  mov r0, r5
   168b4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

000168b8 <XSdPs_WritePolled>:
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_WritePolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, const u8 *Buff)
{
   168b8: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
   168bc: e1a04000  mov r4, r0
  u32 Status;
  u32 PresentStateReg;
  u32 StatusReg;

  if(InstancePtr->Config.CardDetect) {
   168c0: e590000c  ldr r0, [r0, #12]
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_WritePolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, const u8 *Buff)
{
   168c4: e1a07001  mov r7, r1
   168c8: e1a05002  mov r5, r2
   168cc: e1a06003  mov r6, r3
  u32 Status;
  u32 PresentStateReg;
  u32 StatusReg;

  if(InstancePtr->Config.CardDetect) {
   168d0: e3500000  cmp r0, #0
   168d4: 0a000004  beq 168ec <XSdPs_WritePolled+0x34>
    /*
     * Check status to ensure card is initialized
     */
    PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   168d8: e5940004  ldr r0, [r4, #4]
   168dc: e2800024  add r0, r0, #36 ; 0x24
   168e0: ebffbe2c  bl  6198 <Xil_In32>
        XSDPS_PRES_STATE_OFFSET);
    if ((PresentStateReg & XSDPS_PSR_CARD_INSRT_MASK) == 0x0) {
   168e4: e3100801  tst r0, #65536  ; 0x10000
   168e8: 0a00001b  beq 1695c <XSdPs_WritePolled+0xa4>
  }

  /*
   * Set block size to 512 if not already set
   */
  if( XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   168ec: e5940004  ldr r0, [r4, #4]
   168f0: e2800004  add r0, r0, #4
   168f4: ebffbe27  bl  6198 <Xil_In32>
   168f8: e3500c02  cmp r0, #512  ; 0x200
   168fc: 0a000004  beq 16914 <XSdPs_WritePolled+0x5c>
      XSDPS_BLK_SIZE_OFFSET) != XSDPS_BLK_SIZE_512_MASK ) {
    Status = XSdPs_SetBlkSize(InstancePtr,
   16900: e1a00004  mov r0, r4
   16904: e3a01c02  mov r1, #512  ; 0x200
   16908: eb0000a8  bl  16bb0 <XSdPs_SetBlkSize>
      XSDPS_BLK_SIZE_512_MASK);
    if (Status != XST_SUCCESS) {
   1690c: e3500000  cmp r0, #0
   16910: 1a000011  bne 1695c <XSdPs_WritePolled+0xa4>
      goto RETURN_PATH;
    }

  }

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, Buff);
   16914: e1a02006  mov r2, r6
   16918: e1a01005  mov r1, r5
   1691c: e1a00004  mov r0, r4
   16920: ebffff6f  bl  166e4 <XSdPs_SetupADMA2DescTbl>
  Xil_DCacheFlushRange(Buff, BlkCnt * XSDPS_BLK_SIZE_512_MASK);
   16924: e1a01485  lsl r1, r5, #9
   16928: e1a00006  mov r0, r6
   1692c: ebffbb90  bl  5774 <Xil_DCacheFlushRange>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16930: e5940004  ldr r0, [r4, #4]
   16934: e3a01027  mov r1, #39 ; 0x27
   16938: e280000c  add r0, r0, #12
   1693c: ebffbe19  bl  61a8 <Xil_Out16>
      XSDPS_TM_MUL_SIN_BLK_SEL_MASK | XSDPS_TM_DMA_EN_MASK);

  /*
   * Send block write command
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD25, Arg, BlkCnt);
   16940: e1a03005  mov r3, r5
   16944: e1a00004  mov r0, r4
   16948: e1a02007  mov r2, r7
   1694c: e3a01c19  mov r1, #6400 ; 0x1900
   16950: ebfffe5e  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16954: e2505000  subs  r5, r0, #0
   16958: 0a000004  beq 16970 <XSdPs_WritePolled+0xb8>
*     - XST_FAILURE if failure - could be because another transfer
*     is in progress or command or data inhibit is set
*
******************************************************************************/
int XSdPs_WritePolled(XSdPs *InstancePtr, u32 Arg, u32 BlkCnt, const u8 *Buff)
{
   1695c: e3a05001  mov r5, #1

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
}
   16960: e1a00005  mov r0, r5
   16964: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   16968: e3100002  tst r0, #2
   1696c: 1a00000b  bne 169a0 <XSdPs_WritePolled+0xe8>
  /*
   * Check for transfer complete
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16970: e5940004  ldr r0, [r4, #4]
   16974: e2800030  add r0, r0, #48 ; 0x30
   16978: ebffbe04  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   1697c: e3100902  tst r0, #32768  ; 0x8000
   16980: 0afffff8  beq 16968 <XSdPs_WritePolled+0xb0>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16984: e5940004  ldr r0, [r4, #4]
   16988: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   1698c: e3a05001  mov r5, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16990: e2800032  add r0, r0, #50 ; 0x32
   16994: ebffbe03  bl  61a8 <Xil_Out16>

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
}
   16998: e1a00005  mov r0, r5
   1699c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  } while((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   169a0: e5940004  ldr r0, [r4, #4]
   169a4: e3a01002  mov r1, #2
   169a8: e2800030  add r0, r0, #48 ; 0x30
   169ac: ebffbdfd  bl  61a8 <Xil_Out16>

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
}
   169b0: e1a00005  mov r0, r5
   169b4: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}

000169b8 <XSdPs_MmcCardInitialize>:
*   Relative card address respectively.
*   CMD9 is sent to read the card specific data.
*
******************************************************************************/
int XSdPs_MmcCardInitialize(XSdPs *InstancePtr)
{
   169b8: e92d4070  push  {r4, r5, r6, lr}
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   169bc: e2504000  subs  r4, r0, #0
   169c0: 0a000070  beq 16b88 <XSdPs_MmcCardInitialize+0x1d0>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   169c4: e5942014  ldr r2, [r4, #20]
   169c8: e3013111  movw  r3, #4369 ; 0x1111
   169cc: e3413111  movt  r3, #4369 ; 0x1111
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   169d0: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   169d4: e1520003  cmp r2, r3
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   169d8: e3406002  movt  r6, #2
   169dc: e3a03000  mov r3, #0
   169e0: e5863000  str r3, [r6]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   169e4: 1a000024  bne 16a7c <XSdPs_MmcCardInitialize+0xc4>

  if(InstancePtr->Config.CardDetect) {
   169e8: e594300c  ldr r3, [r4, #12]
   169ec: e3530000  cmp r3, #0
   169f0: 1a00001b  bne 16a64 <XSdPs_MmcCardInitialize+0xac>
   * 74 CLK delay after card is powered up, before the first command.
   */

#ifdef __arm__

  usleep(XSDPS_INIT_DELAY);
   169f4: e3a00e7d  mov r0, #2000 ; 0x7d0
   169f8: ebffbb04  bl  5610 <usleep>
#endif

  /*
   * CMD0 no response expected
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD0, 0, 0);
   169fc: e3a01000  mov r1, #0
   16a00: e1a00004  mov r0, r4
   16a04: e1a02001  mov r2, r1
   16a08: e1a03001  mov r3, r1
   16a0c: ebfffe2f  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16a10: e3500000  cmp r0, #0
   16a14: 1a00000f  bne 16a58 <XSdPs_MmcCardInitialize+0xa0>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  InstancePtr->CardType = CT_MMC;
   16a18: e3a03001  mov r3, #1
   16a1c: e5843034  str r3, [r4, #52] ; 0x34
   16a20: ea000004  b 16a38 <XSdPs_MmcCardInitialize+0x80>
    }

    /*
     * Response with card capacity
     */
    RespOCR = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16a24: e5940004  ldr r0, [r4, #4]
   16a28: e2800010  add r0, r0, #16
   16a2c: ebffbdd9  bl  6198 <Xil_In32>
  InstancePtr->CardType = CT_MMC;
  RespOCR = 0;
  /*
   * Send CMD1 while card is still busy with power up
   */
  while ((RespOCR & XSDPS_RESPOCR_READY) == 0) {
   16a30: e3500000  cmp r0, #0
   16a34: ba000019  blt 16aa0 <XSdPs_MmcCardInitialize+0xe8>

    /*
     * Host High Capacity support & High volage window
     */
    Status = XSdPs_CmdTransfer(InstancePtr, CMD1,
   16a38: e3a02902  mov r2, #32768  ; 0x8000
   16a3c: e1a00004  mov r0, r4
   16a40: e34420ff  movt  r2, #16639  ; 0x40ff
   16a44: e3a01c01  mov r1, #256  ; 0x100
   16a48: e3a03000  mov r3, #0
   16a4c: ebfffe1f  bl  162d0 <XSdPs_CmdTransfer>
        XSDPS_ACMD41_HCS | XSDPS_CMD1_HIGH_VOL, 0);
    if (Status != XST_SUCCESS) {
   16a50: e3500000  cmp r0, #0
   16a54: 0afffff2  beq 16a24 <XSdPs_MmcCardInitialize+0x6c>
*   Relative card address respectively.
*   CMD9 is sent to read the card specific data.
*
******************************************************************************/
int XSdPs_MmcCardInitialize(XSdPs *InstancePtr)
{
   16a58: e3a05001  mov r5, #1
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   16a5c: e1a00005  mov r0, r5
   16a60: e8bd8070  pop {r4, r5, r6, pc}
  if(InstancePtr->Config.CardDetect) {
    /*
     * Check the present state register to make sure
     * card is inserted and detected by host controller
     */
    PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16a64: e5940004  ldr r0, [r4, #4]
   16a68: e2800024  add r0, r0, #36 ; 0x24
   16a6c: ebffbdc9  bl  6198 <Xil_In32>
        XSDPS_PRES_STATE_OFFSET);
    if ((PresentStateReg & XSDPS_PSR_CARD_INSRT_MASK) == 0) {
   16a70: e3100801  tst r0, #65536  ; 0x10000
   16a74: 1affffde  bne 169f4 <XSdPs_MmcCardInitialize+0x3c>
   16a78: eafffff6  b 16a58 <XSdPs_MmcCardInitialize+0xa0>
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16a7c: e3080798  movw  r0, #34712  ; 0x8798
   16a80: e1a05003  mov r5, r3
   16a84: e30013da  movw  r1, #986  ; 0x3da
   16a88: e3400001  movt  r0, #1
   16a8c: ebffc97f  bl  9090 <Xil_Assert>
   16a90: e3a03001  mov r3, #1
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   16a94: e1a00005  mov r0, r5
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16a98: e5863000  str r3, [r6]
  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;

}
   16a9c: e8bd8070  pop {r4, r5, r6, pc}
  }

  /*
   * Update HCS support flag based on card capacity response
   */
  if (RespOCR & XSDPS_ACMD41_HCS)
   16aa0: e3100101  tst r0, #1073741824 ; 0x40000000
    InstancePtr->HCS = 1;

  /*
   * CMD2 for Card ID
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD2, 0, 0);
   16aa4: e3a02000  mov r2, #0
   16aa8: e1a00004  mov r0, r4
   16aac: e3a01c02  mov r1, #512  ; 0x200

  /*
   * Update HCS support flag based on card capacity response
   */
  if (RespOCR & XSDPS_ACMD41_HCS)
    InstancePtr->HCS = 1;
   16ab0: 13a03001  movne r3, #1
   16ab4: 1584301c  strne r3, [r4, #28]

  /*
   * CMD2 for Card ID
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD2, 0, 0);
   16ab8: e1a03002  mov r3, r2
   16abc: ebfffe03  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16ac0: e2505000  subs  r5, r0, #0
   16ac4: 1affffe3  bne 16a58 <XSdPs_MmcCardInitialize+0xa0>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  InstancePtr->CardID[0] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16ac8: e5940004  ldr r0, [r4, #4]
   16acc: e2800010  add r0, r0, #16
   16ad0: ebffbdae  bl  6190 <Xil_In16>
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16ad4: e5943004  ldr r3, [r4, #4]
  if (Status != XST_SUCCESS) {
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  InstancePtr->CardID[0] =
   16ad8: e5840020  str r0, [r4, #32]
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16adc: e2830014  add r0, r3, #20
   16ae0: ebffbdaa  bl  6190 <Xil_In16>
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16ae4: e5943004  ldr r3, [r4, #4]
  }

  InstancePtr->CardID[0] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
   16ae8: e5840024  str r0, [r4, #36] ; 0x24
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16aec: e2830018  add r0, r3, #24
   16af0: ebffbda6  bl  6190 <Xil_In16>
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16af4: e5943004  ldr r3, [r4, #4]
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP0_OFFSET);
  InstancePtr->CardID[1] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
   16af8: e5840028  str r0, [r4, #40] ; 0x28
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16afc: e283001c  add r0, r3, #28
   16b00: ebffbda2  bl  6190 <Xil_In16>
      XSDPS_RESP3_OFFSET);

  Status = XSdPs_CmdTransfer(InstancePtr, CMD3, 0, 0);
   16b04: e1a02005  mov r2, r5
   16b08: e1a03005  mov r3, r5
   16b0c: e3a01c03  mov r1, #768  ; 0x300
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP1_OFFSET);
  InstancePtr->CardID[2] =
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP2_OFFSET);
  InstancePtr->CardID[3] =
   16b10: e584002c  str r0, [r4, #44] ; 0x2c
      XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_RESP3_OFFSET);

  Status = XSdPs_CmdTransfer(InstancePtr, CMD3, 0, 0);
   16b14: e1a00004  mov r0, r4
   16b18: ebfffdec  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16b1c: e2505000  subs  r5, r0, #0
   16b20: 1affffcc  bne 16a58 <XSdPs_MmcCardInitialize+0xa0>
  /*
   * Relative card address is stored as the upper 16 bits
   * This is to avoid shifting when sending commands
   */
  InstancePtr->RelCardAddr =
      XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16b24: e5940004  ldr r0, [r4, #4]
   16b28: e2800010  add r0, r0, #16
   16b2c: ebffbd99  bl  6198 <Xil_In32>
        XSDPS_RESP0_OFFSET) & 0xFFFF0000;

  Status = XSdPs_CmdTransfer(InstancePtr, CMD9, (InstancePtr->RelCardAddr), 0);
   16b30: e1a03005  mov r3, r5
   16b34: e3a01c09  mov r1, #2304 ; 0x900
   * Relative card address is stored as the upper 16 bits
   * This is to avoid shifting when sending commands
   */
  InstancePtr->RelCardAddr =
      XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
        XSDPS_RESP0_OFFSET) & 0xFFFF0000;
   16b38: e1a02820  lsr r2, r0, #16

  Status = XSdPs_CmdTransfer(InstancePtr, CMD9, (InstancePtr->RelCardAddr), 0);
   16b3c: e1a00004  mov r0, r4
   * Relative card address is stored as the upper 16 bits
   * This is to avoid shifting when sending commands
   */
  InstancePtr->RelCardAddr =
      XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
        XSDPS_RESP0_OFFSET) & 0xFFFF0000;
   16b40: e1a02802  lsl r2, r2, #16

  /*
   * Relative card address is stored as the upper 16 bits
   * This is to avoid shifting when sending commands
   */
  InstancePtr->RelCardAddr =
   16b44: e5842030  str r2, [r4, #48] ; 0x30
      XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
        XSDPS_RESP0_OFFSET) & 0xFFFF0000;

  Status = XSdPs_CmdTransfer(InstancePtr, CMD9, (InstancePtr->RelCardAddr), 0);
   16b48: ebfffde0  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16b4c: e2505000  subs  r5, r0, #0
   16b50: 1affffc0  bne 16a58 <XSdPs_MmcCardInitialize+0xa0>

  /*
   * Card specific data is read.
   * Currently not used for any operation.
   */
  CSD[0] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16b54: e5940004  ldr r0, [r4, #4]
   16b58: e2800010  add r0, r0, #16
   16b5c: ebffbd8d  bl  6198 <Xil_In32>
      XSDPS_RESP0_OFFSET);
  CSD[1] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16b60: e5940004  ldr r0, [r4, #4]
   16b64: e2800014  add r0, r0, #20
   16b68: ebffbd8a  bl  6198 <Xil_In32>
      XSDPS_RESP1_OFFSET);
  CSD[2] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16b6c: e5940004  ldr r0, [r4, #4]
   16b70: e2800018  add r0, r0, #24
   16b74: ebffbd87  bl  6198 <Xil_In32>
      XSDPS_RESP2_OFFSET);
  CSD[3] = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16b78: e5940004  ldr r0, [r4, #4]
   16b7c: e280001c  add r0, r0, #28
   16b80: ebffbd84  bl  6198 <Xil_In32>
      XSDPS_RESP3_OFFSET);

  Status = XST_SUCCESS;

RETURN_PATH:
  return Status;
   16b84: eaffffb4  b 16a5c <XSdPs_MmcCardInitialize+0xa4>
  u32 PresentStateReg;
  u32 Status;
  u32 RespOCR = 0x0;
  u32 CSD[4];

  Xil_AssertNonvoid(InstancePtr != NULL);
   16b88: e3080798  movw  r0, #34712  ; 0x8798
   16b8c: e30013d9  movw  r1, #985  ; 0x3d9
   16b90: e3400001  movt  r0, #1
   16b94: e1a05004  mov r5, r4
   16b98: ebffc93c  bl  9090 <Xil_Assert>
   16b9c: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16ba0: e3403002  movt  r3, #2
   16ba4: e3a02001  mov r2, #1
   16ba8: e5832000  str r2, [r3]
   16bac: eaffffaa  b 16a5c <XSdPs_MmcCardInitialize+0xa4>

00016bb0 <XSdPs_SetBlkSize>:
*
* @return None
*
******************************************************************************/
int XSdPs_SetBlkSize(XSdPs *InstancePtr, u16 BlkSize)
{
   16bb0: e92d40f8  push  {r3, r4, r5, r6, r7, lr}
  u32 Status = 0;
  u32 PresentStateReg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16bb4: e2506000  subs  r6, r0, #0
   16bb8: 0a00002a  beq 16c68 <XSdPs_SetBlkSize+0xb8>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16bbc: e5960014  ldr r0, [r6, #20]
   16bc0: e3013111  movw  r3, #4369 ; 0x1111
   16bc4: e3413111  movt  r3, #4369 ; 0x1111
int XSdPs_SetBlkSize(XSdPs *InstancePtr, u16 BlkSize)
{
  u32 Status = 0;
  u32 PresentStateReg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16bc8: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16bcc: e1500003  cmp r0, r3
int XSdPs_SetBlkSize(XSdPs *InstancePtr, u16 BlkSize)
{
  u32 Status = 0;
  u32 PresentStateReg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16bd0: e3405002  movt  r5, #2
   16bd4: e3a03000  mov r3, #0
   16bd8: e5853000  str r3, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16bdc: 0a000008  beq 16c04 <XSdPs_SetBlkSize+0x54>
   16be0: e30807a0  movw  r0, #34720  ; 0x87a0
   16be4: e3a01070  mov r1, #112  ; 0x70
   16be8: e3400001  movt  r0, #1
   16bec: e1a04003  mov r4, r3
   16bf0: ebffc926  bl  9090 <Xil_Assert>
   16bf4: e3a03001  mov r3, #1
   16bf8: e5853000  str r3, [r5]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16bfc: e1a00004  mov r0, r4
   16c00: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}
  u32 PresentStateReg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  PresentStateReg = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16c04: e5960004  ldr r0, [r6, #4]
   16c08: e1a07001  mov r7, r1
   16c0c: e2800024  add r0, r0, #36 ; 0x24
   16c10: ebffbd60  bl  6198 <Xil_In32>
      XSDPS_PRES_STATE_OFFSET);

  if (PresentStateReg & (XSDPS_PSR_INHIBIT_CMD_MASK |
   16c14: e3003303  movw  r3, #771  ; 0x303
   16c18: e0033000  and r3, r3, r0
   16c1c: e3530000  cmp r3, #0
   16c20: 0a000002  beq 16c30 <XSdPs_SetBlkSize+0x80>
*
* @return None
*
******************************************************************************/
int XSdPs_SetBlkSize(XSdPs *InstancePtr, u16 BlkSize)
{
   16c24: e3a04001  mov r4, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16c28: e1a00004  mov r0, r4
   16c2c: e8bd80f8  pop {r3, r4, r5, r6, r7, pc}


  /*
   * Send block write command
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD16, BlkSize, 0);
   16c30: e1a00006  mov r0, r6
   16c34: e3a01a01  mov r1, #4096 ; 0x1000
   16c38: e1a02007  mov r2, r7
   16c3c: ebfffda3  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16c40: e2504000  subs  r4, r0, #0
   16c44: 1afffff6  bne 16c24 <XSdPs_SetBlkSize+0x74>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16c48: e5960004  ldr r0, [r6, #4]
   16c4c: e2800010  add r0, r0, #16
   16c50: ebffbd50  bl  6198 <Xil_In32>

  /*
   * Set block size to the value passed
   */
  BlkSize &= XSDPS_BLK_SIZE_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress, XSDPS_BLK_SIZE_OFFSET,
   16c54: e5960004  ldr r0, [r6, #4]
   16c58: e7eb1057  ubfx  r1, r7, #0, #12
   16c5c: e2800004  add r0, r0, #4
   16c60: ebffbd50  bl  61a8 <Xil_Out16>
       BlkSize);

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
   16c64: eaffffe4  b 16bfc <XSdPs_SetBlkSize+0x4c>
int XSdPs_SetBlkSize(XSdPs *InstancePtr, u16 BlkSize)
{
  u32 Status = 0;
  u32 PresentStateReg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16c68: e30807a0  movw  r0, #34720  ; 0x87a0
   16c6c: e3a0106f  mov r1, #111  ; 0x6f
   16c70: e3400001  movt  r0, #1
   16c74: e1a04006  mov r4, r6
   16c78: ebffc904  bl  9090 <Xil_Assert>
   16c7c: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16c80: e3403002  movt  r3, #2
   16c84: e3a02001  mov r2, #1
   16c88: e5832000  str r2, [r3]
   16c8c: eaffffda  b 16bfc <XSdPs_SetBlkSize+0x4c>

00016c90 <XSdPs_Get_BusWidth>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Get_BusWidth(XSdPs *InstancePtr, u8 *SCR)
{
   16c90: e92d4070  push  {r4, r5, r6, lr}
  u32 StatusReg = 0x0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16c94: e2505000  subs  r5, r0, #0
   16c98: 0a000045  beq 16db4 <XSdPs_Get_BusWidth+0x124>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16c9c: e5952014  ldr r2, [r5, #20]
   16ca0: e3013111  movw  r3, #4369 ; 0x1111
   16ca4: e3413111  movt  r3, #4369 ; 0x1111
  u32 StatusReg = 0x0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16ca8: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16cac: e1520003  cmp r2, r3
  u32 StatusReg = 0x0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16cb0: e3406002  movt  r6, #2
   16cb4: e3a0c000  mov ip, #0
   16cb8: e586c000  str ip, [r6]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16cbc: 1a00000f  bne 16d00 <XSdPs_Get_BusWidth+0x70>
   16cc0: e2413001  sub r3, r1, #1
   16cc4: e281e007  add lr, r1, #7
   16cc8: e1a04001  mov r4, r1

  for (LoopCnt = 0; LoopCnt < 8; LoopCnt++) {
    SCR[LoopCnt] = 0;
   16ccc: e5e3c001  strb  ip, [r3, #1]!
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  for (LoopCnt = 0; LoopCnt < 8; LoopCnt++) {
   16cd0: e153000e  cmp r3, lr
   16cd4: 1afffffc  bne 16ccc <XSdPs_Get_BusWidth+0x3c>
  }

  /*
   * Send block write command
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD55,
   16cd8: e1a00005  mov r0, r5
   16cdc: e3a01c37  mov r1, #14080  ; 0x3700
   16ce0: e5952030  ldr r2, [r5, #48] ; 0x30
   16ce4: e3a03000  mov r3, #0
   16ce8: ebfffd78  bl  162d0 <XSdPs_CmdTransfer>
      InstancePtr->RelCardAddr, 0);
  if (Status != XST_SUCCESS) {
   16cec: e2506000  subs  r6, r0, #0
   16cf0: 0a00000b  beq 16d24 <XSdPs_Get_BusWidth+0x94>
*
* @note   None.
*
******************************************************************************/
int XSdPs_Get_BusWidth(XSdPs *InstancePtr, u8 *SCR)
{
   16cf4: e3a04001  mov r4, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16cf8: e1a00004  mov r0, r4
   16cfc: e8bd8070  pop {r4, r5, r6, pc}
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16d00: e30807a0  movw  r0, #34720  ; 0x87a0
   16d04: e1a0400c  mov r4, ip
   16d08: e3a010b0  mov r1, #176  ; 0xb0
   16d0c: e3400001  movt  r0, #1
   16d10: ebffc8de  bl  9090 <Xil_Assert>
   16d14: e3a03001  mov r3, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16d18: e1a00004  mov r0, r4
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16d1c: e5863000  str r3, [r6]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16d20: e8bd8070  pop {r4, r5, r6, pc}

  /*
   * Set block size to the value passed
   */
  BlkSize &= XSDPS_BLK_SIZE_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16d24: e5950004  ldr r0, [r5, #4]
   16d28: e3a01008  mov r1, #8
   16d2c: e2800004  add r0, r0, #4
   16d30: ebffbd1c  bl  61a8 <Xil_Out16>
      XSDPS_BLK_SIZE_OFFSET, BlkSize);

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, SCR);
   16d34: e1a02004  mov r2, r4
   16d38: e1a00005  mov r0, r5
   16d3c: e3a01001  mov r1, #1
   16d40: ebfffe67  bl  166e4 <XSdPs_SetupADMA2DescTbl>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16d44: e5950004  ldr r0, [r5, #4]
   16d48: e3a01011  mov r1, #17
   16d4c: e280000c  add r0, r0, #12
   16d50: ebffbd14  bl  61a8 <Xil_Out16>
      XSDPS_XFER_MODE_OFFSET,
      XSDPS_TM_DAT_DIR_SEL_MASK | XSDPS_TM_DMA_EN_MASK);

  Xil_DCacheInvalidateRange(SCR, 8);
   16d54: e1a00004  mov r0, r4
   16d58: e3a01008  mov r1, #8
   16d5c: ebffbc6a  bl  5f0c <Xil_DCacheInvalidateRange>

  Status = XSdPs_CmdTransfer(InstancePtr, ACMD51, 0, BlkCnt);
   16d60: e1a00005  mov r0, r5
   16d64: e1a02006  mov r2, r6
   16d68: e3a01cb3  mov r1, #45824  ; 0xb300
   16d6c: e3a03001  mov r3, #1
   16d70: ebfffd56  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16d74: e2504000  subs  r4, r0, #0
   16d78: 1affffdd  bne 16cf4 <XSdPs_Get_BusWidth+0x64>
   16d7c: ea000001  b 16d88 <XSdPs_Get_BusWidth+0xf8>
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   16d80: e3100002  tst r0, #2
   16d84: 1a000014  bne 16ddc <XSdPs_Get_BusWidth+0x14c>
  /*
   * Check for transfer complete
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16d88: e5950004  ldr r0, [r5, #4]
   16d8c: e2800030  add r0, r0, #48 ; 0x30
   16d90: ebffbcfe  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   16d94: e3100902  tst r0, #32768  ; 0x8000
   16d98: 0afffff8  beq 16d80 <XSdPs_Get_BusWidth+0xf0>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16d9c: e5950004  ldr r0, [r5, #4]
   16da0: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   16da4: e3a04001  mov r4, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16da8: e2800032  add r0, r0, #50 ; 0x32
   16dac: ebffbcfd  bl  61a8 <Xil_Out16>
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   16db0: eaffffd0  b 16cf8 <XSdPs_Get_BusWidth+0x68>
  u32 StatusReg = 0x0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16db4: e30807a0  movw  r0, #34720  ; 0x87a0
   16db8: e3a010af  mov r1, #175  ; 0xaf
   16dbc: e3400001  movt  r0, #1
   16dc0: e1a04005  mov r4, r5
   16dc4: ebffc8b1  bl  9090 <Xil_Assert>
   16dc8: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16dcc: e3403002  movt  r3, #2
   16dd0: e3a02001  mov r2, #1
   16dd4: e5832000  str r2, [r3]
   16dd8: eaffffc6  b 16cf8 <XSdPs_Get_BusWidth+0x68>
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16ddc: e5950004  ldr r0, [r5, #4]
   16de0: e3a01002  mov r1, #2
   16de4: e2800030  add r0, r0, #48 ; 0x30
   16de8: ebffbcee  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_INTR_TC_MASK);

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16dec: e5950004  ldr r0, [r5, #4]
   16df0: e2800010  add r0, r0, #16
   16df4: ebffbce7  bl  6198 <Xil_In32>
      XSDPS_RESP0_OFFSET);

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
   16df8: eaffffbe  b 16cf8 <XSdPs_Get_BusWidth+0x68>

00016dfc <XSdPs_Change_BusWidth>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Change_BusWidth(XSdPs *InstancePtr)
{
   16dfc: e92d4070  push  {r4, r5, r6, lr}
  u32 Status = 0;
  u32 StatusReg = 0x0;
  u32 Arg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16e00: e2506000  subs  r6, r0, #0
   16e04: 0a00002b  beq 16eb8 <XSdPs_Change_BusWidth+0xbc>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16e08: e5962014  ldr r2, [r6, #20]
   16e0c: e3013111  movw  r3, #4369 ; 0x1111
   16e10: e3413111  movt  r3, #4369 ; 0x1111
{
  u32 Status = 0;
  u32 StatusReg = 0x0;
  u32 Arg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16e14: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16e18: e1520003  cmp r2, r3
{
  u32 Status = 0;
  u32 StatusReg = 0x0;
  u32 Arg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16e1c: e3405002  movt  r5, #2
   16e20: e3a03000  mov r3, #0
   16e24: e5853000  str r3, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16e28: 0a000008  beq 16e50 <XSdPs_Change_BusWidth+0x54>
   16e2c: e30807a0  movw  r0, #34720  ; 0x87a0
   16e30: e3001111  movw  r1, #273  ; 0x111
   16e34: e3400001  movt  r0, #1
   16e38: e1a04003  mov r4, r3
   16e3c: ebffc893  bl  9090 <Xil_Assert>
   16e40: e3a03001  mov r3, #1
   16e44: e5853000  str r3, [r5]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16e48: e1a00004  mov r0, r4
   16e4c: e8bd8070  pop {r4, r5, r6, pc}
  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

#ifndef MMC_CARD

  Status = XSdPs_CmdTransfer(InstancePtr, CMD55,
   16e50: e3a01c37  mov r1, #14080  ; 0x3700
   16e54: e5962030  ldr r2, [r6, #48] ; 0x30
   16e58: ebfffd1c  bl  162d0 <XSdPs_CmdTransfer>
      InstancePtr->RelCardAddr, 0);
  if (Status != XST_SUCCESS) {
   16e5c: e2503000  subs  r3, r0, #0
   16e60: 0a000002  beq 16e70 <XSdPs_Change_BusWidth+0x74>
*
* @note   None.
*
******************************************************************************/
int XSdPs_Change_BusWidth(XSdPs *InstancePtr)
{
   16e64: e3a04001  mov r4, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16e68: e1a00004  mov r0, r4
   16e6c: e8bd8070  pop {r4, r5, r6, pc}
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  Arg = XSDPS_4_BIT_WIDTH;
  Status = XSdPs_CmdTransfer(InstancePtr, ACMD6, Arg, 0);
   16e70: e1a00006  mov r0, r6
   16e74: e3a01c86  mov r1, #34304  ; 0x8600
   16e78: e3a02002  mov r2, #2
   16e7c: ebfffd13  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16e80: e2504000  subs  r4, r0, #0
   16e84: 1afffff6  bne 16e64 <XSdPs_Change_BusWidth+0x68>
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  StatusReg = XSdPs_ReadReg8(InstancePtr->Config.BaseAddress,
   16e88: e5960004  ldr r0, [r6, #4]
   16e8c: e2800028  add r0, r0, #40 ; 0x28
   16e90: ebffbcbc  bl  6188 <Xil_In8>
          XSDPS_HOST_CTRL1_OFFSET);
  StatusReg |= XSDPS_HC_WIDTH_MASK;
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   16e94: e5963004  ldr r3, [r6, #4]
    goto RETURN_PATH;
  }

  StatusReg = XSdPs_ReadReg8(InstancePtr->Config.BaseAddress,
          XSDPS_HOST_CTRL1_OFFSET);
  StatusReg |= XSDPS_HC_WIDTH_MASK;
   16e98: e3801002  orr r1, r0, #2
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   16e9c: e2830028  add r0, r3, #40 ; 0x28
   16ea0: e6ef1071  uxtb  r1, r1
   16ea4: ebffbcbd  bl  61a0 <Xil_Out8>
      XSDPS_HOST_CTRL1_OFFSET,StatusReg);

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16ea8: e5960004  ldr r0, [r6, #4]
   16eac: e2800010  add r0, r0, #16
   16eb0: ebffbcb8  bl  6198 <Xil_In32>
#endif

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
   16eb4: eaffffe3  b 16e48 <XSdPs_Change_BusWidth+0x4c>
{
  u32 Status = 0;
  u32 StatusReg = 0x0;
  u32 Arg = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16eb8: e30807a0  movw  r0, #34720  ; 0x87a0
   16ebc: e3a01e11  mov r1, #272  ; 0x110
   16ec0: e3400001  movt  r0, #1
   16ec4: e1a04006  mov r4, r6
   16ec8: ebffc870  bl  9090 <Xil_Assert>
   16ecc: e3023ae8  movw  r3, #10984  ; 0x2ae8
   16ed0: e3403002  movt  r3, #2
   16ed4: e3a02001  mov r2, #1
   16ed8: e5832000  str r2, [r3]
   16edc: eaffffd9  b 16e48 <XSdPs_Change_BusWidth+0x4c>

00016ee0 <XSdPs_Get_BusSpeed>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Get_BusSpeed(XSdPs *InstancePtr, u8 *ReadBuff)
{
   16ee0: e92d4070  push  {r4, r5, r6, lr}
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16ee4: e2505000  subs  r5, r0, #0
   16ee8: 0a000048  beq 17010 <XSdPs_Get_BusSpeed+0x130>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16eec: e5952014  ldr r2, [r5, #20]
   16ef0: e3013111  movw  r3, #4369 ; 0x1111
   16ef4: e3413111  movt  r3, #4369 ; 0x1111
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16ef8: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16efc: e1520003  cmp r2, r3
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   16f00: e3406002  movt  r6, #2
   16f04: e3a0c000  mov ip, #0
   16f08: e586c000  str ip, [r6]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16f0c: 1a00002d  bne 16fc8 <XSdPs_Get_BusSpeed+0xe8>
   16f10: e2413001  sub r3, r1, #1
   16f14: e281e03f  add lr, r1, #63 ; 0x3f
   16f18: e1a04001  mov r4, r1

  for (LoopCnt = 0; LoopCnt < 64; LoopCnt++) {
    ReadBuff[LoopCnt] = 0;
   16f1c: e5e3c001  strb  ip, [r3, #1]!
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  for (LoopCnt = 0; LoopCnt < 64; LoopCnt++) {
   16f20: e153000e  cmp r3, lr
   16f24: 1afffffc  bne 16f1c <XSdPs_Get_BusSpeed+0x3c>
  }

  BlkCnt = XSDPS_SWITCH_CMD_BLKCNT;
  BlkSize = XSDPS_SWITCH_CMD_BLKSIZE;
  BlkSize &= XSDPS_BLK_SIZE_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16f28: e5950004  ldr r0, [r5, #4]
   16f2c: e3a01040  mov r1, #64 ; 0x40
   16f30: e2800004  add r0, r0, #4
   16f34: ebffbc9b  bl  61a8 <Xil_Out16>
      XSDPS_BLK_SIZE_OFFSET, BlkSize);

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, ReadBuff);
   16f38: e1a02004  mov r2, r4
   16f3c: e1a00005  mov r0, r5
   16f40: e3a01001  mov r1, #1
   16f44: ebfffde6  bl  166e4 <XSdPs_SetupADMA2DescTbl>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16f48: e5950004  ldr r0, [r5, #4]
   16f4c: e3a01011  mov r1, #17
   16f50: e280000c  add r0, r0, #12
   16f54: ebffbc93  bl  61a8 <Xil_Out16>
      XSDPS_XFER_MODE_OFFSET,
      XSDPS_TM_DAT_DIR_SEL_MASK | XSDPS_TM_DMA_EN_MASK);

  Arg = XSDPS_SWITCH_CMD_HS_GET;

  Xil_DCacheInvalidateRange(ReadBuff, 64);
   16f58: e1a00004  mov r0, r4
   16f5c: e3a01040  mov r1, #64 ; 0x40
   16f60: ebffbbe9  bl  5f0c <Xil_DCacheInvalidateRange>

  Status = XSdPs_CmdTransfer(InstancePtr, CMD6, Arg, 1);
   16f64: e30f2ff0  movw  r2, #65520  ; 0xfff0
   16f68: e1a00005  mov r0, r5
   16f6c: e3a01c06  mov r1, #1536 ; 0x600
   16f70: e34020ff  movt  r2, #255  ; 0xff
   16f74: e3a03001  mov r3, #1
   16f78: ebfffcd4  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   16f7c: e2504000  subs  r4, r0, #0
   16f80: 13a04001  movne r4, #1
   16f84: 0a000003  beq 16f98 <XSdPs_Get_BusSpeed+0xb8>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16f88: e1a00004  mov r0, r4
   16f8c: e8bd8070  pop {r4, r5, r6, pc}
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   16f90: e3100002  tst r0, #2
   16f94: 1a000014  bne 16fec <XSdPs_Get_BusSpeed+0x10c>
  /*
   * Check for transfer complete
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   16f98: e5950004  ldr r0, [r5, #4]
   16f9c: e2800030  add r0, r0, #48 ; 0x30
   16fa0: ebffbc7a  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   16fa4: e3100902  tst r0, #32768  ; 0x8000
   16fa8: 0afffff8  beq 16f90 <XSdPs_Get_BusSpeed+0xb0>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16fac: e5950004  ldr r0, [r5, #4]
   16fb0: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   16fb4: e3a04001  mov r4, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16fb8: e2800032  add r0, r0, #50 ; 0x32
   16fbc: ebffbc79  bl  61a8 <Xil_Out16>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16fc0: e1a00004  mov r0, r4
   16fc4: e8bd8070  pop {r4, r5, r6, pc}
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16fc8: e30807a0  movw  r0, #34720  ; 0x87a0
   16fcc: e1a0400c  mov r4, ip
   16fd0: e300116f  movw  r1, #367  ; 0x16f
   16fd4: e3400001  movt  r0, #1
   16fd8: ebffc82c  bl  9090 <Xil_Assert>
   16fdc: e3a03001  mov r3, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16fe0: e1a00004  mov r0, r4
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   16fe4: e5863000  str r3, [r6]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   16fe8: e8bd8070  pop {r4, r5, r6, pc}
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   16fec: e5950004  ldr r0, [r5, #4]
   16ff0: e3a01002  mov r1, #2
   16ff4: e2800030  add r0, r0, #48 ; 0x30
   16ff8: ebffbc6a  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_INTR_TC_MASK);

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   16ffc: e5950004  ldr r0, [r5, #4]
   17000: e2800010  add r0, r0, #16
   17004: ebffbc63  bl  6198 <Xil_In32>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   17008: e1a00004  mov r0, r4
   1700c: e8bd8070  pop {r4, r5, r6, pc}
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17010: e30807a0  movw  r0, #34720  ; 0x87a0
   17014: e300116e  movw  r1, #366  ; 0x16e
   17018: e3400001  movt  r0, #1
   1701c: e1a04005  mov r4, r5
   17020: ebffc81a  bl  9090 <Xil_Assert>
   17024: e3023ae8  movw  r3, #10984  ; 0x2ae8
   17028: e3403002  movt  r3, #2
   1702c: e3a02001  mov r2, #1
   17030: e5832000  str r2, [r3]
   17034: eaffffd3  b 16f88 <XSdPs_Get_BusSpeed+0xa8>

00017038 <XSdPs_Change_ClkFreq>:
* @note   This API will change clock frequency to the value less than
*   or equal to the given value using the permissible dividors.
*
******************************************************************************/
int XSdPs_Change_ClkFreq(XSdPs *InstancePtr, u32 SelFreq)
{
   17038: e92d41f0  push  {r4, r5, r6, r7, r8, lr}
  int DivCnt;
  u16 Divisor;
  u16 ClkLoopCnt;
  int Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   1703c: e2506000  subs  r6, r0, #0
   17040: 0a000043  beq 17154 <XSdPs_Change_ClkFreq+0x11c>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17044: e5962014  ldr r2, [r6, #20]
   17048: e3013111  movw  r3, #4369 ; 0x1111
   1704c: e3413111  movt  r3, #4369 ; 0x1111
  int DivCnt;
  u16 Divisor;
  u16 ClkLoopCnt;
  int Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17050: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17054: e1520003  cmp r2, r3
  int DivCnt;
  u16 Divisor;
  u16 ClkLoopCnt;
  int Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17058: e3405002  movt  r5, #2
   1705c: e3a04000  mov r4, #0
   17060: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17064: 0a000007  beq 17088 <XSdPs_Change_ClkFreq+0x50>
   17068: e30807a0  movw  r0, #34720  ; 0x87a0
   1706c: e3a01e25  mov r1, #592  ; 0x250
   17070: e3400001  movt  r0, #1
   17074: ebffc805  bl  9090 <Xil_Assert>
   17078: e3a03001  mov r3, #1
   1707c: e1a00004  mov r0, r4
   17080: e5853000  str r3, [r5]
   17084: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

  /*
   * Disable clock
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   17088: e5960004  ldr r0, [r6, #4]
   1708c: e1a07001  mov r7, r1
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= ~(XSDPS_CC_INT_CLK_EN_MASK | XSDPS_CC_SD_CLK_EN_MASK);

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17090: e3a04009  mov r4, #9
      XSDPS_CLK_CTRL_OFFSET, ClockReg);

  /*
   * Calculate divisor
   */
  DivCnt = 0x1;
   17094: e3a05001  mov r5, #1
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  /*
   * Disable clock
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   17098: e280002c  add r0, r0, #44 ; 0x2c
   1709c: ebffbc3b  bl  6190 <Xil_In16>
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= ~(XSDPS_CC_INT_CLK_EN_MASK | XSDPS_CC_SD_CLK_EN_MASK);

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   170a0: e5963004  ldr r3, [r6, #4]
  /*
   * Disable clock
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= ~(XSDPS_CC_INT_CLK_EN_MASK | XSDPS_CC_SD_CLK_EN_MASK);
   170a4: e3c01005  bic r1, r0, #5

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   170a8: e283002c  add r0, r3, #44 ; 0x2c
   170ac: e6ff1071  uxth  r1, r1
   170b0: ebffbc3c  bl  61a8 <Xil_Out16>
   170b4: e5968008  ldr r8, [r6, #8]
   * Calculate divisor
   */
  DivCnt = 0x1;
  for(ClkLoopCnt = 0; ClkLoopCnt < XSDPS_CC_MAX_NUM_OF_DIV;
    ClkLoopCnt++) {
    if( ((InstancePtr->Config.InputClockHz)/DivCnt) <= SelFreq) {
   170b8: e1a00008  mov r0, r8
   170bc: e1a01005  mov r1, r5
   170c0: ebffc83a  bl  91b0 <__aeabi_uidiv>
   170c4: e2444001  sub r4, r4, #1
   170c8: e6ff4074  uxth  r4, r4
   170cc: e1500007  cmp r0, r7
   170d0: 9a000004  bls 170e8 <XSdPs_Change_ClkFreq+0xb0>

  /*
   * Calculate divisor
   */
  DivCnt = 0x1;
  for(ClkLoopCnt = 0; ClkLoopCnt < XSDPS_CC_MAX_NUM_OF_DIV;
   170d4: e3540000  cmp r4, #0
    if( ((InstancePtr->Config.InputClockHz)/DivCnt) <= SelFreq) {
      Divisor = DivCnt/2;
      Divisor = Divisor << XSDPS_CC_DIV_SHIFT;
      break;
    }
    DivCnt = DivCnt << 1;
   170d8: e1a05085  lsl r5, r5, #1

  /*
   * Calculate divisor
   */
  DivCnt = 0x1;
  for(ClkLoopCnt = 0; ClkLoopCnt < XSDPS_CC_MAX_NUM_OF_DIV;
   170dc: 1afffff5  bne 170b8 <XSdPs_Change_ClkFreq+0x80>
  if(ClkLoopCnt == 9) {

    /*
     * No valid divisor found for given frequency
     */
    Status = XST_FAILURE;
   170e0: e3a00001  mov r0, #1
   170e4: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  }

  /*
   * Set clock divisor
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   170e8: e5960004  ldr r0, [r6, #4]
   */
  DivCnt = 0x1;
  for(ClkLoopCnt = 0; ClkLoopCnt < XSDPS_CC_MAX_NUM_OF_DIV;
    ClkLoopCnt++) {
    if( ((InstancePtr->Config.InputClockHz)/DivCnt) <= SelFreq) {
      Divisor = DivCnt/2;
   170ec: e0855fa5  add r5, r5, r5, lsr #31
   170f0: e7ef50d5  ubfx  r5, r5, #1, #16
  }

  /*
   * Set clock divisor
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   170f4: e280002c  add r0, r0, #44 ; 0x2c
   170f8: ebffbc24  bl  6190 <Xil_In16>
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= (~XSDPS_CC_SDCLK_FREQ_SEL_MASK);

  ClockReg |= Divisor | XSDPS_CC_INT_CLK_EN_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   170fc: e5963004  ldr r3, [r6, #4]
  /*
   * Set clock divisor
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= (~XSDPS_CC_SDCLK_FREQ_SEL_MASK);
   17100: e6ef1070  uxtb  r1, r0

  ClockReg |= Divisor | XSDPS_CC_INT_CLK_EN_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17104: e283002c  add r0, r3, #44 ; 0x2c
   17108: e3811001  orr r1, r1, #1
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
      XSDPS_CLK_CTRL_OFFSET);
  ClockReg &= (~XSDPS_CC_SDCLK_FREQ_SEL_MASK);

  ClockReg |= Divisor | XSDPS_CC_INT_CLK_EN_MASK;
   1710c: e1811405  orr r1, r1, r5, lsl #8
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17110: e6ff1071  uxth  r1, r1
   17114: ebffbc23  bl  61a8 <Xil_Out16>
      XSDPS_CLK_CTRL_OFFSET, ClockReg);

  /*
   * Wait for internal clock to stabilize
   */
  while((XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   17118: e5960004  ldr r0, [r6, #4]
   1711c: e280002c  add r0, r0, #44 ; 0x2c
   17120: ebffbc1a  bl  6190 <Xil_In16>
   17124: e3100002  tst r0, #2
   17128: 0afffffa  beq 17118 <XSdPs_Change_ClkFreq+0xe0>
    XSDPS_CLK_CTRL_OFFSET) & XSDPS_CC_INT_CLK_STABLE_MASK) == 0);

  /*
   * Enable SD clock
   */
  ClockReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   1712c: e5960004  ldr r0, [r6, #4]
   17130: e280002c  add r0, r0, #44 ; 0x2c
   17134: ebffbc15  bl  6190 <Xil_In16>
      XSDPS_CLK_CTRL_OFFSET);
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17138: e5963004  ldr r3, [r6, #4]
   1713c: e3801004  orr r1, r0, #4
   17140: e283002c  add r0, r3, #44 ; 0x2c
   17144: e6ff1071  uxth  r1, r1
   17148: ebffbc16  bl  61a8 <Xil_Out16>
      XSDPS_CLK_CTRL_OFFSET,
      ClockReg | XSDPS_CC_SD_CLK_EN_MASK);

  Status = XST_SUCCESS;
   1714c: e3a00000  mov r0, #0

  RETURN_PATH:
    return Status;

}
   17150: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}
  int DivCnt;
  u16 Divisor;
  u16 ClkLoopCnt;
  int Status;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17154: e30807a0  movw  r0, #34720  ; 0x87a0
   17158: e300124f  movw  r1, #591  ; 0x24f
   1715c: e3400001  movt  r0, #1
   17160: ebffc7ca  bl  9090 <Xil_Assert>
   17164: e3023ae8  movw  r3, #10984  ; 0x2ae8
   17168: e3403002  movt  r3, #2
   1716c: e3a02001  mov r2, #1
   17170: e1a00006  mov r0, r6
   17174: e5832000  str r2, [r3]
   17178: e8bd81f0  pop {r4, r5, r6, r7, r8, pc}

0001717c <XSdPs_Change_BusSpeed>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Change_BusSpeed(XSdPs *InstancePtr)
{
   1717c: e92d4070  push  {r4, r5, r6, lr}
  u8 ReadBuff[64];
  u16 BlkCnt;
  u16 BlkSize;
#endif

  Xil_AssertNonvoid(InstancePtr != NULL);
   17180: e2504000  subs  r4, r0, #0
*
* @note   None.
*
******************************************************************************/
int XSdPs_Change_BusSpeed(XSdPs *InstancePtr)
{
   17184: e24dd040  sub sp, sp, #64 ; 0x40
  u8 ReadBuff[64];
  u16 BlkCnt;
  u16 BlkSize;
#endif

  Xil_AssertNonvoid(InstancePtr != NULL);
   17188: 0a000050  beq 172d0 <XSdPs_Change_BusSpeed+0x154>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   1718c: e5942014  ldr r2, [r4, #20]
   17190: e3013111  movw  r3, #4369 ; 0x1111
   17194: e3413111  movt  r3, #4369 ; 0x1111
  u8 ReadBuff[64];
  u16 BlkCnt;
  u16 BlkSize;
#endif

  Xil_AssertNonvoid(InstancePtr != NULL);
   17198: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   1719c: e1520003  cmp r2, r3
  u8 ReadBuff[64];
  u16 BlkCnt;
  u16 BlkSize;
#endif

  Xil_AssertNonvoid(InstancePtr != NULL);
   171a0: e3405002  movt  r5, #2
   171a4: e3a03000  mov r3, #0
   171a8: e5853000  str r3, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   171ac: 0a000009  beq 171d8 <XSdPs_Change_BusSpeed+0x5c>
   171b0: e30807a0  movw  r0, #34720  ; 0x87a0
   171b4: e30011cb  movw  r1, #459  ; 0x1cb
   171b8: e3400001  movt  r0, #1
   171bc: e1a06003  mov r6, r3
   171c0: ebffc7b2  bl  9090 <Xil_Assert>
   171c4: e3a03001  mov r3, #1
   171c8: e5853000  str r3, [r5]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   171cc: e1a00006  mov r0, r6
   171d0: e28dd040  add sp, sp, #64 ; 0x40
   171d4: e8bd8070  pop {r4, r5, r6, pc}
#ifndef MMC_CARD

  BlkCnt = XSDPS_SWITCH_CMD_BLKCNT;
  BlkSize = XSDPS_SWITCH_CMD_BLKSIZE;
  BlkSize &= XSDPS_BLK_SIZE_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   171d8: e5940004  ldr r0, [r4, #4]
   171dc: e3a01040  mov r1, #64 ; 0x40
   171e0: e2800004  add r0, r0, #4
   171e4: ebffbbef  bl  61a8 <Xil_Out16>
      XSDPS_BLK_SIZE_OFFSET, BlkSize);

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, ReadBuff);
   171e8: e1a0200d  mov r2, sp
   171ec: e1a00004  mov r0, r4
   171f0: e3a01001  mov r1, #1
   171f4: ebfffd3a  bl  166e4 <XSdPs_SetupADMA2DescTbl>

  Xil_DCacheInvalidateRange(ReadBuff, 64);
   171f8: e3a01040  mov r1, #64 ; 0x40
   171fc: e1a0000d  mov r0, sp
   17200: ebffbb41  bl  5f0c <Xil_DCacheInvalidateRange>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17204: e5940004  ldr r0, [r4, #4]
   17208: e3a01011  mov r1, #17
   1720c: e280000c  add r0, r0, #12
   17210: ebffbbe4  bl  61a8 <Xil_Out16>
      XSDPS_XFER_MODE_OFFSET,
      XSDPS_TM_DAT_DIR_SEL_MASK | XSDPS_TM_DMA_EN_MASK);

  Arg = XSDPS_SWITCH_CMD_HS_SET;
  Status = XSdPs_CmdTransfer(InstancePtr, CMD6, Arg, 1);
   17214: e30f2ff1  movw  r2, #65521  ; 0xfff1
   17218: e1a00004  mov r0, r4
   1721c: e3a01c06  mov r1, #1536 ; 0x600
   17220: e34820ff  movt  r2, #33023  ; 0x80ff
   17224: e3a03001  mov r3, #1
   17228: ebfffc28  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   1722c: e3500000  cmp r0, #0
   17230: 0a000005  beq 1724c <XSdPs_Change_BusSpeed+0xd0>
*
* @note   None.
*
******************************************************************************/
int XSdPs_Change_BusSpeed(XSdPs *InstancePtr)
{
   17234: e3a06001  mov r6, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   17238: e1a00006  mov r0, r6
   1723c: e28dd040  add sp, sp, #64 ; 0x40
   17240: e8bd8070  pop {r4, r5, r6, pc}
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   17244: e3100002  tst r0, #2
   17248: 1a00000a  bne 17278 <XSdPs_Change_BusSpeed+0xfc>
  /*
   * Check for transfer complete
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   1724c: e5940004  ldr r0, [r4, #4]
   17250: e2800030  add r0, r0, #48 ; 0x30
   17254: ebffbbcd  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   17258: e3100902  tst r0, #32768  ; 0x8000
   1725c: 0afffff8  beq 17244 <XSdPs_Change_BusSpeed+0xc8>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17260: e5940004  ldr r0, [r4, #4]
   17264: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   17268: e3a06001  mov r6, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   1726c: e2800032  add r0, r0, #50 ; 0x32
   17270: ebffbbcc  bl  61a8 <Xil_Out16>
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   17274: eaffffd4  b 171cc <XSdPs_Change_BusSpeed+0x50>
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17278: e5940004  ldr r0, [r4, #4]
   1727c: e3a01002  mov r1, #2
   17280: e2800030  add r0, r0, #48 ; 0x30
   17284: ebffbbc7  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_INTR_TC_MASK);

  /*
   * Change the clock frequency to 50 MHz
   */
  Status = XSdPs_Change_ClkFreq(InstancePtr, XSDPS_CLK_50_MHZ);
   17288: e30f1080  movw  r1, #61568  ; 0xf080
   1728c: e1a00004  mov r0, r4
   17290: e34012fa  movt  r1, #762  ; 0x2fa
   17294: ebffff67  bl  17038 <XSdPs_Change_ClkFreq>
  if (Status != XST_SUCCESS) {
   17298: e2506000  subs  r6, r0, #0
   1729c: 1affffe4  bne 17234 <XSdPs_Change_BusSpeed+0xb8>
      Status = XST_FAILURE;
      goto RETURN_PATH;
  }

  StatusReg = XSdPs_ReadReg8(InstancePtr->Config.BaseAddress,
   172a0: e5940004  ldr r0, [r4, #4]
   172a4: e2800028  add r0, r0, #40 ; 0x28
   172a8: ebffbbb6  bl  6188 <Xil_In8>
          XSDPS_HOST_CTRL1_OFFSET);
  StatusReg |= XSDPS_HC_SPEED_MASK;
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   172ac: e5943004  ldr r3, [r4, #4]
      goto RETURN_PATH;
  }

  StatusReg = XSdPs_ReadReg8(InstancePtr->Config.BaseAddress,
          XSDPS_HOST_CTRL1_OFFSET);
  StatusReg |= XSDPS_HC_SPEED_MASK;
   172b0: e3801004  orr r1, r0, #4
  XSdPs_WriteReg8(InstancePtr->Config.BaseAddress,
   172b4: e2830028  add r0, r3, #40 ; 0x28
   172b8: e6ef1071  uxtb  r1, r1
   172bc: ebffbbb7  bl  61a0 <Xil_Out8>
      XSDPS_HOST_CTRL1_OFFSET,StatusReg);

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   172c0: e5940004  ldr r0, [r4, #4]
   172c4: e2800010  add r0, r0, #16
   172c8: ebffbbb2  bl  6198 <Xil_In32>
#endif

  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;
   172cc: eaffffbe  b 171cc <XSdPs_Change_BusSpeed+0x50>
  u8 ReadBuff[64];
  u16 BlkCnt;
  u16 BlkSize;
#endif

  Xil_AssertNonvoid(InstancePtr != NULL);
   172d0: e30807a0  movw  r0, #34720  ; 0x87a0
   172d4: e30011ca  movw  r1, #458  ; 0x1ca
   172d8: e3400001  movt  r0, #1
   172dc: e1a06004  mov r6, r4
   172e0: ebffc76a  bl  9090 <Xil_Assert>
   172e4: e3023ae8  movw  r3, #10984  ; 0x2ae8
   172e8: e3403002  movt  r3, #2
   172ec: e3a02001  mov r2, #1
   172f0: e5832000  str r2, [r3]
   172f4: eaffffb4  b 171cc <XSdPs_Change_BusSpeed+0x50>

000172f8 <XSdPs_Pullup>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Pullup(XSdPs *InstancePtr)
{
   172f8: e92d4070  push  {r4, r5, r6, lr}
  u32 Status = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   172fc: e2506000  subs  r6, r0, #0
   17300: 0a00001f  beq 17384 <XSdPs_Pullup+0x8c>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17304: e5963014  ldr r3, [r6, #20]
   17308: e3012111  movw  r2, #4369 ; 0x1111
   1730c: e3412111  movt  r2, #4369 ; 0x1111
******************************************************************************/
int XSdPs_Pullup(XSdPs *InstancePtr)
{
  u32 Status = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17310: e3025ae8  movw  r5, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17314: e1530002  cmp r3, r2
******************************************************************************/
int XSdPs_Pullup(XSdPs *InstancePtr)
{
  u32 Status = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17318: e3405002  movt  r5, #2
   1731c: e3a04000  mov r4, #0
   17320: e5854000  str r4, [r5]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17324: 0a000007  beq 17348 <XSdPs_Pullup+0x50>
   17328: e30807a0  movw  r0, #34720  ; 0x87a0
   1732c: e3a01faa  mov r1, #680  ; 0x2a8
   17330: e3400001  movt  r0, #1
   17334: ebffc755  bl  9090 <Xil_Assert>
   17338: e3a03001  mov r3, #1
   1733c: e1a00004  mov r0, r4
   17340: e5853000  str r3, [r5]
   17344: e8bd8070  pop {r4, r5, r6, pc}

  Status = XSdPs_CmdTransfer(InstancePtr, CMD55,
   17348: e5962030  ldr r2, [r6, #48] ; 0x30
   1734c: e1a03004  mov r3, r4
   17350: e3a01c37  mov r1, #14080  ; 0x3700
   17354: ebfffbdd  bl  162d0 <XSdPs_CmdTransfer>
      InstancePtr->RelCardAddr, 0);
  if (Status != XST_SUCCESS) {
   17358: e2502000  subs  r2, r0, #0
   1735c: 0a000001  beq 17368 <XSdPs_Pullup+0x70>
   17360: e3a00001  mov r0, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   17364: e8bd8070  pop {r4, r5, r6, pc}
  if (Status != XST_SUCCESS) {
    Status = XST_FAILURE;
    goto RETURN_PATH;
  }

  Status = XSdPs_CmdTransfer(InstancePtr, ACMD42, 0, 0);
   17368: e1a00006  mov r0, r6
   1736c: e3a01caa  mov r1, #43520  ; 0xaa00
   17370: e1a03002  mov r3, r2
   17374: ebfffbd5  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   17378: e2900000  adds  r0, r0, #0
   1737c: 13a00001  movne r0, #1
   17380: e8bd8070  pop {r4, r5, r6, pc}
******************************************************************************/
int XSdPs_Pullup(XSdPs *InstancePtr)
{
  u32 Status = 0;

  Xil_AssertNonvoid(InstancePtr != NULL);
   17384: e30807a0  movw  r0, #34720  ; 0x87a0
   17388: e30012a7  movw  r1, #679  ; 0x2a7
   1738c: e3400001  movt  r0, #1
   17390: ebffc73e  bl  9090 <Xil_Assert>
   17394: e3023ae8  movw  r3, #10984  ; 0x2ae8
   17398: e3403002  movt  r3, #2
   1739c: e3a02001  mov r2, #1
   173a0: e1a00006  mov r0, r6
   173a4: e5832000  str r2, [r3]
   173a8: e8bd8070  pop {r4, r5, r6, pc}

000173ac <XSdPs_Get_Mmc_ExtCsd>:
*
* @note   None.
*
******************************************************************************/
int XSdPs_Get_Mmc_ExtCsd(XSdPs *InstancePtr, u8 *ReadBuff)
{
   173ac: e92d4070  push  {r4, r5, r6, lr}
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   173b0: e2505000  subs  r5, r0, #0
   173b4: 0a000048  beq 174dc <XSdPs_Get_Mmc_ExtCsd+0x130>
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   173b8: e5952014  ldr r2, [r5, #20]
   173bc: e3013111  movw  r3, #4369 ; 0x1111
   173c0: e3413111  movt  r3, #4369 ; 0x1111
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   173c4: e3026ae8  movw  r6, #10984  ; 0x2ae8
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   173c8: e1520003  cmp r2, r3
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   173cc: e3406002  movt  r6, #2
   173d0: e3a0c000  mov ip, #0
   173d4: e586c000  str ip, [r6]
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   173d8: 1a00002d  bne 17494 <XSdPs_Get_Mmc_ExtCsd+0xe8>
   173dc: e281ef7f  add lr, r1, #508  ; 0x1fc
   173e0: e2413001  sub r3, r1, #1
   173e4: e28ee003  add lr, lr, #3
   173e8: e1a04001  mov r4, r1

  for (LoopCnt = 0; LoopCnt < 512; LoopCnt++) {
    ReadBuff[LoopCnt] = 0;
   173ec: e5e3c001  strb  ip, [r3, #1]!
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);

  for (LoopCnt = 0; LoopCnt < 512; LoopCnt++) {
   173f0: e153000e  cmp r3, lr
   173f4: 1afffffc  bne 173ec <XSdPs_Get_Mmc_ExtCsd+0x40>
  }

  BlkCnt = XSDPS_EXT_CSD_CMD_BLKCNT;
  BlkSize = XSDPS_EXT_CSD_CMD_BLKSIZE;
  BlkSize &= XSDPS_BLK_SIZE_MASK;
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   173f8: e5950004  ldr r0, [r5, #4]
   173fc: e3a01c02  mov r1, #512  ; 0x200
   17400: e2800004  add r0, r0, #4
   17404: ebffbb67  bl  61a8 <Xil_Out16>
      XSDPS_BLK_SIZE_OFFSET, BlkSize);

  XSdPs_SetupADMA2DescTbl(InstancePtr, BlkCnt, ReadBuff);
   17408: e1a02004  mov r2, r4
   1740c: e1a00005  mov r0, r5
   17410: e3a01001  mov r1, #1
   17414: ebfffcb2  bl  166e4 <XSdPs_SetupADMA2DescTbl>

  Xil_DCacheInvalidateRange(ReadBuff, 512);
   17418: e1a00004  mov r0, r4
   1741c: e3a01c02  mov r1, #512  ; 0x200
   17420: ebffbab9  bl  5f0c <Xil_DCacheInvalidateRange>

  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17424: e5950004  ldr r0, [r5, #4]
   17428: e3a01011  mov r1, #17
   1742c: e280000c  add r0, r0, #12
   17430: ebffbb5c  bl  61a8 <Xil_Out16>
  Arg = 0;

  /*
   * Send SEND_EXT_CSD command
   */
  Status = XSdPs_CmdTransfer(InstancePtr, CMD8, Arg, 1);
   17434: e1a00005  mov r0, r5
   17438: e3a01b02  mov r1, #2048 ; 0x800
   1743c: e3a02000  mov r2, #0
   17440: e3a03001  mov r3, #1
   17444: ebfffba1  bl  162d0 <XSdPs_CmdTransfer>
  if (Status != XST_SUCCESS) {
   17448: e2504000  subs  r4, r0, #0
   1744c: 13a04001  movne r4, #1
   17450: 0a000003  beq 17464 <XSdPs_Get_Mmc_ExtCsd+0xb8>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   17454: e1a00004  mov r0, r4
   17458: e8bd8070  pop {r4, r5, r6, pc}
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
    }
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);
   1745c: e3100002  tst r0, #2
   17460: 1a000014  bne 174b8 <XSdPs_Get_Mmc_ExtCsd+0x10c>
  /*
   * Check for transfer complete
   * Polling for response for now
   */
  do {
    StatusReg = XSdPs_ReadReg16(InstancePtr->Config.BaseAddress,
   17464: e5950004  ldr r0, [r5, #4]
   17468: e2800030  add r0, r0, #48 ; 0x30
   1746c: ebffbb47  bl  6190 <Xil_In16>
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
   17470: e3100902  tst r0, #32768  ; 0x8000
   17474: 0afffff8  beq 1745c <XSdPs_Get_Mmc_ExtCsd+0xb0>
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17478: e5950004  ldr r0, [r5, #4]
   1747c: e30f13ff  movw  r1, #62463  ; 0xf3ff
          XSDPS_ERR_INTR_STS_OFFSET,
          XSDPS_ERROR_INTR_ALL_MASK);
      Status = XST_FAILURE;
      goto RETURN_PATH;
   17480: e3a04001  mov r4, #1
          XSDPS_NORM_INTR_STS_OFFSET);
    if (StatusReg & XSDPS_INTR_ERR_MASK) {
      /*
       * Write to clear error bits
       */
      XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   17484: e2800032  add r0, r0, #50 ; 0x32
   17488: ebffbb46  bl  61a8 <Xil_Out16>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   1748c: e1a00004  mov r0, r4
   17490: e8bd8070  pop {r4, r5, r6, pc}
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   17494: e30807a0  movw  r0, #34720  ; 0x87a0
   17498: e1a0400c  mov r4, ip
   1749c: e3a01fb6  mov r1, #728  ; 0x2d8
   174a0: e3400001  movt  r0, #1
   174a4: ebffc6f9  bl  9090 <Xil_Assert>
   174a8: e3a03001  mov r3, #1
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   174ac: e1a00004  mov r0, r4
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
  Xil_AssertNonvoid(InstancePtr->IsReady == XIL_COMPONENT_IS_READY);
   174b0: e5863000  str r3, [r6]
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   174b4: e8bd8070  pop {r4, r5, r6, pc}
  } while ((StatusReg & XSDPS_INTR_TC_MASK) == 0);

  /*
   * Write to clear bit
   */
  XSdPs_WriteReg16(InstancePtr->Config.BaseAddress,
   174b8: e5950004  ldr r0, [r5, #4]
   174bc: e3a01002  mov r1, #2
   174c0: e2800030  add r0, r0, #48 ; 0x30
   174c4: ebffbb37  bl  61a8 <Xil_Out16>
      XSDPS_NORM_INTR_STS_OFFSET, XSDPS_INTR_TC_MASK);

  Status = XSdPs_ReadReg(InstancePtr->Config.BaseAddress,
   174c8: e5950004  ldr r0, [r5, #4]
   174cc: e2800010  add r0, r0, #16
   174d0: ebffbb30  bl  6198 <Xil_In32>
  Status = XST_SUCCESS;

  RETURN_PATH:
    return Status;

}
   174d4: e1a00004  mov r0, r4
   174d8: e8bd8070  pop {r4, r5, r6, pc}
  u32 Arg = 0;
  u16 BlkCnt;
  u16 BlkSize;
  int LoopCnt;

  Xil_AssertNonvoid(InstancePtr != NULL);
   174dc: e30807a0  movw  r0, #34720  ; 0x87a0
   174e0: e30012d7  movw  r1, #727  ; 0x2d7
   174e4: e3400001  movt  r0, #1
   174e8: e1a04005  mov r4, r5
   174ec: ebffc6e7  bl  9090 <Xil_Assert>
   174f0: e3023ae8  movw  r3, #10984  ; 0x2ae8
   174f4: e3403002  movt  r3, #2
   174f8: e3a02001  mov r2, #1
   174fc: e5832000  str r2, [r3]
   17500: eaffffd3  b 17454 <XSdPs_Get_Mmc_ExtCsd+0xa8>

00017504 <register_fini>:
   17504: e3003000  movw  r3, #0
   17508: e3403000  movt  r3, #0
   1750c: e3530000  cmp r3, #0
   17510: 012fff1e  bxeq  lr
   17514: e30907ac  movw  r0, #38828  ; 0x97ac
   17518: e3400000  movt  r0, #0
   1751c: eaffd30d  b c158 <atexit>

Disassembly of section .handoff:

00017520 <FsblHandoffJtagExit>:
/************************** Function Prototypes ******************************/

/************************** Variable Definitions *****************************/

FsblHandoffJtagExit:
    mcr  15,0,r0,cr7,cr5,0    /* Invalidate Instruction cache */
   17520: ee070f15  mcr 15, 0, r0, cr7, cr5, {0}
    mcr  15,0,r0,cr7,cr5,6    /* Invalidate branch predictor array */
   17524: ee070fd5  mcr 15, 0, r0, cr7, cr5, {6}

    dsb
   17528: f57ff04f  dsb sy
    isb         /* make sure it completes */
   1752c: f57ff06f  isb sy

  ldr r4, =0
   17530: e3a04000  mov r4, #0
    mcr  15,0,r4,cr1,cr0,0    /* disable the ICache and MMU */
   17534: ee014f10  mcr 15, 0, r4, cr1, cr0, {0}

    isb         /* make sure it completes */
   17538: f57ff06f  isb sy

0001753c <Loop>:
Loop:
  wfe
   1753c: e320f002  wfe
  b Loop
   17540: eafffffd  b 1753c <Loop>

00017544 <FsblHandoffExit>:

FsblHandoffExit:
    mov  lr, r0 /* move the destination address into link register */
   17544: e1a0e000  mov lr, r0

    mcr  15,0,r0,cr7,cr5,0    /* Invalidate Instruction cache */
   17548: ee070f15  mcr 15, 0, r0, cr7, cr5, {0}
    mcr  15,0,r0,cr7,cr5,6    /* Invalidate branch predictor array */
   1754c: ee070fd5  mcr 15, 0, r0, cr7, cr5, {6}

    dsb
   17550: f57ff04f  dsb sy
    isb         /* make sure it completes */
   17554: f57ff06f  isb sy

  ldr r4, =0
   17558: e3a04000  mov r4, #0
    mcr  15,0,r4,cr1,cr0,0    /* disable the ICache and MMU */
   1755c: ee014f10  mcr 15, 0, r4, cr1, cr0, {0}

    isb         /* make sure it completes */
   17560: f57ff06f  isb sy


    bx    lr  /* force the switch, destination should have been in r0 */
   17564: e12fff1e  bx  lr

.Ldone: b   .Ldone          /* Paranoia: we should never get here */
   17568: eafffffe  b 17568 <FsblHandoffExit+0x24>

Disassembly of section .init:

0001756c <_init>:
   1756c: e1a0c00d  mov ip, sp
   17570: e92ddff8  push  {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   17574: e24cb004  sub fp, ip, #4
   17578: e24bd028  sub sp, fp, #40 ; 0x28
   1757c: e89d6ff0  ldm sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   17580: e12fff1e  bx  lr

Disassembly of section .fini:

00017584 <_fini>:
   17584: e1a0c00d  mov ip, sp
   17588: e92ddff8  push  {r3, r4, r5, r6, r7, r8, r9, sl, fp, ip, lr, pc}
   1758c: e24cb004  sub fp, ip, #4
   17590: e24bd028  sub sp, fp, #40 ; 0x28
   17594: e89d6ff0  ldm sp, {r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
   17598: e12fff1e  bx  lr
